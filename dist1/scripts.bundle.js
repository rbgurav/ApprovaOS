
/*!
 * jQuery JavaScript Library v3.1.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-09-22T22:30Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			resolve.call( undefined, value );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.call( undefined, value );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( jQuery.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win, rect, doc,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		// Make sure element is not hidden (display: none)
		if ( rect.width || rect.height ) {
			doc = elem.ownerDocument;
			win = getWindow( doc );
			docElem = doc.documentElement;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		}

		// Return zeros for disconnected and hidden elements (gh-2310)
		return rect;
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.parseJSON = JSON.parse;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}





return jQuery;
} );

/**
* Soho XI Controls v4.3.3-rc
* Date: 21/11/2017 1:36:47 PM
* Revision: eae6b97b67efbc6c242a3e4196aee7cf07f60f69
* License:
*
* The Soho Xi Component Library (the “Runtime”) is made available to you under this Runtime License.
* Infor, Inc. grants you a nonexclusive, non-transferable, non-sublicenseable, and revocable license to use
* the Runtime within the Application for the sole purpose of enabling the Runtime’s functionality within the
* Application. You may not, and you may not permit anyone else to, copy, modify, combine with other software,
* or redistribute the Runtime. You are prohibited from removing, altering, or  obscuring the above copyright
* notice or this Runtime License.
*
* Disclaimer. You assume all responsibility and risk of use of the Runtime. The Runtime is provided "AS IS"
* without warranty or condition of any kind. INFOR DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
* INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT,
* AND ANY WARRANTIES OR CONDITIONS ARISING OUT OF COURSE OF DEALING OR USAGE OF TRADE. Infor is not responsible
* or liable (and makes no representation or warranty) for the accuracy, content, * completeness, legality,
* reliability, or availability of the Runtime.
*
* Limitation of Liability. IN NO EVENT WILL INFOR BE LIABLE TO YOU FOR ANY SPECIAL, INCIDENTAL, EXEMPLARY, PUNITIVE OR
* CONSEQUENTIAL DAMAGES (INCLUDING LOSS OF USE, DATA, BUSINESS OR PROFITS) ARISING OUT OF OR IN CONNECTION WITH
* THIS RUNTIME LICENSE, WHETHER SUCH LIABILITY ARISES FROM ANY CLAIM BASED UPON CONTRACT, WARRANTY,
* TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, AND WHETHER OR NOT INFOR HAS BEEN
* ADVISED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGE. THE FOREGOING LIMITATIONS  * WILL SURVIVE AND
* APPLY EVEN IF ANY LIMITED REMEDY SPECIFIED IN THIS AGREEMENT IS FOUND TO HAVE FAILED OF ITS ESSENTIAL PURPOSE.
* IN NO EVENT WILL INFOR’S TOTAL LIABILITY ARISING OUT OF OR IN CONNECTION WITH THIS AGREEMENT OR FROM THE USE OF
* OR INABILITY TO USE THE RUNTIME EXCEED $100.
*/
(function(factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module
        define(['jquery'], factory);
      } else if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
      } else {
        // Browser globals
        factory(jQuery);
      }
    }(function($) {
  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.personalize = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'personalize',
        defaults = {
          colors: '',
          theme: ''
        },
        settings = $.extend({}, defaults, options);

    /**
    * The personalization routines for setting custom company colors.
    *
    * @class Personalize
    * @param {String} colors  &nbsp;-&nbsp; The list of colors
    * @param {String} theme  &nbsp;-&nbsp; The theme name (light, dark or high-contrast)
    *
    */
    function Personalize(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Personalize.prototype = {
      init: function() {
        this.makeSohoObject()
        .handleEvents();

        if (this.settings.colors) {
          this.setColors(this.settings.colors);
        }

        if (this.settings.theme) {
          this.setTheme(this.settings.theme);
        }
        return this;
      },

      makeSohoObject: function () {
        var self = this;

        window.Soho = window.Soho || {};

        //Handle Personalization and theme
        window.Soho.theme = 'light';
        $('html').removeClass('light-theme dark-theme high-contrast-theme').addClass(window.Soho.theme + '-theme');

        window.Soho.setTheme = function(theme) { // jshint ignore:line
          self.setTheme(theme);
        };

        window.Soho.setColors = function(colors) { // jshint ignore:line
          self.setColors(colors);
        };

        window.Soho.getColorStyleSheet = function(colors) { // jshint ignore:line
          return self.getColorStyleSheet(colors);
        };

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        }).on('changecolors.' + pluginName, function(e, newColor, noAnimate) {
          self.setColors(newColor, noAnimate);
        }).on('changetheme.' + pluginName, function(e, theme) {
          self.setTheme(theme);
        });

        return this;
      },

      // Validates a string containing a hexadecimal number
      // @param {String} hex: A hex color.
      // @returns {String} a validated hexadecimal string.
      validateHex: function(hex) {
        hex = String(hex).replace(/[^0-9a-f]/gi, '');

        if (hex.length < 6) {
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }

        return '#' + hex;
      },

      appendStyleSheet: function(cssRules) {
        var sheet = document.getElementById('soho-personalization');
        if (sheet) {
          sheet.parentNode.removeChild(sheet);
        }

        // Create the <style> tag
        sheet = document.createElement('style');
        sheet.setAttribute('id', 'soho-personalization');
        sheet.appendChild(document.createTextNode(cssRules));

      	// Add the <style> element to the page
      	document.head.appendChild(sheet);
      },

      getColorStyleSheet: function(colors)  {
        Soho.colors = colors;

        if (typeof colors === 'string') {
          Soho.colors = {};
          Soho.colors.header = colors;
        }

        if (!colors || colors === '') {
          return this;
        }

        // Default Colors...
        // (Color)07 for the main color (fx headers)
        // (Color)06 for the secondary color (fx sub-headers)
        // Light or Dark (fff or 000) for the contrast color

        // (Color)06 for the vertical borders between module tabs - 133C59
        // (Color)07 for the page header and active module tab - 2578A9 DEFAULT
        // (Color)08 for the inactive module tab - 1d5f8a
        // (Color)09 for the horizontal border - 134D71
        // (Color)10 for the hover state on module tab - 133C59
        var defaultColors = {header: '2578A9',
                             subheader: '368AC0',
                             text: 'ffffff',
                             verticalBorder: '133C59',
                             horizontalBorder: '134D71',
                             inactive: '1d5f8a',
                             hover: '133C59'};

        // If an event sends a blank string through instead of a hex,
        // reset any color values back to the theme defaults.  Otherwise, get a valid hex value.
        Soho.colors.header = this.validateHex(Soho.colors.header || defaultColors.header);
        Soho.colors.text = this.validateHex(Soho.colors.text || defaultColors.text);
        Soho.colors.subheader = this.validateHex(Soho.colors.subheader || this.getLuminousColorShade(Soho.colors.header, 0.2));
        Soho.colors.inactive = this.validateHex(Soho.colors.inactive || this.getLuminousColorShade(Soho.colors.header, -0.22));
        Soho.colors.verticalBorder = this.validateHex(Soho.colors.verticalBorder || this.getLuminousColorShade(Soho.colors.header, 0.1));
        Soho.colors.horizontalBorder = this.validateHex(Soho.colors.horizontalBorder || this.getLuminousColorShade(Soho.colors.header, -0.4));
        Soho.colors.hover = this.validateHex(Soho.colors.hover || this.getLuminousColorShade(Soho.colors.header, -0.5));

        //not that the sheet is appended in backwards
        var cssRules = '.tab-container.module-tabs.is-personalizable { border-top: 1px solid '+ Soho.colors.horizontalBorder +' !important; border-bottom: 1px solid ' + Soho.colors.horizontalBorder + ' !important}' +
        ' .module-tabs.is-personalizable .tab:not(:first-child) { border-left: 1px solid '+ Soho.colors.verticalBorder +' !important}'  +
        ' .module-tabs.is-personalizable { background-color: '+ Soho.colors.inactive +' !important}'  +
        ' .module-tabs.is-personalizable .tab.is-selected { background-color: '+ Soho.colors.header +' !important}'  +
        ' .accordion.panel .accordion-header.is-selected { background-color: '+ Soho.colors.subheader +' !important; color: '+ Soho.colors.text +' !important}'  +
        ' .builder-header.is-personalizable{ background-color: '+ Soho.colors.subheader +'}'  +
        ' .header.is-personalizable { background-color: '+ Soho.colors.header +'}' +
        ' .header.is-personalizable .title { color: '+ Soho.colors.text +'}' +
        ' .header.is-personalizable h1 { color: '+ Soho.colors.text +'}' +
        ' .module-tabs.is-personalizable .tab-more { border-left: '+ Soho.colors.verticalBorder +' !important}' +
        ' .module-tabs.is-personalizable .tab-more:hover { background-color: '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.is-personalizable .tab-more.is-open { background-color: '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.is-personalizable .tab-more.is-selected { background-color: '+ Soho.colors.header +' !important}' +
        ' .header .toolbar > .toolbar-searchfield-wrapper.active .searchfield { background-color: '+ Soho.colors.hover +' !important; border-bottom-color: ' + Soho.colors.hover  +' !important}' +
        ' .header .toolbar > .toolbar-searchfield-wrapper.active .searchfield-category-button { background-color: '+ Soho.colors.hover +' !important; border-bottom-color: ' + Soho.colors.hover  +' !important}' +
        ' .subheader.is-personalizable { background-color: '+ Soho.colors.subheader +' !important}' +
        ' .builder .sidebar .header {border-right: 1px solid '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.is-personalizable .tab:hover { background-color: '+ Soho.colors.hover +' !important}' +
        ' .module-tabs.has-toolbar.is-personalizable .tab-list-container + .toolbar { border-left: '+ Soho.colors.verticalBorder +' !important}' +
        ' .module-tabs.is-personalizable [class^="btn"] { background-color: '+ Soho.colors.inactive +' !important}' +
        ' .hero-widget.is-personalizable { background-color: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .hero-bottom { background-color: '+ Soho.colors.header +' }' +
        ' .hero-widget.is-personalizable .hero-footer .hero-footer-nav li::before { color: '+ Soho.colors.verticalBorder +' }' +
        ' .hero-widget.is-personalizable .chart-container .arc { stroke: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .chart-container .bar { stroke: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .chart-container.line-chart .dot { stroke: '+ Soho.colors.subheader +' }' +
        '';

        return cssRules;
      },

      /**
      * Sets the personalization color(s)
      *
      * @param {Array} colors  &nbsp;-&nbsp; The original hex color as a string or an object with all the Colors
      */
      setColors: function(colors) {
        if (!colors) {
          return;
        }

        this.appendStyleSheet(this.getColorStyleSheet(colors));
        return this;
      },

      /**
      * Takes a color and performs a change in luminosity of that color programatically.
      * @param {String} hex  &nbsp;-&nbsp; The original Hexadecimal base color.
      * @param {String} lum  &nbsp;-&nbsp; A percentage used to set luminosity change on the base color:  -0.1 would be 10% darker, 0.2 would be 20% brighter
      * @returns {String} hexadecimal color.
      */
      getLuminousColorShade: function(hex, lum) {
        // validate hex string
        hex = this.validateHex(hex).substr(1);
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = '#', c, i;
        for (i = 0; i < 3; i++) {
          c = parseInt(hex.substr(i*2, 2), 16);
          c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
          rgb += ('00' + c).substr(c.length);
        }

        return rgb;
      },

      availableThemes: [
        'light',
        'dark',
        'high-contrast'
      ],

      /**
      * Sets the current theme, blocking the ui during the change.
      *
      * @param {String} theme  &nbsp;-&nbsp; Represents the file name of a color scheme (can be dark, light or high-contrast)
      */
      setTheme: function(theme) {
        if (Soho.theme === theme) {
          return;
        }

        Soho.theme = theme;
        // validate theme
        if (this.availableThemes.indexOf(theme) === -1) {
          return;
        }

        $('html').removeClass('light-theme dark-theme high-contrast-theme').addClass(theme + '-theme');

        this.blockUi();

        var self = this,
          originalCss = $('#stylesheet, #sohoxi-stylesheet'),
          newCss = $('<link rel="stylesheet">'),
          path = originalCss.attr('href');

        newCss.on('load', function() {
          originalCss.remove();
          self.unBlockUi();
        });

        newCss.attr({
          id: originalCss.attr('id'),
          href: path.substring(0, path.lastIndexOf('/')) + '/' + theme + '-theme' + (path.indexOf('.min') > -1 ? '.min' : '') + '.css'
        });
        originalCss.removeAttr('id');
        originalCss.after(newCss);
      },

      //Block the ui from FOUC
      blockUi: function () {

        this.pageOverlay = this.pageOverlay || $('<div style="' +
        	'background: ' + (Soho.theme === 'light' ? '#f0f0f0;' : (Soho.theme === 'dark' ? '#313236;' : '#bdbdbd;')) +
        	'display: block;' +
          'height: 100%;' +
        	'left: 0;' +
        	'position: fixed;' +
          'text-align: center;' +
        	'top: 0;' +
        	'width: 100%;' +
          'z-index: 10000;' +
          '"></div>'
        );

        $('body').append(this.pageOverlay);
      },

      unBlockUi: function (){
        var self = this;

        self.pageOverlay.fadeOut(300, function() {
          self.pageOverlay.remove();
          self.pageOverlay = undefined;
        });
      },

      // Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      // Ideally this will do non-destructive things that make it possible to easily rebuild
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Personalize(this, settings));
      }
    });
  };


  $.fn.initialize = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'initialize',
        defaults = {
          locale: Locale.currentLocale.name || 'en-US'
        },
        settings;

      if (typeof options === 'string') {
        settings = {};
        settings.locale = options;
      } else {
        settings = $.extend({}, defaults, options);
      }

    /**
     * Page Bootstrapper
     * @constructor
     * @param {Object} element
     */
    function Initialize(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Initialize.prototype = {
      init: function() {
        var self = this;

        Locale.set(this.settings.locale).done(function () {
          self.initAll();
        });

        return this;
      },

      initAll : function () {
        var self = this;

        // Iterate all objects we are initializing
        this.element.filter(':not(.no-init)').each(function() {
          var elem = $(this),
            noinitExcludes = '.no-init, [data-init]';

          function invokeWithInlineOptions(elem, plugin) {
            var options = Soho.utils.parseOptions(elem);
            $(elem)[plugin](options);
          }

          function matchedItems(selector) {
            var items = elem.find(selector);
            if (elem.filter(selector).length) {
              items = items.add(elem);
            }
            return items;
          }

          function simpleInit(plugin, selector) {
            //Allow only the plugin name to be specified if the default selector is a class with the same name
            //Like $.fn.header applying to elements that match .header
            if (typeof selector === 'undefined') {
              selector = '.' + plugin;
            }

            if ($.fn[plugin]) {
              matchedItems(selector).each(function () {
                var elem = $(this);

                if (elem.is(noinitExcludes) && selector !=='[data-trackdirty="true"]') {
                  return;
                }

                if (elem.parents().hasClass('no-init')) {
                  return;
                }

                // Don't invoke elements inside of "container" controls that need to invoke their internal
                // items in a specific order.
                if (!elem.is('.icon') && elem.parents('.toolbar').length && !elem.parents().hasClass('masthead')) {
                  return;
                }

                invokeWithInlineOptions(this, plugin);
              });
            }

            // Radio switch
            matchedItems('.radio-section input:radio.handle').change(function() {
              if (this.checked) {
                var option = $(this).closest('.option'),
                siblings = option.siblings(),
                fields = 'button, select, input[type="text"]';

                $(fields, option).removeAttr('disabled');
                $(fields, siblings).attr('disabled','disabled');
              }
            });
          }

          // Mobile Zoom Control
          // Needs manual invokation because the rest of initialization is scoped to the
          // calling element, which is the <body> tag.
          if ($.fn.zoom) {
            $('head').zoom();
          }

          // Application Menu
          if ($.fn.applicationmenu) {
            matchedItems('#application-menu').applicationmenu({
              triggers: elem.find('.application-menu-trigger')
            });
          }

          // Personalization
          if ($.fn.personalize) {
            matchedItems('body').personalize();
          }

          //Array of plugin names and selectors (optional) for no-configuration initializations
          var simplePluginMappings = [

            // Hyperlinks
            ['hyperlink'],

            // Icons
            ['icon'],

            ['splitter'],

            //Tabs
            ['tabs', '.tab-container:not(.vertical)'],

            //Vertical Tabs
            ['verticaltabs', '.tab-container.vertical'],

            //Select / DropDowns
            ['dropdown', 'select.dropdown:not(.multiselect)'],
            ['dropdown', 'select.dropdown-xs:not(.multiselect)'],
            ['dropdown', 'select.dropdown-sm:not(.multiselect)'],
            ['dropdown', 'select.dropdown-lg:not(.multiselect)'],

            //Modals
            ['modal'],

            //Sliders
            ['slider', 'input[type="range"], .slider'],

            //Editors
            ['editor'],

            //Tooltips
            ['tooltip', 'button[title], span[title], .hyperlink[title]'],

            //Tree
            ['tree'],

            //Rating
            ['rating'],

            //Listbuilder
            ['listbuilder'],

            //Composite Form Wrapper
            ['compositeform', '.composite-form'],

            //Progress
            ['progress', '.progress-bar'],

            //Format
            ['mask', 'input[data-mask], .new-mask'],

            //Auto Complete
            ['autocomplete', '.autocomplete:not([data-init])'],

            //Multiselect
            ['multiselect', 'select[multiple]:not(.dropdown), .multiselect:not([data-init])'],

            //Button with Effects
            ['button', '.btn, .btn-toggle, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split, .btn-secondary-border'],

            //Hide Focus
            ['hideFocus', 'a.hide-focus, a.tick, .checkbox, .radio, .switch'],

            //Circle Pager
            ['circlepager'],

            //Track Dirty
            ['trackdirty', '[data-trackdirty="true"]'],

            //Clear x
            ['clearable', '[data-clearable="true"]'],

            //Text Area
            ['textarea', 'textarea'],

            //Spinbox
            ['spinbox'],

            //sort drag and drop
            ['arrange'],

            //Swap List
            ['swaplist'],

            //Color Picker
            ['colorpicker'],

            //Date Picker
            ['datepicker'],

            //Time Picker
            ['timepicker'],

            //Tag
            ['tag'],

            //Busy Indicator
            ['busyindicator','.busy, .busy-xs, .busy-sm'],

            ['header'],

            ['fileupload', 'input.fileupload:not(.fileupload-background-transparent)'],

            ['fileuploadadvanced', '.fileupload-advanced'],

            ['fieldoptions', '.field-options'],

            ['about'],

            ['contextualactionpanel', '.contextual-action-panel-trigger'],

            ['expandablearea', '.expandable-area'],

            ['signin'],

            ['homepage'],

            ['lookup', '.lookup:not([data-init])'],

            ['wizard'],

            ['popdown', '[data-popdown]'],

            ['stepchart', '.step-chart']
          ];

          //Do initialization for all the simple controls
          for(var i = 0; i < simplePluginMappings.length; i++) {
            simpleInit.apply(null, simplePluginMappings[i]);
          }

          if ($.fn.popupmenu) {
            // Don't double-invoke menu buttons
            var btnExcludes = ', .btn-actions, .btn-filter, .btn-menu';

            //Context Menus
            matchedItems('[data-popupmenu]:not('+ noinitExcludes + btnExcludes + ')').each(function () {
              var triggerButton = $(this),
                options = $.extend({}, Soho.utils.parseOptions(this)),
                popupData = triggerButton.attr('data-popupmenu');

              if (popupData) {
                options.menuId = popupData;
              }

              triggerButton.popupmenu(options);
            });

            //Button-based Popup-Menus (Action/More Button, Menu Buttons, etc.)
            matchedItems('.btn-filter, .btn-menu, .btn-actions').filter(':not('+ noinitExcludes +')').each(function() {
              var triggerButton = $(this);

              // Don't auto-invoke Toolbar's Popupmenus.
              // Toolbar needs to completely control its contents and invoke each one manually.
              if (triggerButton.parents('.toolbar').length > 0) {
                return;
              }

              invokeWithInlineOptions(triggerButton, 'popupmenu');
            });
          }

          //Popovers
          if ($.fn.popover) {
            matchedItems('[data-popover]:not('+ noinitExcludes +')').each(function () {
              var options = Soho.utils.parseOptions(this),
                obj = $(this),
                trigger = obj.attr('data-trigger'),
                title = obj.attr('data-title'),
                placement = obj.attr('data-placement');

              if (!$.isEmptyObject(options)) {
                obj.popover({
                  content: $(options.content),
                  popover: true,
                  trigger: options.trigger || 'click',
                  title: options.title || undefined,
                  placement:  options.placement || 'right',
                  extraClass: options.extraClass || undefined
                });
              } else {
                obj.popover({
                  content: $('#' + obj.attr('data-popover')),
                  popover: true,
                  trigger: trigger || 'click',
                  title: title || undefined,
                  placement: placement || 'right',
                  extraClass: options.extraClass || undefined
                });
              }

            });
          }

          //Cardstack
          if ($.fn.listview) {
            matchedItems('.listview:not('+ noinitExcludes +')').each(function () {
              var cs = $(this),
                attr = cs.attr('data-dataset'),
                tmpl = cs.attr('data-tmpl'),
                options = Soho.utils.parseOptions(this) || {};

              options.dataset = options.dataset || attr;
              options.template = options.template || tmpl;

              if (window[options.dataset]) {
                options.dataset = window[options.dataset];
              }
              if (options.template && options.template.length) {
                options.template = $('#' + options.template).html();
              }

              cs.listview(options);
            });
          }

          // Searchfield
          // NOTE:  The Toolbar Control itself understands how to invoke internal searchfields, so they
          // are excluded from this initializer.
          if ($.fn.searchfield) {
            var searchfields = matchedItems('.searchfield:not('+ noinitExcludes +')'),
              toolbarSearchfields = searchfields.filter(function() {
                return $(this).parents('.toolbar').length;
              });
            searchfields = searchfields.not(toolbarSearchfields);

            searchfields.each(function() {
              invokeWithInlineOptions(this, 'searchfield');
            });
          }

          // Accordion
          if ($.fn.accordion) {
            matchedItems('.accordion:not('+ noinitExcludes +')').each(function() {
              var a = $(this);
              if (a.parents('.application-menu').length) {
                return;
              }

              invokeWithInlineOptions(a, 'accordion');
            });
          }

          // Toolbar
          if ($.fn.toolbar) {
            matchedItems('.toolbar:not('+ noinitExcludes +')').each(function() {
              var t = $(this);
              // Don't re-invoke toolbars that are part of the page/section headers or cap header.
              // header.js manually invokes these toolbars during its setup process.
              // However, if initialize is specifically being called on the toolbar element, then allow it to happen.
              if (t.parents('.header, .contextual-action-panel .modal-header').length && !self.element.is('.toolbar')) {
                return;
              }

              invokeWithInlineOptions(t, 'toolbar');
            });
          }

          matchedItems('[data-translate="text"]').each(function () {
            var obj = $(this);
            obj.text(Locale.translate(obj.text()));
          });

          //Toggle boxes on image list
          matchedItems('.block').on('click', function () {
            $(this).toggleClass('is-selected');
          });

          //Validation
          //Should be one of the last items to invoke
          if ($.fn.validate) {
            matchedItems('[data-validate-on="submit"]').validate();
          }

          matchedItems('.breadcrumb ol').attr('aria-label', Locale.translate('Breadcrumb'));
        });

        // NOTE: use of .triggerHandler() here causes event listeners for "initialized" to fire, but prevents the
        // "initialized" event from bubbling up the DOM.  It should be possible to initialize just the contents
        // of an element on the page without causing the entire page to re-initialize.
        this.element.triggerHandler('initialized');

        if ($.fn.validate) {
          self.element.validate();
        }

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = new Initialize(this, settings); // jshint ignore:line
    });
  };


  function Base(element) {
    this.element = $(element);
    this.url = this.getCurrentURL();

    window.Soho = window.Soho || {};

    if (!window.Soho.base) {
      $.detectBaseTag();
    }

    return this;
  }

  // Provides a global object that detects the existence of a Base Tag,
  // and provides some methods that can be used to get an accurate relative
  // URL using the base tag.
  Base.prototype = {
    getCurrentURL: function() {
      return window.location.href
        .replace(window.location.hash, '');
    },

    getBaseURL: function(hash) {
      if (hash) {
        // absolute links
        if (hash.indexOf('/') === 0) {
          return window.location.origin + hash;
        }

        hash = (hash.indexOf('#') === -1 ? '#' : '') + hash;
        return this.url + hash;
      }

      return this.url;
    }
  };

  // Setup a default function that just returns the contents of the hash,
  // if no base tag is present.
  $.getBaseURL = function(hash) {
    return hash;
  };

  // Detect the Base tag and install a global object, if necessary
  $.detectBaseTag = function detectBaseTag() {
    var base = $('base[href]');
    if (base.length) {
      window.Soho.base = new Base(base);

      // override the "getBaseURL"
      $.getBaseURL = window.Soho.base.getBaseURL.bind(window.Soho.base);
    }
  };

/**
 * Transition Support Check
 * Returns the vendor-prefixed name of the 'transition' property available by the browser.
 * If the browser doesn't support transitions, it returns null.
 * @private
 */


  window.Soho = window.Soho || {};
  window.Soho.utils = {};
  window.Soho.DOM = {};

  // Used for changing the stacking order of jQuery events.  This is needed to override certain
  // Events invoked by other plugins http://stackoverflow.com/questions/2360655
  $.fn.bindFirst = function(name, fn) {
    this.on(name, fn);
    this.each(function() {
        var handlers = $._data(this, 'events')[name.split('.')[0]];
        // take out the handler we just inserted from the end
        var handler = handlers.pop();
        // move it at the beginning
        handlers.splice(0, 0, handler);
    });
  };

  function visible(element) {
    return $.expr.filters.visible( element ) &&
      !$(element).parents().addBack().filter(function() {
        return $.css(this, 'visibility') === 'hidden';
      }).length;
  }

  //Get a unique ID
  window.Soho.uniqueIdCount = 0;
  $.fn.uniqueId = function(className, prefix, suffix) {
    var predefinedId = $(this).attr('id');

    if (predefinedId && $('#' + predefinedId).length < 2) {
      return predefinedId;
    }

    prefix = (!prefix ? '' : prefix + '-');
    suffix = (!suffix ? '' : '-' + suffix);
    className = (!className ? $(this).attr('class') : className);

    var str = prefix + className + Soho.uniqueIdCount + suffix;
    Soho.uniqueIdCount = Soho.uniqueIdCount + 1;
    return str;
  };

  // Check for CSS Property Support in a cross browser way
  $.fn.cssPropSupport = function(prop) {
    'use strict';

    if (!prop) {
      return null;
    }

    var el = $('<div></div>')[0],
      propStr = prop.toString(),
      prefixes = ['Moz', 'Webkit', 'O', 'ms'],
      prop_ = propStr.charAt(0).toUpperCase() + propStr.substr(1);

    if (prop in el.style) {
      $(el).remove();
      return prop;
    }

    for (var i = 0; i < prefixes.length; i++) {
      var vendorProp = prefixes[i] + prop_;
      if (vendorProp in el.style) {
        $(el).remove();
        return vendorProp;
      }
    }

    $(el).remove();
    return null;
  };

  // Returns the name of the TransitionEnd event.
  $.fn.transitionEndName = function() {
    var prop = $.fn.cssPropSupport('transition'),
      eventNames = {
        'WebkitTransition' :'webkitTransitionEnd',
        'MozTransition'    :'transitionend',
        'MSTransition'     :'msTransitionEnd',
        'OTransition'      :'oTransitionEnd',
        'transition'       :'transitionend'
      };

    return eventNames[prop] || null;
  };

  // From jQueryUI Core: https://github.com/jquery/jquery-ui/blob/24756a978a977d7abbef5e5bce403837a01d964f/ui/jquery.ui.core.js#L93
  // Adapted from:  http://stackoverflow.com/questions/7668525/is-there-a-jquery-selector-to-get-all-elements-that-can-get-focus
  // Adds the ':focusable' selector to Sizzle to allow for the selection of elements that can currently be focused.
  function focusable(element) {
    var map, mapName, img,
      nodeName = element.nodeName.toLowerCase(),
      isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex'));

    if ('area' === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }

    return (/input|select|textarea|button|object/.test(nodeName) ?
      !element.disabled :
      'a' === nodeName ?
        element.href || isTabIndexNotNaN :
        isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible( element );
  }

  $.extend($.expr[':'], {
    focusable: function(element) {
      return focusable(element, !isNaN($.attr(element, 'tabindex')));
    }
  });

  // Custom Touch Event Handler that simply passes Touch Event Handlers onto a Click Event Handler.
  // Used for avoiding the 300ms wait time that click events have in most mobile environments
  // if 'one' is defined, it only listens once.
  $.fn.onTouchClick = function(eventNamespace, filter, one) {
    eventNamespace = (eventNamespace !== null || eventNamespace !== undefined ? '.' + eventNamespace : '');
    filter = (filter !== null || filter !== undefined ? filter : '');

    return this.each(function() {
      var self = $(this),
        listener = one ? 'one' : 'on',
        threshold = 10,
        thresholdReached = false,
        pos;

     self[listener]('touchstart' + eventNamespace, filter, function handleMove(e) {
        pos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };
      });

      self[listener]('touchmove' + eventNamespace, filter, function handleMove(e) {
        var newPos;
        newPos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };

        if ((newPos.x >= pos.x + threshold) || (newPos.x <= pos.x - threshold) ||
            (newPos.y >= pos.y + threshold) || (newPos.y <= pos.y - threshold)) {
          thresholdReached = true;
        }
      });

      self[listener]('touchend' + eventNamespace + ' touchcancel' + eventNamespace, filter, function handleTouches(e) {
        var elem = $(this);
        if (thresholdReached) {
          thresholdReached = false;
          return;
        }

        setTimeout(function(){
          thresholdReached = false;
          e.preventDefault();

          if (elem.attr('disabled')) {
            return;
          }

          elem.trigger('click');
        }, 0);

        return false;
      });

      return self;
    });
  };

  // Reverses the .onTouchClick() method and turns off a matching event listener
  $.fn.offTouchClick = function(eventNamespace, filter) {
    eventNamespace = (eventNamespace !== null || eventNamespace !== undefined ? '.' + eventNamespace : '');
    filter = (filter !== null || filter !== undefined ? filter : '');

    return this.each(function() {
      return $(this).off('touchend' + eventNamespace + ' touchcancel' + eventNamespace + ' touchstart' + eventNamespace + ' touchmove' + eventNamespace, filter);
    });
  };

  // Returns a key/value list of currently attached event listeners
  $.fn.listEvents = function() {
    var data = {};

    this.each(function() {
      data = $._data(this, 'events');
    });

    return data;
  };

  // Implements consistent support for the placeholder attribute in browsers that do not handle it
  // ** Supports any kind of input (no issues with password) and textarea
  // ** does nothing if native support exists
  $.fn.placeholderPolyfill = function(options) {
    if (!('placeholder' in document.createElement('input'))) {
      var settings = $.extend({className: 'is-placeholder'}, options),
        setInputType = function (input, type, opt) {
          if(opt) {
            input.attr('type', type);
          }
        };
      $('[placeholder]').each(function() {
        var input = $(this),
        isPassword = input.is('input[type="password"]');
        input.removeClass(settings.className).on('focus.placeholderPolyfill, click.placeholderPolyfill', function() {
          if (input.val() === input.attr('placeholder') && input.data('placeholder')) {
            input.get(0).setSelectionRange(0, 0);
          }
        }).on('keydown.placeholderPolyfill', function() {
          setInputType(input, 'password', isPassword);
          if (input.val() === input.attr('placeholder') && input.data('placeholder')) {
            input.val('');
            input.removeClass(settings.className);
          }
        }).on('blur.placeholderPolyfill', function() {
          if (input.val() === '') {
            setInputType(input, 'text', isPassword);
            input.addClass(settings.className);
            input.val(input.attr('placeholder'));
            input.data('placeholder', true);
          } else {
            input.data('placeholder', false);
          }
        }).trigger('blur.placeholderPolyfill').parents('form').on('submit', function() {
          $('[placeholder]', this).each(function () {
            var field = $(this);
            if (field.val() === field.attr('placeholder') && field.data('placeholder')) {
              field.val('');
            }
          });
        });
      });
    }
   return this;
  };


  /**
   * Grabs an attribute from an HTMLElement containing stringified JSON syntax, and interprets it into options.
   * @param {HTMLElement} element
   * @param {String} [attr]
   * @returns {Object}
   */
  window.Soho.utils.parseOptions = function parseOptions(element, attr) {
    var options = {};
    if (!element || !(element instanceof HTMLElement)) {
      return options;
    }

    // Use `data-options` as a default.
    attr = attr || 'data-options';

    var str = element.getAttribute(attr);
    if (!str || typeof str !== 'string' || str.indexOf('{') === -1) {
      return options;
    }

    // replace single to double quotes, since single-quotes may be necessary
    // due to entry in markup.
    function replaceDoubleQuotes(str) {
      return str.replace(/'/g, '"');
    }

    // Manually parse a string more in-depth
    function manualParse(str) {
      var regex = /({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):/g; //get keys
      str = str.replace(regex, '$1\"$2\":'); //add double quotes to keys
      regex = /:(?:\s*)(?!(true|false|null|undefined))([A-Za-z_$\.#][A-Za-z0-9_ \-\.$]*)/g; //get strings in values
      str = str.replace(regex, ':\"$2\"'); //add double quotes to strings in values
      str = replaceDoubleQuotes(str);
      return str;
    }

    try {
      options = JSON.parse(replaceDoubleQuotes(str));
    } catch(err) {
      options = JSON.parse(manualParse(str));
    }

    return options;
  };

  /**
   * jQuery Behavior Wrapper for `Soho.utils.parseOptions`.
   * @deprecated
   * @param {String} [attrName]
   * @return {Object|Object[]}
   */
  $.fn.parseOptions = function(element, attr) {
    var results = [],
      isCalledDirectly = (element instanceof HTMLElement || element instanceof SVGElement || element instanceof $),
      targets = this;

    if (isCalledDirectly) {
      targets = $(element);
    } else {
      attr = element;
      element = undefined;
    }

    targets.each(function(i, item) {
      results.push({
        element: this,
        options: Soho.utils.parseOptions(item, attr)
      });
    });

    if (results.length === 1) {
      return results[0].options;
    }
    return results;
  };

  // Timer - can be use for play/pause or stop for given time
  // use as new instance [ var timer = new $.fn.timer(function() {}, 6000); ]
  // then can be listen events as [ $(timer.event).on('update', function(e, data){console.log(data.counter)}); ]
  // or can access as [ timer.cancel(); -or- timer.pause(); -or- timer.resume(); ]
  $.fn.timer = function(callback, delay) {
    var self = $(this),
      interval,
      speed = 10,
      counter = 0,
      cancel = function() {
        self.triggerHandler('cancel');
        clearInterval(interval);
        counter = 0;
      },
      pause = function() {
        self.triggerHandler('pause');
        clearInterval(interval);
      },
      update = function() {
        interval = setInterval(function() {
          counter += speed;
          self.triggerHandler('update', [{'counter': counter}]);
          if (counter > delay) {
            self.triggerHandler('timeout');
            callback.apply(arguments);
            clearInterval(interval);
            counter = 0;
          }
        }, speed);
      },
      resume = function() {
        self.triggerHandler('resume');
        update();
      };

      update();
    return { event: this, cancel: cancel, pause: pause, resume: resume };
  };

  // Copies a string to the clipboard. Must be called from within an event handler such as click.
  // May return false if it failed, but this is not always
  // possible. Browser support for Chrome 43+, Firefox 42+, Edge and IE 10+.
  // No Safari support, as of (Nov. 2015). Returns false.
  // IE: The clipboard feature may be disabled by an adminstrator. By default a prompt is
  // shown the first time the clipboard is used (per session).
  $.copyToClipboard = function(text) {
    if (window.clipboardData && window.clipboardData.setData) {
      // IE specific code path to prevent textarea being shown while dialog is visible.
      return window.clipboardData.setData('Text', text);
    }
    else if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
      var textarea = document.createElement('textarea');
      textarea.textContent = text;
      textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page in MS Edge.
      document.body.appendChild(textarea);
      textarea.select();
      try {
        return document.execCommand('copy'); // Security exception may be thrown by some browsers.
      }
      catch (ex) {
        // console.warn('Copy to clipboard failed.', ex);
        return false;
      }
      finally {
        document.body.removeChild(textarea);
      }
    }
  };

  //Functions For Sanitising and Escaping Html
  $.escapeHTML = function(value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&/g, '&amp;');
      newValue = newValue.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    return newValue;
  };

  $.unescapeHTML = function(value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
      newValue = newValue.replace(/&amp;/g, '&');
    }
    return newValue;
  };

  //Remove Script tags and all onXXX functions
  $.sanitizeHTML = function(html) {
    var santizedHtml = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/g, '');
    santizedHtml = santizedHtml.replace(/<[^>]+/g, function(match) {
      return match.replace(/(\/|\s)on\w+=(\'|")?[^"]*(\'|")?/g, '');
    });

    return santizedHtml;
  };


  //Clearable (Shows an X to clear)
  $.fn.clearable = function() {
    var self = this;
    this.element = $(this);

    //Create an X icon button styles in icons.scss
    this.xButton = $.createIconElement({ classes: 'close is-empty', icon: 'close' }).icon();

    //Create a function
    this.checkContents = function () {
      var text = self.element.val();
      if (!text || !text.length) {
        this.xButton.addClass('is-empty');
      } else {
        this.xButton.removeClass('is-empty');
      }

      this.element.trigger('contents-checked');
    };

    //Add the button to field parent
    this.xButton.insertAfter(self.element);

    //Handle Events
    this.xButton.offTouchClick('clearable').off()
      .onTouchClick('clearable', '.clearable')
      .on('click.clearable', function handleClear() {
        self.element.val('').trigger('change').focus().trigger('cleared');
        self.checkContents();
      });

    this.element.on('change.clearable, blur.clearable, keyup.clearable', function () {
      self.checkContents();
    });

    //Set initial state
    this.checkContents();
  };

  // Replacement for String.fromCharCode() that takes meta keys into account when determining which
  // character key was pressed.
  window.Soho.utils.actualChar = function(e) {
    var key = e.which,
      character = '',
      toAscii = {
        '188': '44',
        //'109': '45', // changes "m" to "-" when using keypress
        '190': '46',
        '191': '47',
        '192': '96',
        '220': '92',
        '222': '39',
        '221': '93',
        '219': '91',
        '173': '45',
        '187': '61', //IE Key codes
        '186': '59', //IE Key codes
        '189': '45'  //IE Key codes
      },
      shiftUps = {
        '96': '~',
        '49': '!',
        '50': '@',
        '51': '#',
        '52': '$',
        '53': '%',
        '54': '^',
        '55': '&',
        '56': '*',
        '57': '(',
        '48': ')',
        '45': '_',
        '61': '+',
        '91': '{',
        '93': '}',
        '92': '|',
        '59': ':',
        '37': '%',
        '38': '&',
        '39': '\"',
        '44': '<',
        '46': '>',
        '47': '?'
      };

    // Normalize weird keycodes
    if (toAscii.hasOwnProperty(key)) {
      key = toAscii[key];
    }

    // Handle Numpad keys
    if (key >= 96 && key <= 105) {
      key -= 48;
    }

    // Convert Keycode to Character String
    if (!e.shiftKey && (key >= 65 && key <= 90)) {
      character = String.fromCharCode(key + 32);
    } else if (e.shiftKey && shiftUps.hasOwnProperty(key)) { // User was pressing Shift + any key
      character = shiftUps[key];
    } else {
      character = String.fromCharCode(key);
    }

    return character;
  };

  $.actualChar = function(e) {
    return Soho.utils.actualChar(e);
  };

  window.Soho.utils.equals = function equals(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  };

  // Returns an array containing an element's attributes.
  window.Soho.DOM.getAttributes = function getAttributes(element) {
    if (!element || (!(element instanceof HTMLElement) && !(element instanceof SVGElement))) {
      return;
    }

    return element.attributes;
  };

  //Adding, removing, and testing for classes
  window.Soho.DOM.classNameExists = function classNameExists(element) {
    var cn = element.className;
    return cn && cn.length > 0;
  };

  window.Soho.DOM.classNameHas = function has(classNameString, targetContents) {
    return classNameString.indexOf(targetContents) > -1;
  };

  window.Soho.DOM.hasClass = function hasClass (el, className) {
    return el.classList ? el.classList.contains(className) : new RegExp('\\b'+ className+'\\b').test(el.className);
	};

  window.Soho.DOM.addClass = function addClass(el, className) {
     if (el.classList) {
      el.classList.add(className);
    } else if (!window.Soho.DOM.hasClass(el, className)) {
      el.className += ' ' + className;
    }
  };

  /**
   * Checks if an element is valid
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being checked
   * @returns {boolean} - represents all values normally contained by a DOMRect or ClientRect
   */
  window.Soho.DOM.isElement = function isElement(el) {
    if ((el instanceof HTMLElement) || (el instanceof SVGElement) || (el instanceof $ && el.length)) {
      return true;
    }
    return false;
  };

  /**
   * Runs the generic _getBoundingClientRect()_ method on an element, but returns its results
   * as a plain object instead of a ClientRect
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated
   * @returns {object} - represents all values normally contained by a DOMRect or ClientRect
   */
  window.Soho.DOM.getDimensions = function getDimensions(el) {
    if (!Soho.DOM.isElement(el)) {
      return {};
    }

    if (el instanceof $) {
      if (!el.length) {
        return {};
      }

      el = el[0];
    }

    var rect = el.getBoundingClientRect(),
      rectObj = {};
    for (var prop in rect) {
      if (!isNaN(rect[prop])) {
        rectObj[prop] = rect[prop];
      }
    }
    return rectObj;
  };

  // Debounce method
  window.Soho.utils.debounce = function(func, threshold, execAsap) {
    var timeout;

    return function debounced () {
      var obj = this, args = arguments;
      function delayed () {
        if (!execAsap) {
          func.apply(obj, args);
        }
        timeout = null;
      }

      if (timeout) {
        clearTimeout(timeout);
      } else if (execAsap) {
        func.apply(obj, args);
      }

      timeout = setTimeout(delayed, threshold || 250);
    };
  };

  // Debounced Resize method
  // https://www.paulirish.com/2009/throttled-smartresize-jquery-event-handler/
  (function($,sr){
    // smartresize
    $.fn[sr] = function(fn){  return fn ? this.bind('resize', Soho.utils.debounce(fn)) : this.trigger(sr); };
  })($, 'debouncedResize');

  // String parsing utils
  window.Soho.string = {};

  /**
   * The splice() method changes the content of a string by removing a range of
   * characters and/or adding new characters.
   *
   * @param {String} str The string that will be manipulated.
   * @param {number} start Index at which to start changing the string.
   * @param {number} delCount An integer indicating the number of old chars to remove.
   * @param {string} newSubStr The String that is spliced in.
   * @return {string} A new string with the spliced substring.
   */
  window.Soho.string.splice = function splice(str, start, delCount, newSubStr) {
    return str.slice(0, start) + newSubStr + str.slice(start + Math.abs(delCount));
  };


  /**
   * Takes a string with possible duplicate characters and returns a string
   * containing ALL unique characters.  Useful for construction of REGEX objects
   * with characters from an input field, etc.
   */
  window.Soho.string.removeDuplicates = function removeDuplicates(str) {
    return str
      .split('')
      .filter(function(item, pos, self) {
        return self.indexOf(item) === pos;
      })
      .join('');
  };


  /**
   * Object deep copy
   * For now, alias jQuery.extend
   * Eventually we'll replace this with a non-jQuery extend method.
   */
  window.Soho.utils.extend = $.extend;


  /**
   * Hack for IE11 and SVGs that get moved around/appended at inconvenient times.
   * The action of changing the xlink:href attribute to something else and back will fix the problem.
   * @return {undefined}
   */
  window.Soho.utils.fixSVGIcons = function fixSVGIcons(rootElement) {
    if (Soho.env.browser.name !== 'ie' && Soho.env.browser.version !== '11') {
      return;
    }

    if (rootElement === undefined) {
      return;
    }

    if (rootElement instanceof $) {
      if (!rootElement.length) {
        return;
      }

      rootElement = rootElement[0];
    }

    setTimeout(function () {
      var uses = rootElement.getElementsByTagName('use');
      for (var i = 0; i < uses.length; i++) {
        var attr = uses[i].getAttribute('xlink:href');
        uses[i].setAttribute('xlink:href', 'x');
        uses[i].setAttribute('xlink:href', attr);
      }
    }, 1);
  };

  /**
   * Gets the current size of the viewport
   * @returns {object}
   */
  window.Soho.utils.getViewportSize = function getViewportSize() {
    return {
      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    };
  };

  /**
   * Gets the various scrollable containers that an element is nested inside of, and returns their scrollHeight and scrollLeft values.
   * @returns {object[]}
   */
  window.Soho.utils.getContainerScrollDistance = function getContainerScrollDistance(element) {
    if (!Soho.DOM.isElement(element)) {
      return [];
    }

    var containers = [],
      scrollableElements = [
        '.scrollable', '.scrollable-x', '.scrollable-y', '.modal',
        '.card-content', '.widget-content', '.tab-panel',
        '.datagrid-content'
      ];

    $(element).parents(scrollableElements.join(', ')).each(function() {
      var el = this;

      containers.push({
        element: el,
        left: el.scrollLeft,
        top: el.scrollTop
      });
    });

    // Push the body's scroll area if it's not a "no-scroll" area
    if (!document.body.classList.contains('no-scroll')) {
      containers.push({
        element: document.body,
        left: document.body.scrollLeft,
        top: document.body.scrollTop
      });
    }

    return containers;
  };

  /**
   * Takes an element that is currently hidden by some means (FX: "display: none;") and gets its potential dimensions by checking a clone of the element that is NOT hidden.
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated.
   * @param {object} options - incoming options.
   * @param {jQuery[]} [parentElement=undefined] - the parent element where a clone of this hidden element will be attached.
   * @returns {object}
   */
  window.Soho.utils.getHiddenSize = function getHiddenSize(el, options) {
    var defaults = {
      dims: { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
      parentElement: undefined,
      includeMargin: false
    };

    if (!Soho.DOM.isElement(el)) {
      return defaults.dims;
    }

    el = $(el);
    options = $.extend({}, defaults, options);

    // element becomes clone and appended to a parentElement, if defined
    var hasDefinedParentElement = Soho.DOM.isElement(options.parentElement);
    if (hasDefinedParentElement) {
      el = el.clone().appendTo(options.parentElement);
    }

    var dims = options.dims,
      hiddenParents = el.parents().add(el),
      props = {
        transition: 'none',
        webkitTransition: 'none',
        mozTransition: 'none',
        msTransition: 'none',
        visibility: 'hidden',
        display: 'block',
      },
      oldProps = [];

    hiddenParents.each(function () {
      var old = {};

      for (var name in props) {
        if (this.style[name]) {
          old[name] = this.style[name];
          this.style[name] = props[name];
        }
      }

      oldProps.push(old);
    });

    dims.padding = {
      bottom: el.css('padding-bottom'),
      left: el.css('padding-left'),
      right: el.css('padding-right'),
      top: el.css('padding-top')
    };
    dims.width = el.width();
    dims.outerWidth = el.outerWidth(options.includeMargin);
    dims.innerWidth = el.innerWidth();
    dims.scrollWidth = el[0].scrollWidth;
    dims.height = el.height();
    dims.innerHeight = el.innerHeight();
    dims.outerHeight = el.outerHeight(options.includeMargin);
    dims.scrollHeight = el[0].scrollHeight;

    hiddenParents.each(function (i) {
      var old = oldProps[i];
      for (var name in props) {
        if (old[name]) {
          this.style[name] = old[name];
        }
      }
    });

    // element is ONLY removed when a parentElement is defined because it was cloned.
    if (hasDefinedParentElement) {
      el.remove();
    }

    return dims;
  };

  /**
   * Binds the Soho Util _getHiddenSize()_ to a jQuery selector
   * @param {object} options - incoming options
   * @returns {object}
   */
  $.fn.getHiddenSize = function(options) {
    return window.Soho.utils.getHiddenSize(this, options);
  };


  /**
   * Checks if a specific input is a String
   * @param {?} value
   * @returns {boolean}
   */
  window.Soho.utils.isString = function isString(value) {
    return typeof value === 'string' || value instanceof String;
  };


  /**
   * Checks if a specific input is a Number
   * @param {?} value
   * @returns {boolean}
   */
  window.Soho.utils.isNumber = function isNumber(value) {
    return typeof value === 'number' && value.length === undefined && !isNaN(value);
  };


  /**
   * Safely changes the position of a text caret inside of an editable element.
   * In most cases, will call "setSelectionRange" on an editable element immediately, but in some
   * cases, will be deferred with `requestAnimationFrame` or `setTimeout`.
   * @param {HTMLElement} element
   * @param {Number} startPos
   * @param {Number} endPos
   */
  window.Soho.utils.safeSetSelection = function safeSetSelection(element, startPos, endPos) {
    if (startPos && endPos === undefined) {
      endPos = startPos;
    }

    if (document.activeElement === element) {
      if (Soho.env.os.name === 'android') {
        Soho.behaviors.defer(function() {
          element.setSelectionRange(startPos, endPos, 'none');
        }, 0);
      } else {
        element.setSelectionRange(startPos, endPos, 'none');
      }
    }
  };





  window.Soho = window.Soho || {};
  window.Soho.behaviors = window.Soho.behaviors || {};

  /**
   * HideFocus Behavior
   * Only shows the focus state on key entry (tabs or arrows).
   * @param {HTMLElement|SVGElement} element
   * @returns {HideFocus}
   */
  function HideFocus(element) {
    return this.init(element);
  }

  HideFocus.prototype = {
    init: function(element) {
      if (!this.element && (element instanceof HTMLElement || element instanceof SVGElement)) {
        this.element = element;
      }

      var $el = $(element),
        isClick = false,
        isFocused = false,
        labelClicked = false;

      // Checkbox, Radio buttons or Switch
      if ($el.is('.checkbox, .radio, .switch')) {
        var label = $el.next();
        if (label.is('[type="hidden"]')) {
          label = label.next();
        }
        this.label = label[0];

        $el.addClass('hide-focus')
          .on('focusin.hide-focus', function(e) {
            if (!isClick && !isFocused && !labelClicked) {
              $el.removeClass('hide-focus');
              $el.triggerHandler('hidefocusremove', [e]);
            }
            isClick = false;
            isFocused = true;
            labelClicked = false;
          })
          .on('focusout.hide-focus', function(e) {
            $el.addClass('hide-focus');
            labelClicked = label.is(labelClicked);
            isClick = false;
            isFocused = false;
            $el.triggerHandler('hidefocusadd', [e]);
          });

        label.on('mousedown.hide-focus', function(e) {
          labelClicked = this;
          isClick = true;
          $el.addClass('hide-focus');
          $el.triggerHandler('hidefocusadd', [e]);
        });
      }

      // All other elements (ie. Hyperlinks)
      else {
        $el.addClass('hide-focus')
          .on('mousedown.hide-focus touchstart.hide-focus', function(e) {
            isClick = true;
            $el.addClass('hide-focus');
            $el.triggerHandler('hidefocusadd', [e]);
          })
          .on('focusin.hide-focus', function(e) {
            if (!isClick && !isFocused) {
              $el.removeClass('hide-focus');
              $el.triggerHandler('hidefocusremove', [e]);
            }
            isClick = false;
            isFocused = true;
          })
          .on('focusout.hide-focus', function(e) {
            $el.addClass('hide-focus');
            isClick = false;
            isFocused = false;
            $el.triggerHandler('hidefocusadd', [e]);
          });
      }

      return this;
    },

    updated: function() {
      return this
        .teardown()
        .init();
    },

    teardown: function() {
      if (this.label) {
        $(this.label).off('mousedown.hide-focus');
      }

      var elemEvents = [
        'focusin.hide-focus',
        'focusout.hide-focus',
        'mousedown.hide-focus',
        'touchstart.hide-focus'
      ];
      $(this.element).off(elemEvents.join(' '));

      return this;
    }
  };

  window.Soho.behaviors.hideFocus = HideFocus;

  $.fn.hideFocus = function() {
    return this.each(function() {
      var instance = $.data(this, 'hidefocus');
      if (instance) {
        instance.updated();
      } else {
        instance = $.data(this, 'hidefocus', new HideFocus(this));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, 'hidefocus');
        };
      }
    });
  };


  /**
   * Allows for the smooth scrolling of an element's content area.
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated.
   * @param {Number} target - target distance.
   * @param {Number} duration - the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred}
   */
  window.Soho.behaviors.smoothScrollTo = function(el, target, duration) {
    var dfd = $.Deferred();

    if (!Soho.DOM.isElement(el)) {
      // Not a workable element
      return dfd.reject();
    }

    // Strip the jQuery
    if (el instanceof $ && el.length) {
      el = el[0];
    }

    // undefined (not zero) target should instantly resolve
    if (target === undefined || target === null) {
      return dfd.resolve();
    }

    if (isNaN(duration)) {
      duration = 0;
    }

    target = Math.round(target);
    duration = Math.round(duration);

    if (duration < 0) {
      // bad duration
      return dfd.fail();
    }

    if (duration === 0) {
      el.scrollLeft = el.scrollLeft + target;
      return dfd.resolve();
    }

    var startTime = Date.now(),
      endTime = startTime + duration,
      startLeft = el.scrollLeft,
      distance = target /*- startLeft*/;

    // based on http://en.wikipedia.org/wiki/Smoothstep
    function smoothStep(start, end, point) {
      if (point <= start) { return 0; }
      if (point >= end) { return 1; }
      var x = (point - start) / (end - start); // interpolation
      return x*x*(3 - 2*x);
    }

    // This is to keep track of where the element's scrollLeft is
    // supposed to be, based on what we're doing
    var previousLeft = el.scrollLeft;

    // This is like a think function from a game loop
    function scrollFrame() {
      if (el.scrollLeft !== previousLeft) {
        // interrupted
        dfd.reject();
        return;
      }

      // set the scrollLeft for this frame
      var now = Date.now();
      var point = smoothStep(startTime, endTime, now);
      var frameLeft = Math.round(startLeft + (distance * point));
      el.scrollLeft = frameLeft;

      // check if we're done!
      if (now >= endTime) {
        dfd.resolve();
        return;
      }

      // If we were supposed to scroll but didn't, then we
      // probably hit the limit, so consider it done; not
      // interrupted.
      if (el.scrollLeft === previousLeft && el.scrollLeft !== frameLeft) {
        dfd.resolve();
        return;
      }
      previousLeft = el.scrollLeft;

      // schedule next frame for execution
      setTimeout(scrollFrame, 0);
    }

    // boostrap the animation process
    setTimeout(scrollFrame, 0);

    return dfd;
  };


  /**
   * Binds the Soho Behavior _smoothScrollTo()_ to a jQuery selector
   * @param {Number} target - target distance to scroll the element
   * @param {Number} duration - the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred}
   */
  $.fn.smoothScroll = function(target, duration) {
    return window.Soho.behaviors.smoothScrollTo(this, target, duration);
  };


  /**
   * Uses 'requestAnimationFrame' or 'setTimeout' to defer a function
   * @returns {requestAnimationFrame|setTimeout}
   */
  window.Soho.behaviors.defer = function defer(callback, timer) {
    var deferMethod = typeof window.requestAnimationFrame !== 'undefined' ? window.requestAnimationFrame : setTimeout;
    return deferMethod(callback, timer);
  };


  window.Soho = window.Soho || {};
  window.Soho.DOM = window.Soho.DOM || {};

  //==================================================================
  // JS-level Breakpoint Access
  // NOTE: these should match whatever the breakpoints are in "/sass/_config.scss"
  //==================================================================
  window.Soho.breakpoints = {
    'phone': 320,
    'slim': 400,
    'phablet': 610,
    'phone-to-tablet': 767,
    'wide-tablet': 968,
    'tablet-to-desktop': 1280,
    'desktop': 1024,
    'desktop-to-extralarge': 1600
  };


  /**
   * Get the name of the current CSS breakpoint by checking the popuplated 'content' value of the
   * <body> tag's `::after` pseudo-element.  These names should be reflected in the breakpoints object
   * above.
   * @returns {String}
   */
  window.Soho.breakpoints.current = function() {
    var afterElement = window.getComputedStyle ? window.getComputedStyle(document.body, ':after') : false;
    if (!afterElement) {
      return '';
    }
    return (afterElement.getPropertyValue('content') || '').replace(/"/g, '');
  };


  /**
   * @param {string} breakpoint - matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean}
   */
  window.Soho.breakpoints.isAbove = function isAbove(breakpoint) {
    var bp = Soho.breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth > bp;
  };


  /**
   * @param {string} breakpoint - matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean}
   */
  window.Soho.breakpoints.isBelow = function isBelow(breakpoint) {
    var bp = Soho.breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth < bp;
  };


  /**
   * Checks an element for Soho visibility classes and determines whether or not
   * should be hidden based on those values at the current breakpoint.
   * NOTE: this method does NOT determine if the element is ACTUALLY hidden with a
   * `display: none;` or `visibility: hidden;` rule.  It determines whether or not a CSS
   * visibility rule alone would hide the element.
   * @param {HTMLElement} element
   * @returns {boolean}
   */
  window.Soho.breakpoints.isHidden = function(element) {
    if (!element || !Soho.DOM.isElement(element)) {
      return false;
    }

    // If there are no CSS classes on the element, return false.
    var cl = element.classList;
    if (!cl.length) {
      return false;
    }

    // If it's always hidden, always return true.
    if (cl.contains('hidden')) {
      return true;
    }

    var bp = Soho.breakpoints.current(),
      map = {
        'phonedown': 'xs',
        'phone': 'sm',
        'tablet': 'md',
        'desktop': 'lg',
        'extralarge': 'xl',
      },
      size = map[bp],
      hiddenClassName = 'hidden-' + size,
      visibleClassName = 'visible-' + size + '-';

    // Should be hidden on this breakpoint
    if (cl.contains(hiddenClassName)) {
      return true;
    }

    // If explicitly visible, return
    if (cl.toString().indexOf(visibleClassName) > -1) {
      return false;
    }

    // Simply return false if none of these thing are found
    return false;
  };

  /**
   * jQuery wrapper for `Soho.breakpoints.isHidden()`
   * NOTE: if a jQuery selector with multiple elements is passed to this function, it will only operate on the first one.
   * This method is NOT chainable.
   * @returns {boolean}
   */
  $.fn.isHiddenAtBreakpoint = function() {
    if (!this.length) {
      return false;
    }
    return Soho.breakpoints.isHidden($(this).first()[0]);
  };


// Page Bootstrapper


  /**
   * Checks the breakpoint and triggers an event if the breakpoint's changed.
   */
  function breakpointCheck() {
    if (!Soho.breakpoints.last) {
      Soho.breakpoints.last = '';
    }

    var cur = Soho.breakpoints.current();
    if (Soho.breakpoints.last !== cur) {
      $('body').triggerHandler('breakpoint-change', [{
        previous: Soho.breakpoints.last,
        current: cur
      }]);
      Soho.breakpoints.last = cur;
    }
  }


  var version = '4.3.3',
    environment = {

    // Setup a global resize event trigger for controls to listen to
    addGlobalResize: function() {
      window.Soho.breakpoints = window.Soho.breakpoints || {};

      // Global resize event
      $(window).debouncedResize(function() {
        $('body').triggerHandler('resize', [window]);
        breakpointCheck();
      });

      // Also detect whenenver a load or orientation change occurs
      $(window).on('orientationchange load', breakpointCheck);

      return this;
    },

    set: function () {
      this
        .makeSohoObject()
        .addBrowserClasses()
        .addGlobalResize();
    },

    // Global Classes for browser, version and device as needed.
    addBrowserClasses: function() {
      var ua = navigator.userAgent || navigator.vendor || window.opera,
        html = $('html'),
        cssClasses = ''; // User-agent string

      if (ua.indexOf('Safari')  !== -1 &&
          ua.indexOf('Chrome')  === -1 &&
          ua.indexOf('Android') === -1) {
        cssClasses += 'is-safari ';
        Soho.env.browser.name = 'safari';
      }

      if (ua.indexOf('Chrome') !== -1) {
        cssClasses += 'is-chrome ';
        Soho.env.browser.name = 'chrome';
      }

      if (ua.indexOf('Mac OS X') !== -1) {
        cssClasses += 'is-mac ';
        Soho.env.os.name = 'Mac OS X';
      }

      if (ua.indexOf('Firefox') > 0) {
        cssClasses += 'is-firefox ';
        Soho.env.browser.name = 'firefox';
      }

      //Class-based detection for IE
      if (ua.match(/Edge\//)) {
        cssClasses += 'ie ie-edge ';
        Soho.env.browser.name = 'edge';
      }
      if (ua.match(/Trident/)) {
        cssClasses += 'ie ';
        Soho.env.browser.name = 'ie';
      }
      if (navigator.appVersion.indexOf('MSIE 8.0') > -1 ||
        ua.indexOf('MSIE 8.0') > -1 ||
        document.documentMode === 8) {
        cssClasses += 'ie8 ';
        Soho.env.browser.version = '8';
      }
      if (navigator.appVersion.indexOf('MSIE 9.0') > -1) {
        cssClasses += 'ie9 ';
        Soho.env.browser.version = '9';
      }
      if (navigator.appVersion.indexOf('MSIE 10.0') > -1) {
        cssClasses += 'ie10 ';
        Soho.env.browser.version = '10';
      } else {
        if (ua.match(/Trident\/7\./)) {
          cssClasses += 'ie11 ';
          Soho.env.browser.version = '11';
        }
      }

      // Class-based detection for iOS
      // /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/
      if ((/iPhone|iPod|iPad/).test(ua)) {
        cssClasses += 'ios ';
        Soho.env.os.name = 'ios';

        var iDevices = ['iPod', 'iPad', 'iPhone'];
        for (var i = 0; i < iDevices.length; i++) {
          if (new RegExp(iDevices[i]).test(ua)) {
            cssClasses += iDevices[i].toLowerCase() + ' ';
            Soho.env.device = iDevices[i];
          }
        }
      }

      if ((/Android/.test(ua))) {
        cssClasses += 'android ';
        Soho.env.os.name = 'android';
      }

      html.addClass(cssClasses);
      html.attr('data-sohoxi-version', version);
      return this;
    },

    makeSohoObject: function() {
      window.Soho = window.Soho || {};

      window.Soho.logTimeStart = function(label) {
        if (window.Soho.logTime) {
          console.time(label); // jshint ignore:line
        }
      };

      window.Soho.logTimeEnd = function(label) {
        if (window.Soho.logTime) {
          console.timeEnd(label); // jshint ignore:line
        }
      };

      // Environment object provides JS-friendly way to figure out our browser support
      window.Soho.env = {
        browser: {},
        os: {},
        rtl: $('html').attr('dir') === 'rtl'
      };

      // Get the name of the paste event.  Could be "paste" or "input" based on the browser.
      window.Soho.env.pasteEvent = (function getPasteEvent() {
        var el = document.createElement('input'),
            name = 'onpaste';
        el.setAttribute(name, '');
        return ((typeof el[name] === 'function') ? 'paste' : 'input');
      })();

      window.Soho.theme = 'light';

      return this;
    }

  };

  environment.set();
// Height Animation Controls
// Adapted from: http://n12v.com/css-transition-to-from-auto/
// Contains a handful of animation helper methods that attempt to DRY up CSS-powered sliding animations.


  // Use CSS Transitions to animate from "0" to "auto" widths
  $.fn.animateOpen = function(options) {
    'use strict';

    // Settings and Options
    var defaults = {
        direction: 'vertical', // Can also be 'horizontal'
        distance: 'auto', // Distance in pixels that the animation covers.  'auto', or pixel value size
        timing: 300, // in Miliseconds
        transition: 'cubic-bezier(.17, .04, .03, .94)' // CSS Transition Timing Function
      },
      settings = $.extend({}, defaults, options);

    // Initialize the plugin (Once)
    return this.each(function() {
      var self = this,
        $self = $(this),
        eventName = $.fn.transitionEndName(),
        dim = settings.direction === 'horizontal' ? 'width' : 'height',
        cDim = dim.charAt(0).toUpperCase() + dim.slice(1),
        distance = !isNaN(settings.distance) ? parseInt(settings.distance, 10) + 'px' : 'auto',
        timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animateopen');
        self.style.transition = '';
        self.style[dim] = distance;
        $self.trigger('animateopencomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateopenstart.animation', function(e) {
        e.stopPropagation();
        $self.off(eventName + '.animateopen');
      });
      $self.trigger('animateopenstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animateopen', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      var prevVal = this.style[dim];
      this.style[dim] = distance;
      var endVal = getComputedStyle(this)[dim];
      this.style[dim] = prevVal;
      // next line forces a repaint
      this['offset' + cDim]; // jshint ignore:line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = endVal;

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Use CSS Transitions to animate from "auto" to "0" widths
  $.fn.animateClosed = function(options) {

    // Settings and Options
    var defaults = {
        direction: 'vertical', // can also be 'horizontal'
        timing: 300, // in Miliseconds
        transition: 'cubic-bezier(.17, .04, .03, .94)'
      },
      settings = $.extend({}, defaults, options);

    // Initialize the plugin (Once)
    return this.each(function() {
      var self = this,
        $self = $(this),
        eventName = $.fn.transitionEndName(),
        dim = settings.direction === 'horizontal' ? 'width' : 'height',
        cDim = dim.charAt(0).toUpperCase() + dim.slice(1),
        timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animatedclosed');
        self.style.transition = '';
        self.style[dim] = '0px';
        $self.trigger('animateclosedcomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateclosedstart', function(e) {
        e.stopPropagation();
        $self.off(eventName + '.animatedclosed');
      });
      $self.trigger('animateclosedstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animatedclosed', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      this.style[dim] = getComputedStyle(this)[dim];
      // next line forces a repaint
      this['offset' + cDim]; // jshint ignore:line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = '0px';

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Chainable jQuery plugin that checks if an element is in the process of animating
  $.fn.isAnimating = function() {
    return this.each(function() {
      return $(this).data('is-animating') === true;
    });
  };

// Localization Routines
// Data From: http://www.unicode.org/repos/cldr-aux/json/22.1/main/
// For Docs See: http://ibm.co/1nXyNxp


  //If there already exists a Locale object with a culturesPath use that path
  //This allows manually setting the directory for the culture files to be retrieved from
  var existingCulturePath = '';

  if (window.Locale && window.Locale.hasOwnProperty('culturesPath')) {
    existingCulturePath = window.Locale.culturesPath;
  }

  /**
  * The Locale component handles i18n
  *
  * @class Locale
  * @param {String} currentLocale  &nbsp;-&nbsp; The Currently Set Locale
  *
  */
  window.Locale = {

    currentLocale:  {name: '', data: {}}, //default
    cultures: {},
    culturesPath: existingCulturePath,

    //Sets the Lang in the Html Header
    updateLang: function () {
      var html = $('html');

      html.attr('lang', this.currentLocale.name);
      if (this.isRTL()) {
        html.attr('dir', 'rtl');
      } else {
        html.removeAttr('dir');
      }
    },

    //Get the path to the directory with the cultures
    getCulturesPath: function() {
      if (!this.culturesPath) {
        var scripts = document.getElementsByTagName('script'),
          partialPathMin = 'sohoxi.min.js',
          partialPath = 'sohoxi.js';

        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          //remove from ? to end
          var idx = src.indexOf('?');
          if (src !== '' && idx > -1) {
            src = src.substr(0, idx);
          }

          if (scripts[i].id === 'sohoxi-script') {
            return src.substring(0, src.lastIndexOf('/')) + '/';
          }

          if (src.indexOf(partialPathMin) > -1) {
            this.culturesPath = src.replace(partialPathMin, '') + 'cultures/';
          }
          if (src.indexOf(partialPath) > -1) {
            this.culturesPath = src.replace(partialPath, '') + 'cultures/';
          }


        }
      }
      return this.culturesPath;
    },

    cultureInHead: function() {
      var isThere = false,
        scripts = document.getElementsByTagName('script'),
        partialPath = 'cultures';


        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          if (src.indexOf(partialPath) > -1) {
            isThere = true;
          }
        }

      return isThere;
    },

    addCulture: function(locale, data) {
      this.cultures[locale] = data;
    },

    /**
    * Set the currently used colors.
    *
    * @param {String} locale  &nbsp;-&nbsp; The locale to fetch and set.
    */
    set: function (locale) {
      var self = this;
      this.dff = $.Deferred();

      //Map incorrect java locale to correct locale
      if (locale === 'in-ID') {
        locale = 'id-ID';
      }

      if (locale && !this.cultures[locale] && this.currentLocale.name !== locale) {
        this.setCurrentLocale(locale);

        //fetch the local and cache it
        $.ajax({
          url: this.getCulturesPath() + this.currentLocale.name + '.js',
          dataType: 'script',
          error: function () {
            self.dff.reject();
          }
        }).done(function () {
          self.setCurrentLocale(locale, self.cultures[locale]);
          self.addCulture(locale, self.currentLocale.data);

          if (locale && (locale === 'en-US' || self.cultures['en-US'])) {
            self.dff.resolve(self.currentLocale.name);
          }
        });
      }

      if (locale && locale !== 'en-US' && !this.cultures['en-US']) {
        //fetch the english local and cache it from translation defaults
        $.ajax({
          url: this.getCulturesPath() + 'en-US.js',
          dataType: 'script',
          error: function () {
            self.dff.reject();
          }
        }).done(function () {
          self.addCulture(locale, self.currentLocale.data);
          self.dff.resolve(self.currentLocale.name);
        });
      }

      if (locale && self.currentLocale.data && self.currentLocale.dataName === locale) {
        self.dff.resolve(self.currentLocale.name);
      }

      self.setCurrentLocale(locale, self.cultures[locale]);

      if (self.cultures[locale] && this.cultureInHead()) {
        self.dff.resolve(self.currentLocale.name);
      }
      return this.dff.promise();
    },

    setCurrentLocale: function(name, data) {
      this.currentLocale.name = name;

      if (data) {
        this.currentLocale.data = data;
        this.currentLocale.dataName = name;
      }
      this.updateLang();
    },

    /**
    * Format a Date Object and return it parsed in the current locale.
    *
    * @param {Date} value  &nbsp;-&nbsp; The date to show in the current locale.
    * @param {Object} attribs  &nbsp;-&nbsp; Additional formatting settings.
    */
    formatDate: function(value, attribs) {

      //We will use http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
      if (!attribs) {
        attribs = {date: 'short'};  //can be date, time, datetime or pattern
      }

      if (!value) {
        return undefined;
      }

      //Convert if a string..
      if (!(value instanceof Date)) {
        var tDate = new Date(value);
        if (isNaN(tDate) && attribs.date === 'datetime' &&
          value.substr(4, 1) === '-' &&
          value.substr(7, 1) === '-') {
          tDate = new Date(
            value.substr(0, 4),
            value.substr(5, 2) - 1,
            value.substr(8, 2),
            value.substr(11, 2),
            value.substr(14, 2),
            value.substr(17, 2)
          );
        }
        value = tDate;
      }

      // TODO: Can we handle this if (this.dff.state()==='pending')
       var data = this.currentLocale.data,
        pattern, ret = '', cal = (data.calendars ? data.calendars[0] : null);

      if (attribs.pattern) {
        pattern = attribs.pattern;
      }

      if (attribs.date) {
        pattern = cal.dateFormat[attribs.date];
      }

      var day = value.getDate(), month = value.getMonth(), year = value.getFullYear(),
        mins = value.getMinutes(), hours = value.getHours(), seconds = value.getSeconds();

      //Special
      pattern = pattern.replace('ngày','nnnn');
      pattern = pattern.replace('tháng','t1áng');
      pattern = pattern.replace('den','nnn');

      //Day of Month
      ret = pattern.replace('dd', this.pad(day, 2));
      ret = ret.replace('d', day);

      //years
      ret = ret.replace('yyyy', year);
      ret = ret.replace('yy', year.toString().substr(2));
      ret = ret.replace('y', year);

      //Time
      var showDayPeriods = ret.indexOf(' a') > -1;

      if (showDayPeriods && hours === 0) {
        ret = ret.replace('hh', 12);
        ret = ret.replace('h', 12);
      }

      ret = ret.replace('hh', (hours > 12 ? this.pad(hours - 12, 2) : this.pad(hours, 2)));
      ret = ret.replace('h', (hours > 12 ? hours - 12 : hours));
      ret = ret.replace('HH', this.pad(hours, 2));
      ret = ret.replace('H', (hours > 12 ? hours - 12 : hours));
      ret = ret.replace('mm', this.pad(mins, 2));
      ret = ret.replace('ss', this.pad(seconds, 2));
      ret = ret.replace('SSS', this.pad(value.getMilliseconds(), 0));

      //months
      ret = ret.replace('MMMM', cal ? cal.months.wide[month] : null);  //full
      ret = ret.replace('MMM',  cal ? cal.months.abbreviated[month] : null);  //abreviation
      if (pattern.indexOf('MMM') === -1) {
        ret = ret.replace('MM', this.pad(month+1, 2));  //number padded
        ret = ret.replace('M', month+1);                //number unpadded
      }

      //PM
      if (cal) {
        ret = ret.replace(' a', ' '+ (hours >= 12 ? cal.dayPeriods[1] : cal.dayPeriods[0]));
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]);  //Day of Week
      }

      //Day of Week
      if (cal) {
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]);  //Day of Week
      }
      ret = ret.replace('nnnn','ngày');
      ret = ret.replace('t1áng','tháng');
      ret = ret.replace('nnn','den');

      return ret.trim();
    },

    /**
    * Check if the date is valid using the current locale to do so.
    *
    * @param {Date} value  &nbsp;-&nbsp; The date to show in the current locale.
    */
    isValidDate: function (date) {
      if (Object.prototype.toString.call(date) === '[object Date]') {
        // it is a date
        if (isNaN(date.getTime())) {  // d.valueOf() could also work
          return false;
        } else {
          return true;
        }
      } else {
        return false;
      }
    },

    /**
    * Take a date string written in the current locale and parse it into a Date Object
    *
    * @param {String} dateString  &nbsp;-&nbsp; The string to parse in the current format
    * @param {String} dateFormat  &nbsp;-&nbsp; The source format fx yyyy-MM-dd
    * @param {Boolean} isStrict  &nbsp;-&nbsp; If true missing date parts will be considered invalid. If false the current month/day.
    */
    parseDate: function(dateString, dateFormat, isStrict) {
      var thisLocaleCalendar = this.calendar(),
        orgDatestring = dateString;

      if (!dateString) {
        return undefined;
      }

      if (!dateFormat) {
        dateFormat = this.calendar().dateFormat.short;
      }

      if (dateFormat.pattern) {
        dateFormat = dateFormat.pattern;
      }

      if (typeof dateFormat === 'object' && dateFormat.date)  {
        dateFormat = this.calendar().dateFormat[dateFormat.date];
      }

      var formatParts,
        dateStringParts,
        dateObj = {},
        isDateTime = (dateFormat.toLowerCase().indexOf('h') > -1),
        isUTC = (dateString.toLowerCase().indexOf('z') > -1),
        i, l;

      if (isDateTime) {
        //replace [space & colon & dot] with "/"
        dateFormat = dateFormat.replace(/[T\s:.-]/g,'/').replace(/z/i, '');
        dateString = dateString.replace(/[T\s:.-]/g,'/').replace(/z/i, '');
      }

      if (dateFormat === 'Mdyyyy' || dateFormat === 'dMyyyy') {
        dateString = dateString.substr(0, dateString.length - 4) + '/' + dateString.substr(dateString.length - 4, dateString.length);
        dateString = dateString.substr(0, dateString.indexOf('/')/2) + '/' + dateString.substr(dateString.indexOf('/')/2);
      }

      if (dateFormat === 'Mdyyyy') {
        dateFormat = 'M/d/yyyy';
      }

      if (dateFormat === 'dMyyyy') {
        dateFormat = 'd/M/yyyy';
      }

      if (dateFormat.indexOf(' ') !== -1 ) {
        dateFormat = dateFormat.replace(/[\s:.]/g,'/');
        dateString = dateString.replace(/[\s:.]/g,'/');
      }

      if (dateFormat.indexOf(' ') === -1 && dateFormat.indexOf('.') === -1  && dateFormat.indexOf('/')  === -1 && dateFormat.indexOf('-')  === -1) {
        var lastChar = dateFormat[0],
          newFormat = '', newDateString = '';

        for (i = 0, l = dateFormat.length; i < l; i++) {
          newFormat +=  (dateFormat[i] !== lastChar ? '/' + dateFormat[i]  : dateFormat[i]);
          newDateString += (dateFormat[i] !== lastChar ? '/' + dateString[i]  : dateString[i]);

          if (i > 1) {
            lastChar = dateFormat[i];
          }
        }

        dateString = newDateString;
        dateFormat = newFormat;
      }

      formatParts = dateFormat.split('/');
      dateStringParts = dateString.split('/');

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('.');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('.');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('-');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('-');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split(' ');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split(' ');
      }

      // Check the incoming date string's parts to make sure the values are valid against the localized
      // Date pattern.
      var month = this.getDatePart(formatParts, dateStringParts, 'M', 'MM', 'MMM'),
        year = this.getDatePart(formatParts, dateStringParts, 'yy', 'yyyy'),
        hasDays = false;

      for (i = 0, l = dateStringParts.length; i < l; i++) {
        var pattern = formatParts[i] + '',
          value = dateStringParts[i],
          numberValue = parseInt(value);

        if (!hasDays) {
          hasDays = pattern.toLowerCase().indexOf('d') > -1;
        }

        switch(pattern) {
          case 'd':
            var lastDay = new Date(year, month, 0).getDate();

            if (numberValue < 1 || numberValue > 31 || numberValue > lastDay) {
              return;
            }
            dateObj.day = value;
            break;
          case 'dd':
            if ((numberValue < 1 || numberValue > 31) || (numberValue < 10 && value.substr(0,1) !== '0')) {
              return;
            }
            dateObj.day = value;
            break;
          case 'M':
            if (numberValue < 1 || numberValue > 12) {
              return;
            }
            dateObj.month = value-1;
            break;
          case 'MM':
            if ((numberValue < 1 || numberValue > 12) || (numberValue < 10 && value.substr(0,1) !== '0')) {
              return;
            }
            dateObj.month = value-1;
            break;
          case 'MMM':
              var abrMonth = this.calendar().months.abbreviated;

              for (var len = 0; len < abrMonth.length; len++) {
                if (orgDatestring.indexOf(abrMonth[len]) > -1) {
                  dateObj.month = len;
                }
              }

              break;
          case 'MMMM':
            var textMonths = this.calendar().months.wide;

            for (var k = 0; k < textMonths.length; k++) {
              if (orgDatestring.indexOf(textMonths[k]) > -1) {
                dateObj.month = k;
              }
            }

            break;
          case 'yy':
            dateObj.year = this.twoToFourDigitYear(value);
            break;
          case 'yyyy':
            dateObj.year = (value.length === 2) ?
              this.twoToFourDigitYear(value) : value;
            break;
          case 'h':
            if (numberValue < 0 || numberValue > 12) {
              return;
            }
            dateObj.h = value;
            break;
          case 'hh':
            if (numberValue < 0 || numberValue > 12) {
              return;
            }
            dateObj.h = value.length === 1 ? '0'+value : value;
            break;
          case 'H':
            if (numberValue < 0 || numberValue > 12) {
              return;
            }
            dateObj.h = value;
            break;
          case 'HH':
            if (numberValue < 0 || numberValue > 24) {
              return;
            }
            dateObj.h = value.length === 1 ? '0'+value : value;
            break;

          case 'ss':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.ss = 0;
              break;
            }
            dateObj.ss = value;
            break;

	      case 'SSS':
            dateObj.ms = value;
            break;

          case 'mm':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.mm = 0;
              break;
            }
            dateObj.mm = value;
            break;

          case 'a':
            if((value.toLowerCase() === thisLocaleCalendar.dayPeriods[0]) ||
             (value.toUpperCase() === thisLocaleCalendar.dayPeriods[0])) {
              dateObj.a = 'AM';

              if (dateObj.h) {
                if (dateObj.h === 12 || dateObj.h === '12') {
                  dateObj.h = 0;
                }
              }
            }

            if((value.toLowerCase() === thisLocaleCalendar.dayPeriods[1]) ||
             (value.toUpperCase() === thisLocaleCalendar.dayPeriods[1])) {
              dateObj.a = 'PM';

              if (dateObj.h) {
                if (dateObj.h < 12) {
                  dateObj.h = parseInt(dateObj.h) + 12;
                }
              }
            }
            break;
        }
      }

      dateObj.return = undefined;
      dateObj.leapYear = ((dateObj.year % 4 === 0) && (dateObj.year % 100 !== 0)) || (dateObj.year % 400 === 0);

      if ((isDateTime && !dateObj.h && !dateObj.mm)) {
        return undefined;
      }

      if (!dateObj.year && dateObj.year !== 0 && !isStrict) {
        dateObj.isUndefindedYear = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('y') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedYear = false;
            break;
          }
        }
        if (dateObj.isUndefindedYear) {
          dateObj.year = (new Date()).getFullYear();
        } else {
          delete dateObj.year;
        }
      }

      //Fix incomelete 2 and 3 digit years
      if (dateObj.year && dateObj.year.length === 2) {
        dateObj.year = '20' + dateObj.year;
      }

      // TODO: Need to find solution for three digit year
      // http://jira/browse/SOHO-4691
      // if (dateObj.year && dateObj.year.length === 3) {
      //   dateObj.year = '2' + dateObj.year;
      // }

      dateObj.year = $.trim(dateObj.year);
      dateObj.day = $.trim(dateObj.day);

      if (dateObj.year === '' || (dateObj.year && !((dateObj.year + '').length === 2 || (dateObj.year + '').length === 4))) {
        delete dateObj.year;
      }

      if (!dateObj.month && dateObj.month !== 0 && !isStrict) {
        dateObj.isUndefindedMonth = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('M') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedMonth = false;
            break;
          }
        }
        if (dateObj.isUndefindedMonth) {
          dateObj.month = (new Date()).getMonth();
        }
      }

      if (!dateObj.day && dateObj.day !== 0 && (!isStrict || !hasDays)) {
        dateObj.isUndefindedDay = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('d') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedDay = false;
            break;
          }
        }
        if (dateObj.isUndefindedDay) {
          dateObj.day = 1;
        } else {
          delete dateObj.day;
        }
      }

      if (isDateTime) {
        if (isUTC) {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm));
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss));
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms));
          }
        }
        else
        {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm);
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss);
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms);
          }
        }
      } else {
        dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day);
      }

      return (this.isValidDate(dateObj.return) ? dateObj.return : undefined);

    },

    twoToFourDigitYear: function (twoDigitYear) {
      return parseInt((twoDigitYear > 39 ? '19' : '20') + twoDigitYear, 10);
    },

    getDatePart: function (formatParts, dateStringParts, filter1, filter2, filter3) {
      var ret = 0;

      $.each(dateStringParts, function(i) {
        if (filter1 === formatParts[i] || filter2 === formatParts[i] || filter3 === formatParts[i]) {
          ret = dateStringParts[i];
        }
      });

      return ret;
    },

    /**
    * Format a decimal with thousands and padding in the current locale.
    * http://mzl.la/1MUOEWm
    *
    * @param {Number} number  &nbsp;-&nbsp; The source number.
    * @param {Boolean} options  &nbsp;-&nbsp; Additional options.style can be decimal, currency, percent and integer options.percentSign, options.minusSign, options.decimal, options.group options.minimumFractionDigits (0), options.maximumFractionDigits (3)
    */
    formatNumber: function(number, options) {
      //Lookup , decimals, decimalSep, thousandsSep
      var formattedNum, curFormat, percentFormat,
        decimal = options && options.decimal ? options.decimal : this.numbers().decimal,
        group = options && options.group !== undefined ? options.group : this.numbers().group,
        minimumFractionDigits = options && options.minimumFractionDigits !== undefined ? options.minimumFractionDigits : (options && options.style && options.style === 'currency' ? 2 : (options && options.style && options.style === 'percent') ? 0 : 2),
        maximumFractionDigits = options && options.maximumFractionDigits !== undefined ? options.maximumFractionDigits : (options && options.style && (options.style === 'currency' || options.style === 'percent') ? 2 : (options && options.minimumFractionDigits ? options.minimumFractionDigits : 3));

      if (number === undefined || number === null || number === '') {
        return undefined;
      }

      if (options && options.style === 'integer') {
        maximumFractionDigits = 0;
        minimumFractionDigits = 0;
      }

      if (options && options.style === 'currency') {
        var sign = options && options.currencySign ? options.currencySign : this.currentLocale.data.currencySign,
          format = options && options.currencyFormat ? options.currencyFormat : this.currentLocale.data.currencyFormat;

        curFormat = format.replace('¤', sign);
      }

      if (options && options.style === 'percent') {
        var percentSign = this.currentLocale.data.numbers.percentSign;

        percentFormat = this.currentLocale.data.numbers.percentFormat;
        percentFormat = percentFormat.replace('¤', percentSign);
      }

      if (typeof number === 'string') {

        if (decimal !== '.') {
          number = number.replace(decimal, '.');
        }
        number = Locale.parseNumber(number);
      }

      if (options && options.style === 'percent') {
        // the toFixed for maximumFractionDigits + 1 means we won't loose any precision
        number = (number * 100).toFixed(minimumFractionDigits);
      }

      var parts = this.truncateDecimals(number, minimumFractionDigits, maximumFractionDigits, options && options.round).split('.');
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, group);
      formattedNum = parts.join(decimal);

      // Position the negative at the front - There is no CLDR info for this.
      var minusSign = (this.currentLocale.data && this.currentLocale.data.numbers && this.currentLocale.data.numbers.minusSign) ? this.currentLocale.data.numbers.minusSign : '-',
        isNegative = (formattedNum.indexOf(minusSign) > -1);
        formattedNum = formattedNum.replace(minusSign, '');

      if (minimumFractionDigits === 0) { //Not default
        formattedNum = formattedNum.replace(/(\.[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, '');              // remove trailing dot
      }

      if (minimumFractionDigits === 0 && decimal !== '.') { //Not default
        formattedNum = formattedNum.replace(/(\,[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\,$/, '');              // remove trailing dot
      }

      if (minimumFractionDigits > 0) {
        var expr = new RegExp('(\\..{' + minimumFractionDigits+ '}[0-9]*?)0+$');
        formattedNum = formattedNum.replace(expr, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, '');  // remove trailing dot
      }

      //Confirm Logic After All Locales are added.
      if (options && options.style === 'currency') {
        formattedNum = curFormat.replace('#,##0.00', formattedNum);
        formattedNum = formattedNum.replace('#,##0.00', formattedNum);
      }

      if (options && options.style === 'percent') {
        formattedNum = percentFormat.replace('#,##0', formattedNum);
        formattedNum = formattedNum.replace('#.##0', formattedNum);
      }

      if (isNegative) {
        formattedNum = minusSign + formattedNum;
      }
      return formattedNum;
    },

    decimalPlaces: function(number) {
      var result= /^-?[0-9]+\.([0-9]+)$/.exec(number);
      return result === null ? 0 : result[1].length;
    },

    truncateDecimals: function (number, minDigits, maxDigits, round) {
      var multiplier = Math.pow(10, maxDigits),
        adjustedNum = number * multiplier,
        truncatedNum;

      //Round Decimals
      var decimals = this.decimalPlaces(number);

      //Handle larger numbers
      if (number.toString().length - decimals - 1 >= 10 ||
        (decimals === minDigits && decimals === maxDigits) || (decimals < maxDigits)) {
        multiplier = Math.pow(100, maxDigits);
        adjustedNum = number * multiplier;
      }

      truncatedNum = Math[adjustedNum < 0 ? 'ceil' : 'floor'](adjustedNum);

      if (round && decimals >= maxDigits && adjustedNum > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (round && decimals <= maxDigits && decimals > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (decimals < maxDigits && decimals > 0) {
        truncatedNum = Math.floor(adjustedNum);
        maxDigits = Math.max(decimals, minDigits);
      }

      return (truncatedNum / multiplier).toFixed(maxDigits);
    },

    /**
    * Take a Formatted Number and return a real number
    *
    * @param {String} input  &nbsp;-&nbsp; The source number (as a string).
    *
    */
    parseNumber: function(input) {
      var numSettings = this.currentLocale.data.numbers,
        numString, group, decimal, percentSign, currencySign;

      numString = input;

      if (!numString) {
        return NaN;
      }

      group = numSettings ? numSettings.group  : ',';
      decimal = numSettings ? numSettings.decimal  : '.';
      percentSign = numSettings ? numSettings.percentSign  : '%';
      currencySign = currencySign ? this.currentLocale.data.currencySign  : '$';

      numString = numString.replace(new RegExp('\\' + group, 'g'), '');
      numString = numString.replace(decimal, '.');
      numString = numString.replace(percentSign, '');
      numString = numString.replace(currencySign, '');
      numString = numString.replace(' ', '');

      return parseFloat(numString);
    },

    /**
    * Overridable culture messages
    *
    * @param {String} key  &nbsp;-&nbsp; The key to search for on the string.
    *
    */
    translate: function(key, showAsUndefined) {
      if (this.currentLocale.data === undefined || this.currentLocale.data.messages === undefined) {
        return showAsUndefined ? undefined : '[' + key + ']';
      }

      if (this.currentLocale.data.messages[key] === undefined) {
        // Substitue English Expression if missing
        if (!this.cultures['en-US'] || this.cultures['en-US'].messages[key] === undefined) {
          return showAsUndefined ? undefined : '[' + key + ']';
        }
        return this.cultures['en-US'].messages[key].value;
      }

      return this.currentLocale.data.messages[key].value;
    },

    // Translate Day Period
    translateDayPeriod: function(period) {
      if (/am|pm|AM|PM/i.test(period)) {
        return Locale.calendar().dayPeriods[/AM|am/i.test(period) ? 0 : 1];
      }
      return period;
    },

    // Short cut function to get 'first' calendar
    calendar: function() {
      if (this.currentLocale.data.calendars) {
        return this.currentLocale.data.calendars[0];
      }

      //Defaults to ISO 8601
      return {dateFormat: 'yyyy-MM-dd', timeFormat: 'HH:mm:ss'};
    },

    // Short cut function to get numbers
    numbers: function() {
      return this.currentLocale.data.numbers ? this.currentLocale.data.numbers : {
          percentSign: '%',
          percentFormat: '#,##0 %',
          minusSign: '-',
          decimal: '.',
          group: ','
        };
    },

    pad: function(n, width, z) {
      z = z || '0';
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    },

    isRTL: function() {
      return this.currentLocale.data.direction === 'right-to-left';
    },

    /**
     * Takes a string and converts its contents to upper case, taking into account Locale-specific character conversions.
     * In most cases this method will simply pipe the string to `String.prototype.toUpperCase()`
     * @param {string} str - the incoming string
     */
    toUpperCase: function(str) {
      if (typeof this.currentLocale.data.toUpperCase === 'function') {
        return this.currentLocale.data.toUpperCase(str);
      }

      return str.toLocaleUpperCase();
    },

    /**
     * Takes a string and converts its contents to lower case, taking into account Locale-specific character conversions.
     * In most cases this method will simply pipe the string to `String.prototype.toLowerCase()`
     * @param {string} str - the incoming string
     * @returns {string}
     */
    toLowerCase: function(str) {
      if (typeof this.currentLocale.data.toLowerCase === 'function') {
        return this.currentLocale.data.toLowerCase(str);
      }

      return str.toLocaleLowerCase();
    },

    /**
     * Takes a string and capitalizes the first letter, taking into account Locale-specific character conversions.
     * In most cases this method will simply use a simple algorithm for captializing the first letter of the string.
     * @param {string} str - the incoming string
     * @returns {string}
     */
    capitalize: function(str) {
      return this.toUpperCase(str.charAt(0)) + str.slice(1);
    },

    /**
     * Takes a string and capitalizes the first letter of each word in a string, taking into account Locale-specific character conversions.
     * In most cases this method will simply use a simple algorithm for captializing the first letter of the string.
     * @param {string} str - the incoming string
     * @returns {string}
     */
    capitalizeWords: function(str) {
      var words = str.split(' ');

      for(var i = 0; i < words.length; i++) {
        words[i] = this.capitalize(words[i]);
      }

      return words.join(' ');
    },

    flipIconsHorizontally: function() {
      var icons = [
        'attach',
        'bottom-aligned',
        'bullet-list',
        'cancel',
        'cart',
        'collapse-app-tray',
        'cut',
        'document',
        'drilldown',
        'duplicate',
        'expand-app-tray',
        'export',
        'first-page',
        'folder',
        'import',
        'last-page',
        'launch',
        'left-align',
        'left-text-align',
        'left-arrow',
        'new-document',
        'next-page',
        'number-list',
        'paste',
        'previous-page',
        'quote',
        'redo',
        'refresh',
        'right-align',
        'right-arrow',
        'right-text-align',
        'save',
        'search-folder',
        'search-list',
        'search',
        'send',
        'tack',
        'tree-collapse',
        'tree-expand',
        'undo',
        'unlocked',
        'add-grid-record',
        'add-grid-row',
        'additional-help',
        'bubble',
        'cascade',
        'change-font',
        'clear-screen',
        'script',
        'clockwise-90',
        'close-cancel',
        'close-save',
        'contacts',
        'copy-from',
        'copy-mail',
        'copy-url',
        'counter-clockwise-90',
        'create-report',
        'delete-grid-record',
        'delete-grid-row',
        'display',
        'employee-directory',
        'export-2',
        'export-to-pdf',
        'generate-key',
        'get-more-rows',
        'group-selection',
        'headphones',
        'help',
        'helper-list-select',
        'history',
        'invoice-released',
        'language',
        'logout',
        'key',
        'lasso',
        'line-bar-chart',
        'line-chart',
        'new-expense-report',
        'new-payment-request',
        'new-time-sheet',
        'new-travel-plan',
        'no-attachment',
        'no-comment',
        'no-filter',
        'overlay-line',
        'pdf-file',
        'phone',
        'payment-request',
        'pie-chart',
        'queries',
        'quick-access',
        'refresh-current',
        'restore-user',
        'run-quick-access',
        'save-close',
        'save-new',
        'search-results-history',
        'select',
        'send-submit',
        'show-last-x-days',
        'special-item',
        'stacked',
        'timesheet',
        'unsubscribe',
        'update-preview',
        'zoom-100',
        'zoom-in',
        'zoom-out',
        'caret-left',
        'caret-right'
      ];

      $('svg').each(function() {
        var iconName = $(this).getIconName();

        if (iconName && $.inArray(iconName, icons) !== -1) {
          $(this).addClass('icon-rtl-rotate');
        }
      });
    }

  };

  //Has to delay in order to check if no culture in head since scripts load async
  $(function() {
    setTimeout(function() {
      if (window.Locale && !window.Locale.cultureInHead() && !window.Locale.currentLocale.name) {
        window.Locale.set('en-US');
      }

      // ICONS: Right to Left Direction
      if (window.Locale && window.Locale.isRTL()) {
        window.Locale.flipIconsHorizontally();
      }
    }, 50);
  });


window.Soho = window.Soho || {};
window.Soho.masks = window.Soho.masks || {
  EMPTY_STRING: '',
  PLACEHOLDER_CHAR: '_',
  CARET_TRAP: '[]',
  NON_DIGITS_REGEX: /\D+/g,
  DIGITS_REGEX: /\d/,
  ALPHAS_REGEX: /[\u00C0-\u017Fa-zA-Z]/,
  ANY_REGEX: /[\u00C0-\u017Fa-zA-Z0-9]/,
  DEFAULT_API_OPTIONS: {
    locale: 'en-US',
    pattern: undefined,
    pipe: undefined
  }
};

window.Soho.masks.LEGACY_DEFS = {
  '#': /[0-9]/,
  '0': /[0-9]/,
  'x': Soho.masks.ALPHAS_REGEX,
  '*': Soho.masks.ANY_REGEX,
  '?': /./,
  '~': /[-0-9]/,
  'a': /[APap]/,
  'm': /[Mm]/
};

/**
 * Options that get passed for the _conformToMask()_ method.
 */
window.Soho.masks.DEFAULT_CONFORM_OPTIONS = {
  caretTrapIndexes: [],
  guide: true,
  previousMaskResult: Soho.masks.EMPTY_STRING,
  placeholderChar: Soho.masks.PLACEHOLDER_CHAR,
  placeholder: Soho.masks.EMPTY_STRING,
  selection: {
    start: 0
  },
  keepCharacterPositions: true
};


/**
 * @class {SohoMaskAPI}
 * @constructor
 * @returns {SohoMaskAPI}
 */
function SohoMaskAPI(options) {
  this.configure(options);
  return this;
}


SohoMaskAPI.prototype = {

  /**
   * Configure the API for an incoming mask request - set up patterns, change locale, basically 'pre-render'
   */
  configure: function(options) {
    if (!this.settings) {
      this.settings = {};
    }

    if (!options) {
      return this;
    }

    if (options.locale) {
      // TODO: store references to thousands sep, decimal, currency symbols, etc for the specified locale.
      this.locale = options.locale;
    }

    // Pre-define a stored Mask pattern.
    // In cases where the mask is a string (Legacy Soho Mask), the string is automatically converted
    // to an array containing regex patterns.
    // In cases where the mask is a function, the function call is stored and called when the mask
    // needs to be processed.
    if (options.pattern) {
      if (Array.isArray(options.pattern) || typeof options.pattern === 'function') {
        this.pattern = options.pattern;
      } else if (typeof options.pattern === 'string') {
        var defs = Soho.utils.extend({}, Soho.masks.LEGACY_DEFS, (options.definitions || {}));
        this.pattern = this._convertPatternFromString(options.pattern, defs);
      } else {
        // TODO: fail somehow?
      }
    }

    if (options.patternOptions) {
      this.patternOptions = options.patternOptions;
    }

    return this;
  },

  /**
   * Process a string against the masking algorithm
   */
  process: function(rawValue, opts) {
    if (typeof rawValue !== 'string') {
      throw new Error('No string provided');
    }

    var providedMask,
      processResult = {
        originalValue: rawValue,
        caretPos: opts.selection.start,
        maskResult: false
      };

    // Setup the pattern if it's a function.
    if (typeof this.pattern === 'function') {
      if (!opts.patternOptions) {
        opts.patternOptions = {};
      }

      // Merge incom
      var maskOpts = Soho.utils.extend({}, this.patternOptions, opts.patternOptions, {
        caretPos: opts.selection.start,
        previousMaskResult: opts.previousMaskResult
      });

      // Get a processed mask pattern from the function
      providedMask = this.pattern(rawValue, maskOpts);

      // mask functions can setup caret traps to have some control over how the caret moves. We need to process
      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return
      // the indexes of the caret traps.
      var caretTrapInfo = this._processCaretTraps(providedMask);
      providedMask = caretTrapInfo.maskWithoutCaretTraps; // The processed mask is what we're interested in
      opts.caretTrapIndexes = caretTrapInfo.indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`
    } else {
      // Use a provided array
      providedMask = this.pattern;
    }

    // As a convenience, setting the mask to false will cause it to return without processing.
    if (providedMask === false) {
      return processResult;
    }

    try {
      processResult = this._conformToMask(rawValue, providedMask, opts);
    } catch (e) {
      //console.error('Couldn\'t complete masking process: "'+ e.message +'"');
      return processResult;
    }

    // Handle the optional "pipe" cleanup method, if applicable.
    if (typeof opts.pipe === 'function') {
      var pipeResult = {};

      // `pipe` receives the entire `processResult` object and the configurations with which `conformToMask` was called.
      try {
        pipeResult = opts.pipe(processResult, opts);
      } catch (e) {
        //console.error('Couldn\'t complete mask\'s pipe function: "'+ e.message +'"');
        pipeResult = false;
      }

      // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to
      // indicate rejection. Or return just a string when there are no piped characters.
      // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest
      // of the code can work with.
      if (pipeResult === false) {
        // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.
        processResult.pipeResult = false;
        processResult.pipedValue = opts.previousMaskResult;
      } else if (Soho.utils.isString(pipeResult)) {
        processResult.pipeResult = true;
        processResult.pipedValue = pipeResult;
        processResult.pipedCharIndexes = [];
      } else {
        processResult = Soho.utils.extend({}, processResult, {
          pipeResult: pipeResult.result,
          pipedValue: pipeResult.value,
          pipedCharIndexes: pipeResult.characterIndexes
        });
      }
    }

    return processResult;
  },

  /**
   * Processes a raw string value against a masking algorithm and removes unfavorable chracters.
   * @private
   * @param {String} string - incoming full text string to process
   * @param {Object} options - options for parsing
   */
  _conformToMask: function(rawValue, mask, options) {

    // Set default options
    options = Soho.utils.extend({}, Soho.masks.DEFAULT_CONFORM_OPTIONS, options);

    // Setup the placeholder version of the mask
    options.placeholder = this._convertMaskToPlaceholder(mask, options.placeholderChar);

    // Setup booleans and numbers for various settings (speed)
    var charactersRejected = false,
      suppressGuide = options.guide === false && options.previousMaskResult !== undefined,
      rawValueLength = rawValue.length,
      prevMaskResultLength = options.previousMaskResult.length,
      maskLength = this.pattern.length,
      placeholderLength = options.placeholder.length || 0,
      placeholderChar = options.placeholderChar,
      caretPos = options.selection.start,
      resultStr = Soho.masks.EMPTY_STRING;

    var editDistance = rawValueLength - prevMaskResultLength,
      isAddition = editDistance > 0,
      indexOfFirstChange = caretPos + (isAddition ? -editDistance : 0),
      indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);


    // If `_conformToMask()` is configured to keep character positions, that is, for mask 111, previous value
    // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of
    // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be
    // __3, not _3_ (default behavior)
    //
    // The next block of logic handles keeping character positions for the case of deletion. (Keeping
    // character positions for the case of addition is further down since it is handled differently.)
    // To do this, we want to compensate for all characters that were deleted
    if (options.keepCharacterPositions === true && !isAddition) {
      // We will be storing the new placeholder characters in this variable.
      var compensatingPlaceholderChars = Soho.masks.EMPTY_STRING;

      // For every character that was deleted from a placeholder position, we add a placeholder char
      for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {
        if (options.placeholder[i] === placeholderChar) {
          compensatingPlaceholderChars += placeholderChar;
        }
      }

      // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters
      // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters
      // in their positions.
      rawValue = (
        rawValue.slice(0, indexOfFirstChange) +
        compensatingPlaceholderChars +
        rawValue.slice(indexOfFirstChange, rawValueLength)
      );
    }

    // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have
    // existed in the previous conformed value. Identifying new and old characters is needed for `_conformToMask()`
    // to work if it is configured to keep character positions.
    function markAddedChars(char, j) {
      return {
        char: char,
        isNew: j >= indexOfFirstChange && j < indexOfLastChange
      };
    }
    var rawValueArr = rawValue.split(Soho.masks.EMPTY_STRING).map(markAddedChars);

    // The loop below removes masking characters from user input. For example, for mask
    // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below
    // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm
    // then would lay `234` on top of the available placeholder positions in the mask.
    for (var k = rawValueLength - 1; k >= 0; k--) {
      var char = rawValueArr[k];

      if (char !== options.placeholderChar) {
        var shouldOffset = k >= indexOfFirstChange && prevMaskResultLength === maskLength;

        if (char === options.placeholder[(shouldOffset) ? k - editDistance : k]) {
          rawValueArr.splice(k, 1);
        }
      }
    }




    // Loop through the placeholder string to find characters that need to be filled.
    placeholderLoop:
    for (var l = 0; l < placeholderLength; l++) {
      var charInPlaceholder = options.placeholder[l];

      // We see one. Let's find out what we can put in it.
      if (charInPlaceholder === placeholderChar) {
        // But before that, do we actually have any user characters that need a place?
        if (rawValueArr.length > 0) {
          // We will keep chipping away at user input until either we run out of characters
          // or we find at least one character that we can map.
          while (rawValueArr.length > 0) {
            // Let's retrieve the first user character in the queue of characters we have left
            var rawValueChar = rawValueArr.shift();

            // If the character we got from the user input is a placeholder character (which happens
            // regularly because user input could be something like (540) 90_-____, which includes
            // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,
            // then we map this placeholder character to the current spot in the placeholder
            if (rawValueChar.char === placeholderChar && suppressGuide !== true) {
              resultStr += placeholderChar;

              // And we go to find the next placeholder character that needs filling
              continue placeholderLoop;

            // Else if, the character we got from the user input is not a placeholder, let's see
            // if the current position in the mask can accept it.
          } else if (mask[l].test(rawValueChar.char)) {
              // we map the character differently based on whether we are keeping character positions or not.
              // If any of the conditions below are met, we simply map the raw value character to the
              // placeholder position.
              if (
                options.keepCharacterPositions !== true ||
                rawValueChar.isNew === false ||
                options.previousMaskResult === Soho.masks.EMPTY_STRING ||
                options.guide === false ||
                !isAddition
              ) {
                resultStr += rawValueChar.char;
              } else {
                // We enter this block of code if we are trying to keep character positions and none of the conditions
                // above is met. In this case, we need to see if there's an available spot for the raw value character
                // to be mapped to. If we couldn't find a spot, we will discard the character.
                //
                // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the
                // `9`, to the first available placeholder position, but then, there are no more spots available for the
                // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.
                var rawValueArrLength = rawValueArr.length;
                var indexOfNextAvailablePlaceholderChar = null;

                // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,
                // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.
                // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable
                // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.
                for (var x = 0; x < rawValueArrLength; x++) {
                  var charData = rawValueArr[x];

                  if (charData.char !== placeholderChar && charData.isNew === false) {
                    break;
                  }

                  if (charData.char === placeholderChar) {
                    indexOfNextAvailablePlaceholderChar = x;
                    break;
                  }
                }

                // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.
                // We can map it. And to keep the character positions, we remove the placeholder character
                // from the remaining characters
                if (indexOfNextAvailablePlaceholderChar !== null) {
                  resultStr += rawValueChar.char;
                  rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);

                // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to
                // discard it.
                } else {
                  l--;
                }
              }

              // Since we've mapped this placeholder position. We move on to the next one.
              continue placeholderLoop;
            } else {
              charactersRejected = true;
            }
          }
        }

        // We reach this point when we've mapped all the user input characters to placeholder
        // positions in the mask. In *guide* mode, we append the left over characters in the
        // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.
        //
        // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.
        if (suppressGuide === false) {
          resultStr += options.placeholder.substr(l, placeholderLength);
        }

        // And we break
        break;

      // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it
      // with user input. So we just map it to the final output
      } else {
        resultStr += charInPlaceholder;
      }
    }


    // The following logic is needed to deal with the case of deletion in *no guide* mode.
    //
    // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder
    // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.
    // That's why the logic below finds the last filled placeholder character, and removes everything
    // from that point on.
    if (suppressGuide && isAddition === false) {
      var indexOfLastFilledPlaceholderChar = null;

      // Find the last filled placeholder position and substring from there
      for (var m = 0; m < resultStr.length; m++) {
        if (options.placeholder[m] === placeholderChar) {
          indexOfLastFilledPlaceholderChar = m;
        }
      }

      if (indexOfLastFilledPlaceholderChar !== null) {
        // We substring from the beginning until the position after the last filled placeholder char.
        resultStr = resultStr.substr(0, indexOfLastFilledPlaceholderChar + 1);
      } else {
        // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted
        // the first character in the mask. So we return an empty string.
        resultStr = Soho.masks.EMPTY_STRING;
      }
    }

    return {
      caretPos: caretPos,
      caretTrapIndexes: options.caretTrapIndexes,
      conformedValue: resultStr,
      charactersRejected: charactersRejected,
      placeholder: options.placeholder,
      placeholderChar: placeholderChar,
      maskResult: true
    };
  },


  /**
   * Detects Caret Traps inside of a Mask Array and identifies them with a rich object
   * @private
   */
  _processCaretTraps: function(mask) {
    var indexes = [],
      indexOfCaretTrap = mask.indexOf(Soho.masks.CARET_TRAP);

    while(indexOfCaretTrap !== -1) {
      indexes.push(indexOfCaretTrap);
      mask.splice(indexOfCaretTrap, 1);
      indexOfCaretTrap = mask.indexOf(Soho.masks.CARET_TRAP);
    }

    return {
      maskWithoutCaretTraps: mask,
      indexes: indexes
    };
  },


  /**
   * Converts an array-based mask into a placeholder string.
   * @private
   * @param {Array} mask - contains string "literal" characters and Regex matchers.
   * @param {String} placeholderChar - a character that will be used as the placeholder.
   * @returns {String}
   */
  _convertMaskToPlaceholder: function(mask, placeholderChar) {
    if (!Array.isArray(mask)) {
      mask = [];
    }
    if (!placeholderChar) {
      placeholderChar = Soho.masks.PLACEHOLDER_CHAR;
    }

    if (mask.indexOf(placeholderChar) !== -1) {
      throw new Error(
        'Placeholder character must not be used as part of the mask. Please specify a character ' +
        'that is not present in your mask as your placeholder character.\n\n' +
        'The placeholder character that was received is:' + JSON.stringify(placeholderChar) + '\n\n' +
        'The mask that was received is: ' + JSON.stringify(mask)
      );
    }

    var ret = mask.map(function(char) {
      return (char instanceof RegExp) ? placeholderChar : char;
    }).join(Soho.masks.EMPTY_STRING);

    return ret;
  },


  /**
   * Takes an index representing a caret and changes it based on mask modifications
   */
  adjustCaretPosition: function(opts) {
    if (opts.caretPos === 0) {
      return 0;
    }

    function nonPlaceholderFilter(char) {
      return char !== nonPlaceholderFilter;
    }

    // Store lengths for faster performance?
    var rawValueLength = opts.rawValue.length,
      previousConformedValueLength = opts.previousMaskResult.length,
      placeholderLength = opts.placeholder ? opts.placeholder.length : 0,
      conformedValueLength = opts.conformedValue ? opts.conformedValue.length : 0;

    // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,
    // we know the user in this instance pasted two characters
    var editLength = rawValueLength - previousConformedValueLength;

    // If the edit length is positive, that means the user is adding characters, not deleting.
    var isAddition = editLength > 0;

    // This is the first raw value the user entered that needs to be conformed to mask
    var isFirstRawValue = previousConformedValueLength === 0;

    // A partial multi-character edit happens when the user makes a partial selection in their
    // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by
    // selecting the first 3 digits and pressing backspace.
    //
    // Such cases can also happen when the user presses the backspace while holding down the ALT
    // key.
    var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;

    // This algorithm doesn't support all cases of multi-character edits, so we just return
    // the current caret position.
    //
    // This works fine for most cases.
    if (isPartialMultiCharEdit) {
      return opts.caretPos;
    }

    // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter
    // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the
    // same as the original `previousConformedValue`. We handle this case differently for caret
    // positioning.
    var possiblyHasRejectedChar = isAddition && (
      opts.previousMaskResult === opts.conformedValue ||
      opts.conformedValue === opts.placeholder
    );

    var startingSearchIndex = 0,
      trackRightCharacter,
      targetChar;

    if (possiblyHasRejectedChar) {
      startingSearchIndex = opts.caretPos - editLength;
    } else {
      // At this point in the algorithm, we want to know where the caret is right before the raw input
      // has been conformed, and then see if we can find that same spot in the conformed input.
      //
      // We do that by seeing what character lies immediately before the caret, and then look for that
      // same character in the conformed input and place the caret there.

      // First, we need to normalize the inputs so that letter capitalization between raw input and
      // conformed input wouldn't matter.
      var normalizedConformedValue = opts.conformedValue.toLowerCase();
      var normalizedRawValue = opts.rawValue.toLowerCase();

      // Then we take all characters that come before where the caret currently is.
      var leftHalfChars = normalizedRawValue.substr(0, opts.caretPos).split(Soho.masks.EMPTY_STRING);

      // Now we find all the characters in the left half that exist in the conformed input
      // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.
      var intersection = leftHalfChars.filter(function(char) {
        return normalizedConformedValue.indexOf(char) !== -1;
      });

      // The last character in the intersection is the character we want to look for in the conformed
      // value and the one we want to adjust the caret close to
      targetChar = intersection[intersection.length - 1];

      // Calculate the number of mask characters in the previous placeholder
      // from the start of the string up to the place where the caret is
      var previousLeftMaskChars = opts.previousPlaceholder
        .substr(0, intersection.length)
        .split(Soho.masks.EMPTY_STRING)
        .filter(nonPlaceholderFilter)
        .length;

      // Calculate the number of mask characters in the current placeholder
      // from the start of the string up to the place where the caret is
      var leftMaskChars = opts.placeholder
        .substr(0, intersection.length)
        .split(Soho.masks.EMPTY_STRING)
        .filter(nonPlaceholderFilter)
        .length;

      // Has the number of mask characters up to the caret changed?
      var masklengthChanged = leftMaskChars !== previousLeftMaskChars;

      // Detect if `targetChar` is a mask character and has moved to the left
      var targetIsMaskMovingLeft = (
        opts.previousPlaceholder[intersection.length - 1] !== undefined &&
        opts.placeholder[intersection.length - 2] !== undefined &&
        opts.previousPlaceholder[intersection.length - 1] !== opts.placeholderChar &&
        opts.previousPlaceholder[intersection.length - 1] !== opts.placeholder[intersection.length - 1] &&
        opts.previousPlaceholder[intersection.length - 1] === opts.placeholder[intersection.length - 2]
      );

      // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true
      // or the mask is moving to the left, we can't use the selected `targetChar` any longer
      // if we are not at the end of the string.
      // In this case, change tracking strategy and track the character to the right of the caret.
      if (
        !isAddition &&
        (masklengthChanged || targetIsMaskMovingLeft) &&
        previousLeftMaskChars > 0 &&
        opts.placeholder.indexOf(targetChar) > -1 &&
        opts.rawValue[opts.caretPos] !== undefined
      ) {
        trackRightCharacter = true;
        targetChar = opts.rawValue[opts.caretPos];
      }

      // It is possible that `targetChar` will appear multiple times in the conformed value.
      // We need to know not to select a character that looks like our target character from the placeholder or
      // the piped characters, so we inspect the piped characters and the placeholder to see if they contain
      // characters that match our target character.

      // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for
      // our `targetChar`, we don't select a piped char by mistake
      var pipedChars = [];
      if (opts.indexesOfPipedChars) {
        pipedChars = opts.indexesOfPipedChars.map(function(index) {
          return normalizedConformedValue[index];
        });
      }

      // We need to know how many times the `targetChar` occurs in the piped characters.
      var countTargetCharInPipedChars = pipedChars.filter(function(char) {
        return char === targetChar;
      }).length;

      // We need to know how many times it occurs in the intersection
      var countTargetCharInIntersection = intersection.filter(function(char) {
        return char === targetChar;
      }).length;

      // We need to know if the placeholder contains characters that look like
      // our `targetChar`, so we don't select one of those by mistake.
      var countTargetCharInPlaceholder = opts.placeholder
        .substr(0, opts.placeholder.indexOf(opts.placeholderChar))
        .split(Soho.masks.EMPTY_STRING)
        .filter(function(char, index) {
          // Check if `char` is the same as our `targetChar`, so we account for it
          return char === targetChar &&

          // but also make sure that both the `rawValue` and placeholder don't have the same character at the same
          // index because if they are equal, that means we are already counting those characters in
          // `countTargetCharInIntersection`
          opts.rawValue[index] !== char;
        })
        .length;

      // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking
      // for is:
      var requiredNumberOfMatches = (
        countTargetCharInPlaceholder +
        countTargetCharInIntersection +
        countTargetCharInPipedChars +
        // The character to the right of the caret isn't included in `intersection`
        // so add one if we are tracking the character to the right
        (trackRightCharacter ? 1 : 0)
      );

      // Now we start looking for the location of the `targetChar`.
      // We keep looping forward and store the index in every iteration. Once we have encountered
      // enough occurrences of the target character, we break out of the loop
      // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.
      var numberOfEncounteredMatches = 0;
      for (var i = 0; i < conformedValueLength; i++) {
        var conformedValueChar = normalizedConformedValue[i];

        startingSearchIndex = i + 1;

        if (conformedValueChar === targetChar) {
          numberOfEncounteredMatches++;
        }

        if (numberOfEncounteredMatches >= requiredNumberOfMatches) {
          break;
        }
      }
    }

    // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,
    // most cases would be handled. However, we want to fast forward or rewind the caret to the
    // closest placeholder character if it happens to be in a non-editable spot. That's what the next
    // logic is for.

    // In case of addition, we fast forward.
    if (isAddition) {
      // We want to remember the last placeholder character encountered so that if the mask
      // contains more characters after the last placeholder character, we don't forward the caret
      // that far to the right. Instead, we stop it at the last encountered placeholder character.
      var lastPlaceholderChar = startingSearchIndex;

      for (var j = startingSearchIndex; j <= placeholderLength; j++) {
        if (!opts.placeholder) {
          return lastPlaceholderChar;
        }

        if (opts.placeholder[j] === opts.placeholderChar) {
          lastPlaceholderChar = j;
        }

        if (
          // If we're adding, we can position the caret at the next placeholder character.
          opts.placeholder[j] === opts.placeholderChar ||

          // If a caret trap was set by a mask function, we need to stop at the trap.
          opts.caretTrapIndexes.indexOf(j) !== -1 ||

          // This is the end of the placeholder. We cannot move any further. Let's put the caret there.
          j === placeholderLength
        ) {
          return lastPlaceholderChar;
        }
      }
    } else {
      // In case of deletion, we rewind.
      if (trackRightCharacter) {
        // Searching for the character that was to the right of the caret
        // We start at `startingSearchIndex` - 1 because it includes one character extra to the right
        for (var k = startingSearchIndex - 1; k >= 0; k--) {
          // If tracking the character to the right of the cursor, we move to the left until
          // we found the character and then place the caret right before it

          if (
            // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just
            // to the right of the caret
            opts.conformedValue[k] === targetChar ||

            // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(k) !== -1 ||

            // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            k === 0
          ) {
            return k;
          }
        }
      } else {
        // Searching for the first placeholder or caret trap to the left

        for (var l = startingSearchIndex; l >= 0; l--) {
          // If we're deleting, we stop the caret right before the placeholder character.
          // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user
          // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret
          // right after the first `6`

          if (
            // If we're deleting, we can position the caret right before the placeholder character
            opts.placeholder[l - 1] === opts.placeholderChar ||

            // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(l) !== -1 ||

            // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            l === 0
          ) {
            return l;
          }
        }
      }
    }
  },


  /**
   * Converts the legacy Soho Mask pattern format from a string into an array.
   * If character is a defined pattern matcher, the corresponding item at the array index is converted to
   * its regex form.
   * @param {String} pattern - a legacy Soho Mask Pattern
   * @returns {Array} - contains string "literal" characters and Regex matchers
   */
  _convertPatternFromString: function(pattern, defs) {
    var arr = [],
      legacyKeys = Object.keys(defs);

    function getRegex(char) {
      var idx = legacyKeys.indexOf(char);

      if (idx > -1) {
        char = defs[legacyKeys[idx]];
      }
      return char;
    }

    for (var i = 0; i < pattern.length; i++) {
      arr.push(getRegex(pattern[i]));
    }

    // TODO: Attach an object here that contains an analysis of the original mask
    // that can be used to configure the new API accordingly.

    return arr;
  }

};

window.Soho.Mask = SohoMaskAPI;
/**
 * Default Number Mask Options
 */
var DEFAULT_NUMBER_MASK_OPTIONS = {
  prefix: Soho.masks.EMPTY_STRING,
  suffix: Soho.masks.EMPTY_STRING,
  allowThousandsSeparator: true,
  symbols: {
    currency: '$',
    decimal: '.',
    negative: '-',
    thousands: ','
  },
  allowDecimal: true,
  decimalLimit: 2,
  requireDecimal: false,
  allowNegative: false,
  allowLeadingZeroes: false,
  integerLimit: null
};

/**
 * Converts a string representing a formatted number into a Number Mask.
 * @param {String} strNumber
 * @returns {Array} - contains strings representing character literals and regex patterns.
 */
function convertToMask(strNumber) {
  return strNumber
    .split(Soho.masks.EMPTY_STRING)
    .map(function(char) {
      return Soho.masks.DIGITS_REGEX.test(char) ? Soho.masks.DIGITS_REGEX : char;
    });
}

/**
 * Adds thousands separators to the correct spot in a formatted number string.
 * @param {String} n - the string
 * @param {String} thousands - the thousands separator.
 * @returns {String} the incoming string formatted with a thousands separator.
 */
// http://stackoverflow.com/a/10899795/604296
function addThousandsSeparator(n, thousands) {
  return n.replace(/\B(?=(\d{3})+(?!\d))/g, thousands);
}


/**
 * Gets an array of Regex objects matching the number of digits present in a source string
 * @param {String} part - string representing the mark part.
 * @param {String} type - 'any', 'digits', or 'alphas'
 * @returns {Array}
 */
function getRegexForPart(part, type) {
  var types = {
    'any': Soho.masks.ANY_REGEX,
    'digits': Soho.masks.DIGITS_REGEX,
    'alphas': Soho.masks.ALPHAS_REGEX
  };

  if (!types[type]) {
    type = 'any';
  }

  var size = part.toString().length,
    arr = [];

  while (size > 0) {
    arr.push(types[type]);
    size = size - 1;
  }
  return arr;
}


/**
 * Soho Number Mask Function
 * @param {String} rawValue
 * @param {Object} options
 * @returns {Array}
 */
window.Soho.masks.numberMask = function sohoNumberMask(rawValue, options) {

  // Handle default options
  options = Soho.utils.extend({}, DEFAULT_NUMBER_MASK_OPTIONS, options);

  var PREFIX = options.prefix,
    SUFFIX = options.suffix,
    DECIMAL = options.symbols.decimal,
    THOUSANDS = options.symbols.thousands,
    prefixLength = PREFIX && PREFIX.length || 0,
    suffixLength = SUFFIX && SUFFIX.length || 0,
    thousandsSeparatorSymbolLength = THOUSANDS && THOUSANDS.length || 0;

  function numberMask(rawValue) {
    if (typeof rawValue !== 'string') {
      rawValue = Soho.masks.EMPTY_STRING;
    }

    var rawValueLength = rawValue.length;

    if (
      rawValue === Soho.masks.EMPTY_STRING ||
      (rawValue[0] === PREFIX[0] && rawValueLength === 1)
    ) {
      return PREFIX.split(Soho.masks.EMPTY_STRING).concat([Soho.masks.DIGITS_REGEX]).concat(SUFFIX.split(Soho.masks.EMPTY_STRING));
    } else if(
      rawValue === DECIMAL && options.allowDecimal
    ) {
      return PREFIX.split(Soho.masks.EMPTY_STRING).concat(['0', DECIMAL, Soho.masks.DIGITS_REGEX]).concat(SUFFIX.split(Soho.masks.EMPTY_STRING));
    }

    var indexOfLastDecimal = rawValue.lastIndexOf(DECIMAL),
      hasDecimal = indexOfLastDecimal !== -1,
      isNegative = (rawValue[0] === options.symbols.negative) && options.allowNegative,
      integer,
      fraction,
      mask;

    // remove the suffix
    if (rawValue.slice(suffixLength * -1) === SUFFIX) {
      rawValue = rawValue.slice(0, suffixLength * -1);
    }

    if (hasDecimal && (options.allowDecimal || options.requireDecimal)) {
      integer = rawValue.slice(rawValue.slice(0, prefixLength) === PREFIX ? prefixLength : 0, indexOfLastDecimal);

      fraction = rawValue.slice(indexOfLastDecimal + 1, rawValueLength);
      fraction = convertToMask(fraction.replace(Soho.masks.NON_DIGITS_REGEX, Soho.masks.EMPTY_STRING));
    } else {
      if (rawValue.slice(0, prefixLength) === PREFIX) {
        integer = rawValue.slice(prefixLength);
      } else {
        integer = rawValue;
      }
    }

    if (options.integerLimit && typeof options.integerLimit === 'number') {
      var thousandsSeparatorRegex = THOUSANDS === '.' ? '[.]' : '' + THOUSANDS;
      var numberOfThousandSeparators = (integer.match(new RegExp(thousandsSeparatorRegex, 'g')) || []).length;

      integer = integer.slice(0, options.integerLimit + (isNegative ? 1 : 0) + (numberOfThousandSeparators * thousandsSeparatorSymbolLength));
    }

    integer = integer.replace(Soho.masks.NON_DIGITS_REGEX, Soho.masks.EMPTY_STRING);

    if (!options.allowLeadingZeroes) {
      integer = integer.replace(/^0+(0$|[^0])/, '$1');
    }

    integer = (options.allowThousandsSeparator) ? addThousandsSeparator(integer, THOUSANDS) : integer;

    mask = convertToMask(integer);

    if ((hasDecimal && options.allowDecimal) || options.requireDecimal === true) {
      if (rawValue[indexOfLastDecimal - 1] !== DECIMAL) {
        mask.push(Soho.masks.CARET_TRAP);
      }

      mask.push(DECIMAL, Soho.masks.CARET_TRAP);

      if (fraction) {
        if (typeof options.decimalLimit === 'number') {
          fraction = fraction.slice(0, options.decimalLimit);
        }

        mask = mask.concat(fraction);
      }

      if (options.requireDecimal === true && rawValue[indexOfLastDecimal - 1] === DECIMAL) {
        mask.push(Soho.masks.DIGITS_REGEX);
      }
    }

    if (prefixLength > 0) {
      mask = PREFIX.split(Soho.masks.EMPTY_STRING).concat(mask);
    }

    if (isNegative) {
      // If user is entering a negative number, add a mask placeholder spot to attract the caret to it.
      // TODO: Allow the negative symbol as the suffix as well (SOHO-3259)
      if (mask.length === prefixLength) {
        mask.push(Soho.masks.DIGITS_REGEX);
      }

      mask = [/-/].concat(mask);
    }

    if (SUFFIX.length > 0) {
      mask = mask.concat(SUFFIX.split(Soho.masks.EMPTY_STRING));
    }

    return mask;
  }

  numberMask.instanceOf = 'createNumberMask';

  return numberMask(rawValue);
};

/**
 * Default Date Mask Options
 */
var DEFAULT_DATETIME_MASK_OPTIONS = {
  format: 'M/d/yyyy',
  symbols: {
    timeSeparator: ':',
    dayPeriodSeparator: ' ',
    dateSeparator: '/'
  }
};

/**
 * Maximum Values for various section maps of date strings.
 */
var DATE_MAX_VALUES = {
  'dd': 31,
  'd': 31,
  'MMM': undefined,
  'MM': 12,
  'M': 12,
  'yy': 99,
  'yyyy': 9999,
  'h': 12,
  'hh': 12,
  'H': 24,
  'HH': 24,
  'mm': 60,
  'ss': 60,
  'a': undefined
};


window.Soho.masks.dateMask = function dateMask(rawValue, options) {
  options = Soho.utils.extend({}, DEFAULT_DATETIME_MASK_OPTIONS, options);

  var mask = [],
    digitRegex = Soho.masks.DIGITS_REGEX,
    format = options.format,
    splitterStr = Soho.string.removeDuplicates(format.replace(/[dMyHhmsa]+/g, '')),
    splitterRegex = new RegExp('['+ splitterStr +']+'),
    formatArray = format.split(/[^dMyHhmsa]+/),
    rawValueArray = rawValue.split(splitterRegex),
    maxValue = DATE_MAX_VALUES;

  formatArray.forEach(function(part, i) {
    var value = maxValue[part],
      size;

    if (part === 'a') {
      // Match the day period
      mask.push(/[aApP]/, /[Mm]/);
    } else if (!value) {
      mask = mask.concat(getRegexForPart(part, 'alphas'));
    } else {

      // Detect based on the size of a pre-existing formatted value, if possible.
      if (rawValueArray[i]) {
        var rawValueStr = rawValueArray[i].toString(),
          rawValueFirstDigit = parseInt(rawValueStr.substr(0, 1), 10),
          maxFirstDigit = parseInt(maxValue[part].toString().substr(0, 1), 10);

        if (part.length === 1 && rawValueFirstDigit > maxFirstDigit) {
          mask.push(digitRegex);
        } else if (rawValueStr !== '0' && rawValueStr.length === 1 && rawValueFirstDigit <= maxFirstDigit && rawValueArray[i+1] !== undefined) {
          mask.push(digitRegex);
        } else {
          mask = mask.concat(getRegexForPart(value, 'digits'));
        }
      } else {
        // If NOT possible, pass back the maximum digit length that can be entered here
        size = value.toString().length;
        while(size > 0) {
          mask.push(digitRegex);
          size = size - 1;
        }
      }

    }

    // If this is not the last part, add whatever literals come after this part, but before the next part.
    var nextPart = formatArray[i+1];
    if (nextPart !== undefined) {
      var thisPartSize = part.toString().length,
        start = format.indexOf(part) + thisPartSize,
        end = format.indexOf(nextPart),
        literals = format.substring(start, end).split(Soho.masks.EMPTY_STRING);

      mask = mask.concat(literals);
    }
  });

  return mask;
};


/**
 * Generates a pipe function that can be applied to a Mask API that will correct
 * shorthand numeric dates.
 * NOTE: DOES NOT WORK FOR DATES WITH ALPHABETIC CONTENT. Do not use this if your
 * dates contain "MMM" or the full month name.
 */
window.Soho.masks.autocorrectedDatePipe = function autoCorrectedDatePipe(processResult, options) {
  if (!options.dateFormat) {
    options.dateFormat = Locale.calendar().dateFormat.short;
  }

  var indexesOfPipedChars = [],
    dateFormatArray = options.dateFormat.split(/[^dMy]+/),
    maxValue = {'d': 31, 'M': 12, 'yy': 99, 'yyyy': 9999},
    minValue = {'d': 1, 'M': 1, 'yy': 0, 'yyyy': 1},
    conformedValueArr = processResult.conformedValue.split('');

  // Check first digit
  dateFormatArray.forEach(function(format) {
    var position = options.dateFormat.indexOf(format);
    var maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);

    if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
      conformedValueArr[position + 1] = conformedValueArr[position];
      conformedValueArr[position] = 0;
      indexesOfPipedChars.push(position);
    }
  });

  var placeholderRegex = new RegExp('[^'+ processResult.placeholderChar +']'),
    maskPieces = processResult.placeholder.split(placeholderRegex),
    conformedPieces = processResult.conformedValue.split(/\D/g);

  // Check for invalid date
  var isInvalid = dateFormatArray.some(function(format, i) {
    var length = maskPieces[i].length > format.length ? maskPieces[i].length : format.length,
      textValue = conformedPieces[i] || '',
      value = parseInt(textValue, 10);

    return value > maxValue[format] || (textValue.length === length && value < minValue[format]);
  });

  if (isInvalid) {
    return false;
  }

  return {
    value: conformedValueArr.join(''),
    characterIndexes: indexesOfPipedChars
  };
};

  /**
   * Default Masked Input field options
   */
  var DEFAULT_MASKED_INPUT_OPTIONS = {
    autocorrect: false,
    definitions: undefined,
    guide: false,
    maskAPI: window.Soho.Mask,
    keepCharacterPositions: false,
    pattern: undefined,
    patternOptions: undefined,
    placeholderChar: '_',
    pipe: undefined,
    process: undefined,
    processOnBlur: true,
    processOnInitialize: true
  };


  /**
   * @class {SohoMaskedInput}
   * Component Wrapper for input elements that gives them the ability to become "masked".
   *
   * @constructor
   * @param {HTMLInputElement} element - regular HTML Input Element (not wrapped with jQuery)
   * @param {SohoMaskedInputOptions} options
   * @returns {SohoMaskedInput}
   */
  function SohoMaskedInput(element, options) {
    this.element = element;

    if (!options) {
      options = {};
    }

    return this.init(options);
  }


  SohoMaskedInput.prototype = {

    /**
     * Initialization/things that need to be called on `updated()` in addition to initialization
     * @private
     */
    init: function(options) {
      // Define internal settings
      if (!this.settings) {
        this.settings = $.extend({}, DEFAULT_MASKED_INPUT_OPTIONS, options);
      } else {
        this.settings = $.extend({}, this.settings, options);
      }
      if (!this.settings.patternOptions) {
        this.settings.patternOptions = {};
      }

      // TODO: Deprecate legacy settings in v4.4.0, remove in v4.5.0
      this._replaceLegacySettings();

      var styleClasses = ['is-number-mask'];

      // If the 'process' setting is defined, connect a pre-defined Soho Mask/Pattern
      if (typeof this.settings.process === 'string') {
        switch(this.settings.process) {
          case 'number': {
            this.settings.pattern = window.Soho.masks.numberMask;
            this.element.classList.add('is-number-mask');
            break;
          }
          case 'date': {
            // Check for an instance of a Datepicker/Timepicker Component, and grab the date format
            var datepicker = $(this.element).data('datepicker');
            if ($.fn.datepicker && $(this.element).data('datepicker')) {
              this.settings.patternOptions.format = datepicker.settings.format;
            }
            this.settings.pattern = Soho.masks.dateMask;
            break;
          }
          default: {
            this.element.classList.remove(styleClasses.join(' '));
            break;
          }
        }
      }

      this.mask = new this.settings.maskAPI(this.settings);
      this.state = {
        previousMaskResult: ''
      };

      this.handleEvents();

      if (this.settings.processOnInitialize) {
        this.process();
      }

      return this;
    },


    /**
     * Sets up events
     */
    handleEvents: function() {
      var self = this;

      // Store an initial value on focus
      this.focusEventHandler = function() {
        self.state.initialValue = self.element.value;
      };
      this.element.addEventListener('focus', this.focusEventHandler);


      // Handle all masking on the `input` event
      this.inputEventHandler = function() {
        return self.process();
      };
      this.element.addEventListener('input', this.inputEventHandler);


      // Remove an initial value from the state object on blur
      this.blurEventHandler = function(e) {
        // Handle mask processing on blur, if settings allow.  Otherwise, return out.
        if (self.settings.processOnBlur) {
          if (self.element.readOnly) {
            e.preventDefault();
            return false;
          }

          // in Windows 7 IE11, change event doesn't fire for some unknown reason.
          // Added this for backwards compatility with this OS/Browser combo.
          // See http://jira.infor.com/browse/SOHO-6895
          if (self._hasChangedValue() && self._isWin7IE11()) {
            $(self.element).trigger('change');
          }
        }

        delete self.state.initialValue;
        return self.process();
      };
      this.element.addEventListener('blur', this.blurEventHandler);

      return this;
    },


    /**
     * Main Process for conforming a mask against the API.
     * @returns {boolean}
     */
    process: function() {
      // If no pattern's defined, act as if no mask component is present.
      if (!this.settings.pattern) {
        return true;
      }

      // Get a reference to the desired Mask API (by default, the one setup during Soho initialization).
      var api = this.mask;
      if (!api.pattern) {
        api.configure({
          pattern: this.settings.pattern,
          patternOptions: this.settings.patternOptions
        });
      }

      // Get all necessary bits of data from the input field.
      var rawValue = this.element.value;

      // Don't continue if there was no change to the input field's value
      if (rawValue === this.state.previousMaskResult) {
        return false;
      }

      var posBegin = this.element.selectionStart,
        posEnd = this.element.selectionEnd;

      // On Android, the first character inserted into a field is automatically selected when it shouldn't be.
      // This snippet fixes that problem.

      if (this._isAndroid() && this.state.previousMaskResult === '' && posBegin !== posEnd) {
        Soho.utils.safeSetSelection(rawValue.length, rawValue.length);
        posBegin = rawValue.length;
        posEnd = rawValue.length;
      }

      // Attempt to make the raw value safe to use.  If it's not in a viable format this will throw an error.
      rawValue = this._getSafeRawValue(rawValue);

      var opts = {
        guide: this.settings.guide,
        keepCharacterPositions: this.settings.keepCharacterPositions,
        patternOptions: this.settings.patternOptions,
        placeholderChar: this.settings.placeholderChar,
        previousMaskResult: this.state.previousMaskResult,
        selection: {
          start: posBegin,
          end: posEnd
        }
      };

      if (posBegin !== posEnd) {
        opts.selection.contents = rawValue.substring(posBegin, posEnd);
      }
      if (typeof this.settings.pipe === 'function') {
        opts.pipe = this.settings.pipe;
      }

      // Perform the mask processing.
      var processed = api.process(rawValue, opts);
      if (!processed.maskResult) {
        // Error during masking.  Simply return out and don't mask this field.
        return processed.maskResult;
      }

      // Use the piped value, if applicable.
      var finalValue = processed.pipedValue ? processed.pipedValue : processed.conformedValue;

      // Setup values for getting corrected caret position
      // TODO: Improve this by eliminating the need for an extra settings object.
      var adjustCaretOpts = {
        previousMaskResult: this.state.previousMaskResult || '',
        previousPlaceholder: this.state.previousPlaceholder || '',
        conformedValue: finalValue,
        placeholder: processed.placeholder,
        rawValue: rawValue,
        caretPos: processed.caretPos,
        placeholderChar: this.settings.placeholderChar
      };
      if (processed.pipedCharIndexes) {
        adjustCaretOpts.indexesOfPipedChars = processed.pipedCharIndexes;
      }
      if (processed.caretTrapIndexes) {
        adjustCaretOpts.caretTrapIndexes = processed.caretTrapIndexes;
      }

      // Get a corrected caret position.
      processed.caretPos = api.adjustCaretPosition(adjustCaretOpts);

      // Set the internal component state
      this.state.previousMaskResult = finalValue;
      this.state.previousPlaceholder = processed.placeholder;

      // Set state of the input field
      this.element.value = finalValue;
      Soho.utils.safeSetSelection(this.element, processed.caretPos);

      // Fire the 'write' event (backwards compat)
      // TODO: Deprecate in v4.4.0?
      $(this.element).trigger('write.mask', [processed.conformedValue]);

      // return event handler true/false
      return processed.maskResult;
    },


    /**
     * Obfuscates the operating system/browser check from Soho.env into internal methods
     * NOTE: Helps compartmentalize us from using calls to global "Soho" object until we can
     * properly setup import/export for unit tests.
     * TODO: deprecate eventually (v4.4.0?)
     * @private
     * @returns {boolean}
     */
    _isAndroid: function() {
      var os = Soho.env && Soho.env.os && Soho.env.os.name ? Soho.env.os.name : '';
      return os === 'android';
    },


    /**
     * Same as the Android method, but for IE 11 on Windows 7
     * TODO: deprecate eventually (v4.4.0?)
     * @private
     * @returns {boolean}
     */
    _isWin7IE11: function() {
      var browser = Soho.env && Soho.env.browser && Soho.env.browser.name ? Soho.env.browser.name : '',
        version = Soho.env.browser.version ? Soho.env.browser.version : '';

      return browser === 'ie' && version === '11';
    },


    /**
     * Checks the current value of this masked input against it's stored "previousMaskResult" state to see if the value changed.
     * @private
     * @returns {boolean}
     */
    _hasChangedValue: function() {
      if (!this.state || !this.state.previousMaskResult) {
        return true;
      }

      return this.state.previousMaskResult !== this.state.initialValue;
    },


    /**
     * Gets the safe raw value of an input field
     * @private
     * @param {?} inputValue
     * @returns {String}
     */
    _getSafeRawValue: function getSafeRawValue(inputValue) {
      if (Soho.utils.isString(inputValue)) {
        return inputValue;
      } else if (Soho.utils.isNumber(inputValue)) {
        return String(inputValue);
      } else if (inputValue === undefined || inputValue === null) {
        return '';
      } else {
        throw new Error(
          'The "value" provided to the Masked Input needs to be a string or a number. The value ' +
          'received was:\n\n' + JSON.stringify(inputValue)
        );
      }
    },


    /**
     * Changes a bunch of "legacy" setting definitions into more apt names.  Additionally handles
     * the old data-attribute system that is still occasionally used.
     * @private
     */
    _replaceLegacySettings: function() {
      var modes = ['group', 'number', 'date', 'time'];

      // pre-set a bunch of objects if they don't already exist
      this.settings.patternOptions = this.settings.patternOptions || {};
      this.settings.patternOptions.symbols = this.settings.patternOptions.symbols || {};

      //======================================
      // Deprecated as of v4.3.2
      //======================================
      // Order of operations when choosing pattern strings:
      // HTML5 'data-mask' attribute > Generic pattern string based on "type" attribute > nothing.
      //
      // if no pattern is provided in settings, use a pre-determined pattern based
      // on element type, or grab the pattern from the element itself.
      var html5DataMask = this.element.getAttribute('data-mask') || false;
      if (typeof html5DataMask === 'string' && html5DataMask.length) {
        this.settings.pattern = html5DataMask;
      }

      // If a "mode" is defined, special formatting rules may apply to this mask.
      // Otherwise, the standard single-character pattern match will take place.
      var html5DataMaskMode = this.element.getAttribute('data-mask-mode') || false;
      if (html5DataMaskMode && modes.indexOf(html5DataMaskMode) > -1) {
        this.settings.mode = html5DataMaskMode;
      }

      // map deprecated "mode" setting to "process".  Triggers additional settings in
      // some cases.
      if (this.settings.mode) {
        if (modes.indexOf(this.settings.mode) === -1) {
          delete this.settings.mode;
        }

        if (this.settings.mode === 'group') {
          this.settings.process = undefined;
        } else if (this.settings.mode === 'date') {
          this.settings.process = 'date';
        } else {
          this.settings.process = this.settings.mode;
        }

        delete this.settings.mode;
      }

      if (this.settings.process === 'number') {
        // map deprecated "thousandsSeparator" to "patternOptions.allowThousandsSeparator"
        if (this.settings.thousandsSeparator) {
          this.settings.patternOptions.allowThousandsSeparator = this.settings.thousandsSeparator;
          delete this.settings.thousandsSeparator;
        }

        // If "thousands" is defined, the thousands separator for numbers (comma or decimal, based on
        // localization) will be inserted wherever necessary during typing. Will automatically set to
        // "true" if the localized thousands separator is detected inside the mask.
        var html5DataThousands = this.element.getAttribute('data-thousands') || false;
        if (html5DataThousands) {
          this.settings.patternOptions.allowThousandsSeparator = (html5DataThousands === 'true');
        }

        if (typeof this.settings.pattern === 'string') {
          // If "negative" is defined, you can type the negative symbol in front of the number.
          // Will automatically set to "true" if a negative symbol is detected inside the mask.
          var allowNegative = this.settings.pattern.indexOf('-') !== -1;
          if (allowNegative) {
            this.settings.patternOptions.allowNegative = allowNegative;
            this.settings.patternOptions.symbols.negative = '-';
          }

          // Detect the thousands separator and see if we use it.
          var thousandsSep = this.settings.patternOptions && this.settings.patternOptions.symbols && this.settings.patternOptions.symbols.thousands ?
            this.settings.patternOptions.symbols.thousands :
            Locale.currentLocale.data.numbers.group;

          var hasThousandsInPattern = this.settings.pattern.indexOf(thousandsSep) !== -1;
          this.settings.patternOptions.allowThousandsSeparator = hasThousandsInPattern;
          if (hasThousandsInPattern) {
            this.settings.patternOptions.symbols.thousands = thousandsSep;
          }

          // The new masking algorithm requires an "integerLimit" defined to function.
          // This grabs the number of items currently inside this part of the mask, and sets it.
          var decimal = typeof this.settings.patternOptions.symbols.decimal === 'string' ?
            this.settings.patternOptions.symbols.decimal : '.';
          var decimalParts =  this.settings.pattern.split(decimal);

          this.settings.patternOptions.integerLimit = decimalParts[0].replace(/[^#0]/g, '').length;

          if (decimalParts[1]) {
            this.settings.patternOptions.allowDecimal = true;
            this.settings.patternOptions.decimalLimit = decimalParts[1].toString().replace(/[^#0]/g, '').length;
            if (!this.settings.patternOptions.symbols.decimal) {
              this.settings.patternOptions.symbols.decimal = decimal;
            }
          }
        }
      }

      // If 'mustComplete' is defined, you MUST complete the full mask, or the mask will revert to empty
      // once the field is blurred.
      var html5DataMustComplete = this.element.getAttribute('data-must-complete') || false;
      if (html5DataMustComplete) {
        this.settings.mustComplete = html5DataMustComplete;
      }

      // Backwards compat with the old "data-show-currency"
      var html5DataCurrency = this.element.getAttribute('data-show-currency');
      if (html5DataCurrency) {
        this.settings.showSymbol = 'currency';
      }

      // Handle the currency/percent symbols automatically
      var symbolSetting = this.settings.showSymbol,
        symbolTypes = ['currency', 'percent'],
        symbol;

      if (symbolTypes.indexOf(symbolSetting) > -1) {
        symbol = (function(s) {
          if (s === 'currency') {
            return {
              char: Locale.currentLocale.data.currencySign,
              format: Locale.currentLocale.data.currencyFormat
            };
          }
          if (s === 'percent') {
            return {
              char: Locale.currentLocale.data.numbers.percentSign,
              format: Locale.currentLocale.data.numbers.percentFormat
            };
          }
        })(this.settings.showSymbol);

        // derive the location of the symbol
        var detectableSymbol = (symbolSetting === 'currency' ? '¤' : symbol.char),
          symbolRegex = new RegExp(detectableSymbol, 'g'),
          match = symbolRegex.exec(symbol.format),
          replacementRegex,
          symbolWithWhitespace,
          index = -1,
          placementType;

        if (match.length) {
          index = symbol.format.indexOf(match[0]);
          if (index === 0) {
            placementType = 'prefix';
            replacementRegex = new RegExp('[^'+ detectableSymbol +']\\S', 'g');
            symbolWithWhitespace = symbol.format.replace(replacementRegex, '');
          } else if (index > 0) {
            placementType = 'suffix';
            replacementRegex = new RegExp('\\S[^'+ detectableSymbol +']', 'g');

            while(/\s/.test(symbol.format.charAt(index - 1))) {
              --index;
            }
            symbolWithWhitespace = symbol.format.substr(index).replace(replacementRegex, '');
          }

          if (symbolSetting === 'currency') {
            symbolWithWhitespace = symbolWithWhitespace.replace('¤', symbol.char);
          }
          this.settings.patternOptions[placementType] = symbolWithWhitespace;
        }
      }
    },

    /**
     * Updates the component instance with new settings.
     */
    updated: function(options) {
      return this
        .teardown()
        .init(options);
    },

    /**
     * Tears down the current component instance
     */
    teardown: function() {
      this.element.removeEventListener('focus', this.focusEventHandler);
      delete this.focusEventHandler;

      this.element.removeEventListener('input', this.inputEventHandler);
      delete this.inputEventHandler;

      if (this.blurEventHandler) {
        this.element.removeEventListener('blur', this.blurEventHandler);
        delete this.blurEventHandler;
      }

      return this;
    }

  };

  /**
   * Attaches the Mask prototype as a component to Soho's base object.
   */
  window.Soho.components = window.Soho.components || {};
  window.Soho.components.MaskedInput = SohoMaskedInput;

  /**
   * Wrap as a jQuery component, and attach the factory function to $.fn
   */
  $.fn.maskedinput = function(options) {
    return this.each(function() {
      var instance = $.data(this, 'mask');
      if (instance) {
        instance.updated(options);
      } else {
        instance = $.data(this, 'mask', new SohoMaskedInput(this, options));
        instance.destroy = function() {
          this.teardown();
          $.removeData(this.element, 'mask');
        };
      }
    });
  };

  /**
   * Backwards Compatibility with the old Mask
   */
  $.fn.mask = $.fn.maskedinput;


  var defaults = {
      caseSensitive: false,
      filterMode: 'startsWith',
      highlightMatchedText: false,
      highlightCallback: null,
      searchableTextCallback: undefined
    },
    filterModes = ['startsWith', 'contains'];


  /**
  * Abstracted search/filter for use in other controls
  *
  * @class ListFilter
  * @param {Boolean} caseSensitive  &nbsp;-&nbsp; Set to true if searches ARE case sensitive
  * @param {String} filterMode  &nbsp;-&nbsp; Type of search can current be either 'startsWith' or 'contains'
  * @param {Boolean} highlightMatchedText  &nbsp;-&nbsp; Inserts markup that appears to highlight text
  * @param {function} highlightCallback  &nbsp;-&nbsp; If defined, will execute this code for highlighting text instead of the built-in highlighting code
  * @param {function} searchableTextCallback  &nbsp;-&nbsp; If defined, will take each filterable item passed and return user-defined, searchable text content
  *
  */
  function ListFilter(settings) {
    this.settings = $.extend({}, defaults, settings);
    Soho.logTimeStart('ListFilter');
    this.init();
    Soho.logTimeEnd('ListFilter');
  }

  ListFilter.prototype = {

    init: function() {
      // Sanitize Incoming Options
      function setReasonableDefaults(setting, limits, preset) {
        if ($.inArray(setting, limits) === -1) {
          setting = preset;
        }
      }

      var checks = [
        { setting: this.settings.filterMode, limits: filterModes, preset: defaults.filterMode }
      ];

      for (var i = 0; i < checks.length; i++) {
        setReasonableDefaults(checks[i].setting, checks[i].limits, checks[i].preset);
      }

      return this;
    },

    /**
    * Run the filter on the list for the given sreach term.
    * @param {Array} list  &nbsp;-&nbsp; The array to search.
    * @param {String} term  &nbsp;-&nbsp; The term to look for.
    * @returns {boolean|Array|jQuery[]}
    */
    filter: function(list, term) {
      if (!list) {
        return false;
      }

      // Check incoming list type
      if (!$.isArray(list) && !(list instanceof jQuery)) {
        return false;
      }

      // Search term must exist and must not be nothing
      if (!term || typeof term !== 'string' || !term.length) {
        return false;
      }

      var self = this,
        items = [],
        isJQuery = false;

      // make search term lowercase if the search is not case-senstive
      if (!this.settings.caseSensitive) {
        term = term.toLowerCase();
      }

      // If it's not an array, build an array of the incoming object(s) for iterating through
      if (!$.isArray(list)) {
        if (list instanceof jQuery || typeof list === 'object') {
          list = $.makeArray(list);
          isJQuery = true;
        }
      }

      // If a custom callback for getting searchable content is defined, return a string result from that callback.
      // Otherwise, perform the standard method of grabbing text content.
      function getSearchableContent(item) {
        if (typeof self.settings.searchableTextCallback === 'function') {
          return self.settings.searchableTextCallback(item);
        }

        var isString = typeof item === 'string';
        return (isString ? item : $(item).text());
      }

      // Iterates through each list item and attempts to find the provided search term.
      function searchItemIterator(item) {
        var text = getSearchableContent(item),
          parts = text.split(' '),
          match = false;

        if (self.settings.filterMode === 'startsWith') {
          for (var a = 0; a < parts.length; a++) {
            if (parts[a].toLowerCase().indexOf(term) === 0) {
              match = true;
              break;
            }
          }

          //Direct Match
          if (text.toLowerCase().indexOf(term) === 0) {
            match = true;
          }

          //Partial dual word match
          if (term.indexOf(' ') > 0 && text.toLowerCase().indexOf(term) > 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'contains') {
          if (text.toLowerCase().indexOf(term) >= 0) {
            match = true;
          }
        }

        if (match) {
          items.push(item);
        }

        return;
      }

      // Run the iterator
      list.forEach(searchItemIterator);

      // If we originally took in a jQuery selector, rebuild that jQuery selector with the relevant results.
      if (isJQuery) {
        items = $(items);
      }

      return items;
    },

    updated: function(settingsObj) {
      this.settings = $.extend({}, this.settings, settingsObj);
      return this
        .teardown()
        .init();
    },

    teardown: function() {
      return this;
    },

    destroy: function() {
      return this.teardown();
    }

  };

  // Add it to the Window for use
  window.ListFilter = ListFilter;


  $.fn.about = function(options) {

    // Settings and Options
    var pluginName = 'about',
        defaults = {
          appName: 'Infor Application Name',
          content: undefined,
          copyrightYear: new Date().getFullYear(),
          deviceSpecs: true,
          productName: undefined,
          useDefaultCopyright: true,
          version: undefined
        },
        settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class About
    * @param {String} appName The Main Application Name to display in the header.
    * @param {String} content Additional Text content to display at the top.
    * @param {String} copyrightYear The year displayed in the copyright, defaults to current year.
    * @param {Boolean} deviceSpecs Determines whether or not to display device information (Browser, Platform, Locale, Cookies Enabled)
    * @param {String} productName Additional product name information to display.
    * @param {Boolean} useDefaultCopyright Add the Legal Approved Infor Copy Right Text.
    * @param {String} version Semantic Version Number for example (4.0.0).
    *
    */
    function About(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    About.prototype = {

      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        this.isBody = $(this.element).is('body');
        var appName = this.element.attr('data-appname');
        this.settings.appName = appName !== undefined ? appName.toString() : this.settings.appName;

        var content = this.element.attr('data-about-content');
        this.settings.content = content !== undefined ? content.toString() : this.settings.content;

        var copyrightYear = this.element.attr('data-copyright-year');
        this.settings.copyrightYear = copyrightYear !== undefined ? copyrightYear.toString() : this.settings.copyrightYear;

        var deviceSpecs = this.element.attr('data-device-specs');
        if (deviceSpecs) {
          this.settings.deviceSpecs = deviceSpecs === 'true';
        }

        var productName = this.element.attr('data-product-name');
        this.settings.productName = productName !== undefined ? productName.toString() : this.settings.productName;

        var useDefaultCopyright = this.element.attr('data-use-default');
        if (useDefaultCopyright !== undefined) {
          this.settings.useDefaultCopyright = useDefaultCopyright === 'true';
        }

        var version = this.element.attr('data-version');
        this.settings.version = version !== undefined ? version.toString() : this.settings.version;

        // Get the default copyright text and cut in the current year
        this.defaultCopyright = Locale.translate('AboutText') + ' <a class="hyperlink" href="http://www.infor.com" target="_blank">www.infor.com</a>.';
        this.defaultCopyright = this.defaultCopyright.replace('{0}', this.settings.copyrightYear);

        return this;
      },

      build: function() {
        this.modal = $('<div class="modal about" id="about-modal"></div>');
        $('<div class="modal-content"></div>').appendTo(this.modal);
        var header = $('<div class="modal-header"></div>').appendTo(this.modal.find('.modal-content'));
        $('<div class="close-container"></div>')
          .append($('<button name="close" type="button" class="btn-icon hide-focus"></button>')
            .append($.createIconElement({ icon: 'close', classes: 'icon-close' }))
            .append('<span>' + Locale.translate('Close') + '</span>'))
          .appendTo(header);
        $.createIconElement({ icon: 'logo-trademark', classes: ['icon', 'about-logo'] }).attr({ viewBox: '0 0 44 44' }).appendTo(header);
        this.title = $('<h1 class="title"></h1>').text(this.settings.appName).appendTo(this.modal.find('.modal-header'));

        var body = $('<div class="modal-body"></div>').appendTo(this.modal.find('.modal-content'));

        if (this.settings.version || this.settings.productName) {
          var productAndVersion = '' + (this.settings.productName ? this.settings.productName + ' ' : '') +
            (this.settings.version ? this.settings.version : '');
          $('<p></p>').text(productAndVersion).appendTo(body);
        }

        if (this.settings.content) {
          $('<div class="additional-content"></div>').html(this.settings.content).appendTo(body);
        }

        if (this.settings.useDefaultCopyright || !this.settings.content) {
          $('<p></p>').html(this.defaultCopyright).appendTo(body);
        }

        if (this.settings.deviceSpecs) {
          var specs = this.getDeviceSpecs(),
            text = '<span class="browser">' + Locale.translate('Browser') + ' : ' + specs.browser + '</span><br>' +
              '<span class="platform">' + Locale.translate('Platform') + ' : ' + specs.os + '</span><br>' +
              '<span class="locale">' + Locale.translate('Locale') + ' : ' + specs.locale + '</span><br>' +
              '<span class="cookiesEnabled">' + Locale.translate('CookiesEnabled') + ' : ' +  specs.cookiesEnabled + '</span><br>';
          $('<p></p>').html(text).appendTo(body);
        }

        //$('<div class="modal-buttonset"><button type="button" name="done" class="btn-modal">Done</button></div>').appendTo(this.modal.find('.modal-content'));
        this.buttons = this.modal.find('button');

        this.modal.find('.hide-focus').one('blur', function () {
          $(this).removeClass('hide-focus');
        });

        this.element.attr('data-modal','about-modal');

        $('.modal-body', this.modal)[0].tabIndex = 0;

        this.modal.appendTo('body');
        this.modal.modal({trigger: this.isBody ? 'immediate' : 'click'});
        return this;
      },

      /**
      * Return the browser specs. Currently returns browse, os, cookiesEnabled and locale
      * @returns {String}
      */
      getDeviceSpecs: function() {

        var locale = navigator.appName === 'Microsoft Internet Explorer' ? navigator.userLanguage : navigator.language,
          browser = (function(){
            var ua= navigator.userAgent, tem,
            M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

            if (/trident/i.test(M[1])){
              tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
              return 'IE '+(tem[1] || '');
            }

            if (M[1]=== 'Chrome'){
              tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
              if (tem!= null) {
                return tem.slice(1).join(' ').replace('OPR', 'Opera');
              }
            }

            M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
            if ((tem= ua.match(/version\/(\d+)/i))!= null) {
              M.splice(1, 1, tem[1]);
            }
            return M.join(' ');
        })();

        return {
          browser: browser,
          os: navigator.platform,
          cookiesEnabled: navigator.cookieEnabled,
          locale: locale
        };
      },

      /**
      * Progamatically Close the About Dialog.
      */
      close: function() {
        var modalApi = this.modal.data('modal');

        if (modalApi) {
          modalApi.close();
        }

        if (this.isBody) {
          this.destroy();
        }
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        var modalApi = this.modal.data('modal');

        if (modalApi) {
          modalApi.element.off('beforeopen.about');
          modalApi.destroy();
        }

        this.buttons.off();
        this.element.off('open.about');
        $.removeData(this.element[0], pluginName);
      },

      /**
      * Fires before the dialog is closing. You can return false syncronously to delay closing.
      *
      * @event beforeclose
      * @type {object} fires
      * @property {Object} event - The jquery event object.
      * @property {Object} ui - The dialog object
      */

      /**
      * Fires as the dialog is closing
      *
      * @event close
      * @type {object} fires
      * @property {Object} event - The jquery event object.
      * @property {Object} ui - The dialog object
      */

      /**
       *Fires after the dialog has closed in the DOM entirely.
       *
       * @event afterclose
       * @type {object} fires
       * @property {Object} event - The jquery event object.
       * @property {Object} ui - The dialog object
       */

      handleEvents: function() {
        var self = this;

        this.element.on('open.about', function(e) {
          e.stopPropagation();
          self.element.trigger('click');
        });

        this.buttons.filter('[name="done"], [name="close"]').on('click.about', function() {
          self.close();
        });

        this.modal.data('modal').element.on('beforeopen.about', function() {
          self.modal.find('.modal-body').scrollTop(0);
        });

        $(document).on('keydown.about', function(e) {
          // Close on Escape.
          if (e.which === 0 || e.which === 27) {
            self.close();
          }
        });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
      } else {
        instance = $.data(this, pluginName, new About(this, settings));
      }
    });
  };

// NOTE:  There are AMD Blocks available


  window.Soho = window.Soho || {};
  window.Soho.components = window.Soho.components || {};

  var DEFAULT_ACCORDION_OPTIONS = {
    allowOnePane: true,
    displayChevron: true,
    rerouteOnLinkClick: true,
    source: null
  };

  /**
   * The Accordion is a grouped set of collapsible panels used to navigate sections of
   * related content. Each panel consists of two levels: the top level identifies the
   * category or section header, and the second level provides the associated options.
   *
   * @class Accordion
   * @param {String} allowOnePane &nbsp;-&nbsp; If set to true, allows only one pane of the Accordion to be open at a time.  If an Accordion pane is open, and that pane contains sub-headers, only one of the pane's sub-headers can be open at a time. (default true)
   * @param {String} displayChevron  &nbsp;-&nbsp; Displays a "Chevron" icon that sits off to the right-most side of a top-level accordion header.  Used in place of an Expander (+/-) if enabled.
   * @param {String} rerouteOnLinkClick  &nbsp;-&nbsp; Can be set to false if routing is externally handled
   * @param {Boolean} source  &nbsp;-&nbsp; A callback function that when implemented provided a call back for "ajax loading" of tab contents on open.
   *
   */
  function Accordion(element, options) {
    this.element = $(element);
    this.settings = $.extend({}, DEFAULT_ACCORDION_OPTIONS, this.getInlineOptions(element[0]), options);

    this.init();
  }

  // Plugin Methods
  Accordion.prototype = {

    /**
     * Initialization kickoff point
     * @private
     * @param {jQuery[]} [headers] - if provided, only attempts to build the specified headers and their related anchors/panes
     * @returns {this}
     */
    init: function(headers) {
      this
        .build(headers)
        .handleEvents(headers);
    },

    /**
     * Handles the access of HTML-inlined `data-options`
     * @private
     * @returns {Object}
     */
    getInlineOptions: function() {
      return Soho.utils.parseOptions(this.element[0]);
    },

    /**
     * Takes a barebones Accordion markup definition and fleshes out any missing parts,
     * as well as storing references to headers, anchors, and panes.
     * @private
     * @param {jQuery[]} [headers] - if provided, only attempts to build the specified headers and their related anchors/panes
     * @returns {this}
     */
    build: function(headers) {
      var self = this,
        anchors, panes, isGlobalBuild = true;

      if (!headers || !(headers instanceof jQuery)) {
        headers = this.headers = this.element.find('.accordion-header');
        anchors = this.anchors = headers.children('a');
        panes = this.panes = headers.next('.accordion-pane');
      } else {
        anchors = headers.children('a');
        panes = headers.next('.accordion-pane');
        isGlobalBuild = false;

        // update internal refs
        this.headers = this.headers.add(headers);
        this.anchors = this.anchors.add(anchors);
        this.panes = this.panes.add(panes);
      }

      var headersHaveIcons = false;

      // Accordion Headers that have an expandable pane need to have an expando-button added inside of them
      headers.each(function addExpander() {
        var header = $(this),
          hasIcons = false,
          containerPane = header.parent(),
          isTopLevel = containerPane.is('.accordion');

        function checkIfIcons() {
          if (isTopLevel) {
            return;
          }

          if (!hasIcons) {
            header.addClass('no-icon');
            return;
          }

          containerPane.addClass('has-icons');
        }

        header.attr('role', 'presentation').hideFocus();

        // For backwards compatibility:  If an icon is found inside an anchor, bring it up to the level of the header.
        header.children('a').find('svg').detach().insertBefore(header.children('a'));

        var outerIcon = header.children('.icon, svg');
        outerIcon.addClass('icon').attr({'role': 'presentation', 'aria-hidden': 'true', 'focusable': 'false'});
        if (isTopLevel && outerIcon.length) {
          headersHaveIcons = true;
        }

        if (header.is('.list-item') || (!isTopLevel && header.find('button').length)) {
          hasIcons = true;
        }

        // Enable/Disable
        if (header.hasClass('is-disabled')) {
          header.children('a, button').attr('tabindex', '-1');
        }

        // Don't continue if there's no pane
        if (!header.next('.accordion-pane').length) {
          checkIfIcons();
          return;
        }

        hasIcons = true;

        var expander = header.children('.btn');
        if (!expander.length) {
          expander = $('<button class="btn" type="button"></button>');

          var method = 'insertBefore';
          if (self.settings.displayChevron && isTopLevel) {
            header.addClass('has-chevron');
            method = 'insertAfter';
          }
          expander[method](header.children('a'));
          header.data('addedExpander', expander);
        }

        // Hide Focus functionality
        expander.hideFocus();

        // If Chevrons are turned off and an icon is present, it becomes the expander
        if (outerIcon.length && !self.settings.displayChevron) {
          outerIcon.appendTo(expander);
        }

        var expanderIcon = expander.children('.icon, .svg, .plus-minus');
        if (!expanderIcon.length) {
          if (self.settings.displayChevron && isTopLevel) {
            expanderIcon = $.createIconElement({ icon: 'caret-down', classes: ['chevron'] });
          } else {
            var isActive = self.isExpanded(header) ? ' active' : '';
            expanderIcon = $('<span class="icon plus-minus'+ isActive +'" aria-hidden="true" role="presentation"></span>');
          }
          expanderIcon.appendTo(expander);
        }
        var expanderIconOpts = {
          'role': 'presentation',
          'aria-hidden': 'true'
        };
        if (!expanderIcon.is('span')) {
          expanderIconOpts.focusable = 'false';
        }
        expanderIcon.attr(expanderIconOpts);

        // Move around the Expander depending on whether or not it's a chevron
        if (expanderIcon.is('.chevron')) {
          header.addClass('has-chevron');
          expander.insertAfter(header.children('a'));
        } else {
          header.removeClass('has-chevron');
          expander.insertBefore(header.children('a'));
        }

        // Double check to see if we have left-aligned expanders or icons present,
        // so we can add classes that do alignment
        if (!self.settings.displayChevron && isTopLevel) {
          headersHaveIcons = true;
        }
        checkIfIcons();

        // Add an Audible Description to the button
        var description = expander.children('.audible');
        if (!description.length) {
          description = $('<span class="audible"></span>').appendTo(expander);
        }
        description.text(Locale.translate('Expand'));
      });

      if (headersHaveIcons) {
        this.element.addClass('has-icons');
      }

      // Setup correct ARIA for accordion panes, and auto-collapse them
      panes.each(function addPaneARIA() {
        var pane = $(this),
          header = pane.prev('.accordion-header');

        header.children('a').attr({'aria-haspopup': 'true', 'role': 'button'});

        if (!self.isExpanded(header)) {
          pane.data('ignore-animation-once', true);
          self.collapse(header);
        }
      });

      // Expand to the current accordion header if we find one that's selected
      if (isGlobalBuild && !this.element.data('updating')) {
        var targetsToExpand = headers.filter('.is-selected, .is-expanded');

        if (this.settings.allowOnePane) {
          targetsToExpand = targetsToExpand.first();
        }

        this.expand(targetsToExpand);
        this.select(targetsToExpand.last());
      }

      return this;
    },

    /**
     * Header Click Handler
     * @param {jQuery.Event} e,
     * @param {jQuery[]} header
     * @returns {boolean}
     */
    handleHeaderClick: function(e, header) {
      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        e.preventDefault();
        return;
      }

      // Check that we aren't clicking the expando button.  If we click that, this listener dies
      if ($(e.target).is('[class^="btn"]')) {
        e.preventDefault();
        return;
      }

      var anchor = header.children('a');
      return this.handleAnchorClick(e, anchor);
    },

    /**
     * Anchor Click Handler
     * @param {jQuery.Event} e,
     * @param {jQuery[]} anchor
     * @returns {boolean}
     */
    handleAnchorClick: function(e, anchor) {
      var self = this,
        header = anchor.parent('.accordion-header'),
        pane = header.next('.accordion-pane'),
        ngLink = anchor.attr('ng-reflect-href');

      if (e && !ngLink) {
        e.preventDefault();
      }

      if (!header.length || this.isDisabled(header) || this.isFiltered(header)) {
        return false;
      }

      var canSelect = this.element.triggerHandler('beforeselect', [anchor]);
      if (canSelect === false) {
        return;
      }

      this.element.trigger('selected', header);

      // Set the original element for DOM traversal by keyboard
      this.originalSelection = anchor;

      this.select(anchor);

      function followLink() {
        var href = anchor.attr('href');
        if (href && href !== '' && href !== '#') {
          if (!self.settings.rerouteOnLinkClick) {
            return true;
          }

          window.location.href = href;
          return true;
        }
        return false;
      }

      function toggleExpander() {
        if (pane.length) {
          self.toggle(header);
        }
        anchor.focus();
      }

      // Stop propagation here because we don't want to bubble up to the Header and potentially click the it twice
      if (e) {
        e.stopPropagation();
      }

      // If the anchor's a real link, follow the link and die here
      if (followLink()) {
        this.element.trigger('followlink', [anchor]);
        return true;
      }

      // If it's not a real link, try and toggle an expansion pane
      toggleExpander();
      return true;
    },

    /**
     * Expander-Button Click Handler
     * @param {jQuery.Event} e,
     * @param {jQuery[]} expander
     * @returns {boolean}
     */
    handleExpanderClick: function(e, expander) {
      var header = expander.parent('.accordion-header');
      if (!header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        return;
      }

      // Set the original element for DOM traversal by keyboard
      this.originalSelection = expander;

      // Don't propagate when clicking the expander.  Propagating can cause the link to be clicked in cases
      // where it shouldn't be clicked.
      if (e) {
        e.stopPropagation();
      }

      var pane = header.next('.accordion-pane');
      if (pane.length) {
        this.toggle(header);
        this.select(header);
        expander.focus();
        return;
      }

      // If there's no accordion pane, attempt to simply follow the link.
      return this.handleAnchorClick(null, header.children('a'));
    },

    /**
     * Keypress Event Handler for expanders and anchors
     * @param {jQuery.Event} e
     * @returns {boolean}
     */
    handleKeys: function(e) {
      var self = this,
        key = e.which,
        target = $(e.target), // will be either an anchor or expando button.  Should NEVER be the header itself.
        header = target.parent(),
        expander = header.children('[class^="btn"]').first(),
        anchor = header.children('a');

      function setInitialOriginalSelection(selection) {
        if (!selection) {
          selection = target;
        }

        if (!self.originalSelection) {
          self.originalSelection = selection;
        }
      }

      if (key === 9) { // Tab (also triggered by Shift + Tab)
        this.headers.removeClass('is-selected');

        if (target.is('a') && expander.length) {
          setInitialOriginalSelection(expander);
        } else {
          setInitialOriginalSelection(anchor);
        }
      }

      if (key === 32) { // Spacebar
        e.preventDefault();

        // Don't let this propagate and run against the header element, if it's a button
        if (target.is('[class^="btn"]')) {
          e.stopPropagation();
          e.stopImmediatePropagation();

          // Firefox will attempt to run this twice, despite the fact that we're stopping propagation.
          // Just cancel the whole thing if Firefox is running this method.
          if ($('html').hasClass('is-firefox')) {
            return;
          }
        }

        if (expander.length) {
          setInitialOriginalSelection(expander);
          return this.handleExpanderClick(null, target);
        } else {
          setInitialOriginalSelection(anchor);
          return this.handleAnchorClick(null, target);
        }
      }

      if (key === 37 || key === 38) { // Left Arrow/Up Arrow
        e.preventDefault();
        setInitialOriginalSelection();
        if (e.shiftKey) {
          return this.ascend(header);
        }
        return this.prevHeader(header);
      }

      if (key === 39 || key === 40) { // Right Arrow/Down Arrow
        e.preventDefault();
        setInitialOriginalSelection();
        if (e.shiftKey) {
          return this.descend(header);
        }
        return this.nextHeader(header);
      }
    },

    /**
     * Translates all existing markup inside the accordion to a JSON-compatible object structure.
     * @param {boolean} flatten - if true, places all accordion headers in the root array.
     * @param {boolean} addElementReference - if true, includes a reference to the original header element inside the structure (NOT valid JSON).
     * @returns {Object}
     */
    toData: function(flatten, addElementReference) {
      var data = [],
        topHeaders = this.element.children('.accordion-header');

      function buildHeaderJSON(el, index, parentNesting, parentArr) {
        var $el = $(el),
          pane = $(el).next('.accordion-pane'),
          headerData = {
            text: $(el).children('a, span').text().trim(),
            index: '' + (parentNesting !== undefined ? parentNesting + '.' : '') + index
          };

        if (el.getAttribute('id')) {
          headerData.id = el.getAttribute('id');
        }

        var icon = $el.children('.icon');
        if (icon.length) {
          headerData.icon = icon[0].tagName.toLowerCase() === 'svg' ?
            icon[0].getElementsByTagName('use')[0].getAttribute('xlink:href') :
            '';
        }

        if (addElementReference) {
          headerData.element = el;
        }

        if ($el.hasClass('is-disabled')) {
          headerData.disabled = true;
        }

        if (pane.length) {
          var content = pane.children('.accordion-content'),
            subheaders = pane.children('.accordion-header'),
            subheaderData = [];

          if (content.length) {
            headerData.content = '' + content.html();
          }

          if (subheaders.length) {
            // Normally this will nest.  If "flatten" is true, don't nest and add straight to the parent array.
            var targetArray = subheaderData;
            if (flatten) {
              targetArray = parentArr;
            }

            subheaders.each(function(j, subitem) {
              buildHeaderJSON(subitem, j, headerData.index, targetArray);
            });


            headerData.children = subheaderData;
          }
        }

        parentArr.push(headerData);
      }

      // Start traversing the accordion
      topHeaders.each(function(i, item) {
        buildHeaderJSON(item, i, undefined, data);
      });

      return data;
    },

    /**
     * Makes a header "selected" if its expander button or anchor tag is focused.
     * @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
     */
    select: function(element) {
      if (!element || !element.length) {
        return;
      }

      // Make sure we select the anchor
      var anchor = element,
        header = anchor.parent();

      if (element.is('.accordion-header')) {
        header = element;
        anchor = header.children('a');
      }

      if (anchor.is('[class^="btn"]')) {
        anchor = element.next('a');
      }

      if (this.isDisabled(header) || this.isFiltered(header)) {
        return;
      }

      this.headers.removeClass('child-selected').removeClass('is-selected');

      header.addClass('is-selected');

      var items = header.parentsUntil(this.element, '.accordion-pane')
        .prev('.accordion-header');

      items.addClass('child-selected');
    },

    /**
    * Checks if a particular header is disabled, or if the entire accordion is disabled..
    * @param {Object} header &nbsp;-&nbsp; the jquery header element
    * @returns {Boolean}
    */
    isDisabled: function(header) {
      if (this.element.hasClass('is-disabled')) {
        return true;
      }

      if (!header) {
        return false;
      }

      return header.hasClass('is-disabled');
    },

    /**
     * @param {Object} header
     * @returns {boolean}
     */
    isFiltered: function(header) {
      if (!header) {
        return false;
      }

      return header.hasClass('filtered');
    },

    /**
    * Checks if an Accordion Section is currently expanded
    * @param {Object} header &nbsp;-&nbsp; the jquery header element
    * @returns {Boolean}
    */
    isExpanded: function(header) {
      if (!header || !header.length) {
        return;
      }

      return header.children('a').attr('aria-expanded') === 'true';
    },

    /**
    * Toggle the given Panel on the Accordion between expanded and collapsed
    * @param {Object} header &nbsp;-&nbsp; the jquery header element
    */
    toggle: function(header) {
      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header)) {
        return;
      }

      if (this.isExpanded(header)) {
        this.collapse(header);
        return;
      }
      this.expand(header);
    },

    /**
    * Expand the given Panel on the Accordion.
    * @param {Object} header &nbsp;-&nbsp; the jquery header element
    */
    expand: function(header) {
      if (!header || !header.length) {
        return;
      }

      var self = this,
        pane = header.next('.accordion-pane'),
        a = header.children('a');

      var canExpand = this.element.triggerHandler('beforeexpand', [a]);
      if (canExpand === false) {
        return;
      }

      function continueExpand() {
        // Change the expander button into "collapse" mode
        var expander = header.children('.btn');
        if (expander.length) {
          expander.children('.plus-minus, .chevron').addClass('active');
          expander.children('.audible').text(Locale.translate('Collapse'));
        }

        var headerParents = header.parentsUntil(self.element).filter('.accordion-pane').prev('.accordion-header').add(header);

        // If we have the correct settings defined, close other accordion headers that are not parents of this one.
        if (self.settings.allowOnePane) {
          self.headers.not(headerParents).each(function() {
            var h = $(this);
            if (self.isExpanded(h)) {
              self.collapse(h);
            }
          });
        }

        // Expand all headers that are parents of this one, if applicable
        headerParents.not(header).each(function() {
          var h = $(this);
          if (!self.isExpanded(h)) {
            self.expand(h);
          }
        });

        pane.addClass('is-expanded');
        self.element.trigger('expand', [a]);

        pane.one('animateopencomplete', function(e) {
          e.stopPropagation();
          header.children('a').attr('aria-expanded', 'true');
          self.element.trigger('afterexpand', [a]);
        }).css('display', 'block').animateOpen();
      }

      // Load from an external source, if applicable
      if (!this.callSource(a, continueExpand)) {
        continueExpand.apply(this);
      }
    },

    /**
     * Expands all accordion headers, if possible.
     */
    expandAll: function() {
      if (this.settings.allowOnePane === true) {
        return;
      }

      var self = this;
      this.headers.each(function() {
        var h = $(this);
        if (!self.isExpanded(h)) {
          self.expand(h);
        }
      });
    },

    /**
    * Collapse the given Panel on the Accordion.
    * @param {Object} header &nbsp;-&nbsp; the jquery header element
    */
    collapse: function(header) {
      if (!header || !header.length) {
        return;
      }

      var self = this,
        pane = header.next('.accordion-pane'),
        a = header.children('a');

      var canExpand = this.element.triggerHandler('beforecollapse', [a]);
      if (canExpand === false) {
        return;
      }

      // Change the expander button into "expand" mode
      var expander = header.children('.btn');
      if (expander.length) {
        expander.children('.plus-minus, .chevron').removeClass('active');
        expander.children('.audible').text(Locale.translate('Expand'));
      }

      pane.removeClass('is-expanded').closeChildren();
      a.attr('aria-expanded', 'false');

      self.element.trigger('collapse', [a]);

      pane.one('animateclosedcomplete', function(e) {
        e.stopPropagation();
        pane[0].style.display = 'none';
        self.element.trigger('aftercollapse', [a]);
      }).animateClosed();
    },

    /**
     * Collapses all accordion headers.
     */
    collapseAll: function() {
      var self = this;
      this.headers.each(function() {
        var h = $(this);
        if (self.isExpanded(h)) {
          self.collapse(h);
        }
      });
    },

    /**
     * Uses a function (this.settings.source()) to call out to an external API to fill the
     * inside of an accordion pane.
     * @param {jQuery[]} anchor
     * @param {function} animationCallback
     * @returns {boolean}
     */
    callSource: function(anchor, animationCallback) {
      if (!this.settings.source || typeof this.settings.source !== 'function') {
        return false;
      }

      var self = this,
        header = anchor.parent(),
        pane = header.next('.accordion-pane'),
        ui = {
          anchor: anchor,
          header: header,
          pane: pane
        };

      function response() {
        self.updated();
        setTimeout(function() {
          animationCallback.apply(self);
        }, 1);
        return;
      }

      // Trigger the external method and wait for a response.
      return this.settings.source(ui, response);
    },

    /**
     * Prepares a handful of references for dealing with a specific accordion header
     * @param {Event.target} eventTarget
     * @returns {Object}
     */
    getElements: function(eventTarget) {
      var target = $(eventTarget),
        header, anchor, expander, pane;

      if (target.is('.accordion-header')) {
        header = target;
        expander = target.children('[class^="btn"]');
        anchor = target.children('a');
      }

      if (target.is('.btn')) {
        expander = target;
        header = expander.parent();
        anchor = header.children('a');
      }

      if (target.is('a')) {
        anchor = target;
        header = anchor.parent();
        expander = header.children('.btn');
      }

      pane = header.next('.accordion-pane');

      return {
        header: header,
        expander: expander,
        anchor: anchor,
        pane: pane
      };
    },

    /**
     * Selects an adjacent Accordion Header that sits directly before the currently selected Accordion Header.
     * @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
     * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent against descending.
     */
    prevHeader: function(element, noDescend) {
      var elem = this.getElements(element),
        adjacentHeaders = elem.header.parent().children(),
        currentIndex = adjacentHeaders.index(elem.header),
        target = $(adjacentHeaders.get(currentIndex - 1));

      if (!adjacentHeaders.length || currentIndex === 0) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header);
        }
        target = adjacentHeaders.last();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':first-child')) {
          return this.ascend(elem.header);
        }
        target = target.prev();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');
        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader, -1);
          }
        }
        target = prevHeader;

        // if no target's available here, we've hit the end and need to wrap around
        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header);
          }

          target = adjacentHeaders.last();
          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.prev();
          }
        }
      }

      this.focusOriginalType(target);
    },

    /**
     * Selects an adjacent Accordion Header that sits directly after the currently selected Accordion Header.
     * @param {jQuery[]} element - a jQuery Object containing either an expander button or an anchor tag.
     * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent against descending.
     */
    nextHeader: function(element, noDescend) {
      var elem = this.getElements(element),
        adjacentHeaders = elem.header.parent().children(),
        currentIndex = adjacentHeaders.index(elem.header),
        target = $(adjacentHeaders.get(currentIndex + 1));

      if (!adjacentHeaders.length || currentIndex === adjacentHeaders.length - 1) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header, -1);
        }
        target = adjacentHeaders.first();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':last-child')) {
          return this.ascend(elem.header);
        }
        target = target.next();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');
        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader);
          }
        }
        target = $(adjacentHeaders.get(currentIndex + 2));

        // if no target's available here, we've hit the end and need to wrap around
        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header, -1);
          }

          target = adjacentHeaders.first();
          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.next();
          }
        }
      }

      this.focusOriginalType(target);
    },

    /**
     * Selects the first Accordion Header in the parent container of the current Accordion Pane.
     * If we're at the top level, jump out of the accordion to the last focusable element.
     * @param {jQuery[]} header - a jQuery Object containing an Accordion header.
     * @param {integer} direction - if -1, sets the position to be at the end of this set of headers instead of at the beginning.
     */
    ascend: function(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.parent('.accordion-pane'),
        target = pane.prev();

      if (direction === -1) {
        target = pane.next('.accordion-header');
        if (!target.length) {
          if (pane.parent('.accordion').length) {
            return this.nextHeader(pane.prev().children('a'), true);
          }

          return this.ascend(pane.prev(), -1);
        }
      }

      this.focusOriginalType(target);
    },

    /**
     * Selects the first Accordion Header in the child container of the current Accordion Header.
     * @param {jQuery[]} header - a jQuery Object containing an Accordion header.
     * @param {integer} direction - if -1, sets the position to be at the end of this set of headers instead of at the beginning.
     */
    descend: function(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.next('.accordion-pane'),
        target = pane.children('.accordion-header').first();

      if (direction === -1) {
        target = pane.children('.accordion-header').last();
      }

      // No headers may be present.  In which case, it may be necessary to simply focus the header for the current pane.
      if (!target.length) {
        return this.focusOriginalType(header);
      }

      if (this.isExpanded(target)) {
        return this.descend(target, -1);
      }

      this.focusOriginalType(target);
    },

    /**
     * Selects an Accordion Header, then focuses either an expander button or an anchor.
     * Governed by the property "this.originalSelection".
     * @param {Object} header - a jQuery Object containing an Accordion header.
     */
    focusOriginalType: function(header) {
      //this.select(header.children('a'));

      if (this.originalSelection.is('.btn') && header.children('.btn').length) {
        header.children('.btn').focus();
      } else {
        header.children('a').focus();
      }
    },

    /**
    * Disable an accordion from events
    */
    disable: function() {
      this.element
        .addClass('is-disabled');

      this.anchors.add(this.headers.children('[class^="btn"]')).attr('tabindex', '-1');
    },

    /**
    * Enable a disabled accordion.
    */
    enable: function() {
      this.element
        .removeClass('is-disabled');

      this.anchors.add(this.headers.children('[class^="btn"]')).removeAttr('tabindex');
    },

    /**
     * Updates an entire accordion, or specific portion(s).
     * @param {jQuery[]} [headers] - optional jQuery object containing accordion headers whose contents need to be torndown/rebound
     * @returns {this}
     */
    updated: function(headers) {
      this.element.data('updating', true);

      var currentFocus = $(document.activeElement);
      if (!$.contains(this.element[0], currentFocus[0])) {
        currentFocus = undefined;
      }

      // If accordion headers are passed in, simply teardown/rebind events only for those sections.
      // Otherwise, re-init the entire accordion.
      if (headers && (headers instanceof jQuery)) {
        this
          .teardown(headers)
          .init(headers);
      } else {
        this
          .teardown()
          .init();
      }

      if (currentFocus && currentFocus.length) {
        currentFocus.focus();
      }

      $.removeData(this.element[0], 'updating');
      return this;
    },

    /**
     * Teardown process for accordion elements
     * @param {jQuery} [headers] -
     */
    teardown: function(headers) {
      var globalEventTeardown = false;

      if (!headers || !(headers instanceof jQuery)) {
        headers = this.headers;
        globalEventTeardown = true;
      }
      var anchors = headers.find('a');

      headers
        .off('touchend.accordion click.accordion focusin.accordion focusout.accordion keydown.accordion mousedown.accordion mouseup.accordion')
        .each(function() {
          var header = $(this),
            icon = header.children('.icon');

          var hideFocus = header.data('hidefocus');
          if (hideFocus) {
            hideFocus.destroy();
          }

          if (icon.length) {
            var iconAPI = icon.data('icon');
            if (iconAPI) {
              iconAPI.destroy();
            }
          }

          var expander = header.data('addedExpander');
          if (expander) {
            expander.remove();
            $.removeData(this, 'addedExpander');
          }
        });

      anchors.off('touchend.accordion keydown.accordion click.accordion');

      headers.children('[class^="btn"]')
        .off('touchend.accordion click.accordion keydown.accordion');

      if (globalEventTeardown) {
        this.element.off('updated.accordion selected.accordion');
      }

      return this;
    },

    /**
    * Teardown and remove any added markup and events.
    */
    destroy: function() {
      this.teardown();
      $.removeData(this.element[0], 'accordion');
    },

    /**
     *  This component fires the following events.
     *
     * @fires Accordion#events
     * @param {Object} selected  &nbsp;-&nbsp; Fires when a panel is opened.
     * @param {Object} followlink  &nbsp;-&nbsp; If the anchor is a real link, follow the link and die here. This indicates the link has been followed.
     * @param {Object} expand  &nbsp;-&nbsp; Fires when expanding a pane is initiated.
     * @param {Object} afterexpand  &nbsp;-&nbsp; Fires after a pane is expanded.
     * @param {Object} collapse  &nbsp;-&nbsp; Fires when collapsed a pane is initiated.
     * @param {Object} aftercollapse  &nbsp;-&nbsp; Fires after a pane is collapsed.
     *
     */
    handleEvents: function(headers) {
      var self = this,
        headerWhereMouseDown = null,
        globalEventSetup = false;

      // If no header elements are passed in, simply default to ALL headers.
      if (!headers || !(headers instanceof jQuery)) {
        headers = this.headers;
        globalEventSetup = true;
      }
      var anchors = headers.find('a');

      // Returns "Header", "Anchor", or "Expander" based on the element's tag
      function getElementType(element) {
        var elementType = 'Header';
        if (element.is('a')) {
          elementType = 'Anchor';
        }
        if (element.is('button')) {
          elementType = 'Expander';
        }
        return elementType;
      }

      // Intercepts a 'click' event in order to either prevent a link from being followed,
      // or allows it to continue.
      function clickInterceptor(e, element) {
        var type = getElementType(element);
        return self['handle' + type + 'Click'](e, element);
      }

      headers.on('click.accordion', function(e) {
        return clickInterceptor(e, $(this));
      }).on('focusin.accordion', function(e) {
        var target = $(e.target);

        if (!self.originalSelection) {
          self.originalSelection = target;
        }

        if (target.is(':not(.btn)')) {
          $(this).addClass('is-focused').removeClass('hide-focus');
        }
      }).on('focusout.accordion', function() {
        if (!$.contains(this, headerWhereMouseDown) || $(this).is($(headerWhereMouseDown))) {
          $(this).removeClass('is-focused');
        }
      }).on('keydown.accordion', function(e) {
        self.handleKeys(e);
      }).on('mousedown.accordion', function(e) {
        $(this).addClass('is-focused').removeClass('hide-focus');
        headerWhereMouseDown = e.target;
      }).on('mouseup.accordion', function() {
        headerWhereMouseDown = null;
      });

      anchors.on('click.accordion', function(e) {
        return clickInterceptor(e, $(this));
      });

      headers.children('[class^="btn"]')
        .on('click.accordion', function(e) {
          return clickInterceptor(e, $(this));
        }).on('keydown.accordion', function(e) {
          self.handleKeys(e);
        });

      if (globalEventSetup) {
        this.element.on('selected.accordion', function(e) {
          // Don't propagate this event above the accordion element
          e.stopPropagation();
        }).on('updated.accordion', function(e) {
          // Don't propagate just in case this is contained by an Application Menu
          e.stopPropagation();
          self.updated();
        });
      }

      return this;
    }

  };

  // Add Accoridon to the Soho Components lib
  window.Soho.components.Accordion = Accordion;

  $.fn.accordion = function(options) {
    var pluginName = 'accordion';

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Accordion(this, options));
      }
    });
  };


  window.Soho = window.Soho || {};
  window.Soho.components = window.Soho.components || {};

  var DEFAULT_APPLICATIONMENU_OPTIONS = {
    breakpoint: 'phone-to-tablet',
    filterable: false,
    openOnLarge: false,
    triggers: []
  };

  /**
  * The Application Menu provides access to all the functions, pages, and forms in an application.
  *
  * @class ApplicationMenu
  * @param {String} breakpoint  &nbsp;-&nbsp; Can be 'tablet' (+720), 'phablet (+968), ' 'desktop' +(1024), or 'large' (+1280). Default is phablet (968)
  * @param {String} filterable
  * @param {String} openOnLarge  &nbsp;-&nbsp; If true, will automatically open the Application Menu when a large screen-width breakpoint is met.
  * @param {String} triggers  &nbsp;-&nbsp; An Array of jQuery-wrapped elements that are able to open/close this nav menu.
  */
  function ApplicationMenu(element, options) {
    this.element = $(element);
    this.settings = $.extend({}, DEFAULT_APPLICATIONMENU_OPTIONS, this.getInlineOptions(element[0]), options);

    return this.init();
  }

  // Plugin Methods
  ApplicationMenu.prototype = {

    /**
     * @private
     * @returns {this}
     */
    init: function() {
      this
        .setup()
        .handleEvents();
    },

    /**
     * Handles the access of HTML-inlined `data-options`
     * @private
     * @returns {Object}
     */
    getInlineOptions: function() {
      return Soho.utils.parseOptions(this.element[0]);
    },

    /**
     * @private
     * @returns {this}
     */
    setup: function() {
      this.hasTrigger = false;
      this.isAnimating = false;

      if (!this.hasTriggers()) {
        this.triggers = $();
      }

      this.menu = this.element;

      var openOnLarge = this.element.attr('data-open-on-large');
      this.settings.openOnLarge = openOnLarge !== undefined ? openOnLarge === 'true' : this.settings.openOnLarge;

      var breakpoints = Soho.breakpoints,
      dataBreakpoint = this.element.attr('data-breakpoint');
      this.settings.breakpoint = breakpoints[dataBreakpoint] !== undefined ? dataBreakpoint : this.settings.breakpoint;

      // Pull in the list of Nav Menu trigger elements and store them internally.
      this.modifyTriggers(this.settings.triggers, false, true);

      this.scrollTarget = this.menu.parents('.header');
      var masthead = this.menu.prevAll('.masthead'),
        moduleTabs = this.menu.prevAll('.module-tabs');

      if (masthead.length > 0) {
        this.scrollTarget = masthead;
        this.menu.addClass('short');
      }
      if (moduleTabs.length > 0) {
        this.scrollTarget = moduleTabs;
      }

      this.accordion = this.menu.find('.accordion');
      this.accordion.addClass('panel').addClass('inverse');

      // Check to make sure that the internal Accordion Control is invoked
      var accordion = this.accordion.data('accordion');
      if (!accordion) {
        var accOpts = this.accordion.parseOptions();
        this.accordion.accordion(accOpts);
        accordion = this.accordion.data('accordion');
      }
      this.accordionAPI = accordion;

      // detect the presence of a searchfield
      this.searchfield = this.element.children('.searchfield, .searchfield-wrapper');

      // Setup filtering, if applicable.
      if (this.settings.filterable && typeof $.fn.searchfield === 'function') {
        if (this.searchfield.length) {
          if (this.searchfield.is('.searchfield-wrapper')) {
            this.searchfield = this.searchfield.children('.searchfield');
          }
        } else {
          this.searchfield = $('<div class="searchfield-wrapper">' +
            '<label for="application-menu-searchfield">'+ Locale.translate('Search') +'</label>' +
            '<input id="application-menu-searchfield" class="searchfield" /></div>').prependTo(this.element);
        }

        var self = this;
        this.searchfield.searchfield({
          source: function(term, done, args) {
            done(term, self.accordion.data('accordion').toData(true, true), args);
          },
          searchableTextCallback: function(item) {
            return item.text || '';
          },
          resultIteratorCallback: function(item) {
            item._highlightTarget = 'text';
            return item;
          },
          displayResultsCallback: function(results, done) {
            return self.filterResultsCallback(results, done);
          }
        });
      } else {
        if (this.searchfield.length) {
          this.searchfield.off();
          this.searchfield.parent('.searchfield-wrapper').remove();
          delete this.searchfield;
        }
      }

      // Sync with application menus that have an 'is-open' CSS class.
      // Otherwise, just adjust the height.
      if (this.isOpen()) {
        this.openMenu(false, false, true);
      } else {
        this.adjustHeight();
      }

      return this;
    },

    /**
     * Gets a reference to this Application Menu's adjacent container element.
     * @returns {jQuery[]}
     */
    getAdjacentContainerElement: function() {
      var container = this.element.next('.page-container');
      if (!container.length) {
        container = $('body');
      }
      return container;
    },

    // Setup click events on this.element if it's not the menu itself
    // (this means that it's a trigger button)
    handleTriggerEvents: function() {
      var self = this;

      function triggerClickHandler(e) {
        // Don't allow hamburger buttons that have changed state to activate/deactivate the app menu.
        if ($(e.currentTarget).find('.icon.app-header').hasClass('go-back')) {
          return false;
        }

        if (self.isAnimating) {
          return false;
        }

        var isOpen = self.menu.hasClass('is-open');
        if (!isOpen) {
          self.openMenu(undefined, true);
        } else {
          self.closeMenu(true);
        }
        return true;
      }

      if (this.triggers.length) {
        this.triggers.off('click.applicationmenu').on('click.applicationmenu', triggerClickHandler);
      }

      $(document).on('keydown.applicationmenu', function(e) {
        self.handleKeyDown(e);
      });

    },

    handleKeyDown: function(e) {
      var key = e.which;

      if (key === 121) { // F10
        e.preventDefault();

        if (this.isOpen()) {
          this.closeMenu(true);
          if (this.triggers.length) {
            this.triggers.eq(0).focus();
          }
        } else {
          this.openMenu();
        }

        return false;
      }
    },

    notify: function(anchor, value) {
      if (!anchor || anchor === undefined) {
        return;
      }
      if (anchor instanceof HTMLElement) {
        anchor = $(anchor);
      }
      if (!anchor.is('a')) {
        return;
      }

      var tag = anchor.find('.tag');

      // Close the tag if an undefined or '0' value is passed
      if (!value || value === undefined || parseInt(value, 10) === 0) {
        if (tag.length) {
          tag.remove();
        }
        return;
      }

      if (!tag.length) {
        tag = $('<span class="tag"></span>').appendTo(anchor);
      }

      tag.text(value.toString());
      return tag;
    },

    /**
     * Adjusts the application menu's height to fit the page.
     * @private
     */
    adjustHeight: function() {
      var isSticky = this.scrollTarget.is('.is-sticky'),
        totalHeight = this.scrollTarget.outerHeight(true),
        offset = totalHeight - (!isSticky ? $(window).scrollTop() : 0);

      if (this.scrollTarget.prev().is('.masthead')) {
        offset += this.scrollTarget.prev().outerHeight(true);
      }

      this.menu[0].style.height = offset > 0 ? ('calc(100% - ' + offset + 'px)') : '100%';
    },

    /**
     * Checks the window size against the defined breakpoint.
     * @private
     */
    isLargerThanBreakpoint: function() {
      return Soho.breakpoints.isAbove(this.settings.breakpoint);
    },

    /**
     * Detects whether or not the application menu is open
     * @returns {boolean}
     */
    isOpen: function() {
      return this.menu[0].classList.contains('is-open');
    },

    /**
     * Detects a change in breakpoint size that can cause the Application Menu's state to change.
     */
    testWidth: function() {
      if (this.isOpen()) {
        if (Soho.breakpoints.isAbove(this.settings.breakpoint)) {
          this.element[0].classList.remove('show-shadow');
          return;
        }

        this.element[0].classList.add('show-shadow');

        if (this.element.find(document.activeElement).length || this.isAnimating) {
          return;
        }

        if (!this.userOpened) {
          this.closeMenu();
        }
        return;
      }

      if (Soho.breakpoints.isBelow(this.settings.breakpoint)) {
        return;
      }

      if (this.userClosed || !this.settings.openOnLarge || this.isAnimating) {
        return;
      }

      this.openMenu(true);
    },

    /**
     * Opens the Application Menu
     * @param {boolean} noFocus - If true, sets focus on the first item in the application menu.
     * @param {boolean} [userOpened] - If true, notifies the component that the menu was manually opened by the user.
     * @param {boolean} [openedByClass] - If true, only adjusts bare-miniumum requirements for the application menu to appear open (should be used in cases where the application menu has the `is-open` CSS appended to it via markup).  This skips events, animation, etc.
     */
    openMenu: function(noFocus, userOpened, openedByClass) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this,
        transitionEnd = $.fn.transitonEndName;

      if (!openedByClass) {
        this.isAnimating = true;
      }
      this.adjustHeight();

      function isOpen() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        if (userOpened) {
          self.userOpened = true;
          self.userClosed = undefined;
        }

        if (!openedByClass) {
          self.isAnimating = false;
          self.element.trigger('applicationmenuopen');
          $('body').triggerHandler('resize');
        }

        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }

      this.triggers.each(function() {
        var trig = $(this);
        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          var header = trig.parents('.header, .masthead');
          if (header.parents('.page-container').length) {
            return;
          }

          trig.find('.icon.app-header').removeClass('go-back').addClass('close');
          trig.trigger('icon-change');
        }
      });

      // Animate the application menu open.
      // If opened by class, `is-open` is already applied to the app menu at this point in the render cycle, and should not be re-applied.
      if (!openedByClass) {
        this.menu.off(transitionEnd + '.applicationmenu');
        this.menu[0].style.display = '';
        // next line forces a repaint
        this.menu[0].offsetHeight; //jshint ignore:line
        this.menu.addClass('is-open');
      }

      if (Soho.breakpoints.isBelow(this.settings.breakpoint)) {
        this.menu.addClass('show-shadow');
      }

      if (!noFocus || noFocus !== true) {
        this.menu.find('.is-selected > a').focus();
      }

      var container = this.getAdjacentContainerElement();
      container.addClass('ios-click-target');

      if (!openedByClass) {
        this.menu.one(transitionEnd + '.applicationmenu', isOpen);
        this.timeout = setTimeout(isOpen, 300);
      } else {
        isOpen();
      }

      // Events that will close the nav menu
      // On a timer to prevent conflicts with the Trigger button's click events
      setTimeout(function() {
        $(document).on('click.applicationmenu', function(e) {
          if ($(e.target).parents('.application-menu').length < 1 && !self.isLargerThanBreakpoint()) {
            self.closeMenu(true);
          }
        });
      }, 0);
    },

    /**
     * Closes the Application Menu
     * @param {boolean} userClosed - if true, sets a flag notifying the component that the user was responsible for closing.
     */
    closeMenu: function(userClosed) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this,
        transitionEnd = $.fn.transitionEndName();

      this.isAnimating = true;

      function close() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        self.menu.off(transitionEnd + '.applicationmenu');
        self.menu[0].style.display = 'none';
        self.isAnimating = false;

        if (userClosed) {
          self.userOpened = undefined;
          self.userClosed = true;
        }

        self.element.trigger('applicationmenuclose');
        $('body').triggerHandler('resize');
      }

      this.triggers.each(function() {
        var trig = $(this);
        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          trig.find('.icon.app-header').removeClass('close');
          trig.trigger('icon-change');
        }
      });

      var container = this.getAdjacentContainerElement();
      container.removeClass('ios-click-target');

      this.menu.one(transitionEnd + '.applicationmenu', close);
      this.timeout = setTimeout(close, 300);

      this.menu.removeClass('is-open show-shadow').find('[tabindex]');
      $(document).off('click.applicationmenu');
    },

    /**
     * Detects whether or not the Application Menu has external trigger buttons setup to control it.
     * @returns {boolean}
     */
    hasTriggers: function() {
      return (this.triggers !== undefined && this.triggers instanceof $ && this.triggers.length);
    },

    /**
     * Externally Facing function that can be used to add/remove application nav menu triggers.
     * @param {Array[]} triggers - an array of HTMLElements or jQuery-wrapped elements that will be used as triggers.
     * @param {boolean} [remove] - if defined, triggers that are defined will be removed internally instead of added.
     * @param {boolean} [norebuild] - if defined, this control's events won't automatically be rebound to include the new triggers.
     */
    modifyTriggers: function(triggers, remove, norebuild) {
      if (!triggers || !triggers.length) {
        return;
      }
      var changed = $();

      $.each(triggers, function(i, obj) {
        changed = changed.add($(obj));
      });

      this.triggers = this.triggers[!remove ? 'add' : 'not'](changed);
      this.handleTriggerEvents();

      if (norebuild && norebuild === true) {
        return;
      }

      this.updated();
    },

    /**
     * @param {Array} results
     * @param {function} done
     */
    filterResultsCallback: function(results, done) {
      var self = this,
        filteredParentHeaders = this.accordion.find('.has-filtered-children');

      this.accordionAPI.headers.removeClass('filtered has-filtered-children');

      if (!results || !results.length) {
        this.accordionAPI.collapse(filteredParentHeaders);
        this.accordionAPI.updated();
        this.isFiltered = false;
        this.element.triggerHandler('filtered', [results]);
        done();
        return;
      }

      var matchedHeaders = $();
      results.map(function(item) {
        matchedHeaders = matchedHeaders.add(item.element);

        var parentPanes = $(item.element).parents('.accordion-pane');
        parentPanes.each(function() {
          var parentHeaders = $(this).prev('.accordion-header').addClass('has-filtered-children');
          filteredParentHeaders = filteredParentHeaders.not(parentHeaders);
          self.accordionAPI.expand(parentHeaders);
        });
      });

      this.isFiltered = true;
      this.accordionAPI.headers.not(matchedHeaders).addClass('filtered');
      this.accordionAPI.collapse(filteredParentHeaders);
      this.accordionAPI.updated(matchedHeaders);

      this.element.triggerHandler('filtered', [results]);
      done();
    },

    /**
     * handles the Searchfield Input event
     * @param {jQuery.Event} e
     */
    handleSearchfieldInputEvent: function() {
      if (!this.searchfield || !this.searchfield.length) {
        return;
      }

      var val = this.searchfield.val();

      if (!val || val === '') {
        var filteredParentHeaders = this.accordion.find('.has-filtered-children');
        this.accordionAPI.headers.removeClass('filtered has-filtered-children');
        this.accordionAPI.collapse(filteredParentHeaders);
        this.accordionAPI.updated();
        this.element.triggerHandler('filtered', [[]]);
        return;
      }
    },

    /**
     * Unbinds event listeners and removes extraneous markup from the Application Menu.
     * @returns {this}
     */
    teardown: function() {
      this.menu
        .off('animateopencomplete animateclosedcomplete')
        .removeClass('short')
        .removeAttr('style');

      $(window).off('scroll.applicationmenu');
      $('body').off('resize.applicationmenu');
      $(document).off('click.applicationmenu open-applicationmenu close-applicationmenu keydown.applicationmenu');

      this.accordion.off('blur.applicationmenu');
      if (this.accordionAPI && typeof this.accordionAPI.destroy === 'function') {
        if (this.isFiltered) {
          this.accordionAPI.collapse();
        }
        this.accordionAPI.destroy();
      }

      if (this.searchfield && this.searchfield.length) {
        this.searchfield.off('input.applicationmenu');
        var sfAPI = this.searchfield.data('searchfield');
        if (sfAPI) {
          sfAPI.destroy();
        }
      }

      if (this.hasTriggers()) {
        this.triggers.off('click.applicationmenu');
      }

      return this;
    },

    /**
    * Triggers a UI Resync.
    */
    updated: function() {
      return this
        .teardown()
        .init();
    },

    /**
    * Teardown - Remove added markup and events
    */
    destroy: function() {
      this.teardown();
      $.removeData(this.element[0], 'applicationmenu');
    },

    /**
     *  This component fires the following events.
     *
     * @fires Applicationmenu#events
     * @param {Object} applicationmenuopen  &nbsp;-&nbsp; Fires when the menu is opened.
     * @param {Object} applicationmenuclose  &nbsp;-&nbsp; Fires as the menu is closed.
      *
     */
    handleEvents: function() {
      var self = this;

      this.handleTriggerEvents();

      // Setup notification change events
      this.menu.on('notify.applicationmenu', function(e, anchor, value) {
        self.notify(anchor, value);
      }).on('updated.applicationmenu', function() {
        self.updated();
      });

      this.accordion.on('blur.applicationmenu', function() {
        self.closeMenu();
      });

      $(document).on('open-applicationmenu', function() {
        self.openMenu();
      }).on('close-applicationmenu', function() {
        self.closeMenu();
      });

      $(window).on('scroll.applicationmenu', function() {
        self.adjustHeight();
      });

      $('body').on('resize.applicationmenu', function() {
        self.testWidth();
      });

      if (this.settings.filterable === true && this.searchfield && this.searchfield.length) {
        this.searchfield.on('input.applicationmenu', function(e) {
          self.handleSearchfieldInputEvent(e);
        });
      }

      if (this.settings.openOnLarge && this.isLargerThanBreakpoint()) {
        this.menu.addClass('no-transition');
        $('.page-container').addClass('no-transition');
      }
      this.testWidth();

      //Remove after initial transition
      setTimeout(function() {
        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }, 800);

      return this;
    }

  };


  // Add to the Soho Components object
  window.Soho.components.ApplicationMenu = ApplicationMenu;


  /**
   * jQuery component wrapper for the Application Menu
   * @param {Object} options
   * @returns {ApplicationMenu}
   */
  $.fn.applicationmenu = function(options) {
    return this.each(function() {
      var instance = $.data(this, 'applicationmenu');
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, 'applicationmenu', new ApplicationMenu(this, options));
      }
      return instance;
    });
  };


  $.fn.autocomplete = function(options) {
    'use strict';

    // Default Autocomplete Result Item Template
    var DEFAULT_AUTOCOMPLETE_TEMPLATE = '<li id="{{listItemId}}" data-index="{{index}}" {{#hasValue}}data-value="{{value}}"{{/hasValue}} role="listitem">' + '\n\n' +
      '<a href="#" tabindex="-1">' + '\n\n' +
        '<span>{{{label}}}</span>' + '\n\n' +
      '</a>' + '\n\n' +
    '</li>';

    var DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK = function(item) {
      var isString = typeof item === 'string';
      return (isString ? item : item.label);
    };

    var DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK = function resultIterator(item, index) {
      // For standard autocompletes with a popupmenu, build the dataset that
      // will be submitted to the template.
      var isString = typeof item === 'string',
        dataset = {
          _highlightTarget: 'label',
          index: index,
          listItemId: 'ac-list-option' + index
        };

      if (!isString) {
        dataset = Soho.utils.extend({}, dataset, item);
      } else {
        dataset.label = item;
      }

      dataset.hasValue = item.value !== undefined;
      if (dataset.hasValue) {
        dataset.value = item.value;
      }

      return dataset;
    };

    /**
     * @param {String} item
     * @param {Object} options
     * @param {String} [options.alias]
     * @param {String} options.filterMode
     * @param {String} options.term
     * @returns {String}
     */
    var DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK = function highlightMatch(item, options) {
      var targetProp = item,
        hasAlias = false;

      // If this is an object and we need to replace text within a specific property, look for an "alias"
      // property to use instead of the item itself.
      if (typeof options.alias === 'string' && item[options.alias] !== undefined) {
        hasAlias = true;
        targetProp = item[options.alias];
      }

      // Easy match for 'contains'-style filterMode.
      if (options.filterMode === 'contains') {
        targetProp = targetProp.replace(new RegExp('(' + options.term + ')', 'ig'), '<i>$1</i>');
      } else {
        // Handle "startsWith" filterMode highlighting a bit differently.
        var originalItem = targetProp,
          pos = Locale.toLowerCase(originalItem).indexOf(options.term);

        if (pos > 0) {
          targetProp = originalItem.substr(0, pos) + '<i>' + originalItem.substr(pos, options.term.length) + '</i>' + originalItem.substr(options.term.length + pos);
        } else if (pos === 0) {
          targetProp = '<i>' + originalItem.substr(0, options.term.length) + '</i>' + originalItem.substr(options.term.length);
        }
      }

      // place result back
      if (hasAlias) {
        item[options.alias] = targetProp;
      } else {
        item = targetProp;
      }

      return item;
    };

    /**
    * The Autocomplete control provides an easier means of searching through a large amount of data by filtering down the results based on keyboard input from the user.
    *
    * @class Autocomplete
    *
    * @param {String} source  &nbsp;-&nbsp; Defines the data to use, must be specified.
    * @param {String} sourceArguments  &nbsp;-&nbsp; If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
    * @param {Boolean} template  &nbsp;-&nbsp; If defined, use this to draw the contents of each search result instead of the default draw routine.
    * @param {String} filterMode  &nbsp;-&nbsp; The matching algorithm, startsWith and contains are supported - false will not filter client side
    * @param {Boolean} delay  &nbsp;-&nbsp; The delay between key strokes on the keypad before it thinks you stopped typing
    * @param {String} width  &nbsp;-&nbsp; Width of the open auto complete menu
    * @param {String} offset  &nbsp;-&nbsp; For the open menu, the left or top offset
    * @param {String} autoSelectFirstItem  &nbsp;-&nbsp; Whether or not to select he first item in the list to be selected
    * @param {function} resultsCallback  &nbsp;-&nbsp; If defined, does not produce the results of the Autocomplete inside a popupmenu, instead piping them to a process defined inside this callback function.
    */
    var pluginName = 'autocomplete',
      defaults = {
        source: [],
        sourceArguments: {},
        template: undefined,
        filterMode: 'startsWith',
        delay: 300,
        width: null,
        offset: null,
        autoSelectFirstItem: false,
        highlightMatchedText: true,
        highlightCallback: DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK,
        resultIteratorCallback: DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK,
        displayResultsCallback: undefined,
        searchableTextCallback: DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK
      },
      settings = $.extend({}, defaults, options);

    function Autocomplete(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Object
    Autocomplete.prototype = {

      init: function() {
        // data-autocomplete can be a url, 'source' or an array
        var data = this.element.attr('data-autocomplete');
        if (data && data !== 'source') {
          this.settings.source = data;
        }

        if (!this.listFilter) {
          this.listFilter = new ListFilter({
            filterMode: this.settings.filterMode,
            highlightMatchedText: this.settings.highlightMatchedText,
            searchableTextCallback: this.settings.searchableTextCallback
          });
        }

        this.addMarkup();
        this.handleEvents();
      },

      addMarkup: function () {
        this.element.addClass('autocomplete').attr({
          'role': 'combobox',
          'autocomplete': 'off'
        });
      },

      isLoading: function() {
        return this.element.hasClass('is-loading') && this.element.hasClass('is-blocked');
      },

      openList: function (term, items) {
        if (this.element.is('[disabled], [readonly]') || this.isLoading()) {
          return;
        }

        var self = this;
        term = Locale.toLowerCase(term);

        //append the list
        this.list = $('#autocomplete-list');
        if (this.list.length === 0) {
          this.list = $('<ul id="autocomplete-list" aria-expanded="true"></ul>').appendTo('body');
        }

        this.list[0].style.height = 'auto';
        this.list[0].style.width = this.element.outerWidth() + 'px';
        this.list.addClass('autocomplete');
        this.list.empty();

        if (this.settings.width) {
          this.list[0].style.width = this.settings.width + (/(px|%)/i.test(this.settings.width + '') ? '' : 'px');
        }

        // Pre-compile template.
        // Try to get an element first, and use its contents.
        // If the string provided isn't a selector, attempt to use it as a string, or fall back to the default template.
        var templateAttr = $(this.element.attr('data-tmpl'));
        this.tmpl = $(templateAttr).length ? $(templateAttr).text() :
          typeof templateAttr === 'string' ? templateAttr :
          $(this.settings.template).length ? $(this.settings.template).text() :
          typeof this.settings.template === 'string' ? this.settings.template :
          DEFAULT_AUTOCOMPLETE_TEMPLATE;

        // Send full item list to the ListFilter for filtering.
        var filterResult = this.listFilter.filter(items, term),
          modifiedFilterResults = [];

        // Modify filtered results for a specific template with a `resultIteratorCallback`, if applicable.
        // Each of these results is deep-copied.
        filterResult.forEach(function(val, index) {
          var result = Soho.utils.extend(true, {}, val);
          result = self.settings.resultIteratorCallback(result, index);

          if (self.settings.highlightMatchedText) {
            var filterOpts = {
              filterMode: self.settings.filterMode,
              term: term
            };
            if (result._highlightTarget) {
              filterOpts.alias = result._highlightTarget;
            }
            result = self.settings.highlightCallback(result, filterOpts);
          }

          modifiedFilterResults.push(result);
        });

        // If a "resultsCallback" method is defined, pipe the filtered items to that method and skip
        // building a popupmenu.
        if (typeof this.settings.displayResultsCallback === 'function') {
          return this.settings.displayResultsCallback(modifiedFilterResults, function() {
            self.element.trigger('listopen', [modifiedFilterResults]);
          });
        }

        this.handleListResults(term, items, modifiedFilterResults);
      },

      handleListResults: function(term, items, filterResult) {
        var self = this;

        function autocompletePlaceCallback(placementObj) {
          // Nudge the autocomplete to the right by 1px in Chrome
          if (Soho.env.browser.name === 'chrome') {
            placementObj.setCoordinate('x', placementObj.x + 1);
          }
          return placementObj;
        }

        var popupOpts = {
          menuId: 'autocomplete-list',
          ariaListbox: true,
          mouseFocus: false,
          trigger: 'immediate',
          attachToBody: true,
          autoFocus: false,
          returnFocus: false,
          placementOpts: {
            callback: autocompletePlaceCallback,
            parent: this.element
          }
        };

        filterResult.forEach(function(dataset) {
          if (typeof Tmpl !== 'undefined') {
            var compiledTmpl = Tmpl.compile(self.tmpl),
              renderedTmpl = compiledTmpl.render(dataset);

            self.list.append($.sanitizeHTML(renderedTmpl));
          } else {
            var listItem = $('<li role="listitem"></li>');
            listItem.attr('id', dataset.listItemId);
            listItem.attr('data-index', dataset.index);
            listItem.attr('data-value', dataset.value);
            listItem.append('<a href="#" tabindex="-1"><span>' + dataset.label + '</span></a>');
            self.list.append($.sanitizeHTML(listItem));
          }
        });

        this.element.addClass('is-open')
          .popupmenu(popupOpts)
          .on('close.autocomplete', function () {
            self.closeList(true);
          });

        // Optionally select the first item in the list
        if (self.settings.autoSelectFirstItem) {
          self.list.children().filter(':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)').first()
            .addClass('is-selected');
        }

        this.noSelect = true;
        this.element.trigger('populated', [filterResult]).focus();

        // Overrides the 'click' listener attached by the Popupmenu plugin
        self.list.off('click touchend')
          .on('touchend.autocomplete click.autocomplete', 'a', function(e) {
            self.select(e, items);
          })
          .off('focusout.autocomplete').on('focusout.autocomplete', function() {
            self.checkActiveElement();
          });

        // Highlight anchors on focus
        var all = self.list.find('a').on('focus.autocomplete touchend.autocomplete', function () {
          self.highlight($(this), all);
        });

        if (this.settings.offset) {
          var domListParent = this.list.parent()[0];

          if (this.settings.offset.left) {
            domListParent.style.left = parseInt(domListParent.style.left, 10) + this.settings.offset.left + 'px';
          }
          if (this.settings.offset.top) {
            domListParent.style.top = parseInt(domListParent.style.top, 10) + this.settings.offset.top + 'px';
          }
        }

        // As chars are typed into the edit field, nothing was announced to indicate
        // that a value has been suggested, for the non-sighted user an offscreen span
        // added and will remove soon popup close that includes aria-live="polite"
        // which have the first suggested item automatically announced when it
        // appears without moving focus.
        self.list.parent('.popupmenu-wrapper').append(''+
          '<span id="ac-is-arialive" aria-live="polite" class="audible">'+
            $.trim(this.list.find('>li:first-child').text()) +
          '</span>');

        this.noSelect = true;
        this.element.trigger('listopen', [filterResult]);
      },

      closeList: function(dontClosePopup) {
        var popup = this.element.data('popupmenu');
        if (!popup) {
          return;
        }

        if (!dontClosePopup) {
          popup.close();
        }

        this.element.trigger('listclose');
        $('#autocomplete-list').parent('.popupmenu-wrapper').remove();
        $('#autocomplete-list').remove();
        this.element.removeClass('is-open');
      },

      listIsOpen: function() {
        return this.list instanceof $ && this.list.length && this.list.is(':visible');
      },

      // Handles the Autocomplete's "keydown" event
      handleAutocompleteKeydown: function(e) {
        var self = this;

        if (this.isLoading()) {
          e.preventDefault();
          return false;
        }

        if (!this.listIsOpen()) {
          return;
        }

        function getHighlighted(items) {
          return items.filter('.is-selected');
        }

        function unhighlight(item) {
          item.removeClass('is-selected is-focused');
        }

        function highlight(item) {
          item.addClass('is-selected').find('a').focus();
        }

        var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)',
          items = this.list.find(excludes),
          highlighted = getHighlighted(items);

        //Down - select next
        if (e.keyCode === 40 && this.listIsOpen()) {
          if (highlighted.length) {
            self.noSelect = true;
            unhighlight(highlighted);
            highlight( items.eq(items.index(highlighted) + 1) );
            e.preventDefault();
            e.stopPropagation();
          }
        }

        //Up select prev
        if (e.keyCode === 38 && this.listIsOpen()) {
          if (highlighted.length) {
            self.noSelect = true;
            unhighlight(highlighted);
            highlight( items.eq(items.index(highlighted) - 1) );
            e.preventDefault();
            e.stopPropagation();
          }
        }

        //Enter/Tab - apply selected item
        if ((e.keyCode === 9 || e.keyCode === 13) && this.listIsOpen()) {
          //Apply selection if an item is selected, otherwise close list and allow default tab/enter behavior to happen
          if (highlighted.length) {
            e.stopPropagation();
            e.preventDefault();
            self.noSelect = true;
            self.select(highlighted, this.currentDataSet);
          } else {
            self.closeList();
          }
        }

      },

      // Handles the Autocomplete's "input" event
      handleAutocompleteInput: function(e) {
        var self = this;

        if (self.isLoading()) {
          e.preventDefault();
          return false;
        }

        // Makes a new AJAX call every time a key is pressed.
        var waitForSource = this.getDataFromSource();
        waitForSource.done(function doneHandler(term, response) {
          self.currentDataSet = response;
          self.openList(term, response);
        });
      },

      /**
       * Check to see whether or not the currently-focused element resides within the Autocomplete's field
       * or list, and if not, fires a "safe-blur" event on the element.
       *
       * @private
       * @param {Object} e - The event object passed in from the jQuery `.on()` listener.
       */
      checkActiveElement: function() {
        var self = this;
        setTimeout( function() {
          var activeElem = document.activeElement;

          if ((self.listIsOpen() && $.contains(self.list[0], activeElem)) || self.element.is(activeElem)) {
            return;
          }

          self.element.trigger('safe-blur');
        }, 0);
      },

      getDataFromSource: function() {
        var self = this;

        // Don't attempt to load if we're already loading.
        if (self.isLoading()) {
          return false;
        }

        var field = this.element,
          dfd = $.Deferred(),
          buffer;

        clearTimeout(this.loadingTimeout);

        function done(searchTerm, response, deferredStatus) {
          self.element.triggerHandler('complete'); // For Busy Indicator
          self.element.trigger('requestend', [searchTerm, response]);

          if (deferredStatus === false) {
            return dfd.reject(searchTerm);
          }
          return dfd.resolve(searchTerm, response);
        }

        this.loadingTimeout = setTimeout(function () {
          if (self.isLoading()) {
            return;
          }

          buffer = field.val();
          if (buffer === '') {
            if (self.element.data('popupmenu')) {
              self.element.data('popupmenu').close();
            }
            return;
          }
          buffer = buffer;

          var sourceType = typeof self.settings.source;
          self.element.triggerHandler('start'); // For Busy Indicator
          self.element.trigger('requeststart', [buffer]);

          if (sourceType === 'function') {
            // Call the 'source' setting as a function with the done callback.
            self.settings.source(buffer, done, self.settings.sourceArguments);
          } else if (sourceType === 'object') {
            // Use the 'source' setting as pre-existing data.
            // Sanitize accordingly.
            var sourceData = $.isArray(self.settings.source) ? self.settings.source : [self.settings.source];
            done(buffer, sourceData, true);
          } else if (!self.settings.source) {
            dfd.reject(buffer);
            return;
          } else {

            // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
            var sourceURL = self.settings.source.toString(),
              request = $.getJSON(sourceURL + buffer);

            request.done(function(data) {
              done(buffer, data, true);
            }).fail(function() {
              done(buffer, [], false);
            });
          }

        }, self.settings.delay);

        return dfd;
      },

      // Handles the Autocomplete's "focus" event
      handleAutocompleteFocus: function() {
        var self = this;
        if (this.noSelect) {
          this.noSelect = false;
          return;
        }

        //select all text (after a delay since works better across browsers), but only if element is still focused
        //to avoid flashing cursor focus trap (since select causes focus event to fire if no longer focused)
        setTimeout(function () {
          if (self.element.is(':focus')) {
            self.element.select();
          }
        }, 10);
      },

      highlight: function(anchor, allAnchors) {
        var text = anchor.text().trim();

        if (anchor.find('.display-value').length > 0) {
          text = anchor.find('.display-value').text().trim();
        }

        if (allAnchors && allAnchors.length) {
          allAnchors.parent('li').removeClass('is-selected');
        }
        anchor.parent('li').addClass('is-selected');

        this.noSelect = true;
        this.element.val(text).focus();
      },

      select: function(anchorOrEvent, items) {
        var a, li, ret, dataIndex, dataValue,
          isEvent = false;

        // Initial Values
        if (anchorOrEvent instanceof $.Event) {
          isEvent = true;
          a = $(anchorOrEvent.currentTarget);
        } else {
          a = anchorOrEvent;
        }

        if (a.is('li')) {
          li = a;
          a = a.children('a');
        }

        li = a.parent('li');
        ret = a.text().trim();
        dataIndex = li.attr('data-index');
        dataValue = li.attr('data-value');

        this.element.attr('aria-activedescendant', li.attr('id'));

        if (items && items.length) {
          // If the data-index attr is supplied, use it to get the item (since two items could have same value)
          if (dataIndex) {
            ret = items[parseInt(dataIndex, 10)];
          } else if (dataValue) {
            // Otherwise use data-value to get the item (a custom template may not supply data-index)
            for (var i = 0, value; i < items.length; i++) {
              value = items[i].value.toString();
              if (value === dataValue) {
                ret = items[i];
              }
            }
          }
        }

        this.closeList();
        this.highlight(a);

        this.noSelect = true;
        this.element
          .trigger('selected', [a, ret])
          .focus();

        if (isEvent) {
          anchorOrEvent.preventDefault();
        }

        return false;
      },

      updated: function() {
        this.teardown().init();
        return this;
      },

      /**
      * Enable the input from readonly or disabled state.
      */
      enable: function() {
        this.element.prop('disabled', false);
      },

      /**
      * Disable the input from editing
      */
      disable: function() {
        this.element.prop('disabled', true);
      },

      teardown: function(){
        var popup = this.element.data('popupmenu');
        if (popup) {
          popup.destroy();
        }

        this.element.off('keypress.autocomplete focus.autocomplete requestend.autocomplete updated.autocomplete');
        return this;
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Autocomplete#events
       * @param {Object} listopen  &nbsp;-&nbsp; Fires when the menu is opened.
       * @param {Object} listclosed  &nbsp;-&nbsp; Fires when the menu is closed.
       * @param {Object} populated  &nbsp;-&nbsp; Fires after the menu is populated with its contents.
       * @param {Object} input  &nbsp;-&nbsp; Fires after the input is edited.
       * @param {Object} safe-blur  &nbsp;-&nbsp; Fires after the input (and menu) both loose focus
       * @param {Object} requestend  &nbsp;-&nbsp; Fires when the ajax request (source option) is completed
       * @param {Object} requeststart  &nbsp;-&nbsp; Fires when the ajax request (source option) is initiated
       */
      handleEvents: function () {
        //similar code as dropdown but close enough to be dry
        var self = this;

        this.element.off('updated.autocomplete').on('updated.autocomplete', function() {
          self.updated();
        }).off('keydown.autocomplete').on('keydown.autocomplete', function(e) {
          self.handleAutocompleteKeydown(e);
        }).off('input.autocomplete').on('input.autocomplete', function (e) {
          self.handleAutocompleteInput(e);
        }).off('focus.autocomplete').on('focus.autocomplete', function () {
          self.handleAutocompleteFocus();
        }).off('focusout.autocomplete').on('focusout.autocomplete', function () {
          self.checkActiveElement();
        });
      }

    };

    // Initialize Once
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Autocomplete(this, settings));
      } else {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      }
    });
  };


  $.fn.busyindicator = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'busyindicator',
        defaults = {
          blockUI: true,
          text: null,
          displayDelay: 1000,
          timeToComplete: 0,
          transparentOverlay: false,
          overlayOnly: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * A Busy Indicator notifies the user that the system is processing a request, and that they must wait for that request to be processed before continuing with the current task.
    *
    * @class BusyIndicator
    * @param {String} blockUI  &nbsp;-&nbsp; makes the element that Busy Indicator is invoked on unusable while it's displayed.
    * @param {String} text  &nbsp;-&nbsp; Custom Text To Show or Will Show Localized Loading....
    * @param {String} displayDelay  &nbsp;-&nbsp; umber in miliseconds to pass before the markup is displayed.  If 0, displays immediately.
    * @param {Boolean} timeToComplete  &nbsp;-&nbsp; fires the 'complete' trigger at a certain timing interval.  If 0, goes indefinitely.
    * @param {String} transparentOverlay  &nbsp;-&nbsp; If true, allows the "blockUI" setting to display an overlay that prevents interaction, but appears transparent instead of gray.
    *
    */
    function BusyIndicator(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    BusyIndicator.prototype = {

      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');

        this
          .setup()
          .handleEvents();
      },

      // Sanitize incoming option values
      setup: function() {
        var blockUI = this.element.attr('data-block-ui'),
          delay = this.element.attr('data-display-delay'),
          completionTime = this.element.attr('data-completion-time');

        this.blockUI = blockUI !== undefined ? blockUI : this.settings.blockUI;
        if (!this.settings.overlayOnly) {
          this.loadingText = this.settings.text ? this.settings.text : Locale.translate('Loading');
        }
        this.delay = delay !== undefined && !isNaN(delay) && parseInt(delay, 10) > 20 ? delay : !isNaN(this.settings.displayDelay) && this.settings.displayDelay >= 20 ? this.settings.displayDelay : 20;
        this.completionTime = completionTime !== undefined && !isNaN(completionTime) ? parseInt(completionTime, 10) : this.settings.timeToComplete;

        return this;
      },

      /**
      * Builds and starts the indicator
      */
      activate: function() {
        var self = this;

        // If the markup already exists don't do anything but clear
        if (this.container) {
          if (self.closeTimeout) {
            clearTimeout(self.closeTimeout);
          }
          this.label.remove();
          if (!this.settings.overlayOnly) {
            this.label = $('<span>' + this.loadingText + '</span>').appendTo(this.container);

            if (this.element.is('input, .dropdown, .multiselect, .busy-xs, .busy-sm')) {
              this.label.addClass('audible');
            }
          }

          this.container
            .removeClass('is-hidden')
            .trigger('afterstart');
          return;
        }

        // Build all the markup
        this.container = $('<div class="busy-indicator-container is-hidden"></div>').attr({
          'aria-live': 'polite',
          'role': 'status'
        });
        this.loader = $('<div class="busy-indicator active"></div>').appendTo(this.container);

        if (!this.settings.overlayOnly) {
          $('<div class="bar one"></div>' +
            '<div class="bar two"></div>' +
            '<div class="bar three"></div>' +
            '<div class="bar four"></div>' +
            '<div class="bar five"></div>').appendTo(this.loader);

          this.label = $('<span>'+ this.loadingText +'</span>').appendTo(this.container);
        }

        var transparency = '';

        if (this.blockUI) {
          if (this.settings.transparentOverlay) {
            transparency = ' transparent';
          }

          this.originalPositionProp = this.element[0].style.position;
          this.element[0].style.position = 'relative';
          this.overlay = $('<div class="overlay busy is-hidden'+ transparency +'"></div>').appendTo(this.element);
          this.container.addClass('blocked-ui');
        }

        if (this.label && this.element.is('.busy-xs, .busy-sm')) {
          this.label.addClass('audible');
        }

        // Append the markup to the page
        // Use special positioning logic for compatibility with certain controls
        if (this.element.is('input, .dropdown, .multiselect')) {
          this.element.addClass('is-loading');
          if (this.blockUI) {
            this.element.addClass('is-blocked');
          }
          if (this.label) {
            this.label.addClass('audible');
          }


          var target;

          if (this.element.is('input')) {
            target = this.element;
            this.container.insertAfter(this.isInlineLabel ? this.inlineLabel : this.element);
          } else {
            var dd = this.element.data('dropdown');
            target = dd.pseudoElem;
            this.container.appendTo(target.parent());
          }

          if (this.overlay) {
            this.overlay.insertAfter(this.container);
          }

          var rect = target.position(),
            h = target.outerHeight(),
            w = target.outerWidth(),
            elements = this.container.add(this.overlay),
            setCssStyle = function(el, key, value) {
              el.style[key] = value + 'px';
            };

          for (var i = 0, l = elements.length; i < l; i++) {
            setCssStyle(elements[i], 'left', rect.left);
            setCssStyle(elements[i], 'top', rect.top);
            setCssStyle(elements[i], 'bottom', rect.bottom);
            setCssStyle(elements[i], 'right', rect.right);
            setCssStyle(elements[i], 'height', h);
            setCssStyle(elements[i], 'width', w);
          }
        } else {
          // Normal Operations
          this.container.appendTo(this.element);
        }

        // Fade in shortly after adding the markup to the page (prevents the indicator from abruptly showing)
        setTimeout(function() {
          if (self.container) {
            self.container.removeClass('is-hidden');
          }
          if (self.overlay) {
            self.overlay.removeClass('is-hidden');
          }
        }, self.delay);

        // Lets external code know that we've successully kicked off.
        this.element.trigger('afterstart');

        // Start the JS Animation Loop if IE9
        if (!$.fn.cssPropSupport('animation')) {
          self.isAnimating = true;
          self.animateWithJS();
        }

        // Triggers complete if the "timeToComplete" option is set.
        if (this.completionTime > 0) {
          setTimeout(function() {
            self.element.trigger('complete');
          }, self.completionTime);
        }
      },

      /**
      * Removes the appended markup and hides any trace of the indicator
      */
      close: function(fromEvent) {
        var self = this;

        // If closed from an event, fire the necessary event triggers
        // and removes the 'is-loading' CSS class.
        if (fromEvent) {
          this.element.removeClass('is-loading');
          this.element.removeClass('is-blocked');
        }

        if (this.container) {
          this.container.addClass('is-hidden');
        }

        if (this.overlay) {
          this.overlay.addClass('is-hidden');
        }

        // Give the indicator time to fade out before removing all of its components from view
        self.closeTimeout = setTimeout(function() {
          clearTimeout(self.closeTimeout);
          if (self.container) {
            self.container.remove();
          }

          self.container = undefined;
          self.loader = undefined;
          self.label = undefined;

          if (self.overlay) {
            self.overlay.remove();
            self.element[0].style.position = self.originalPositionProp;
            self.originalPositionProp = undefined;
          }
          self.overlay = undefined;
          self.element.trigger('aftercomplete.busyindicator');
          self.element.off('complete.busyindicator');
        }, 600);
      },

      // Browsers that don't support CSS-based animation can still show the animating Busy Indicator.
      animateWithJS: function() {
        var self = this,
          bar1 = this.container.find('.bar.one'),
          bar2 = this.container.find('.bar.two'),
          bar3 = this.container.find('.bar.three'),
          bar4 = this.container.find('.bar.four'),
          bar5 = this.container.find('.bar.five'),
          t = 0,
          interval;

        // Animation Loop
        function animate() {
          if (!self.isAnimating) {
            clearInterval(interval);
            return;
          }

          t += 1;

          if (t === 1) {
            bar1.addClass('half');
          }
          if (t === 13) {
            bar1.removeClass('half').addClass('full');
            bar2.addClass('half');
          }
          if (t === 26) {
            bar1.removeClass('full').addClass('half');
            bar2.removeClass('half').addClass('full');
            bar3.addClass('half');
          }
          if (t === 39) {
            bar1.removeClass('half');
            bar2.removeClass('full').addClass('half');
            bar3.removeClass('half').addClass('full');
            bar4.addClass('half');
          }
          if (t === 51) {
            bar2.removeClass('half');
            bar3.removeClass('full').addClass('half');
            bar4.removeClass('half').addClass('full');
            bar5.addClass('half');
          }
          if (t === 64) {
            bar3.removeClass('half');
            bar4.removeClass('full').addClass('half');
            bar5.removeClass('half').addClass('full');
          }
          if (t === 77) {
            bar4.removeClass('half');
            bar5.removeClass('full').addClass('half');
          }
          if (t === 90) {
            bar5.removeClass('half');
          }

          if (t === 103) {
            t = 0;
          }
        }

        setInterval(animate, 10);
      },

      updated: function() {
        return this.setup();
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.element.off('start.busyindicator complete.busyindicator afterstart.busyindicator aftercomplete.busyindicator updated.busyindicator');
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component listens to the following events.
       *
       * @fires Busyindicator#events
       * @param {Object} start  &nbsp;-&nbsp; Starts / shows the indictor.
       * @param {Object} complete  &nbsp;-&nbsp; Hides / Ends the indictaor
       * @param {Object} updated  &nbsp;-&nbsp; Sync the UI/Settings. Fx chnaging the text in the DOM.
       *
       */
      handleEvents: function() {
        var self = this;
        self.element.on('start.busyindicator', function(e) {
          e.stopPropagation();
          self.activate();
        }).on('afterstart.busyindicator', function() {
          // Complete event is only active once the indicator is "started"
          self.element.on('complete.busyindicator', function(e) {
            e.stopPropagation();
            self.close(true);
          });
        }).on('updated.busyindicator', function() {
          self.close(true);
          self.updated();
        });

        return this;
      },

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new BusyIndicator(this, settings));
      }
    });
  };


  $.fn.button = function(options) {
    'use strict';

    /**
    * Clickable Button Elements.
    *
    * @class Button
    *
    * @param {String} toggleOnIcon  &nbsp;-&nbsp; The icon to use for on state on toggle buttons
    * @param {String} toggleOffIcon  &nbsp;-&nbsp; The icon to use for off state on toggle buttons
    * @param {String} replaceText  &nbsp;-&nbsp; If true the selection will be used to replace the content in the button.
    *
    */
    var pluginName = 'button',
      defaults = {
        toggleOnIcon: null,
        toggleOffIcon: null,
        replaceText: false
      },
      settings = $.extend({}, defaults, options);

    function Button(element) {
      this.element = $(element);
      this.settings = $.extend({}, settings);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Button.prototype = {
      init: function() {
        var self = this;

        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isSafari = $('html').is('.is-safari');
        this.isFirefox = $('html').is('.is-firefox');

        if (this.element.hasClass('no-ripple')) {
          return;
        }

        if (this.element.hasClass('btn-menu') && !this.element.hasClass('btn-icon') && !this.element.hasClass('btn-actions')) {
          var ddIcon = this.element.children('svg.icon'),
              use = ddIcon.find('use'), hasIcon = false;

          if (ddIcon.length > 0 && use.length === 1) {
            hasIcon = use.attr('xlink:href').indexOf('#icon-dropdown') > -1;
          }

          if (!hasIcon) {
            ddIcon = $.createIconElement({ icon: 'dropdown', classes: ['icon-dropdown']});
            this.element.append(ddIcon);
          }

          if (!ddIcon.hasClass('icon-dropdown')) {
            ddIcon.addClass('icon-dropdown');
          }

          if (this.settings.replaceText) {
            this.element.on('selected.content', function (e, a) {
              $(this).find('span').text(a.text());
            });
          }
        }

        if (this.element.hasClass('btn-toggle') || this.element.hasClass('icon-favorite')) {
          this.element.on('click.favorite', function() {
            var elem = $(this),
              svg = elem.find('svg:not(.ripple-effect)'),
              isPressed = elem.attr('aria-pressed') === 'true';

            elem.attr('aria-pressed', isPressed ? 'false' : 'true');
            if (self.settings.toggleOffIcon && self.settings.toggleOnIcon) {
              svg.changeIcon(isPressed ? self.settings.toggleOffIcon : self.settings.toggleOnIcon);
            } else {
              elem.toggleClass('is-pressed');
            }

            if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle') && svg.find('use').attr('xlink:href') === '#icon-star-filled') {
              svg.changeIcon('star-outlined');
            } else if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle')) {
              svg.changeIcon('star-filled');
            }

          });

          if (!this.element.attr('aria-pressed')) {
            this.element.attr('aria-pressed', 'false');
          }

        }

        if (!this.element.parent().is('.field') && this.element.hasClass('btn-actions') && !this.element.data('tooltip')) {
          this.element.attr('title', Locale.translate('More')).tooltip({
            content: Locale.translate('More')
          });
        }

        this.element.hideFocus();

        this.element
        .on('touchstart.button click.button', function (e) {

          if ((self.element.attr('disabled')) || self.element.is('.is-disabled') || (!self.isTouch && e.which !== 1) ||
              ($('.ripple-effect', this).length) || (self.isTouch && e.type !== 'touchstart')) {
            return;
          }

          var element = $(this),
            btnOffset = element.offset(),
            xPos = e.pageX - btnOffset.left,
            yPos = e.pageY - btnOffset.top,
            ripple = $('<svg class="ripple-effect" focusable="false" aria-hidden="true" role="presentation"><circle r="0" class="ripple-circle"></circle></svg>');


          if (self.isTouch) {
            // Make sure the user is using only one finger and then get the touch position relative to the ripple wrapper
            e = e.originalEvent;
            if (e && e.touches && e.touches.length === 1) {
              xPos = e.touches[0].pageX - btnOffset.left;
              yPos = e.touches[0].pageY - btnOffset.top;
            }
          }

          // Using keyboard to click
          xPos = (xPos < 0) ? self.element.outerWidth()/2 : xPos;
          yPos = (yPos < 0) ? self.element.outerHeight()/2 : yPos;

          $('svg.ripple-effect', element).remove();
          ripple[0].style.left = xPos + 'px';
          ripple[0].style.top = yPos + 'px';
          element.prepend(ripple);

          // Start the JS Animation Loop if IE9
          // Or Safari/Firefox has bug with combination like: animation, overflow, position, border-radius etc.)
          if (!$.fn.cssPropSupport('animation') || self.isSafari || self.isFirefox) {
            ripple.removeClass('is-animation');
            self.animateWithJS(ripple);
          } else {
            var elem = $('svg.ripple-effect', element);
            elem.addClass('is-animation');
          }

          setTimeout(function() {
            ripple.remove();
          }, 1000);

        });
      },

      // Browsers that don't support CSS-based animation can still show the animation
      animateWithJS: function(el) {
        var scale = 200,
        elStyle = el[0].style,
        xPos = (parseFloat(elStyle.left) - (scale / 2)) + 'px',
        yPos = (parseFloat(elStyle.top)  - (scale / 2)) + 'px';

        el[0].style.opacity = '0.4';
        el.animate({
          opacity: 0,
          left: xPos,
          top: yPos,
          width: scale,
          height: scale
        }, 1000);
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.element.off('click.button touchstart.button focusin.hide-focus focusout.hide-focus mousedown.hide-focus touchstart.hide-focus');

        var moreTooltip = this.element.data('tooltip');
        if (this.element.hasClass('btn-actions') && moreTooltip) {
          moreTooltip.destroy();
        }

        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Autocomplete#events
       * @param {Object} click  &nbsp;-&nbsp; Fires when the button is clicked (if enabled).
       * @param {Object} focus  &nbsp;-&nbsp; Fires when the menu is focused.
       */
      handleEvents: function () {
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Button(this));
      }
    });
  };

/**
* @constructor
*/

window.Chart = function(container) {
  'use strict';

  var charts = this;
  this.container = $(container);

  //IE8 and Below Message
  if (typeof d3 === 'undefined') {
    $(container).append('<p class="chart-message"></p>');
    return null;
  }

  var colorRange = ['#1D5F8A', '#8ED1C6', '#9279A6', '#5C5C5C', '#F2BC41', '#66A140', '#AD4242',
   '#8DC9E6', '#EFA836', '#317C73', '#EB9D9D', '#999999', '#488421', '#C7B4DB',
   '#54A1D3', '#6e5282', '#AFDC91', '#69ADA3', '#DB7726', '#D8D8D8'];

  this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  this.pieColors = d3.scale.ordinal().range(colorRange);
  this.colorRange = colorRange;
  this.greyColors = d3.scale.ordinal().range(['#737373', '#999999', '#bdbdbd', '#d8d8d8']);
  this.sparklineColors = d3.scale.ordinal().range(['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8']);
  this.colors = d3.scale.ordinal().range(colorRange);

  this.chartColor = function(i, chartType, data) {
    var specColor = (data && data.color ? data.color : null);

    //error, alert, alertYellow, good, neutral or hex
    if (specColor) {
      if (specColor ==='error' ) {
        return '#e84f4f';
      }
      if (specColor ==='alert' ) {
        return '#ff9426';
      }
      if (specColor ==='alertYellow' ) {
        return '#ffd726';
      }
      if (specColor ==='good' ) {
        return '#80ce4d';
      }
      if (specColor ==='neutral' ) {
        return '#bdbdbd';
      }
      if (specColor && specColor.indexOf('#') === 0) {
        return data.color;
      }
    }

    if (chartType === 'pie' || chartType === 'donut') {
      return this.colorRange[i];
    }
    if (chartType === 'bar-single' || chartType === 'column-single') {
      return '#1D5F8A';
    }
    if (chartType === 'bar' || chartType === 'line') {
      return this.colors(i);
    }
  };

  // Help Function to Select from legend click
  this.selectElem = function (line, series) {
    var idx = $(line).index(),
      elem = series[idx],
      s = charts.settings,
      selector;

    if (s.chartType === 'Pie') {
      selector = d3.select(s.svg.selectAll('.arc')[0][idx]);
    }
    else if (s.type === 'column-positive-negative') {
      if (!elem.option || (elem.option && elem.option === 'target')) {
        return;
      }
      selector = s.svg.select('.bar.'+ elem.option);
    }
    else if (['Column', 'HorizontalBar'].indexOf(s.chartType) !== -1) {
      // Grouped or singlular
      if (s.isGrouped || s.isSingular) {
        selector = s.svg.select('.series-'+ idx);
      }
      // Stacked
      else if (s.isStacked && !s.isSingular) {
        var thisGroup = d3.select(s.svg.selectAll(s.chartType==='HorizontalBar' ? '.series-group' : '.g')[0][idx]);
        selector = thisGroup.select('.bar');
      }
    }

    if (['Pie', 'Column', 'HorizontalBar'].indexOf(s.chartType) !== -1) {
      s.isByLegends = true;
      selector.on('click').call(selector.node(), selector.datum(), idx);
    }

    if (elem.selectionObj) {
      charts.selectElement(d3.select(elem.selectionObj[0][idx]), elem.selectionInverse, elem.data);
    }
  };

  this.addLegend = function(series, chartType) {
    var i, s = charts.settings;

    if (series.length === 0) {
      return;
    }
    var isTwoColumn = series[0].display && series[0].display === 'twocolumn',
      legend = isTwoColumn ? $('<div class="chart-legend" style="margin: 2em auto auto; border-top: 1px solid #ccc;  padding-bottom: 1em; padding-top: 1em;"></div>') : $('<div class="chart-legend"></div>');

    // Legend width
    var width = 0,
      currentWidth,
      widthPercent;

    for (i = 0; i < series.length; i++) {
      currentWidth = series[i].name.length * 6;
      width = (series[i].name && currentWidth > width) ? currentWidth : width;
    }

    width += 55;
    widthPercent = width / $(container).width() * 100;

    for (i = 0; i < series.length; i++) {
      if (!series[i].name) {
        continue;
      }

      var extraClass = '';
      if (isTwoColumn || (series[i].display && series[i].display === 'block')) {
        extraClass += ' lg';
      }
      if (s.type === 'column-positive-negative' && series[i].option) {
        extraClass += ' '+ series[i].option;
      }

      var seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0"></span>',
        hexColor = charts.chartColor(i, chartType ? chartType : (series.length === 1 ? 'bar-single' : 'bar'), series[i]);

      var color = $('<span class="chart-legend-color" style="background-color: '+ (series[i].pattern ? 'transparent' : hexColor) +'"></span>'),
        textBlock = $('<span class="chart-legend-item-text">'+ series[i].name + '</span>');

      if (series[i].pattern) {
        color.append('<svg width="12" height="12"><rect style="fill: '+ hexColor +'" mask="url(#'+ series[i].pattern +')" height="12" width="12" /></svg>');
      }

      if (series[i].percent) {
        var pct = $('<span class="chart-legend-percent"></span>').text(series[i].percent);
        textBlock.append(pct);
      }

      if (series[i].display && series[i].display==='block') {
        seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: block; margin: 0 auto; width: '+ width +'px;"></span>';
      }

      if (isTwoColumn) {
        if(widthPercent > 45) {
          seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: block; margin: 0 auto; width: '+ width +'px;"></span>';
        } else {
          seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: inline-block; width: 45%;"></span>';
        }
      }
      seriesLine = $(seriesLine);
      seriesLine.append(color, textBlock);
      legend.append(seriesLine);
    }

    if (legend instanceof $) {
      legend.on('click.chart', '.chart-legend-item', function () {
          charts.selectElem(this, series);
        }).on('keypress.chart', '.chart-legend-item', function (e) {
          if (e.which === 13 || e.which === 32) {
            charts.selectElem(this, series);
          }
        });

      $(container).append(legend);
    }
  };

  this.renderLegend = function() {
    if (charts.legendformatter && typeof charts.legendformatter === 'function') {
      var markup = '';
      var runInterval = true,
      legendInterval = setInterval(function () {
        if(runInterval) {
          runInterval = false;
          charts.legendformatter(function (data) {
            markup = data;
          });
        }
        if(markup !== '') {
          clearInterval(legendInterval);
          $(container).append(markup);
        }
      }, 10);
    }
  };

  //Add Toolbar to the page
  this.appendTooltip = function() {
    this.tooltip = $('#svg-tooltip');
    if (this.tooltip.length === 0) {
      this.tooltip = $('<div id="svg-tooltip" class="tooltip right is-hidden"><div class="arrow"></div><div class="tooltip-content"><p><b>32</b> Element</p></div></div>').appendTo('body');
      if (this.isTouch) {
        this.tooltip[0].style.pointerEvents = 'auto';
        this.tooltip.on('touchend.svgtooltip', function () {
          charts.hideTooltip();
        });
      }
    }
  };

  this.triggerContextMenu = function(elem, d) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
    d3.event.stopImmediatePropagation();

    var e = $.Event('contextmenu');
    e.target = elem;
    e.pageX = d3.event.pageX;
    e.pageY = d3.event.pageY;
    $(container).trigger(e, [elem, d]);
  };

  //Show Tooltip
  this.showTooltip = function(x, y, content, arrow) {
    var self = this;

    //Simple Collision of left side
    if (x < 0) {
      x = 2;
    }

    this.tooltip[0].style.left = x + 'px';
    this.tooltip[0].style.top = y + 'px';
    this.tooltip.find('.tooltip-content').html(content);

    this.tooltip.removeClass('bottom top left right').addClass(arrow);
    this.tooltip.removeClass('is-hidden');

    // Hide the tooltip when the page scrolls.
    $('body').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function() {
      self.hideTooltip();
    });

    $('.scrollable').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function() {
      self.hideTooltip();
    });
  };

  this.getTooltipSize = function(content) {
    this.tooltip.find('.tooltip-content').html(content);
    return {height: this.tooltip.outerHeight(), width: this.tooltip.outerWidth()};
  };

  //Hide Tooltip
  this.hideTooltip = function() {
    var self = this;

    d3.select('#svg-tooltip').classed('is-hidden', true).style('left', '-999px');

    // Remove scroll events
    $('body, .scrollable').off('scroll.chart-tooltip', function() {
      self.hideTooltip();
    });
  };

  //Format Currency
  this.formatCurrency = function(num) {
    var symbol = (Locale.currentLocale.data ? Locale.currentLocale.data.currencySign : '$');
    num = (isNaN(num * 1)) ? 0 : num;
    return symbol + (num * 1).toFixed(2);
  };

  this.HorizontalBar = function(chartData, isNormalized, isStacked) {
    //Original http://jsfiddle.net/datashaman/rBfy5/2/

    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    var dataset, maxTextWidth, width, height, series, rects, svg, stack, xMin, xMax,
        xScale, yScale, yAxis, yMap, xAxis, groups, isGrouped, isSingle, legendMap,
        gindex, totalBarsInGroup, totalGroupArea, totalHeight, gap, barHeight;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    var maxBarHeight = 30,
      legendHeight = 40,
      gapBetweenGroups = 0.5; // As of one bar height (barHeight * 0.5)

    isStacked = isStacked === undefined ? true : isStacked;

    var isViewSmall = $(container).parent().width() < 450;

    var margins = {
      top: isStacked ? 30 : 20,
      left: 30,
      right: 30,
      bottom: 30 // 30px plus size of the bottom axis (20)
    };

    dataset = chartData;
    $(container).addClass('chart-vertical-bar');

    width =  parseInt($(container).parent().width()) - margins.left - margins.right;
    height =  parseInt($(container).parent().height()) - margins.top - margins.bottom - legendHeight;  //influences the bar width

    //Get the Legend Series'
    series = dataset.map(function (d) {
      return {name: d.name, color: d.color, pattern: d.pattern};
    });

    //Map the Data Sets and Stack them.
    dataset = dataset.map(function (d) {
      return d.data.map(function (o) {
        return $.extend({}, o, {
            y: o.value,
            x: o.name,
            color: o.color,
            pattern: o.pattern
        });
      });
    });
    stack = d3.layout.stack();
    stack(dataset);

    //Calculate max text width
    maxTextWidth = 0;
    dataset = dataset.map(function (group, i) {
      if (!isStacked) {
        if (series[i]) {
          maxTextWidth = (series[i].name.length > maxTextWidth ? series[i].name.length : maxTextWidth);
        }
      }
      return group.map(function (d) {
        if(isStacked) {
          maxTextWidth = (d.x.length > maxTextWidth ? d.x.length : maxTextWidth);
        }

        // Invert the x and y values, and y0 becomes x0
        return $.extend({}, d, {
            x: d.y,
            y: d.x,
            x0: d.y0,
            color: d.color,
            pattern: d.pattern
        });

      });
    });

    var h = parseInt($(container).parent().height()) - margins.bottom - (isStacked ? 0 : (legendHeight / 2)),
      w = parseInt($(container).parent().width()) - margins.left,
      textWidth = margins.left + (maxTextWidth * 6);

    svg = d3.select(container)
      .append('svg')
      .attr('width',  w)
      .attr('height', h)
      .append('g')
      .attr('class', 'group')
      .attr('transform', 'translate(' + (textWidth) + ',' + margins.top + ')');

    xMin = d3.min(dataset, function (group) {
      return d3.min(group, function (d) {
          return isStacked ? (d.x + d.x0) : d.x;
      });
    });

    xMax = d3.max(dataset, function (group) {
      return d3.max(group, function (d) {
          return isStacked ? (d.x + d.x0) : d.x;
      });
    });

    if (isStacked && isNormalized) {
      var gMax = [];
      //get the max for each array group
      dataset.forEach(function(d) {
        d.forEach(function(d, i) {
        gMax[i] = (gMax[i] === undefined ? 0 : gMax[i]) + d.x;
       });
      });

      //Normalize Each Group
      dataset.forEach(function(d) {
        d.forEach(function(d, i) {
          var xDif = gMax[i]/100;
          d.x = d.x / xDif;
          d.x0 = d.x0 / xDif;
       });
      });
      xMax = 100;
    }

    //Width of the bar minus the margin
    var barWith = w - textWidth - margins.left;

    if (settings.useLogScale) {
      xScale = d3.scale.log()
        .domain([(xMin > 0 ? xMin : 1), xMax])
        .nice()
        .range([1, barWith]).nice();

    } else {
      xScale = d3.scale.linear()
        .domain([(xMin < 0 ? xMin : 0), xMax])
        .nice()
        .range([0, barWith]).nice();
    }

    if (isStacked) {
      yMap = dataset[0].map(function (d) {
        return d.y;
      });

      barHeight = 0.32;
    } else {
      yMap = series.map(function (d) {
        return d.name;
      });

      (function() {
        var i, l, lm;
        // Loop backwards to catch and override with found first custom info from top
        for (i = dataset.length-1,l = -1; i > l; i--) {
          lm = dataset[i].map(function (d) {
            return d;
          });
          $.extend(true, legendMap, lm);
          // Convert back to array from object
          legendMap = $.map(legendMap, function(d) {
            return d;
          });
        }
      })();

      gindex = 0;
      totalBarsInGroup = legendMap.length;
      totalGroupArea = height / yMap.length;
      barHeight = totalGroupArea / totalBarsInGroup;
      totalHeight = totalBarsInGroup > 1 ?
        totalGroupArea - (barHeight * gapBetweenGroups) : maxBarHeight;
      gap = totalGroupArea - totalHeight;
      maxBarHeight = totalHeight / totalBarsInGroup;
      barHeight = 0;
    }

    yScale = d3.scale.ordinal()
      .domain(yMap)
      .rangeRoundBands([0, height], barHeight, barHeight);

    xAxis = d3.svg.axis()
      .scale(xScale)
      .tickSize(-height)
      .orient('middle');

    if (isViewSmall) {
      xAxis.ticks(textWidth < 100 ? 5 : 3);
    }

    if (isStacked && isNormalized) {
      xAxis.tickFormat(function(d) { return d + '%'; });
    }

    if (settings.useLogScale) {
      xAxis.ticks(10, ',.1s');

      if (settings.showLines === false) {
        xAxis.tickSize(0);
      }
    }

    if (settings.ticks) {
      xAxis.ticks(settings.ticks.number, settings.ticks.format);
    }

    yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(0)
      .orient('left');

    svg.append('g')
      .attr('class', 'axis x')
      .attr('transform', 'translate(0,' + height + ')')
      .call(xAxis);

    svg.append('g')
      .attr('class', 'axis y')
      .call(yAxis);

    groups = svg.selectAll('g.group')
      .data(dataset)
      .enter()
      .append('g')
      .attr('class', 'series-group')
      .attr('data-group-id', function (d, i) {
        return i;
      });

    isGrouped = (svg.selectAll('.series-group')[0].length > 1 && !isStacked);
    isSingle = (svg.selectAll('.series-group')[0].length === 1 && isStacked);

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'HorizontalBar',
      isSingle: isSingle,
      isGrouped: isGrouped,
      isStacked: isStacked
    });

    rects = groups.selectAll('rect')
      .data(function (d, i) {
        d.forEach(function(d) {
          d.index = i;

          if(!isStacked) {
            d.gindex = gindex++;
          }

        });
        return d;
    })
    .enter()
    .append('rect')
    .attr('class', function(d, i) {
      return 'bar series-'+ i;
    })
    .style('fill', function(d, i) {
      return isStacked ?
        (series.length === 1 ? (charts.chartColor(i, 'bar-single', d)) :
          (charts.chartColor(d.index, 'bar', series[d.index]))) :
        (charts.chartColor(i, 'bar', legendMap[i]));
    })
    .attr('mask', function (d, i) {
      if (dataset.length === 1 && dataset[0][i].pattern) {
        return 'url(#'+ dataset[0][i].pattern +')';
      }
      else if (isStacked && series[d.index].pattern) {
        return 'url(#'+ series[d.index].pattern +')';
      }
      else if (!isStacked && legendMap[i].pattern) {
        return 'url(#'+ legendMap[i].pattern +')';
      }
    })
    .attr('x', function (d) {
      if (settings.useLogScale) {
        return 0;
      }
      return (isStacked && !isSingle) ? xScale(d.x0) : xScale(0);
    })
    .attr('y', function (d) {
      return isStacked ? yScale(d.y) :
        ((((totalGroupArea - totalHeight) / 2) + (d.gindex * maxBarHeight)) + (d.index * gap));
    })
    .attr('height', function () {
      return isStacked ? (yScale.rangeBand()) : maxBarHeight;
    })
    .attr('width', 0) //Animated in later
    .on('mouseenter', function (d, i) {
      var j, l, hexColor,
        total = 0,
        totals = [],
        content = '',
        data = d3.select(this.parentNode).datum(),
        mid = Math.round(data.length/2),
        shape = d3.select(this),
        setPattern = function(pattern, hexColor) {
          return !pattern || !hexColor ? '' :
            '<svg width="12" height="12">'+
              '<rect style="fill: '+ hexColor +'" mask="url(#'+ pattern +')" height="12" width="12" />'+
            '</svg>';
        },

        show = function(xPosS, yPosS, isTooltipBottom) {
          var size = charts.getTooltipSize(content),
            x = xPosS+(parseFloat(shape.attr('width'))/2)-(size.width/2),
            y = isTooltipBottom ? yPosS : (yPosS-size.height-13);

          if(content !== '') {
            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        };

       if (dataset.length === 1) {
          content = '<p><b>'+ d.y +' </b>'+ d.x +'</p>';
        }
        else {
          content = '<div class="chart-swatch">';

          if (isStacked) {
            for (j=0,l=dataset.length; j<l; j++) {
              total = 0;
              hexColor = charts.chartColor(j, 'bar', series[j]);
              for (var k=0,kl=dataset.length; k<kl; k++) {
                total += dataset[k][i].x;
                totals[k] = dataset[k][i].x;
              }
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (series[j].pattern ? 'transparent' : hexColor) +';">'+
                    setPattern(series[j].pattern, hexColor)+
                  '</div>'+
                  '<span>'+ series[j].name +'</span><b> '+ (isFormatter ? format(totals[j]) : (Math.round((totals[j]/total)*100)+'%')) +' </b>'+
                '</div>';
            }

          }
          else {
            if(mid > 1) {
              shape = d3.select(this.parentNode).select('.series-' + mid);
            }
            for (j=0,l=data.length; j<l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (legendMap[j].pattern ? 'transparent' : hexColor) +';">'+
                    setPattern(legendMap[j].pattern, hexColor)+
                  '</div>'+
                  '<span>'+ data[j].name +'</span><b>'+ format(data[j].value) +'</b>'+
                '</div>';
            }
          }
          content += '</div>';
        }

        if (total > 0) {
          content = '<span class="chart-tooltip-total"><b>' + total + '</b> '+Locale.translate('Total')+'</span>' +content;
        }

        var yPosS = shape[0][0].getBoundingClientRect().top + $(window).scrollTop(),
            xPosS = shape[0][0].getBoundingClientRect().left + $(window).scrollLeft();

        var maxBarsForTopTooltip = 6,
          isTooltipBottom = (!isStacked && (data.length > maxBarsForTopTooltip));

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function() {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCache[i] = data;
                });
              }
              if (content !== '') {
                clearInterval(tooltipInterval);
                show(xPosS, yPosS, isTooltipBottom);
              }
            }, 10);
          } else {
            content = tooltipDataCache[i] || tooltipData || d.tooltip || content || '';
            show(xPosS, yPosS, isTooltipBottom);
          }
    })
    .on('mouseleave', function () {
      clearInterval(tooltipInterval);
      charts.hideTooltip();
    })
    .on('click', function (d, i) {
      var isSelected = this && d3.select(this).classed('is-selected'),
        thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

      charts.setSelectedElement({
        task: (isSelected ? 'unselected' : 'selected'),
        container: container,
        selector: this,
        isTrigger: !isSelected,
        triggerGroup: isGrouped,
        d: d,
        i: i
      });

      if (isSelected) {
        $(container).triggerHandler('selected', [d3.select(this)[0], {}, (isGrouped ? thisGroupId : i)]);
      }
      return;
    });

    //Adjust the labels
    svg.selectAll('.axis.y text').attr({'x': charts.isRTL ? 15 : -15});
    svg.selectAll('.axis.x text').attr('class', function(d) {
      return d < 0 ? 'negative-value' : 'positive-value';
    });

    if (charts.isRTL && charts.isIE) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');
    }

    if (isViewSmall && settings.useLogScale) {
      var ticks = d3.selectAll('.x .tick text'),
        foundMid = false;

      //At small breakpoint hide the last ones
      ticks.attr('class', function(d, i){
          var middleTick = Math.round(ticks.size()/2);

          if (i >= middleTick && !foundMid && d.toString().startsWith('1')) {
            foundMid =  true;
            middleTick = d;
          }

          if (i !==0 && i !== ticks.size() -1 && (settings.useLogScale ? d !== middleTick : i !== middleTick )) {
            d3.select(this).remove();
          }
      });
    }

    // Set x-axix tick css class
    svg.selectAll('.x.axis .tick').attr('class', function(d) {
      return 'tick' + (d === 0 ? ' tick0' : '');
    });

    //Animate the Bars In
    svg.selectAll('.bar')
      .transition().duration(charts.animate ? 1000 : 0)
      .attr('width', function (d) {
        var scale = xScale(d.x),
          scale0 = xScale(0);

        if (isNaN(scale)) {
          scale = 0;
        }

        if (isNaN(scale0)) {
          scale0 = 0;
        }

        return Math.abs(scale - scale0);
      })
      .attr('x', function (d) {
        if (settings.useLogScale) {
          return 0;
        }
        return (isStacked && !isSingle) ? xScale(d.x0) : (d.x < 0 ? xScale(d.x) : xScale(0));
      });

    //Add Legends
    if (charts.showLegend) {
      charts.addLegend(isStacked ? series : legendMap);
    }
    charts.appendTooltip();

    charts.setSelected = function (o, isToggle) {
      if (!o) {
        return;
      }
      var selected = 0,
        equals = window.Soho.utils.equals,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup, xGroup,

        setSelectedBar = function (g) {
          var isGroup = !!g;
          g = isGroup ? d3.select(g) : svg;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if (selected < 1) {
              if ((typeof o.fieldName !== 'undefined' &&
                    typeof o.fieldValue !== 'undefined' &&
                      o.fieldValue === d[o.fieldName]) ||
                  (typeof o.index !== 'undefined' && o.index === i) ||
                  (o.data && equals(o.data, chartData[d.index].data[i])) ||
                  (o.elem && $(this).is(o.elem))) {
                selected++;
                selector = d3.select(this);
                barIndex = i;
                if (isGroup && !isStacked) {
                  isStackedGroup = true;
                }
              }
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function() {
              setSelectedBar(this);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingle)) {
        chartData.forEach(function(d, i) {
          if (selected < 1) {
            xGroup = $(svg.select('[data-group-id="'+ i +'"]').node());
            if ((typeof o.groupName !== 'undefined' &&
                  typeof o.groupValue !== 'undefined' &&
                    o.groupValue === d[o.groupName]) ||
                (typeof o.groupIndex !== 'undefined' && o.groupIndex === i) ||
                (o.data && equals(o.data, d)) ||
                (o.elem && (xGroup.is(o.elem)))) {

              if (typeof o.fieldName === 'undefined' &&
                    typeof o.fieldValue === 'undefined' &&
                      typeof o.index === 'undefined') {
                selected++;
                selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
                barIndex = i;
                if (isStacked && !isGrouped) {
                  isStackedGroup = true;
                }
              }
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

    };

    // Set initial selected
    (function () {
      var selected = 0,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup,

        setSelectedBar = function (g) {
          g = g ? d3.select(g) : svg;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if (d.selected && selected < 1) {
              selected++;
              selector = d3.select(this);
              barIndex = i;
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function() {
              setSelectedBar(this);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingle)) {
        chartData.forEach(function(d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
            barIndex = i;
            if (isStacked && !isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

    })();

    $(container).trigger('rendered');
    return $(container);
  };


  this.Pie = function(initialData, isDonut, options) {
    var defaults = {
      labels: {
        // true|false
        hideLabels: true,
        isTwoline: true,

        // 'name'|'value'|'percentage'|'name, value'|'name (value)'|'name (percentage)'
        contentsTop: 'percentage',
        contentsBottom: 'name',

        // Use d3 Format
        // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
        // [null | formatter string] - Only value will be formated
        formatterTop: null,
        formatterBottom: null,

        // 'default'|'color-as-arc'|'#000000'|'black'
        colorTop: 'color-as-arc',
        colorBottom: 'default',
        lineColor: 'default',
        lineWidth: 2,
        linehideWhenMoreThanPercentage: 10
      }
    },
    settings = $.extend(true, defaults, options),
    lb = settings.labels;

    if (!lb.isTwoline && options && !options.labels.colorTop) {
      lb.colorTop = lb.colorBottom;
    }

    var self = this,
      parent = $(container).parent(),
      isRTL = charts.isRTL;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    charts.appendTooltip();
    charts.hideTooltip();

    var showLegend = charts.showLegend || false;

    var chartData = initialData[0].data;
    chartData = chartData.sort(function(a, b) {
      return isRTL ? +b.value - +a.value : +a.value - +b.value;
    });

    var total = d3.sum(chartData, function(d) { return d.value; });

    chartData = chartData.map(function (d) {
      return { data: d, elm: d, name: d.name, color: d.color, value: d.value, percent: d3.round(100*(d.value/total)) };
    });

    if (total === 0) {
      // Handle zero based pies
      chartData.push({data: {}, color: '#BDBDBD', name: 'Empty-Pie', value: 100, percent: 100});
    }

    var svg = d3.select(container).append('svg'),
      arcs = svg.append('g').attr('class','arcs'),
      lines = svg.append('g').attr('class','lines'),
      centerLabel = initialData[0].centerLabel;

    $(container).addClass('chart-pie');

    var pie = d3.layout.pie().value(function (d) {
      return d.value;
    }).sort(null);

    // Store our chart dimensions
    var dims = {
      height: parseInt(parent.height()),  //header + 20 px padding
      width: parseInt(parent.width()),
      widgetheight: 318
    };
    var isSmall = (dims.width < 405);
    dims.height = dims.height > dims.widgetheight ? dims.widgetheight : dims.height;
    dims.height = isSmall && !lb.hideLabels ? dims.width : dims.height;

    var donutWidth = 30;

    dims.outerRadius = ((Math.min(dims.width, dims.height) / 2) - 40);
    dims.innerRadius = isDonut ? dims.outerRadius - (donutWidth + 5) : 0;
    dims.labelRadius = dims.outerRadius + (donutWidth - 10);
    dims.center = { x: (dims.width / 2) + 7, y: dims.height / 2 };

    svg.attr({
      'width': '100%',
      'height': ((isSmall && !lb.hideLabels) || dims.height === dims.widgetheight) ? dims.height - 50 : '100%',
      'viewBox': '0 0 ' + dims.width + ' ' + dims.height
    });

    // move the origin of the group's coordinate space to the center of the SVG element
    arcs.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y  + ')');
    lines.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y + ')');

    var pieData = pie(chartData);

    // calculate the path information for each wedge
    var pieArcs = d3.svg.arc()
        .innerRadius(dims.innerRadius)
        .outerRadius(dims.outerRadius);

    var pieCircles = d3.svg.arc()
        .innerRadius(dims.outerRadius)
        .outerRadius(dims.outerRadius);

    var pieLabelCircles = d3.svg.arc()
        .innerRadius(dims.labelRadius)
        .outerRadius(dims.labelRadius);

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'Pie'
    });

    // Draw the arcs.
    var enteringArcs = arcs.selectAll('.arc').data(pieData).enter();
    enteringArcs.append('path')
      .attr('class', 'arc')
      .on('contextmenu',function (d) {
        self.triggerContextMenu(d3.select(this).select('path')[0][0], d);
      })
      .on('click', function (d, i) {
        var isSelected = this && d3.select(this).classed('is-selected');

        if (isSelected) {
          // Make unselected
          charts.setSelectedElement({
            task: 'unselected',
            container: container,
            selector: '.chart-container .is-selected',
            isTrigger: false,
            d: d.data,
            i: i
          });
          $(container).triggerHandler('selected', [d3.select(this)[0], {}, i]);
        }
        else {
          // Make selected
          charts.setSelectedElement({
            task: 'selected',
            container: container,
            selector: this,
            isTrigger: true,
            d: d.data,
            i: i
          });
        }
      })
      .on('mouseenter', function(d, i) {
        var size, x, y, t, tx, ty,
          offset = parent.offset(),
          content = '',
          show = function() {
            size = charts.getTooltipSize(content);
            x -= size.width/2;
            y -= size.height/2;

            if (content !== '') {
              charts.showTooltip(x, y, content, 'top');
            }
          };

        var circles = svg.selectAll('.pie-circle');
        t = d3.transform(d3.select(circles[0][i]).attr('transform'));
        tx = t.translate[0] + (t.translate[0] > 0 ? 10 * -1: 10 * 1);
        ty = t.translate[1] + (t.translate[1] > 0 ? 10 * -1: 10 * 1);

        //Adjustments
        ty += (t.translate[0] > 0 && t.translate[1] > 0 ? -32 : 0);
        tx += (t.translate[1] > 0 && t.translate[0] < 0 ? 17 : 0);
        ty += (t.translate[1] < 0 && t.translate[0] < 0 ? -17 : 0);
        ty += (t.translate[0] < 0 && t.translate[1] > 0 ? -24 : 0);

        x = tx + offset.left + dims.center.x;
        y = ty + offset.top + dims.center.y;

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          var runInterval = true;
          tooltipInterval = setInterval(function() {
            if(runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = tooltipDataCache[i] = data;
              });
            }
            if(content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {
          tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
          content = tooltipDataCache[i] || tooltipData || d.data.tooltip || d.data.data.tooltip || '';
          content = content.replace('{{percent}}', d.data.percent + '%');
          content = content.replace('{{value}}', d.value);
          content = content.replace('%percent%', d.data.percent + '%');
          content = content.replace('%value%', d.value);
          show();
        }
      })
      .on('mouseleave', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })
      .style('fill', function(d, i) {return charts.chartColor(self.isRTL ? chartData.length-i-1 : i, 'pie', d.data); })
      .transition().duration(charts.animate ? 350 : 0)
      .attrTween('d', function(d) {
        var i = d3.interpolate(d.startAngle + 0.1, d.endAngle);
        return function(t) { d.endAngle = i(t); return pieArcs(d); };
      });

    // Now we'll draw our label lines, etc.
    var textLabels, textX=[], textY=[], textLabelsLength = 0,
      perEvenRound = [], perRound = [], perRoundTotal = 0,

      // http://stackoverflow.com/a/13484393
      // Fix: http://jira/browse/SOHO-4951
      evenRound = function(orig, target) {
        var i = orig.length,
          j = 0,
          total = 0,
          change,
          newVals = [],
          next, factor1,
          factor2,
          len = orig.length,
          marginOfErrors = [],
          errorFactor = function (oldNum, newNum) {
            return Math.abs(oldNum - newNum) / oldNum;
          };

        // map original values to new array
        while (i--) {
          total += newVals[i] = Math.round(orig[i]);
        }

        change = total < target ? 1 : -1;

        while (total !== target) {
          // Iterate through values and select the one that once changed will introduce
          // the least margin of error in terms of itself. e.g. Incrementing 10 by 1
          // would mean an error of 10% in relation to the value itself.
          for (i = 0; i < len; i++) {
            next = i === len - 1 ? 0 : i + 1;
            factor2 = errorFactor(orig[next], newVals[next] + change);
            factor1 = errorFactor(orig[i], newVals[i] + change);

            if (factor1 > factor2) {
              j = next;
            }
          }
          newVals[j] += change;
          total += change;
        }
        for (i = 0; i < len; i++) {
          marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
        }

        // Math.round() causes some problems as it is difficult to know at the beginning
        // whether numbers should have been rounded up or down to reduce total margin of error.
        // This section of code increments and decrements values by 1 to find the number
        // combination with least margin of error.
        for (i = 0; i < len; i++) {
          for (j = 0; j < len; j++) {
            if (j === i) {
              continue;
            }
            var roundUpFactor = errorFactor(orig[i], newVals[i] + 1)  + errorFactor( orig[j], newVals[j] - 1);
            var roundDownFactor = errorFactor(orig[i], newVals[i] - 1) + errorFactor( orig[j], newVals[j] + 1);
            var sumMargin = marginOfErrors[i] + marginOfErrors[j];

            if(roundUpFactor < sumMargin) {
              newVals[i] = newVals[i] + 1;
              newVals[j] = newVals[j] - 1;
              marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
              marginOfErrors[j] = newVals[j] && Math.abs(orig[j] - newVals[j]) / orig[j];
            }
            if(roundDownFactor < sumMargin) {
              newVals[i] = newVals[i] - 1;
              newVals[j] = newVals[j] + 1;
              marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
              marginOfErrors[j] = newVals[j] && Math.abs(orig[j] - newVals[j]) / orig[j];
            }
          }
        }
        return newVals;
      },

      setEvenRoundPercentage = function() {

        var arr = [];
        for (var i = 0, l = chartData.length; i < l; i++) {
          var d = chartData[i],
            v = (total === 0 ? 0 : d.value / total),
            f1 = d3.format('0.0%'),
            f2 = d3.format('0.3%'),
            r1 = f1(v),
            r2 = f2(v);
          perRound.push(+(r1.replace('%','')));
          arr.push(+(r2.replace('%','')));
        }

        perEvenRound = evenRound(arr, 100);
        perRoundTotal = perRound.reduce(function(a, b) { return a + b; });
      },

      labelsContextFormatter = function (d, context, formatterString, isShortName, idx) {
        formatterString = /percentage/i.test(context) ? '0.0%' : formatterString;
        var r,
          format = d3.format(formatterString || ''),
          percentage = format(d.value / total),
          name = isShortName ? (d.data.shortName || d.data.name.substring(0, 9) + (d.data.name.length > 9 ? '...' : '')) : d.data.name,
          value = formatterString && formatterString !== '0.0%' ? format(d.value) : d.value;

        if (/percentage/i.test(context) && perRoundTotal !== 100) {
          percentage = perEvenRound[idx] +'%';
        }
        // 'name'|'value'|'percentage'|'name, value'|'name (value)'|'name (percentage)'
        switch (context) {
          case 'name': r = name; break;
          case 'value': r = value; break;
          case 'percentage': r = percentage; break;
          case 'name, value': r = name + ', '  + value; break;
          case 'name (value)': r = name + ' (' + value + ')'; break;
          case 'name (percentage)': r = name + ' (' + percentage + ')'; break;
          default: r = name + ', ' + value + ' (' + percentage + ')'; break;
        }
        return r || '';
      },

      labelsColorFormatter = function (d, i, opt) {
        return opt === 'color-as-arc' ? (charts.chartColor(self.isRTL ? chartData.length-i-1 : i, 'pie', d.data)) : (opt === 'default' ? '' : opt);
      },

      drawTextlabels = function (isShortName) {
        svg.selectAll('.lb-top').each(function(d, i) {
          var parentX = +d3.select(this.parentNode).attr('x');

          if (((dims.center.x + parentX) - (d.data.name.length*5)) < 25 ||
          parentX > 0 && (dims.center.x - (d.data.name.length*5 + parentX)) < 25) {
            isShortName =  true;
          }

          d3.select(this)
            .text(function() {
              return labelsContextFormatter(d, lb.contentsTop, lb.formatterTop, isShortName, i);
            })
            .style({
              'font-weight': lb.isTwoline ? 'normal' : 'normal',
              'font-size': lb.isTwoline ? (dims.width > 450 ? '1.8em' : '1.1em') : '1em',
              'fill': function() {
                var color = labelsColorFormatter(d, i, lb.colorTop);
                color = color === '#bdbdbd' ? '#868686' : color;
                return color;
              }
            });
        });

        if (lb.isTwoline) {
          svg.selectAll('.lb-bottom').each(function(d, i) {
            var parentX = +d3.select(this.parentNode).attr('x');

            if (((dims.center.x + parentX) - (d.data.name.length*5)) < 25 ||
            parentX > 0 && (dims.center.x - (d.data.name.length*5 + parentX)) < 25) {
              isShortName =  true;
            }

            d3.select(this)
              .text(function() {
                return labelsContextFormatter(d, lb.contentsBottom, lb.formatterBottom, isShortName);
              })
              .style({
                'font-size': '1em',
                'fill': function() {
                  return labelsColorFormatter(d, i, lb.colorBottom);
                }
              });

              isShortName = null;
          });
        }
      },

      addLabels = function () {

        svg.selectAll('.labels').remove();

        var labels = svg.append('g').attr('class','labels'),
          enteringLabels = labels.selectAll('.label').data(pieData).enter(),
          labelGroups = enteringLabels.append('g').attr('class', 'label');

        labels.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y + ')');

        labelGroups.append('circle')
          .style('fill', 'none')
          .attr({'class': 'pie-circle', x: 0, y: 0, r: 1,
            transform: function (d) {
              var x = pieCircles.centroid(d)[0],
                y = pieCircles.centroid(d)[1];
              return 'translate(' + x + ',' + y + ')';
            }
          });

        labelGroups.append('circle')
          .style('fill', 'none')
          .attr({'class': 'label-circle', x: 0, y: 0, r: 1,
            transform: function (d) {
              var x = pieLabelCircles.centroid(d)[0],
                y = pieLabelCircles.centroid(d)[1];
              return 'translate(' + x + ',' + y + ')';
            }
          });

        textLabels = labelGroups.append('text').attr({
          'class': 'label-text',
          'x': function (d) {
            var centroid = pieArcs.centroid(d),
              midAngle = Math.atan2(centroid[1], centroid[0]),
              x = Math.cos(midAngle) * dims.labelRadius,
              sign = (x > 0) ? 1 : -1,
              labelX = x + (1 * sign);

            textLabelsLength++;
            textX.push(x);
            return labelX;
          },
          'y': function (d) {
            var centroid = pieArcs.centroid(d),
              midAngle = Math.atan2(centroid[1], centroid[0]),
              y = Math.sin(midAngle) * dims.labelRadius;
            textY.push(y);
            return y;
          },
          'text-anchor': function (d) {
            var centroid = pieArcs.centroid(d),
             midAngle = Math.atan2(centroid[1], centroid[0]),
              x = Math.cos(midAngle) * dims.labelRadius;

            if (isRTL && charts.isIE) {
              return (x > 0 ? 'start' : 'end');
            }

            return isRTL ? (x > 0 ? 'end' : 'start') : (x > 0 ? 'start' : 'end');
          }
        });

        textLabels.append('tspan').attr('class', 'lb-top');
        if (lb.isTwoline) {
          textLabels.append('tspan')
            .attr({'class': 'lb-bottom',
              'x': function(d, i) {
                  var x = textX[i];
                  return x;
              },
              'dy': '17'
            });
        }

        setEvenRoundPercentage();

        if (lb.hideLabels) {
          drawTextlabels();

          // Add center label only if its donut chart
          if (isDonut) {
            arcs.append('text')
              .attr('dy', '.35em')
              .style('text-anchor', 'middle')
              .attr('class', 'chart-donut-text')
              .html(centerLabel);

            // FIX: IE does not render .html
            if (charts.isIE) {
              if (charts.isHTML(centerLabel)) {
                // http://stackoverflow.com/questions/13962294/dynamic-styling-of-svg-text
                var text  = arcs.select('.chart-donut-text'),
                  tmp = document.createElement('text');
                tmp.innerHTML = centerLabel;
                var nodes = Array.prototype.slice.call(tmp.childNodes);
                nodes.forEach(function(node) {
                  text.append('tspan')
                    .attr('style', node.getAttribute && node.getAttribute('style'))
                    .attr('x', node.getAttribute && node.getAttribute('x'))
                    .attr('dy', node.getAttribute && node.getAttribute('dy'))
                    .text(node.textContent);
                });
              }
              else {
                arcs.select('.chart-donut-text').text(centerLabel);
              }
            }
          }
        }
      };
      addLabels();

      if (lb.hideLabels) {
        var isRunning = true,
          maxRunning = textLabelsLength * 15,
          orgLabelPos,
          spacing = 35;

        // Resolve label positioning collisions

        // Record org x, y position
        orgLabelPos = textLabels[0].map(function(d) {
          d = d3.select(d);
          return { x: +d.attr('x'), y: +d.attr('y') };
        });

        // Fix y position
        var relax = function () {
          var again = false;
          maxRunning--;
          textLabels.each(function (d, i) {
            var a = this,
              da = d3.select(a),
              y1 = +da.attr('y');

            textLabels.each(function (d2, i2) {
              if (i2 > i) {
                var deltaY,
                  b = this,
                  db = d3.select(b),
                  y2 = +db.attr('y');

                if (da.attr('text-anchor') === db.attr('text-anchor') && (a === textLabels[0][i2-1])) {
                  deltaY = Math.round(Math.abs(y1 - y2));
                  if (deltaY < spacing) {
                    deltaY += 1;
                    var newY = y2 > 0 ? y2-(deltaY/2) : y2+(deltaY/2)+1;
                    again = true;
                    db.attr('y', newY); //padding

                    if (Math.round(Math.abs(newY)) < 2) {
                      again = false;
                      newY = y2 > 0 ? y2-(spacing) : y2+(spacing/2);
                      db.attr('y', newY);
                    }
                  }
                }
              }
            });
          });

          if (again && maxRunning > 0) {
            relax();
          } else {
            isRunning = false;
          }
        };

        relax();

        // Draw lines and set short name
        // Fix x position
        var labelCircles = svg.selectAll('.label-circle');
        spacing *=  -1;
        textLabels.each(function(d, i) {
          var x,
            label = d3.select(this),
            x1 = +label.attr('x'),
            y1 = +label.attr('y'),
            sign = (x1 > 0 ? 1 : -1);

            x = isRTL ?
              ((dims.labelRadius - Math.abs(y1) + Math.abs(orgLabelPos[i].x - (spacing * 1.5))) * sign):
              ((dims.labelRadius - Math.abs(y1) + Math.abs(orgLabelPos[i].x + (spacing * 1.5))) * sign);

          if (orgLabelPos[i].y !== y1 || (i === 0 && chartData[i].percent < 10)) {
            x += chartData[i].percent <= 10 ? Math.ceil(x1/2) : Math.ceil(x1-x)- (spacing/2);
            label.attr('x', x);

            if (lb.isTwoline) {
              label.select('.lb-bottom').attr('x', x);
            }

            var t = d3.transform(d3.select(labelCircles[0][i]).attr('transform')),
              tx = t.translate[0] + (t.translate[0] > 0 ? 10 : -10);

            if (x < tx || Math.abs(x) > dims.center.x) {
              label.attr('x', tx);
              if (lb.isTwoline) {
                label.select('.lb-bottom').attr('x', tx);
              }
            }
          }
        });

        var lineFunction = d3.svg.line()
          .x(function(d) { return d.x; })
          .y(function(d) { return d.y; })
          .interpolate('basis');

        var labels = svg.selectAll('.label');

        svg.selectAll('.label-text tspan').each(function() {
          if (d3.select(this).text().substring(5) === '...') {
            showLegend = true;
          }
        });

        // Collect source and targets [x, y] position
        labels.each(function(d, i) {
          var label = d3.select(this),
            pieCircle = label.select('.pie-circle'),
            labelCircle = label.select('.label-circle'),
            text = label.select('.label-text'),
            ct = d3.transform(pieCircle.attr('transform')),
            ct2 = d3.transform(labelCircle.attr('transform')),
            points = [
              { x:Number(ct.translate[0]), y:Number(ct.translate[1]) },
              { x:Number(ct2.translate[0]), y:Number(ct2.translate[1]) },
              { x:Number(text.attr('x')), y:Number(text.attr('y')) + (lb.isTwoline ? 5 : 0) }
            ];

          // Draw line from center of arc to label
          if (lb.linehideWhenMoreThanPercentage > chartData[i].percent) {
            lines.append('path')
              .attr({
                'class': 'label-line',
                'd': lineFunction(points)
              })
              .style({
                'stroke-width': lb.lineWidth,
                'stroke': function() { return labelsColorFormatter(d, i, lb.lineColor); }
              });
            }
        });

      } else {
        showLegend = true;
      }

    //Get the Legend Series'
    var series = chartData.map(function (d) {
      var name = d.name +' ('+ (isNaN(d.percent) ? 0 : d.percent) +'%)';

      if (d.name === 'Empty-Pie') {
        name= '';
      }
      return {name: name, display:'twocolumn', color: d.color};

    });

    // Add Legends
    if (showLegend || charts.legendformatter) {
      charts[charts.legendformatter ? 'renderLegend' : 'addLegend'](series, 'donut');
    }

    charts.setSelected = function (o, isToggle) {
      var selector, arcIndex,
        selected = 0,
        equals = window.Soho.utils.equals;
      arcs.selectAll('.arc').each(function(d, i) {
        if (!d || !d.data || !d.data.data) {
          return;
        }
        if (selected < 1) {
          if ((typeof o.fieldName !== 'undefined' &&
                typeof o.fieldValue !== 'undefined' &&
                  o.fieldValue === d.data.data[o.fieldName]) ||
              (typeof o.index !== 'undefined' && o.index === i) ||
              (o.data && equals(o.data, chartData[i].data)) ||
              (o.elem && $(this).is(o.elem))) {
            selected++;
            selector = d3.select(this);
            arcIndex = i;
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        selector.on('click').call(selector.node(), selector.datum(), arcIndex);
      }
    };

    // Set initial selected
    (function () {
      var selected = 0,
        selector;
      arcs.selectAll('.arc').each(function(d, i) {
        if (!d || !d.data || !d.data.data) {
          return;
        }
        if (d.data.data.selected && selected < 1) {
          selected++;
          selector = d3.select(this);
          selector.on('click').call(selector.node(), selector.datum(), i);
        }
      });
    })();

    if (isRTL && lb.isTwoline) {
      // Fix: incorrect text tspan position when RTL
      // https://connect.microsoft.com/IE/feedback/details/846683
      setTimeout(function() {
        svg.selectAll('.label-text').each(function() {
          var label = d3.select(this),
            parent = d3.select(label.node().parentNode),
            clone = d3.select(parent.node().appendChild(label.node().cloneNode(true)));
          label.select('.lb-bottom').remove();
          clone.select('.lb-top').remove();
        });
      }, 100);
    }

    $(container).trigger('rendered');
    return $(container);
  };

  this.elementTransform = function(options) {
    options.element.attr('transform', function () {
      var el = options.sameAs || this,
        t = d3.transform(d3.select(el).attr('transform')),
        x = t.translate[0],
        y = t.translate[1];

      x = options.addtoX ? (x>0?(x+options.addtoX):(x-options.addtoX)) : x;
      y = options.addtoY ? (y>0?(y+options.addtoY):(y-options.addtoY)) : y;
      return 'translate('+ x +','+ y +')';
    });
  };

  this.moveLabels = function(options) {
    var labelElements = options.textLabels[0];
    if (options.addtoX) {
      options.textLabels.attr('x',function() {
        var x = d3.select(this).attr('x');
        return x > 0 ? (x + options.addtoX) : (x - options.addtoX);
      });
      options.textLines.attr('x2',function(d, i) {
        var labelForLine = d3.select(labelElements[i]);
        return labelForLine.attr('x');
      });
    }
    else if (options.addtoY) {
      options.textLabels.attr('y',function() {
        var y = Number(d3.select(this).attr('y'));
        return y > 0 ? (y + options.addtoY) : (y - options.addtoY);
      });
      options.textLines.attr('y2',function(d, i) {
        var labelForLine = d3.select(labelElements[i]);
        return labelForLine.attr('y');
      });
    }
  };

  //TODO: Test this with two charts on the page.
  this.handleResize = function () {
    var timeout = null,
      width = 0;

    //Handle Resize / Redraw
    function resizeCharts() {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        var api = $(container).data('chart'),
            cont = $(container);

        if (width === cont.width()) {
          return;
        }

        width = cont.width();

        if (!cont.is(':visible')) {
          return true;
        }
        cont.empty();
        api.initChartType(api.settings);
      }, 200);
    }

    if (this.redrawOnResize) {
      $(window).on('resize.charts', resizeCharts);
      $(container).off('resize').on('resize', resizeCharts);

      resizeCharts();
    }
  };

  // Donut Chart - Same as Pie but inner radius
  this.Ring = function(chartData) {
    return charts.Pie(chartData, true);
  };

  //Conserve aspect ratio of the orignal region. Useful when shrinking/enlarging
  this.calculateAspectRatioFit = function (d) {
    var ratio = Math.min(d.maxWidth / d.srcWidth, d.maxHeight / d.srcHeight);
    return { width: d.srcWidth*ratio, height: d.srcHeight*ratio };
  };

  // Sparkline Chart
  this.Sparkline = function(chartData, options) {
    var tooltipIntervalMedianRange,
      tooltipIntervalDots,
      tooltipDataCacheMedianRange = [],
      tooltipDataCacheDots = [],
      tooltipData = charts.options.tooltip;

    // calculate max and min values in the NLWest data
    var max=0, min=0, len=0, i,
      dimensions = this.calculateAspectRatioFit({
        srcWidth: 385,
        srcHeight: 65,
        maxWidth: $(container).width(),
        maxHeight: 600 //container min-height
      }),
      dotsize = dimensions.width > 300 ? 4 : 3;

    for (i = 0; i < chartData.length; i++) {
      min = d3.min([d3.min(chartData[i].data), min]);
      max = d3.max([d3.max(chartData[i].data), max]);
      len = d3.max([chartData[i].data.length, len]);
    }

    var p = 10,
      w = dimensions.width,
      h = dimensions.height,
      x = d3.scale.linear().domain([0, len]).range([p, w - p]),
      y = d3.scale.linear().domain([min, max]).range([h - p, p]),
      line = d3.svg.line()
                   .x(function(d, i) { return x(i); })
                   .y(function(d) { return y(d); });

    charts.appendTooltip();
    var svg = d3.select(container)
      .append('svg')
      .attr('height', h)
      .attr('width', w);

    //Add Median Range
    //https://www.purplemath.com/modules/meanmode.htm
    if(options.isMedianRange) {
      max = d3.max(chartData[0].data);
      min = d3.min(chartData[0].data);

      var minWidth = 10,
        maxWidth = w-45,
        median = d3.median(chartData[0].data),
        range = max-min,
        scaleMedianRange = d3.scale.linear().domain([min, max]).range([0, h]),
        top = h-scaleMedianRange(median>range ? median : range),
        bot = h-scaleMedianRange(median<range ? median : range);

      svg.append('g')
        .attr('class', 'medianrange')
        .attr('transform', function() {return 'translate('+ minWidth +','+ top +')';})
        .append('rect')
        .attr('width', maxWidth)
        .attr('height', bot)
        .style('fill', '#d8d8d8')
        .on('mouseenter', function(d, i) {
          var rect = this.getBoundingClientRect(),
            content = '<p>' + (chartData[0].name ? chartData[0].name +'<br> ' : '') +
            Locale.translate('Median') + ': <b>'+ median +'</b><br>'+
            Locale.translate('Range') +': <b>'+ range +'</b>'+
            (options.isPeakDot ? '<br>'+Locale.translate('Peak') +': <b>'+ max +'</b>' : '') +'</p>',
            show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left + ((rect.width - size.width)/2),
                y = rect.top - size.height - 5; // 5: extra padding

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheMedianRange[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalMedianRange = setInterval(function() {
              if(runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCacheMedianRange[i] = data;
                });
              }
              if(content !== '') {
                clearInterval(tooltipIntervalMedianRange);
                show();
              }
            }, 10);
          } else {
            tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
            content = tooltipDataCacheMedianRange[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }
        })
        .on('mouseleave', function() {
          clearInterval(tooltipIntervalMedianRange);
          charts.hideTooltip();
        });
    }

    for (i = 0; i < chartData.length; i++) {
      var set = chartData[i],
        g = svg.append('g');
        g.append('path')
         .attr('d', line(set.data))
         .attr('stroke', options.isMinMax ? '#999999' : charts.sparklineColors(i))
         .attr('class', 'team connected-line');
    }


    //Add Dots (Dots/Peak/MinMAx)
    min = d3.min(chartData[0].data);
      svg.selectAll('.point')
        .data(chartData[0].data)
        .enter()
        .append('circle')
        .attr('r', function(d) {
          return (options.isMinMax && max === d || options.isMinMax && min === d) ? (dotsize+1) :
            (options.isDots || (options.isPeakDot && max === d)) ? dotsize : 0;
        })
        .attr('class', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? 'point peak' :
            (options.isMinMax && max === d) ? 'point max' :
            (options.isMinMax && min === d) ? 'point min' : 'point';
        })
        .style('fill', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? '#ffffff' :
            (options.isMinMax && max === d) ? '#56932E' :
            (options.isMinMax && min === d) ? '#941E1E' : charts.sparklineColors(0);
        })
        .style('stroke', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? charts.sparklineColors(0) :
            (options.isMinMax && max === d) ? 'none' :
            (options.isMinMax && min === d) ? 'none' : '#ffffff';
        })
        .style('cursor', 'pointer')
        .attr('cx', function(d, i) { return x(i); })
        .attr('cy', function(d) { return y(d); })
        .on('mouseenter', function(d) {
          var rect = this.getBoundingClientRect(),
            content = '<p>' + (chartData[0].name ? chartData[0].name + '<br> ' +
              ((options.isMinMax && max === d) ? Locale.translate('Highest') + ': ' :
               (options.isMinMax && min === d) ? Locale.translate('Lowest') + ': ' :
               (options.isPeakDot && max === d) ? Locale.translate('Peak') + ': ' : '') : '') + '<b>' + d  + '</b></p>',
            show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left - (size.width /2) + 6,
                y = rect.top - size.height - 8;

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheDots[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalDots = setInterval(function() {
              if(runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCacheDots[i] = data;
                });
              }
              if(content !== '') {
                clearInterval(tooltipIntervalDots);
                show();
              }
            }, 10);
          } else {
            tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
            content = tooltipDataCacheDots[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }

          d3.select(this).attr('r', (options.isMinMax && max === d ||
            options.isMinMax && min === d) ? (dotsize+2) : (dotsize+1));
        })
        .on('mouseleave', function(d) {
          clearInterval(tooltipIntervalDots);
          charts.hideTooltip();
          d3.select(this).attr('r', (options.isMinMax && max === d ||
            options.isMinMax && min === d) ? (dotsize+1) : dotsize);
        })
        .on('click', function(d, i) {
          var data = {value: d, index: i, name: chartData[0].name};

          if (options.isMinMax && max === d) {
            data.isHighest = true;
          }
          if (options.isMinMax && min === d) {
            data.isLowest = true;
          }
          if (options.isPeakDot && max === d) {
            data.isPeakDot = true;
          }

          charts.selectElement(d3.select(this), svg.selectAll('.point, .connected-line'), data);
        });

    charts.setSelected = function (o, isToggle) {
      var selected = 0,
        selector,
        selectorData,
        dataset = chartData,

        setSelected = function (d, i, groupIdx) {
          groupIdx = groupIdx > -1 ? groupIdx : 0;
          var elem = svg.selectAll('.point:nth-child('+ (i+2) +')'),
            data = {value: d, index: i, name: dataset[groupIdx].name};

          if (options.isMinMax && max === d) {
            data.isHighest = true;
          }
          if (options.isMinMax && min === d) {
            data.isLowest = true;
          }
          if (options.isPeakDot && max === d) {
            data.isPeakDot = true;
          }

          selected++;
          selector = elem;
          selectorData = data;
        };

      dataset.forEach(function(d, i) {
        if (selected < 1) {
          if (d && d.data && (typeof o.groupName !== 'undefined' &&
            typeof o.groupValue !== 'undefined' &&
            typeof o.index === 'number' &&
            o.groupValue === d[o.groupName] &&
            o.index > -1 && d.data[o.index])) {
              setSelected(d.data[o.index], o.index, i);
          }
        }
        if (selected < 1) {
          if (d && d.data && (typeof o.groupName === 'undefined' &&
            typeof o.groupValue === 'undefined' &&
            typeof o.index === 'number' &&
            o.index > -1 && d.data[o.index])) {
              setSelected(d.data[o.index], o.index, i);
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        charts.selectElement(selector, svg.selectAll('.point, .connected-line'), selectorData);
      }
    };

    // Set initial selected
    (function () {
      var selected = 0,
        selector,
        selectorData,
        dataset = chartData,

        setSelected = function (d, i, groupIdx) {
          groupIdx = groupIdx > -1 ? groupIdx : 0;
          var elem = svg.selectAll('.point:nth-child('+ (i+2) +')'),
            isSelected = elem.node() && elem.classed('is-selected'),
            data = {value: d, index: i, name: dataset[groupIdx].name};

          if (!isSelected) {
            if (options.isMinMax && max === d) {
              data.isHighest = true;
            }
            if (options.isMinMax && min === d) {
              data.isLowest = true;
            }
            if (options.isPeakDot && max === d) {
              data.isPeakDot = true;
            }
            selected++;
            selector = elem;
            selectorData = data;
          }
        };

      dataset.forEach(function(d, i) {
        if (selected < 1) {
          if (d && d.data && typeof d.selected === 'number' && d.selected > -1) {
            if (d.data[d.selected]) {
              setSelected(d.data[d.selected], d.selected, i);
            }
          }
        }
      });

      if (selected > 0) {
        charts.selectElement(selector, svg.selectAll('.point, .connected-line'), selectorData);
      }
    })();

    $(container).trigger('rendered');

    return $(container);
  };

  // Column Chart - Sames as bar but reverse axis
  this.Column = function(chartData, isStacked) {
    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    var datasetStacked,
      dataset = chartData,
      self = this,
      parent = $(container).parent(),
      isRTL = charts.isRTL,
      isPositiveNegative = (charts.settings.type === 'column-positive-negative'),
      isSingular = (dataset.length === 1),
      margin = {top: 40, right: 40, bottom: (isSingular && chartData[0].name === undefined ? (isStacked ? 20 : 50) : 35), left: 45},
      legendHeight = 40,
      width = parent.width() - margin.left - margin.right - 10,
      height = parent.height() - margin.top - margin.bottom - (isSingular && chartData[0].name === undefined ? (isStacked || isPositiveNegative ? (legendHeight - 10) : 0) : legendHeight),
      yMin, yMax, yMinTarget, yMaxTarget, series, seriesStacked,
      pnColors, pnPatterns, pnLegends, pnSeries;

    yMin = d3.min(dataset, function (group) {
      return d3.min(group.data, function (d) {
          return d.value;
      });
    });

    yMax = d3.max(dataset, function (group) {
      return d3.max(group.data, function (d) {
          return d.value;
      });
    });

    if (isPositiveNegative) {
      yMinTarget = d3.min(dataset, function (group) {
        return d3.min(group.data, function (d) {
            return d.target;
        });
      });

      yMaxTarget = d3.max(dataset, function (group) {
        return d3.max(group.data, function (d) {
            return d.target;
        });
      });

      yMin = d3.min([yMin, yMinTarget]);
      yMax = d3.max([yMax, yMaxTarget]);

      pnLegends = {target: 'Target', positive: 'Positive', negative: 'Negative'};
      pnColors = {target: 'neutral', positive: 'good', negative: 'error'};
      pnPatterns = {};

      if (dataset[0]) {
        if (dataset[0].colors) {
          $.extend(true, pnColors, dataset[0].colors);
        }
        if (dataset[0].legends) {
          $.extend(true, pnLegends, dataset[0].legends);
        }
        if (dataset[0].patterns) {
          $.extend(true, pnPatterns, dataset[0].patterns);
        }
      }
      //Converting object into array
      pnSeries = [];
      $.each(pnLegends, function(key, val) {
        pnSeries.push({
          name: val,
          color: pnColors[key],
          pattern: pnPatterns[key],
          option: key
        });
      });
    }

    $(container).addClass('column-chart');

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    var x0 = d3.scale.ordinal()
      .rangeRoundBands([0, width], 0.1);

    var x1 = d3.scale.ordinal();

    var y = d3.scale.linear()
      .range([height, 0]);

    if (isStacked) {
      //Map the Data Sets and Stack them.
      if (isSingular) {
        datasetStacked = dataset[0].data.map(function (d) {
          return [$.extend({}, d, {
            y: d.value,
            x: d.name,
            color: d.color,
            pattern: d.pattern,
            parentName: d.name,
            tooltip: d.tooltip
          })];
        });
      } else {
        datasetStacked = dataset.map(function (d) {
          return d.data.map(function (o) {
            return $.extend({}, o, {
              y: o.value,
              x: o.name,
              color: o.color,
              pattern: o.pattern,
              parentName: d.name,
              tooltip: d.tooltip
            });
          });
        });
      }

      var stack = d3.layout.stack();
      stack(datasetStacked);

      var xScale = d3.scale.ordinal()
        .domain(d3.range(datasetStacked[0].length))
        .rangeRoundBands([0, width], 0.05);

      var yScale = d3.scale.linear()
        .domain([0,
          d3.max(datasetStacked, function(d) {

            return d3.max(d, function(d) {
              return d.y0 + d.y;
            });
          })
        ])
        .range([0, height]);
    }

    //List the values along the x axis
    var xAxisValues = dataset[0].data.map(function (d) {return d.name;});

    var xAxis = d3.svg.axis()
        .scale(x0)
        .tickSize(0)
        .tickPadding(12)
        .orient('bottom');

    var yAxis = d3.svg.axis()
        .scale(y)
        .tickSize(-width)
        .tickPadding(isRTL ? -12 : 12)
        .tickFormat(d3.format(charts.format || 's'))
        .orient('left');

    var svg = d3.select(container)
      .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
          .attr('transform', 'translate('+ margin.left +','+ margin.top +')');

    // Get the Different Names
    var names = dataset.map(function (d) {
      return d.name;
    });

    //Get the Maxes of each series
    var maxesStacked, maxes = dataset.map(function (d) {
      return d3.max(d.data, function(d){
        return isPositiveNegative ? d.target : d.value;
      });
    });

    if (isStacked) {
      maxesStacked = datasetStacked.map(function (d) {
        return d3.max(d, function(d){ return d.y + d.y0;});
      });
    }

    if (isSingular) {
      names = dataset[0].data.map(function (d) {
        return d.name;
      });
    }

    // Extra ticks
    if (isPositiveNegative) {
      yMin += yMin / y.ticks().length;
      maxes[0] += maxes[0] / y.ticks().length;
    }

    // Set series
    (function() {
      if (isStacked && isSingular) {
        series = dataset[0].data;
      }
      else {
        var i, l, lm;
        // Loop backwards to catch and override with found first custom info from top
        for (i = dataset.length-1,l = -1; i > l; i--) {
          lm = dataset[i].data.map(function (d) {
            return d;
          });
          $.extend(true, series, lm);
          // Convert back to array from object
          series = $.map(series, function(d) {
            return d;
          });
        }
      }
    })();

    if (isStacked && !isSingular) {
      seriesStacked = names.map(function (d, i) {
        return dataset[i];
      });
    }

    x0.domain(isStacked ? xAxisValues : names);
    x1.domain(xAxisValues).rangeRoundBands([0, (isSingular||isStacked) ? width : x0.rangeBand()]);
    y.domain([(yMin < 0 ? yMin : (charts.settings.minValue || 0)), d3.max(isStacked ? maxesStacked : maxes)]).nice();

    if (!isSingular || (isSingular && !isStacked)) {
      svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + (height + (isPositiveNegative ? 10 : 0)) + ')')
        .call(xAxis);
    }

    svg.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    // Adjust extra(x) space for negative values for RTL
    if (isRTL && yMin < 0) {
      var yMaxLength = 0,
        tempLength;

      svg.selectAll('.axis.y text')
        .attr('class', function(d) {
          tempLength = d3.select(this).text().length;
          yMaxLength = (tempLength > yMaxLength) ? tempLength : yMaxLength;
          return d < 0 ? 'negative-value' : 'positive-value';
        })
        .attr('x', function(d) {
          return d < 0 ? ((yMaxLength ) * 9) : ((yMaxLength ) * 5);
        });

    }

    //Make an Array of objects with name + array of all values
    var dataArray = [];
    chartData.forEach(function(d) {
      dataArray.push($.extend({}, d, {values: d.data}));
    });

    if (isSingular) {
      dataArray = [];
      names = dataset[0].data.forEach(function (d) {
        dataArray.push(d);
      });
    }

    var bars, targetBars, pnBars,
      barMaxWidth = 35,
      color = function(colorStr) {
        return charts.chartColor(0, '', {'color': colorStr});
      },
      onEndAllTransition = function (transition, callback) {
        var n;
        if (transition.empty()) {
          callback();
        }
        else {
          n = transition.size();
          transition.each('end', function() {
            n--;
            if (n === 0) {
              callback();
            }
          });
        }
      };

    function drawBars(isTargetBars) {
      var bars;
      isTargetBars = isPositiveNegative && isTargetBars;

      // Add the bars - done different depending on if grouped or singlular
      if (isSingular || isPositiveNegative) {
        bars = svg.selectAll('rect' + (isTargetBars ? '.target-bar' : '.bar'))
          .data(isStacked ? datasetStacked : dataArray)
          .enter()
          .append('rect')
          .attr('class', function(d, i) {
            var classStr = 'bar series-'+ i;

            if (isPositiveNegative) {
              classStr = (isTargetBars ? ('target-bar series-'+ i) : classStr) +
                (d.value > 0 ? ' positive' : ' negative');
            }
            return classStr;
          })
          .attr('width', Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]))
          .attr('x', function(d) {
            return isStacked ? xScale(0) : (x1(d.name) + (x1.rangeBand() - barMaxWidth)/2);
          })
          .attr('y', function() {
            return y(0) > height ? height : y(0);
          })
          .attr('height', function() {
            return 0;
          })
          .attr('mask', function (d) {
            return !isPositiveNegative ? null :
              (isTargetBars ? (pnPatterns.target ? 'url(#' + pnPatterns.target + ')' : null) :
                (d.value < 0 ? (pnPatterns.negative ? 'url(#' + pnPatterns.negative + ')' : null) :
                (pnPatterns.positive ? 'url(#' + pnPatterns.positive + ')' : null))
              );
          })
          .style('fill', function(d) {
            return !isPositiveNegative ? null :
              color(isTargetBars ? pnColors.target : (d.value < 0 ? pnColors.negative : pnColors.positive));
          });

        if (isPositiveNegative) {
          var yTextPadding = 12;
          svg.selectAll(isTargetBars ? '.target-bartext' : '.bartext')
            .data(dataArray)
            .enter()
            .append('text')
            .attr('class', function(d) {
              return (isTargetBars ? 'target-bartext' : 'bartext') +
                (d.value > 0 ? ' positive' : ' negative');
            })
            .attr('text-anchor', 'middle')
            .attr('x', function(d) {
              return (x1(d.name) + (x1.rangeBand())/2) * (isRTL ? -1 : 1);
            })
            .attr('y', function(d) {
              return isTargetBars ?
                (y(d.target) - (yTextPadding/2)) : (y(d.value > 0 ? 0 : d.value) + yTextPadding);
            })
            .style('opacity', 0)
            .style('fill', function(d) {
              return isTargetBars ? '' /* color(pnColors.target) */ :
                (d.value < 0 ? color(pnColors.negative) : color(pnColors.positive));
            })
            .style('font-weight', 'bold')
            .text(function(d) {
              return format(isTargetBars ? d.target : d.value);
            });
        }

        bars.transition().duration(charts.animate ? 1000 : 0)
          .call(onEndAllTransition, function () {
            svg.selectAll('.target-bartext, .bartext')
              .transition().duration(charts.animate ? 300 : 0).style('opacity', 1);
          })
          .attr('y', function(d) {
            var r = isStacked ? (height - yScale(d[0].y) - yScale(d[0].y0)) :
            (d.value < 0 ? y(0) : y(d.value));
            return (isTargetBars ? y(d.target) : (d.value < 0 ? r : (r > (height-3) ? height-2 : r)));
          })
          .attr('height', function(d) {
            var r;
            if (isStacked) {
              r = yScale(d[0].y);
            }
            else {
              if (d.value < 0) {
                r = (height-y(0)) - (height-y(d.value));
              }
              else {
                r = (height-y(d.value)) - (height-y(0));
              }
            }
            r = d.value < 0 ? r : (r < 3 ? 2 : (r > height ? (height-y(d.value)) : r));
            return isTargetBars ? (height-y(d.target)) - (height-y(0)) : r;
          });
      } else {
        var xValues = svg.selectAll('.x-value')
          .data(isStacked ? datasetStacked : dataArray)
          .enter()
          .append('g')
          .attr('class', 'series-group g')
          .attr('data-group-id', function (d, i) {
            return i;
          })
          .attr('transform', function(d) {
            return 'translate(' + x0(isStacked ? xAxisValues[0] : d.name) + ',0)';
          });

        bars = xValues.selectAll('rect')
          .data(function(d) {return isStacked ? d : d.values;})
          .enter()
          .append('rect')
            .attr('class', function(d, i) {
              return 'series-'+ i +' bar';
            })
            .attr('width', Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]))
            .attr('x', function(d, i) {
              var width = Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]);
              return isStacked ? xScale(i) : (x1.rangeBand()/2 + ((width + 2) * i) - (dataArray[0].values.length === 1 || dataArray[0].values.length === 5 || dataArray[0].values.length === 4  ? (width/2) : 0) );//' * (dataArray[0].values.length/2)) );
            })
            .attr('y', function() {return y(0) > height ? height : y(0);})
            .attr('height', function() {return 0;});

        bars
          .transition().duration(charts.animate ? 1000 : 0)
          .attr('y', function(d) {
            var r = isStacked ? (height-yScale(d.y)-yScale(d.y0)) : (d.value < 0 ? y(0) : y(d.value));
            return d.value < 0 ? r : (r > (height-3) ? height-2 : r);
          })
          .attr('height', function(d) {
            var r;
           if (isStacked) {
             r = yScale(d.y);
           }
           else {
             if (d.value < 0) {
               r = (height-y(0)) - (height-y(d.value));
             }
             else {
               r = (height-y(d.value)) - (height-y(0));
             }
           }
           return d.value < 0 ? r : (r < 3 ? 2 : (r > height ? (height-y(d.value)) : r));
          });
      }
      return bars;
    }

    if (isPositiveNegative) {
      targetBars = drawBars(true); //Draw target bars
    }
    bars = drawBars();

    if (isPositiveNegative) {
      pnBars = d3.selectAll('.empty-bars');
      charts.mergeArrays(pnBars[0], targetBars[0], bars[0]);
    }

    if (!isPositiveNegative) {
      //Style the bars and add interactivity
      if (!isStacked) {
        bars
          .style('fill', function(d, i) {
            return isSingular ?
              charts.chartColor(i, 'column-single', chartData[0].data[i]) :
              charts.chartColor(i, 'bar', series[i]);
          })
          .attr('mask', function (d, i) {
            return isSingular ?
              (chartData[0].data[i].pattern ? 'url(#'+ chartData[0].data[i].pattern +')' : null) :
              (series[i].pattern ? 'url(#'+ series[i].pattern +')' : null);
          });
      } else if (isStacked && !isSingular) {
        bars
          .style('fill', function() {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return charts.chartColor(thisGroup, 'bar', dataset[thisGroup]);
          })
          .attr('mask', function() {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return (dataset[thisGroup].pattern ? 'url(#'+ dataset[thisGroup].pattern +')' : null);
          });
      } else if (isStacked && isSingular) {
        bars
          .style('fill', function(d, i) {
            return charts.chartColor(i, 'bar', d[0]);
          })
          .attr('mask', function(d) {
            return (d[0].pattern ? 'url(#'+ d[0].pattern +')' : null);
          });
      }
    }

    var isSingle = isSingular || !isSingular && isStacked,
      isGrouped = !isSingle;

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'Column',
      isSingle: isSingle,
      isGrouped: isGrouped,
      isStacked: isStacked,
      isSingular: isSingular
    });

    (isPositiveNegative ? pnBars : bars)
      .on('mouseenter', function(d, i) {
        var x, y, j, l, hexColor, size, isTooltipBottom,
          maxBarsForTopTooltip = 6,
          thisShape = this,
          shape = $(this),
          content = '',
          ePageY = d3.event.pageY,

          setPattern = function(pattern, hexColor) {
            return !pattern || !hexColor ? '' :
              '<svg width="12" height="12">'+
                '<rect style="fill: '+ hexColor +'" mask="url(#'+ pattern +')" height="12" width="12" />'+
              '</svg>';
          },

          show = function(isTooltipBottom) {
            size = charts.getTooltipSize(content);
            x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);

            if (isStacked) {
              y = shape[0].getBoundingClientRect().top - size.height - 10;
            } else {
              y = ePageY-charts.tooltip.outerHeight() - 25;
              if (dataset.length > 1) {
                x = thisShape.parentNode.getBoundingClientRect().left - (size.width /2) + (thisShape.parentNode.getBoundingClientRect().width/2);
                if (isTooltipBottom) {
                  y += charts.tooltip.outerHeight() + 50;
                  if (y > (thisShape.parentNode.getBoundingClientRect().bottom + 10)) {
                    y = thisShape.parentNode.getBoundingClientRect().bottom + 10;
                  }
                } else {
                  y = thisShape.parentNode.getBoundingClientRect().top-charts.tooltip.outerHeight() + 25;
                }
              }
            }

            if (content !== '') {
              charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
            }
          };

        // Stacked
        if (isStacked) {
          if (isSingular) {
            content = '<p><b>'+ format(d[0].value) +'</b> '+ d[0].name +'</p>';
          } else {
            content = ''+
              '<div class="chart-swatch">'+
                '<div class="swatch-caption"><b>'+ datasetStacked[0][i].name +'</b></div>';
            for (j=datasetStacked.length-1,l=0; j>=l; j--) {
              hexColor = charts.chartColor(j, 'bar', dataset[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (dataset[j].pattern ? 'transparent' : hexColor) +';">'+
                    (setPattern(dataset[j].pattern, hexColor))+
                  '</div>'+
                  '<span>'+ datasetStacked[j][i].parentName +'</span><b>'+ format(datasetStacked[j][i].value) +'</b>'+
                '</div>';
            }
            content += '</div>';
          }
          size = charts.getTooltipSize(content);
          x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);
          y = shape[0].getBoundingClientRect().top - size.height - 10;
        }

        // No Stacked
        else {
          if (isPositiveNegative) {
            content = ''+
              '<div class="chart-swatch">'+
                '<div class="swatch-caption"><b>'+ d.name +'</b></div>'+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (pnPatterns.target ? 'transparent' : color(pnColors.target)) +';">'+
                    (setPattern(pnPatterns.target, color(pnColors.target)))+
                  '</div>'+
                  '<span>'+ pnLegends.target +'</span><b>'+ format(d.target) +'</b>'+
                '</div>'+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (d.value < 0 ?
                    (pnPatterns.negative ? 'transparent' : color(pnColors.negative)) :
                    (pnPatterns.positive ? 'transparent' : color(pnColors.positive))) +
                  ';">'+
                    (d.value < 0 ?
                      setPattern(pnPatterns.negative, color(pnColors.negative)) :
                      setPattern(pnPatterns.positive, color(pnColors.positive)))+
                  '</div>'+
                  '<span>'+ pnLegends[d.value < 0 ? 'negative' : 'positive'] +'</span><b>'+ format(d.value) +'</b>'+
                '</div>'+
              '</div>';
          }
          else if (dataset.length === 1) {
            content = '<p><b>'+ format(d.value) + '</b> '+ d.name +'</p>';
          } else {
            var data = d3.select(this.parentNode).datum().values;

            content = '<div class="chart-swatch">';
            for (j=0,l=data.length; j<l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (series[j].pattern ? 'transparent' : hexColor) +';">'+
                    (setPattern(series[j].pattern, hexColor))+
                  '</div>'+
                  '<span>'+ data[j].name +'</span><b>'+ format(data[j].value) +'</b>'+
                '</div>';
            }
            content += '</div>';
            isTooltipBottom = data.length > maxBarsForTopTooltip;
          }

          size = charts.getTooltipSize(content);
          x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);
          y = ePageY-charts.tooltip.outerHeight() - 25;
          if (dataset.length > 1) {
            x = this.parentNode.getBoundingClientRect().left - (size.width /2) + (this.parentNode.getBoundingClientRect().width/2);
            y = this.parentNode.getBoundingClientRect().top-charts.tooltip.outerHeight() + 25;
          }
        }

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function() {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = tooltipDataCache[i] = data;
              });
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {

          content = tooltipDataCache[i] || tooltipData || content || '';
          if (d.tooltip) {
            var val = d.tooltip.replace('{{value}}', format(d.value));
            content = '<p>'+ val +'</p>';
          }
          show(isTooltipBottom);
        }

      })

      // Mouseleave
      .on('mouseleave', function() {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })

      // Click
      .on('click', function (d, i) {
        var selector, isTargetBar = this && d3.select(this).classed('target-bar');
        if (isTargetBar) {
          selector = svg.select('.bar.series-'+ i);
          selector.on('click').call(selector.node(), selector.datum(), i);
          return;
        }

        var isSelected = this && d3.select(this).classed('is-selected'),
          thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

        charts.setSelectedElement({
          task: (isSelected ? 'unselected' : 'selected'),
          container: container,
          selector: this,
          isTrigger: !isSelected,
          triggerGroup: isGrouped,
          d: d,
          i: i
        });

        if (isSelected) {
          $(container).triggerHandler('selected', [d3.select(this)[0], {}, (isGrouped ? thisGroupId : i)]);
        }
        return;
      })

      // Contextmenu
      .on('contextmenu',function (d) {
        self.triggerContextMenu(d3.select(this)[0][0], d);
      });

    //Add Legend
    if (isSingular && chartData[0].name) {
      charts.addLegend(chartData);
    } else if (isPositiveNegative) {
      charts.addLegend(pnSeries);
    } else if (isStacked && isSingular) {
      charts.addLegend(series);
    } else if (!isSingular) {
      charts.addLegend(isStacked ? seriesStacked : series);
    }

    if (charts.isRTL && charts.isIE) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');

      if (isPositiveNegative) {
        svg.selectAll('.negative-value').style('text-anchor', 'end');
      }

    }

    // Set y-axix tick css class
    svg.selectAll('.y.axis .tick').attr('class', function(d) {
      return 'tick' + (d === 0 ? ' tick0' : '');
    });

    //Add Tooltips
    charts.appendTooltip();

    //See if any labels overlap and use shorter */
    // [applyAltLabels] - function(svg, dataArray, elem, selector, isNoEclipse)
    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, 'shortName');
    }

    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, 'abbrName');
    }

    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, null, null, true);

      // Adjust extra(x) space with short name for RTL
      if (isPositiveNegative) {
        svg.selectAll('.target-bartext, .bartext').attr('x', function() {
          return +d3.select(this).attr('x') - (isRTL ? -6 : 6);
        });
      }
    }

    charts.setSelected = function (o, isToggle) {
      var selected = 0,
        equals = window.Soho.utils.equals,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup, xGroup,

        setSelectedBar = function (g, gIdx) {
          var isGroup = !!g;
          g = isGroup ? d3.select(g) : svg;
          gIdx = typeof gIdx !== 'undefined' ? gIdx : 0;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if (selected < 1) {
              if ((typeof o.fieldName !== 'undefined' &&
                    typeof o.fieldValue !== 'undefined' &&
                      o.fieldValue === (isSingular && isStacked ? d[0][o.fieldName] : d[o.fieldName])) ||
                  (typeof o.index !== 'undefined' && o.index === i) ||
                  (o.data && equals(o.data, chartData[gIdx].data[i])) ||
                  (o.elem && $(this).is(o.elem))) {
                selected++;
                selector = d3.select(this);
                barIndex = i;
                if (isGroup && !isStacked) {
                  isStackedGroup = true;
                }
              }
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function(d, i) {
              setSelectedBar(this, i);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingular && !isGrouped)) {
        chartData.forEach(function(d, i) {
          if (selected < 1) {
            xGroup = $(svg.select('[data-group-id="'+ i +'"]').node());
            if ((typeof o.groupName !== 'undefined' &&
                  typeof o.groupValue !== 'undefined' &&
                    o.groupValue === d[o.groupName]) ||
                (typeof o.groupIndex !== 'undefined' && o.groupIndex === i) ||
                (o.data && equals(o.data, d)) ||
                (o.elem && (xGroup.is(o.elem)))) {

              if (typeof o.fieldName === 'undefined' &&
                    typeof o.fieldValue === 'undefined' &&
                      typeof o.index === 'undefined') {
                selected++;
                selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
                barIndex = i;
                if (isStacked && !isGrouped) {
                  isStackedGroup = true;
                }
              }
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }
    };

    // Set initial selected
    (function () {
      var selected = 0,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup,

        setSelectedBar = function (g) {
          g = g ? d3.select(g) : svg;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if ((isSingular && isStacked ? d[0].selected : d.selected) && selected < 1) {
              selected++;
              selector = d3.select(this);
              barIndex = i;
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function() {
              setSelectedBar(this);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingular && !isGrouped)) {
        chartData.forEach(function(d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
            barIndex = i;
            if (isStacked && !isSingular && !isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

    })();

    $(container).trigger('rendered');
    return $(container);
  };

  // Merge the contents of multiple arrays together into the first array
  this.mergeArrays = function() {
    var i, len = arguments.length;
    if (len > 1) {
      for (i = 1; i < len; i++) {
        arguments[i].forEach(function(v) {
          this.push(v);
        }, arguments[0]);
      }
    }
  };

  this.labelsColide = function(svg) {
    var ticks = svg.selectAll('.x text'),
      collides = false;

    ticks.each(function(d, i) {
      var rect1 = this.getBoundingClientRect(), rect2;

      ticks.each(function(d, j) {
        if (i !== j) {
          rect2 = this.getBoundingClientRect();

          var overlap = !(rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom);

          if (overlap) {
            collides = true;
          }
        }

      });
    });

    return collides;
  };

  this.applyAltLabels = function(svg, dataArray, elem, selector, isNoEclipse) {
    var ticks = selector ? svg.selectAll(selector) : svg.selectAll('.x text');

    ticks.each(function(d, i) {
      var text = dataArray[i] ? dataArray[i][elem] : '';

      text = text || (isNoEclipse ?
        ((d3.select(this).text().substring(0, 1))) : (d3.select(this).text().substring(0, 6) +'...'));
      d3.select(this).text(text);
    });
  };

  this.Line = function(chartData, options, isArea, isBubble) {
    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    $(container).addClass('line-chart' + (isBubble ? ' bubble' : ''));

    var dots = {
      radius: 5,
      radiusOnHover: 7,
      strokeWidth: 2,
      class: 'dot'
    };
    if (isBubble) {
      dots.radius = 0;
      dots.radiusOnHover = 0;
      dots.strokeWidth = 0;
    }
    $.extend(true, dots, settings.dots);

    var isRTL = charts.isRTL;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    //Config axis labels
    var i, l,
      axisLabels = {},
      isAxisLabels = {atLeastOne: false},
      axisArray = ['left', 'top', 'right', 'bottom'];
    if (charts.options.axisLabels) {
      $.extend(true, axisLabels, charts.options.axisLabels);
    }
    if (!$.isEmptyObject(axisLabels)) {
      for (i = 0, l = axisArray.length; i < l; i++) {
        var thisAxis = axisLabels[axisArray[i]];
        if (thisAxis && typeof thisAxis === 'string' && $.trim(thisAxis) !== '') {
          isAxisLabels[axisArray[i]] = true;
          isAxisLabels.atLeastOne = true;
        }
      }
    }

    //Append the SVG in the parent area.
    var longestLabel = '',
      longestLabelLength = 0,
      dataset = chartData,
      isAxisXRotate = (settings.xAxis && settings.xAxis.rotate !== undefined),
      getMaxes = function (d, option) {
        return d3.max(d.data, function(d) {
          return option ? d.value[option] : d.value;
        });
      };

    if (isAxisXRotate) {
      //get the longeset label
      dataset[0].data.map(function (d) {
        if (d.name.length > longestLabel.length) {
          longestLabel = d.name;
        }
      });
      longestLabelLength = longestLabel.length;
    }

    var hideDots = (options.hideDots),
      parent = $(container).parent(),
      isCardAction = !!$('.widget-chart-action', parent).length,
      isViewSmall = parent.width() < 450,
      margin = {
        top: (isAxisLabels.top ? (isCardAction ? 15 : 40) : (isCardAction ? 5 : 30)),
        right: (isAxisLabels.right ? (isViewSmall ? 45 : 65) : (isViewSmall ? 45 : 55)),
        bottom: (isAxisLabels.bottom ? (isAxisXRotate ? 60 : 50) : (isAxisXRotate ? (longestLabelLength * 5) + 35 : 35)),
        left: (isAxisLabels.right ? (isViewSmall ? 55 : 75) : (isViewSmall ? 45 : 65))
      },
      width = parent.width() - margin.left - margin.right,
      height = parent.height() - margin.top - margin.bottom - 30; //legend

    if (isCardAction) {
      height -= 40;
    }

    var svg = d3.select(container).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    var names = dataset[0].data.map(function (d) {
      return d.name;
    });

    var formatValue,
      valueFormatterString = {};
    if (dataset[0] && dataset[0].valueFormatterString) {
      $.extend(true, valueFormatterString, dataset[0].valueFormatterString);
    }
    formatValue = function (s, value) {
      return !$.isEmptyObject(valueFormatterString) && !!s ?
        (d3.format(s)(s === '0.0%' ? value/100 : value)) : value;
    };

    var labels = {
      name: 'Name',
      value: {
        x: 'Value.x',
        y: 'Value.y',
        z: 'Value.z'
      }
    };
    if (dataset[0] && dataset[0].labels) {
      $.extend(true, labels, dataset[0].labels);
    }

    // Calculate the Domain X and Y Ranges
    var maxes,
      x = ((!!settings.xAxis && !!settings.xAxis.scale) ? (settings.xAxis.scale) : (d3.scale.linear())).range([0, width]),
      y = d3.scale.linear().range([height, 0]),
      z = d3.scale.linear().range([1, 25]);

    if (isBubble) {
      maxes = {
        x: dataset.map(function (d) { return getMaxes(d, 'x'); }),
        y: dataset.map(function (d) { return getMaxes(d, 'y'); }),
        z: dataset.map(function (d) { return getMaxes(d, 'z'); })
      };
    } else {
      maxes = dataset.map(function (d) { return getMaxes(d); });
    }

    var entries = d3.max(dataset.map(function(d){ return d.data.length; })) -1,
      xScale = x.domain(!!settings.xAxis && !!settings.xAxis.domain ? (settings.xAxis.domain) : ([0, isBubble ? d3.max(maxes.x) : entries])),
      yScale = y.domain([0, d3.max(isBubble ? maxes.y : maxes)]).nice(),
      zScale = z.domain([0, d3.max(isBubble ? maxes.z : maxes)]).nice();

    var xAxis = d3.svg.axis()
      .scale(xScale)
      .orient('bottom')
      .ticks((!!settings.xAxis && !!settings.xAxis.ticks) ?
        (settings.xAxis.ticks === 'auto' ?
          Math.max(width/55, 2) : settings.xAxis.ticks) :
            (isBubble && isViewSmall ? Math.round(entries/2) : entries))
      .tickPadding(10)
      .tickSize(isBubble ? -(height + 10) : 0)
      .tickFormat(function (d, i) {
        if (!!settings.xAxis) {
          if (!!settings.xAxis.formatter) {
            return settings.xAxis.formatter(d, i);
          }
          if (settings.xAxis.ticks === 'auto') {
            return names[d];
          }
        }
        return isBubble ? d : names[i];
      });

    var yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(-(width + 20))
      .tickPadding(isRTL ? -18 : 20)
      .orient('left');

    if (settings.yAxis && settings.yAxis.formatter) {
      yAxis.tickFormat(function (d, i) {
        if (typeof settings.yAxis.formatter === 'function') {
          return settings.yAxis.formatter(d, i);
        }
        return d;
      });
    }

    if (settings.yAxis && settings.yAxis.ticks) {
      yAxis.ticks(settings.yAxis.ticks.number, settings.yAxis.ticks.format);
    }

    //Append The Axis Labels
    if (isAxisLabels.atLeastOne) {
      var axisLabelsGroup = svg.append('g').attr('class', 'axis-labels'),
        place = {
          top: 'translate('+ (width/2) +','+(-10)+')',
          right: 'translate('+ (width+28) +','+(height/2)+')rotate(90)',
          bottom: 'translate('+ (width/2) +','+(height+40)+')',
          left: 'translate('+ (-40) +','+(height/2)+')rotate(-90)'
        },
        placeStyle = {
          top: 'rotate(0deg) scaleX(-1) translate(-'+(width/2)+'px, '+ (-10) +'px)',
          right: 'rotate(90deg) scaleX(-1) translate(-'+(height/2)+'px, -'+ (width+28) +'px)',
          bottom: 'rotate(0deg) scaleX(-1) translate(-'+(width/2)+'px, '+ (height+40) +'px)',
          left: 'rotate(90deg) scaleX(-1) translate(-'+(height/2)+'px, '+ (55) +'px)'
        },
        addAxis = function(pos) {
          if (isAxisLabels[pos]) {
            axisLabelsGroup.append('text')
              .attr({
                'class': 'axis-label-'+ pos,
                'text-anchor': 'middle',
                'transform': isRTL ? '' : place[pos]
              })
              .style({
                'font-size': '1.3em',
                'transform': isRTL ? placeStyle[pos] : ''
              })
              .text(axisLabels[pos]);
          }
        };

      for (i = 0, l = axisArray.length; i < l; i++) {
        addAxis(axisArray[i]);
      }
    }


    //Append The Axis to the svg
    svg.append('g')
    .attr('class', 'x axis')
    .attr('transform', 'translate(0,' + height + ')')
    .call(xAxis);

    svg.append('g')
      .attr('class', 'y axis')
      .call(yAxis);

    //Offset the tick inside, uses the fact that the yAxis has 20 added.
    svg.selectAll('.tick line').attr('x1', '-10');

    if (isBubble) {
      svg.selectAll('.x.axis .tick line, .y.axis .tick line').style('opacity', 0);
      svg.select('.x.axis .tick line').attr('x2', '-10').style('opacity', 1);
      svg.select('.y.axis .tick line').style('opacity', 1);
    }

    if (charts.isRTL) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');
    }

    if (isAxisXRotate) {
      svg.selectAll('.x.axis .tick text')  // select all the text for the xaxis
      .attr('y', 0)
      .attr('x', function () {
        return -(this.getBBox().width + 10);
      })
      .attr('dy', '1em')
      .attr('transform', 'rotate(' + settings.xAxis.rotate + ')')
      .style('text-anchor', 'start');
    }

    if (settings.xAxis && settings.xAxis.formatText) {
      svg.selectAll('.x.axis .tick text').each(function(i) {
        var elem = d3.select(this),
          text = d3.select(this).text(),
          markup = settings.xAxis.formatText(text, i);

        elem.html(markup);
      });
    }

    // Create the line generator
    var line = d3.svg.line()
      .x(function(d, i) {
        if (!!settings.xAxis && !!settings.xAxis.parser)  {
          return xScale(settings.xAxis.parser(d, i));
        }
        return xScale(isBubble ? d.value.x : i);
      })
      .y(function(d) {
        return yScale(isBubble ? d.value.y : d.value);
      });

    //append the three lines.
    dataset.forEach(function(d, i) {

      var lineGroups = svg.append('g')
        .attr({'data-group-id': i, 'class': 'line-group'});

      if (isArea) {
        var area = d3.svg.area()
          .x(function(d, i) {
            return xScale(i);
          })
          .y0(height)
          .y1(function(d) {
            return yScale(isBubble ? d.value.y : d.value);
          });

        lineGroups.append('path')
          .datum(d.data)
          .attr('fill', function () { return charts.chartColor(i, 'line', d); })
          .style('opacity', '.2')
          .attr('class', 'area')
          .attr('d', area);
      }

      var path = lineGroups.append('path')
        .datum(d.data)
        .attr('d', line(d.data))
        .attr('stroke', function () { return isBubble ? '' : charts.chartColor(i, 'line', d); })
        .attr('stroke-width', 2)
        .attr('fill', 'none')
        .attr('class', 'line')
        .on('click.chart', function() {
          charts.selectElement(d3.select(this.parentNode), svg.selectAll('.line-group'), d);
        });

      // Add animation
      var totalLength = path.node().getTotalLength();
      path
        .attr('stroke-dasharray', totalLength + ' ' + totalLength)
        .attr('stroke-dashoffset', totalLength)
        .transition()
          .duration(charts.animate ? 750 : 0)
          .ease('cubic')
          .attr('stroke-dashoffset', 0);

      if (!hideDots) {
          lineGroups.selectAll('circle')
          .data(d.data)
          .enter()
          .append('circle')
          .attr('class', dots.class)
          .attr('cx', function (d, i) {
            if (!!settings.xAxis && !!settings.xAxis.parser)  {
              return xScale(settings.xAxis.parser(d, i));
            }
            return xScale(isBubble ? d.value.x : i);
          })
          .attr('cy', function (d) { return yScale(isBubble ? 0 : d.value); })
          .attr('r', dots.radius)
          .style('stroke-width', dots.strokeWidth)
          .style('fill', function () { return charts.chartColor(i, 'line', d); })
          .style('opacity', (isBubble ? '.7' : '1'))
          .on('mouseenter.chart', function(d2) {
            var rect = this.getBoundingClientRect(),
              content = '<p><b>' + d2.name + ' </b> ' + format(d2.value) + '</p>',

              show = function() {
                var size = charts.getTooltipSize(content),
                  x = rect.left - (size.width /2) + 6,
                  y = rect.top - size.height - 18;

                x = isBubble ? ((rect.left + (rect.width /2)) - (size.width /2)) : x;

                if(content !== '') {
                  charts.showTooltip(x, y, content, 'top');
                }
              };

            if (isBubble) {
              content = ''+
                '<div class="chart-swatch" style="min-width: 95px;">'+
                  '<div class="swatch-caption">'+
                    '<span style="background-color:'+ charts.chartColor(i, 'line', d) +';" class="indicator-box"></span>'+
                    '<b>'+ d.name +'</b>'+
                  '</div>';

                var obj = d2;
                for (var key in obj) {
                  if(obj.hasOwnProperty(key)) {
                    if (typeof obj[key] !== 'object') {
                      content += ''+
                        '<div class="swatch-row">'+
                          '<span>'+ labels[key] +'</span>'+
                          '<b>'+ obj[key] +'</b>'+
                        '</div>';
                    } else {
                      var obj2 = obj[key];
                      for (var key2 in obj2) {
                        if(obj2.hasOwnProperty(key2)) {
                          content += ''+
                            '<div class="swatch-row">'+
                              '<span style="text-transform: capitalize;">'+ labels[key][key2] +'</span>'+
                              '<b>'+ formatValue(valueFormatterString[key2], obj2[key2]) +'</b>'+
                            '</div>';
                        }
                      }
                    }
                  }
                }
              content += '</div>';
            }

            if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
              content = '';
              var runInterval = true;
              tooltipInterval = setInterval(function() {
                if(runInterval) {
                  runInterval = false;
                  tooltipData(function (data) {
                    content = tooltipDataCache[i] = data;
                  });
                }
                if(content !== '') {
                  clearInterval(tooltipInterval);
                  show();
                }
              }, 10);
            } else {
              tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
              content = tooltipDataCache[i] || tooltipData || d2.tooltip || d.tooltip || content || '';
              show();
            }

            //Circle associated with hovered point
            d3.select(this).attr('r', function (d) {
              return isBubble ? (2 + zScale(d.value.z)) : dots.radiusOnHover;
            });
          })
          .on('mouseleave.chart', function() {
            clearInterval(tooltipInterval);
            charts.hideTooltip();
            d3.select(this).attr('r', function (d) {
              return isBubble ? zScale(d.value.z) : dots.radius;
            });
          })
          .on('click.chart', function(d) {
            charts.selectElement(d3.select(this.parentNode), svg.selectAll('.line-group'), d);
          });

        if (isBubble) {
          // Add animation
          lineGroups.selectAll('circle')
            .attr('cy', function (d) { return yScale(d.value.y); })
            .transition().duration(charts.animate ? 750 : 0).ease('cubic')
            .attr('r', function (d) { return zScale(d.value.z); });
        }
      }

    });

    // Set y-axix tick css class
    svg.selectAll('.y.axis .tick').attr('class', function(d) {
      return 'tick' + (d === 0 ? ' tick0' : '');
    });

    var series = dataset.map(function (d) {
      return {color: d.color, name: d.name, selectionObj: svg.selectAll('.line-group'), selectionInverse: svg.selectAll('.line-group'), data: d};
    });

    if (charts.showLegend) {
      charts.addLegend(series);
    }
    charts.appendTooltip();

    charts.setSelected = function (o, isToggle) {
      var selected = 0,
        equals = window.Soho.utils.equals,
        selector, selectorData, elem,

        setSelected = function(d, i, d2, i2) {
          if (d2) {
            elem = svg.select('[data-group-id="'+ i +'"]')
                      .select('.dot:nth-child('+ (i2+2) +')');
            if ((typeof o.groupIndex === 'number' &&
                  typeof o.fieldName !== 'undefined' &&
                    typeof o.fieldValue !== 'undefined' &&
                      o.groupIndex === i &&
                        o.fieldValue === d2[o.fieldName]) ||
                (typeof o.index !== 'undefined' &&
                  typeof o.groupIndex === 'number' &&
                    o.groupIndex === i && o.index === i2) ||
                (o.elem && $(elem.node()).is(o.elem)) ||
                (o.data && equals(o.data, d2))) {
              selected++;
              selectorData = d2;
              selector = svg.select('[data-group-id="'+ i +'"]');
            }
          }
          else {
            elem = svg.select('[data-group-id="'+ i +'"]');
            if ((typeof o.groupName !== 'undefined' &&
                  typeof o.groupValue !== 'undefined' &&
                    o.groupValue === d[o.groupName]) ||
                (typeof o.groupIndex !== 'undefined' &&
                  o.groupIndex === i) ||
                (o.elem && $(elem.node()).is(o.elem)) ||
                (o.data && equals(o.data, d))) {
              selected++;
              selectorData = d;
              selector = elem;
            }
          }
        };

      dataset.forEach(function(d, i) {
        if (selected < 1 && d && d.data) {
          d.data.forEach(function(d2, i2) {
            if (selected < 1 && d2) {
              setSelected(d, i, d2, i2);
            }
          });
          if (selected < 1) {
            setSelected(d, i);
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        charts.selectElement(selector, svg.selectAll('.line-group'), selectorData);
      }
    };

    // Set initial selected
    (function () {
      var selected = 0,
        selector,
        selectorData,

        setSelected = function (node, d, i) {
          if (node.selected && selected < 1) {
            selected++;
            selector = d3.select(svg.selectAll('.line-group')[0][i]);
            selectorData = d;
          }
        };

      dataset.forEach(function(d, i) {
        if (d) {
          setSelected(d, d, i);
        }
      });
      dataset.forEach(function(d, i) {
        if (d || d.data) {
          d.data.forEach(function(d2) {
            setSelected(d2, d, i);
          });
        }
      });

      if (selected > 0) {
        charts.selectElement(selector, svg.selectAll('.line-group'), selectorData);
      }
    })();


    $(container).trigger('rendered');
    return $(container);
  };

  this.Bullet = function(chartData) {
    $(container).addClass('bullet-chart');

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    //Append the SVG in the parent area.
    var dataset = chartData,
      noMarkers = false,
      parent = $(container).parent(),
      margin = {top: 30, right: 55, bottom: 35, left: 55},
      width = parent.width() - margin.left - margin.right,
      height = parent.height() - margin.top - margin.bottom - 30; //legend

    height = height < 0 ? 50 : height; //default minimum height

    var svg = d3.select(container).append('svg')
              .attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom)
              .append('g')
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    //Functions Used in the Loop
    function bulletWidth(x) {
      var x0 = x(0);
      return function(d) {
        return Math.abs(x(d) - x0);
      };
    }

    for (var i = 0; i < dataset[0].data.length; i++) {
      var duration = charts.animate ? 600 : 0,
          barHeight = 20,
          rowData = dataset[0].data[i],
          ranges = rowData.ranges.slice().sort(d3.descending),
          markers = (rowData.markers ? rowData.markers.slice().sort(d3.descending) : []),
          measures = (rowData.measures ? rowData.measures.slice().sort(d3.descending) : []),
          rangesAsc = rowData.ranges.slice().sort(d3.ascending),
          markersAsc = (rowData.markers ? rowData.markers.slice().sort(d3.ascending) : []),
          measuresAsc = (rowData.measures ? rowData.measures.slice().sort(d3.ascending) : []);

      if (markers.length === 0) {
        markers = measures;
        markersAsc = measuresAsc;
        noMarkers = true;
      }

      var g = svg.append('g')
              .attr('class', 'bullet')
              .attr('transform', 'translate(0, ' + (i * (barHeight * 3.5)) + ')');

      //Add Title and Subtitle
      var title = g.append('g');

      var text = title.append('text')
          .attr('class', 'title')
          .attr('dy', '-10px')
          .text(function() { return rowData.title; });

      text.append('tspan')
          .attr('class', 'subtitle')
          .attr('dx', '15px')
          .text(function() { return rowData.subtitle; });

      var maxAll = Math.max(ranges[0], markers[0], measures[0]),
          minAll = Math.min(rangesAsc[0], markersAsc[0], measuresAsc[0]);

      minAll = minAll < 0 ? minAll : 0;

      // Compute the new x-scale.
      var x1 = d3.scale.linear()
          .domain([minAll, maxAll])
          .range([0, width])
          .nice();

      // Derive width-scales from the x-scales.
      var w1 = bulletWidth(x1);

      // Update the range rects.
      var range = g.selectAll('rect.range')
          .data(ranges);

      range.enter().append('rect')
          .attr('class', function(d, i) { return 'range s' + i; })
          .attr('data-idx', i)
          .attr('width', 0)
          .attr('x', function (d) { return x1(d < 0 ? d : 0); })
          .style('fill', function(d, i) {
            if (chartData[0].barColors) {
              return chartData[0].barColors[i];
            }
          })
          .attr('height', barHeight)
          .on('click', function () {
            var bar = d3.select(this);
            $(container).trigger('selected', [bar, chartData[0].data[bar.attr('data-idx')]]);
          })
          .on('mouseenter', function(d, i) {

            var bar = d3.select(this),
              data = chartData[0].data[bar.attr('data-idx')],
              rect = this.getBoundingClientRect(),
              content = '<p>' + d + '</p>',

              show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left + rect.width - (size.width/2),
                y = rect.top - size.height + $(window).scrollTop() - 5;

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

            if (data.tooltip && data.tooltip[i]) {
              content = data.tooltip[data.tooltip.length - i -1];
            }

            if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
              content = '';
              var runInterval = true;
              tooltipInterval = setInterval(function() {
                if(runInterval) {
                  runInterval = false;
                  tooltipData(function (data) {
                    content = tooltipDataCache[i] = data;
                  });
                }
                if(content !== '') {
                  clearInterval(tooltipInterval);
                  show();
                }
              }, 10);
            } else {
              tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
              content = tooltipDataCache[i] || tooltipData || content || '';
              show();
            }

          })
          .on('mouseleave', function() {
            clearInterval(tooltipInterval);
            charts.hideTooltip();
          });


      range.transition()
          .duration(duration)
          .attr('width', w1);

      // Update the measure rects.
      var measure = g.selectAll('rect.measure')
          .data(measures);

      measure.enter().append('rect')
          .attr('class', function(d, i) { return 'measure s' + i; })
          .attr('width', 0)
          .attr('height', 3)
          .attr('x', function (d) { return x1(d < 0 ? d : 0); })
          .style('fill', function(d,i) {
            if (chartData[0].lineColors) {
              return chartData[0].lineColors[i];
            }
          })
          .attr('y', 8.5);

      measure.transition()
          .duration(duration)
          .attr('width', w1);

      // Update the marker lines.
      var marker = g.selectAll('line.marker')
          .data(markers);

      marker.enter().append('line')
          .attr('class', (noMarkers ? 'hidden' : 'marker'))
          .attr('x1', 0)
          .attr('x2', 0)
          .style('stroke', function(d, i) {
            if (chartData[0].markerColors) {
              return chartData[0].markerColors[i];
            }
          })
          .attr('y1', barHeight / 6)
          .attr('y2', barHeight * 5 / 6);

      marker.transition()
          .duration(duration)
          .attr('x1', x1)
          .attr('x2', x1)
          .attr('y1', barHeight / 6)
          .attr('y2', barHeight * 5 / 6);

      //Difference
      var diff = (markers[0] > measures[0] ? '-' : '+') + Math.abs(markers[0] - measures[0]),
        line;

      if (Math.abs(markers[0] - measures[0]) !== 0) {
        line = marker.enter().append('text')
            .attr('class', 'inverse')
            .attr('text-anchor', 'middle')
            .attr('y', barHeight /2 + 4)
            .attr('dx', charts.isRTL ? '-20px' : '20px')
            .attr('x', 0)
            .text(diff);

          marker.transition()
              .duration(duration)
              .attr('x', function() {
                var total = 0;

                g.selectAll('.measure').each(function(d) {
                  var w = w1(d),
                    x = x1(d);

                  if (w > total) {
                    total = w;
                  }

                  if (x > total) {
                    total = x;
                  }
                });

                return charts.isRTL ? -total : total;
              })
              .style('opacity', 1);
      }

      // Update the tick groups.
      var tick = g.selectAll('g.tick')
          .data(x1.ticks(8));

      // Initialize the ticks with the old scale, x0.
      var tickEnter = tick.enter().append('g')
          .attr('class', 'tick')
          .attr('transform', 'translate(0,0)')
          .style('opacity', 0);

      tickEnter.append('line')
          .attr('y1', barHeight)
          .attr('y2', Math.round((barHeight * 7) / 4.7));

      tickEnter.append('text')
          .attr('text-anchor', 'middle')
          .attr('dy', '1.1em')
          .attr('y', Math.round((barHeight * 7) / 4.7))
          .attr('class', function(d) {
            return d < 0 ? 'negative-value' : 'positive-value';
          })
          .text(function (d) {
            return d;
          });

      // Transition the entering ticks to the new scale, x1.
      tickEnter.transition()
          .duration(duration)
          .attr('transform', function (d) {
            return 'translate(' + x1(d) + ',0)';
          })
          .style('opacity', 1);

      if (charts.isRTL && charts.isIE) {
        svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      }

    }

    //Add Legends
    //charts.addLegend(isStacked ? series);
    charts.appendTooltip();
    $(container).trigger('rendered');

  };

  //Completion chart
  this.Completion = function(chartData) {

    // Set vars
    var dataset = chartData[0].data[0],
      isTarget = charts.settings.type === 'completion-target',
      isAchievment = charts.settings.type === 'targeted-achievement';

    $(container).addClass('completion-chart' + (charts.settings.type === 'targeted-achievement' ? ' chart-targeted-achievement': ''));

    // Set total defaults
    dataset.total = $.extend({}, {value: 100}, dataset.total);

    // Basic functions
    var isUndefined = function(value) {
        return typeof value === 'undefined';
      },
      fixUndefined = function(value, isNumber) {
        return !isUndefined(value) ? value : (isNumber ? 0 : '');
      },
      toValue = function(percent, ds) {
        ds = ds || dataset;
        return percent /100 * fixUndefined(ds.total.value, true);
      },
      toPercent = function(value, ds) {
        ds = ds || dataset;
        return d3.round(100 * (value / fixUndefined(ds.total.value, true)));
      },
      localePercent = function (value) {
        return Locale.formatNumber(value/100, {style: 'percent', maximumFractionDigits: 0});
      },
      format = function (value, formatterString, ds) {
        if (formatterString === '.0%') {
          return localePercent(toPercent(value, ds));
        }
        return d3.format(formatterString || '')(value);
      },
      fixPercent = function(value, ds) {
        var s = value.toString();
        if (s.indexOf('%') !== -1) {
          return toValue(s.replace(/%/g, ''), ds);
        }
        return value;
      },
      updateWidth = function(elem, value, ds) {
        var percent = toPercent(value, ds),
          w = percent > 100 ? 100 : (percent < 0 ? 0 : percent);
        elem[0].style.width = w + '%';
      },
      updateTargetline = function(elem, value) {
        var w = value > 100 ? 100 : (value < 0 ? 0 : value);
        elem[0].style.left = w + '%';
      },
      setFormat = function(obj, ds, isPrivate) {
        var value = isPrivate ? obj._value : obj.value;
        return (obj && !isUndefined(value) && obj.format) ?
          format(fixPercent(value, ds), obj.format, ds) :
          (obj ? fixPercent(value, ds) : 0);
      },
      setOverlap = function() {
        if (isTarget && !isAchievment) {
          setTimeout(function() {
            var remaining = $('.remaining', container),
              total = $('.total', container),
              rect1 = $('.completed .value', container)[0].getBoundingClientRect(),
              rect2 = remaining.find('.value')[0].getBoundingClientRect();

            remaining.add(total)
              [(rect1.right > rect2.left-20) ? 'addClass' : 'removeClass']('overlap');
          }, 500);
        }
      },
      getSpecColor = function(ds) {
        var specColor = {};
        ds = ds || dataset;

        if (ds.info && !isUndefined(ds.info.color)) {
          if (dataset.info.color.indexOf('#') === 0) {
            specColor.info = true;
          }
        }
        if (ds.completed && !isUndefined(ds.completed.color)) {
          if (ds.completed.color.indexOf('#') === 0) {
            specColor.completed = true;
          }
        }
        if (ds.remaining && !isUndefined(ds.remaining.color)) {
          if (ds.remaining.color.indexOf('#') === 0) {
            specColor.remaining = true;
          }
        }
        if (ds.targetline && !isUndefined(ds.targetline.color)) {
          if (ds.targetline.color.indexOf('#') === 0) {
            specColor.targetline = true;
          }
        }
        return specColor;
      },
      getTotalText = function(ds) {
        var totalText,
          difference = {};

        ds = ds || dataset;

        if (ds.total.difference) {
          difference.value = (ds.total.value - ds.completed.value);
          difference.format = dataset.total.format;
        }

        totalText = (!ds.total.textOnly ? setFormat(ds.total.difference ? difference : ds.total) : '') + (ds.total.text || '');

        totalText = isAchievment && ds.remaining ?
          (!ds.remaining.textOnly ? setFormat(ds.remaining) : '') + (ds.remaining.text || ''): totalText;

        return totalText;
      },
      resetColor = function(node, color) {
        color = color || '';
        if (color.indexOf('#') === 0) {
          node.css({color: ''});
        } else {
          node.removeClass(color);
        }
      },
      updateColor = function(node, color) {
        color = color || '';
        var specColor = color.indexOf('#') === 0;
        if (specColor) {
          node.css({color: color});
        } else if (color !== '') {
          node.addClass(color);
        }
      },
      percentTextDefault = {show: false, color1: '', color2: 'inverse'},
      percentText = $.extend({}, percentTextDefault, dataset.percentText),
      setPercentText = function (ds) {
        ds = ds || dataset;
        percentText._value = ds.completed ? ds.completed.value : 0;
        percentText.percent = toPercent(fixUndefined(percentText._value, true), ds);
        percentText.format = '.0%';
        percentText._text = (typeof percentText.text !== 'undefined' ?
          percentText.text : (typeof percentText.value !== 'undefined' ?
            localePercent(percentText.value) : setFormat(percentText, ds, true)));
        percentText.color = percentText[percentText.percent > 55 ? 'color2': 'color1'];
      },
      c,// Cache will after created
      cacheElements = function () {
        c = {
          name: $('.name', container),
          info: {
            value: $('.info .value', container),
            text: $('.info .text', container)
          },
          completed: {
            bar: $('.completed.bar', container),
            value: $('.completed .value', container),
            text: $('.completed .text, .completed-label .text', container)
          },
          remaining: {
            bar: $('.remaining.bar', container),
            value: $('.remaining .value', container),
            text: $('.remaining .text', container)
          },
          targetline: {
            bar: $('.targetline', container),
            value: $('.targetline .value', container),
            text: $('.targetline .text', container)
          },
          total: {
            bar: $('.total.bar', container),
            value: $('.total.value', container),
          },
          percentText: $('.chart-percent-text', container)
        };
      },
      setJsonData = function(ds) {
        ds = ds || dataset;
        c.name.data('jsonData', {name: ds.name});
        c.info.value.add(c.info.text).data('jsonData', {info: ds.info});
        c.completed.bar.add(c.completed.value).add(c.completed.text)
          .data('jsonData', {completed: ds.completed});
        c.remaining.bar.add(c.remaining.value).add(c.remaining.text)
          .data('jsonData', {remaining: ds.remaining});
        c.targetline.bar.add(c.targetline.value).add(c.targetline.text)
          .data('jsonData', {targetline: ds.targetline});
        c.total.bar.add(c.total.value).data('jsonData', {total: ds.total});
        c.percentText.data('jsonData', {percentText: ds.percentText});
      },
      updateBars = function(ds) {
        var w;
        ds = ds || dataset;
        // Update completed bar width
        if (ds.completed) {
          w = fixPercent(ds.completed.value, ds);
          updateWidth(c.completed.bar, w, ds);
        }

        // Update remaining bar width
        if (ds.remaining) {
          w = fixPercent(ds.completed.value, ds) + fixPercent(ds.remaining.value, ds);
          updateWidth(c.remaining.bar, w, ds);
          setOverlap();
        }

        // Update target line bar position
        if (ds.targetline) {
          w = fixPercent(ds.targetline.value, ds);
          updateTargetline(c.targetline.bar, w, ds);
        }
      };

      if (!isUndefined(percentText.color) && percentText.color1 === '') {
        percentText.color1 = percentText.color;
      }

      this.update = function(o) {
        //$(container).triggerHandler('selected', [d3.select(this)[0], {}, i]);
        if (isAchievment) {
          var ds = $.extend(true, {}, dataset, o),
            parent, child;

          for (var key in o) {
            if (o.hasOwnProperty(key)) {
              parent = key;
              child = o[key];
              if(child instanceof Object) {
                for (var k in child) {
                  if (child.hasOwnProperty(k)) {

                    if (parent === 'completed') {
                      if (k === 'text') {
                        c.completed.text.html(child[k]);
                      }
                      if (k === 'color') {
                        resetColor(c.completed.bar.add(c.completed.value).add(c.completed.text), dataset.completed.color);
                        updateColor(c.completed.bar.add(c.completed.value).add(c.completed.text), child[k]);
                      }
                      if (k === 'value') {
                        if (dataset.remaining && dataset.remaining.value &&
                            dataset.completed && dataset.completed.value &&
                            (!o.remaining || (o.remaining && !o.remaining.value))) {
                          ds.remaining.value = (dataset.completed.value + dataset.remaining.value) - ds.completed.value;
                        }
                        c.total.value.html(getTotalText(ds));
                        updateBars(ds);
                        resetColor(c.percentText, percentText.color);
                        setPercentText(ds);
                        updateColor(c.percentText, percentText.color);
                        c.percentText.html(percentText._text);
                      }
                      c.completed.bar.add(c.completed.value).add(c.completed.text)
                        .data('jsonData', {completed: ds.completed});
                    }

                    if (parent === 'remaining') {
                      if (k === 'text') {
                        c.total.value.html(getTotalText(ds));
                      }
                      if (k === 'color') {
                        resetColor(c.total.value, dataset.remaining.color);
                        updateColor(c.total.value, child[k]);
                      }
                      if (k === 'value') {
                        c.total.value.html(getTotalText(ds));
                        updateBars(ds);
                        resetColor(c.percentText, percentText.color);
                        setPercentText(ds);
                        updateColor(c.percentText, percentText.color);
                        c.percentText.html(percentText._text);
                      }
                      c.remaining.bar.add(c.remaining.value).add(c.remaining.text)
                        .data('jsonData', {remaining: ds.remaining});
                    }

                    if (parent === 'total') {
                      if (k === 'text') {
                        c.total.value.html(getTotalText(ds));
                      }
                      if (k === 'color') {
                        resetColor(c.total.value, dataset.total.color);
                        updateColor(c.total.value, child[k]);
                      }
                      if (k === 'value' || k === 'difference') {
                        c.total.value.html(getTotalText(ds));
                        updateBars(ds);
                        resetColor(c.percentText, percentText.color);
                        setPercentText(ds);
                        updateColor(c.percentText, percentText.color);
                        c.percentText.html(percentText._text);
                      }
                      c.total.bar.add(c.total.value).data('jsonData', {total: ds.total});
                    }

                    if (parent === 'percentText') {
                      if (k === 'show') {
                        c.percentText[child[k] ? 'show' : 'hide']();
                      }
                      if (k === 'color' || k === 'color1' || k === 'color2') {
                        resetColor(c.percentText, percentText.color);
                        setPercentText(ds);
                        updateColor(c.percentText, child[k]);
                        c.percentText.html(percentText._text);
                      }
                      c.percentText.data('jsonData', {percentText: ds.percentText});
                    }

                    if (parent === 'name') {
                      if (k === 'text') {
                        c.name.html(child[k]).data('jsonData', {name: ds.name});
                      }
                    }

                  }
                }
              }
            }
          }
          dataset = ds;
          $(container).triggerHandler('updated');
          return;
        }

        var type, bar, nodes, jsonData;
        if (!o.data) {
          return;
        }

        if (!o.type) {
          nodes = o.node;
        }
        else {
          type = o.type;
          if (!dataset[type]) {
            return;
          }
          nodes = (type === 'name') ?
            $('.name', container) : ((type === 'total') ?
              $('.total.value', container) :
                $('.'+ type +' .value, .'+ type +' .text', container));
        }

        jsonData = (nodes.length === 1 ? nodes : nodes.first()).data('jsonData');

        type = jsonData ? Object.keys(jsonData)[0] : 'name';
        bar = $('.'+ type +'.bar', container);
        $.extend(true, dataset[type], o.data);

        nodes.each(function() {
          var node = $(this);

          // Update text
          if (o.data.text && node.is('.name, .text')) {
            node.html(fixUndefined(dataset[type].text));
          }

          // Update color for text, value, bar
          if (o.data.color && node.is('.name, .info, .text, .value')) {
            if (o.data.color.indexOf('#') === -1) {
              ((type === 'completed' && (!dataset.info || (dataset.info && isUndefined(dataset.info.value)))) ?
                node.add($('.info .value', container)) : node).add(bar)
                  .removeClass('error dark good primary amethyst07')
                  .addClass(o.data.color);
            }
            else {
              if (node.is('.name, .total')) {
                node[0].style.color = dataset[type].color;
              }
              else {
                ((type === 'completed' && (!dataset.info || (dataset.info && isUndefined(dataset.info.value)))) ?
                  $('.'+ type +' .value, .'+ type +' .text, .info .value', container) :
                  $('.'+ type +' .value, .'+ type +' .text', container))[0].style.color = dataset[type].color;
                bar[0].style.backgroundColor = dataset[type].color;
              }
            }
          }

          // Update value & bar width
          if (o.data.value && node.is('.value')) {
            var w,
              completed = $('.completed', container),
              remaining = $('.remaining', container);

            if (type === 'completed') {
              ((!dataset.info || (dataset.info && isUndefined(dataset.info.value))) ?
                node.add($('.info .value', container)) : node)
                  .html(setFormat(dataset[type]));

              if (toPercent(fixPercent(dataset[type].value)) >= 100) {
                remaining.hide();
                completed[0].style.marginTop = 'inherit';
              }
            }
            else {
              node.html(setFormat(dataset[type]));
            }

            if (!node.is('.name, .total') && type !== 'targetline') {
              if (type === 'completed') {
                w = fixPercent(dataset[type].value);
                updateWidth(bar, w);
                w += fixPercent(dataset.remaining.value);
                updateWidth($('.remaining.bar', container), w);
              }
              else if (type === 'remaining') {
                w = fixPercent(dataset[type].value) + fixPercent(dataset.completed.value);
                updateWidth(bar, w);
              }
            }
            else if (!node.is('.name, .total, .remaining') && type === 'targetline') {
              w = fixPercent(dataset[type].value);
              updateTargetline(bar, w);
            }
            setOverlap();
          }
        });
        $(container).triggerHandler('updated');
      };

    // Render
    var html = {body: $('<div class="total bar" />')},
      specColor = getSpecColor();

    if (isTarget || isAchievment) {
      var totalText = getTotalText();

      html.body.addClass('chart-completion-target' + (isAchievment ? ' chart-targeted-achievement' : ''));

      html.label = ''+
      '<span class="label">'+
        '<span class="name">'+
        (dataset.completed.color && dataset.completed.color === 'error' ? $.createIcon({icon:'error', classes:'icon-error'}) : '' ) +
        fixUndefined(dataset.name.text) + '</span>'+
        '<span class="l-pull-right total value">'+ totalText +'</span>'+
      '</span>';
    }
    else {
      html.body.addClass('chart-completion');
      html.label = ''+
      '<b class="label name">'+ fixUndefined(dataset.name.text) +'</b>'+
      '<b class="label info'+ (dataset.info.color && !specColor.info ?
        ' '+ fixUndefined(dataset.info.color) :
          (!specColor.completed ? ' '+ fixUndefined(dataset.completed.color) : '') +' colored') +'">'+
        '<span class="value'+ (dataset.info.color && !specColor.info ?
          ' '+ fixUndefined(dataset.info.color) :
            (!specColor.completed ? ' '+ fixUndefined(dataset.completed.color) : '')) +'"'+ (dataset.info.color && specColor.info ?
              ' style="color:'+ (fixUndefined(dataset.info.color) +';"') :
                (specColor.completed ? ' style="color:'+ (fixUndefined(dataset.completed.color) +';"') : '')) +'>'+
        (dataset.info && !isUndefined(dataset.info.value) ? fixUndefined(dataset.info.value) :
          setFormat(dataset.completed)) +
        '</span> '+
        '<span class="text'+ (dataset.info.color && !specColor.info ?
          ' '+ fixUndefined(dataset.info.color) :
            (!specColor.completed ? ' '+ fixUndefined(dataset.completed.color) : '')) +'"'+ (dataset.info.color && specColor.info ?
              ' style="color:'+ (fixUndefined(dataset.info.color) +';"') :
                (specColor.completed ? ' style="color:'+ (fixUndefined(dataset.completed.color) +';"') : '')) +'>'+ fixUndefined(dataset.info.text) +'</span>'+
      '</b>';
    }

    if (dataset.remaining) {
      html.remaining = ''+
      '<div class="target remaining bar'+ (!specColor.remaining ? ' '+ fixUndefined(dataset.remaining.color) : '') +'"'+ (specColor.remaining ? (' style="color:'+ dataset.remaining.color +';background-color:'+ dataset.remaining.color +';"') : '') +'">'+
      (isAchievment ? '' : '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value'+ (!specColor.remaining ? ' '+ fixUndefined(dataset.remaining.color) : '') +'"'+ (specColor.remaining ? (' style="color:'+ dataset.remaining.color +';"') : '') +'">'+
            setFormat(dataset.remaining) +
          '</span><br />'+
          '<span class="text'+ (!specColor.remaining ? ' '+ fixUndefined(dataset.remaining.color) : '') +'"'+ (specColor.remaining ? (' style="color:'+ dataset.remaining.color +';"') : '') +'">'+
            fixUndefined(dataset.remaining.text) +
          '</span>'+
        '</span>') +
      '</div>';
    } else {
      html.remaining = '<div class="target remaining bar" style="opacity: 0"></div>';
    }

    if (dataset.completed && isAchievment) {
      setPercentText();
      specColor.percentText = percentText.color.indexOf('#') === 0;

      html.completed = ''+
      '<div class="completed bar'+ (!specColor.completed ? ' '+ fixUndefined(dataset.completed.color) : '') +'"'+ (specColor.completed ? (' style="color:'+ dataset.completed.color +';background-color:'+ dataset.completed.color +';"') : '') +'"></div>'+
      (percentText.show ? '<div class="chart-percent-text'+ (!specColor.percentText && percentText.color !== '' ? ' '+ percentText.color : '') +'"'+ (specColor.percentText ? (' style="color:'+ percentText.color +';"') : '') +'>'+ percentText._text +'</div>' : '')+
        '<span class="completed-label" aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="text">'+
            fixUndefined(dataset.completed.text) +
          '</span>'+
        '</span>';
    }

    if (dataset.completed && !isAchievment) {
      html.completed = ''+
      '<div class="completed bar'+ (!specColor.completed ? ' '+ fixUndefined(dataset.completed.color) : '') +'"'+ (specColor.completed ? (' style="color:'+ dataset.completed.color +';background-color:'+ dataset.completed.color +';"') : '') +'>'+
        '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value'+ (!specColor.completed ? ' '+ fixUndefined(dataset.completed.color) : '') +'"'+ (specColor.completed ? (' style="color:'+ dataset.completed.color +';"') : '') +'">'+ setFormat(dataset.completed) +'</span><br />'+
          '<span class="text'+ (!specColor.completed ? ' '+ fixUndefined(dataset.completed.color) : '') +'"'+ (specColor.completed ? (' style="color:'+ dataset.completed.color +';"') : '') +'">'+
            fixUndefined(dataset.completed.text) +
          '</span>'+
        '</span></div>';
    }

    if (dataset.targetline) {
      html.targetline = ''+
      '<div class="target-line targetline bar'+ (!specColor.targetline ? ' '+ fixUndefined(dataset.targetline.color) : '') +'"'+ (specColor.targetline ? (' style="color:'+ dataset.targetline.color +';background-color:'+ dataset.targetline.color +';"') : '') +'">'+
        '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value'+ (!specColor.targetline ? ' '+ fixUndefined(dataset.targetline.color) : '') +'"'+ (specColor.targetline ? (' style="color:'+ dataset.targetline.color +';"') : '') +'">'+
            setFormat(dataset.targetline) +
            '</span><br />'+
            '<span class="text'+ (!specColor.targetline ? ' '+ fixUndefined(dataset.targetline.color) : '') +'"'+ (specColor.targetline ? (' style="color:'+ dataset.targetline.color +';"') : '') +'">'+
              fixUndefined(dataset.targetline.text) +
            '</span>'+
        '</span>'+
      '</div>';
    }

    html.body.append(html.remaining, html.completed, html.targetline);
    $(container).append(html.label, html.body);

    cacheElements();
    setJsonData();
    updateBars();
  };

  //Select the element and fire the event, make the inverse selector opace
  this.selectElement = function(elem, inverse, data) {
    var isSelected = elem.node() && elem.classed('is-selected'),
      triggerData = [{elem: elem, data: (!isSelected ? data : {})}];

    inverse.classed('is-selected', false)
      .classed('is-not-selected', !isSelected);

    elem.classed('is-not-selected', false)
      .classed('is-selected', !isSelected);

    this._selected = $.isEmptyObject(triggerData[0].data) ? [] : triggerData;

    //Fire Events
     $(container).triggerHandler('selected', [triggerData]);
  };

  // Make bars to be Selected or Unselected
  this.setSelectedElement = function (o) {
    var s = charts.settings,
      dataset = s.dataset,
      isPositiveNegative = s.type === 'column-positive-negative',
      isTypeHorizontalBar = s.chartType === 'HorizontalBar',
      isTypeColumn = s.chartType === 'Column',
      isTypePie = s.chartType === 'Pie',

      svg = s.svg,
      isSingle = s.isSingle,
      isGrouped = s.isGrouped,
      isStacked = s.isStacked,
      isSingular = s.isSingular,

      taskSelected = (o.task === 'selected'),
      selector = d3.select(o.selector),
      isPositive = selector.classed('positive'),
      ticksX = svg.selectAll('.axis.x .tick'),
      ticksY = svg.selectAll('.axis.y .tick'),
      pnPositiveText = svg.selectAll('.bartext.positive, .target-bartext.positive'),
      pnNegativeText = svg.selectAll('.bartext.negative, .target-bartext.negative'),
      thisGroup = d3.select(o.selector.parentNode),
      thisGroupId = parseInt((thisGroup.node() ? thisGroup.attr('data-group-id') : 0), 10),
      triggerData = [],
      selectedBars = [],
      thisData;

    if (isStacked || isTypePie) {
      dataset = dataset || null;
    } else {
      dataset = (dataset && dataset[thisGroupId]) ? dataset[thisGroupId].data : null;
    }

    ticksX.style('font-weight', 'normal');
    ticksY.style('font-weight', 'normal');
    pnPositiveText.style('font-weight', 'normal');
    pnNegativeText.style('font-weight', 'normal');
    svg.selectAll('.is-selected').classed('is-selected', false);

    // Task make selected
    if (taskSelected) {
      svg.selectAll('.bar, .target-bar').style('opacity', 0.6);

      // By legends only
      if (s.isByLegends && !isTypePie) {
        if (isPositiveNegative) {
          s.svg.selectAll(isPositive ?
            '.bar.positive, .target-bar.positive': '.bar.negative, .target-bar.negative')
              .classed('is-selected', true).style('opacity', 1);

          (isPositive ? pnPositiveText : pnNegativeText).style('font-weight', 'bolder');

          svg.selectAll('.bar').each(function(d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({elem: bar[0], data: (dataset ? dataset[i] : d)});
            }
          });
          triggerData = selectedBars;
        }
        // Grouped and stacked only -NOT singular-
        else if (isTypeColumn || isTypeHorizontalBar) {
          if (isGrouped || isSingular) {
            s.svg.selectAll('.series-'+ o.i).classed('is-selected', true).style('opacity', 1);
          } else {
            thisGroup.classed('is-selected', true)
              .selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          svg.selectAll('.bar.is-selected').each(function(d, i) {
            var bar = d3.select(this);

            thisData = s.dataset;
            thisData = thisData ? (isStacked ? isSingular ? (thisData[0].data[o.i]) : (thisData[o.i].data[i]) : thisData[i].data[o.i]) : d;
            selectedBars.push({elem: bar[0], data: thisData});
          });
          triggerData = selectedBars;
        }
      }

      // Single and stacked only -NOT grouped-
      else if (isSingular && isStacked && isTypeColumn) {
        thisData = dataset[0] && dataset[0].data ? dataset[0].data : o.d;
        selector.classed('is-selected', true).style('opacity', 1);
        triggerData.push({elem: selector[0], data: thisData[o.i]});
      }

      // Single or groups only -NOT stacked-
      else if ((isSingle || isGrouped) && !isStacked && (isTypeColumn || isTypeHorizontalBar)) {
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') +' .tick:nth-child('+ ((isGrouped ? thisGroupId : o.i) + 1) +')')
          .style('font-weight', 'bolder');

        selector.classed('is-selected', true).style('opacity', 1);
        svg.select('.target-bar.series-'+ o.i).style('opacity', 1);
        d3.select(svg.selectAll('.bartext')[0][o.i]).style('font-weight', 'bolder');
        d3.select(svg.selectAll('.target-bartext')[0][o.i]).style('font-weight', 'bolder');

        if (isGrouped || isPositiveNegative || isTypeColumn) {
          if (!isPositiveNegative && !isTypeColumn || (isTypeColumn && isGrouped)) {
            thisGroup.classed('is-selected', true)
              .selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          thisGroup.selectAll('.bar').each(function(d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({elem: bar[0], data: (dataset ? dataset[i] : d)});
            }
          });
          if (isGrouped) {
            triggerData.push({groupIndex: thisGroupId, groupElem: thisGroup[0], groupItems: selectedBars});
          } else {
            triggerData = selectedBars;
          }
        }
      }

      // Stacked Only
      else if (isTypeColumn || isTypeHorizontalBar) {
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') +' .tick:nth-child('+ (o.i + 1) +')')
          .style('font-weight', 'bolder');

        svg.selectAll('.bar:nth-child('+ (o.i + 1) +')')
          .classed('is-selected', true).style('opacity', 1);

        svg.selectAll('.bar.is-selected').each(function(d, i) {
          var bar = d3.select(this);
          selectedBars.push({elem: bar[0], data: (dataset ? dataset[i].data[o.i] : d)});
        });
        triggerData = selectedBars;
      }

      // Pie
      else if (isTypePie) {
        //Unselect selected ones
        svg.selectAll('.arc')
          .style({'stroke': '', 'stroke-width': ''})
          .attr('transform', '');

        var color = charts.chartColor(o.i, 'pie', o.d.data),
          thisArcData = dataset && dataset[0] && dataset[0].data ? dataset[0].data[o.i] : (o.d ? o.d.data : o.d);
        selector.classed('is-selected', true)
          .style({'stroke': color, 'stroke-width': 0})
          .attr('transform', 'scale(1.025, 1.025)');
        triggerData.push({elem: selector[0], data: thisArcData, index: o.i});
      }
    }
    // Task make unselected
    else {
      svg.selectAll('.bar, .target-bar').style('opacity', 1);
      pnPositiveText.style('font-weight', 'bolder');
      pnNegativeText.style('font-weight', 'bolder');

      if (isTypePie) {
        selector.classed('is-selected', false)
          .style('stroke', '#fff')
          .style('stroke-width', '1px')
          .attr('transform', '');
      }
    }

    if (s.isByLegends) {
      s.isByLegends = false;
    }

    this._selected = triggerData;

    if (o.isTrigger) {
      $(o.container).triggerHandler((taskSelected ? 'selected' : 'unselected'), [triggerData]);
    }
  };

  this.isHTML = function (str) {
    return /(<([^>]+)>)/i.test(str);
  };

  this.initChartType = function (options) {
    //default
    this.options = options;
    this.animate = true;
    this.redrawOnResize = true;
    this.isRTL = Locale.isRTL();
    this.isIE = $('html').hasClass('ie');

    /**
    * Set Animation Type
    * @param {Boolean} animate  &nbsp;-&nbsp; true|false - will do or not do the animation.
    * @param {String} animate  &nbsp;-&nbsp; 'initial' will do only first time the animation.
    */
    if (options.animate !== undefined) {
      this.animate = (options.animate === 'initial') ?
        (this._animateIndex === 0) :
        (!(options.animate === false || options.animate === 'false'));
      this._animateIndex++;
    }

    if (options.redrawOnResize !== undefined) {
      this.redrawOnResize = options.redrawOnResize;
    }
    if (options.format) {
      this.format = options.format;
    }
    if (options.tooltip) {
      this.tooltip = options.tooltip;
    }
    if (options.showLegend) {
      this.showLegend = options.showLegend;
    }
    if (options.legendformatter) {
      this.legendformatter = options.legendformatter;
    }
    // Prevent error from passed empty dataset
    if (!options.dataset || !options.dataset.length) {
      $.extend(true, options, {dataset: [{data: []}]});
    }
    if (options.type === 'pie') {
      this.Pie(options.dataset, false, options);
    }
    if (options.type === 'bar' || options.type === 'bar-stacked') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset);
    }
    if (options.type === 'bar-normalized') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset, true);
    }
    if (options.type === 'bar-grouped') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset, true, false); //dataset, isNormalized, isStacked
    }
    if (options.type === 'column-stacked') {
      this.Column(options.dataset, true);
    }
    if (['column', 'column-grouped', 'column-positive-negative'].indexOf(options.type) > -1) {
      this.Column(options.dataset);
    }
    if (options.type === 'donut') {
      this.Pie(options.dataset, true, options);
    }
    if (options.type === 'sparkline') {
      this.Sparkline(options.dataset, options);
    }
    if (options.type === 'sparkline-dots') {
      this.Sparkline(options.dataset, {isDots: true});
    }
    if (options.type === 'sparkline-peak') {
      this.Sparkline(options.dataset, {isPeakDot: true});
    }
    if (options.type === 'sparkline-dots-n-peak') {
      this.Sparkline(options.dataset, {isDots: true, isPeakDot: true});
    }
    if (options.type === 'sparkline-minmax') {
      this.Sparkline(options.dataset, {isMinMax: true});
    }
    if (options.type === 'sparkline-medianrange') {
      this.Sparkline(options.dataset, {isMedianRange: true});
    }
    if (options.type === 'sparkline-medianrange-n-peak') {
      this.Sparkline(options.dataset, {isMedianRange: true, isPeakDot: true});
    }
    if (options.type === 'line') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options);
    }
    if (options.type === 'area') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options, true);
    }
    if (options.type === 'bubble') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options, false, true);
    }
    if (options.type === 'bullet') {
      this.Bullet(options.dataset);
    }
    if (options.type === 'completion' ||
        options.type === 'completion-target' || options.type === 'targeted-achievement') {
      this.redrawOnResize = false;
      this.Completion(options.dataset);
    }
  };

};

//Make it a plugin
$.fn.chart = function(options) {
  return this.each(function() {
    var instance = $.data(this, 'chart'),
      chartInst;

    if (instance) {
      $(window).off('resize.line');
      $(window).off('resize.pie');
      $(window).off('resize.charts load.charts');
      $(this).empty();
    }

    chartInst = new Chart(this, options);
    instance = $.data(this, 'chart', chartInst);
    instance.settings = options;
    instance._animateIndex = 0;
    instance.destroy = function() {
      instance.tooltip.remove();
      instance.container.find('*').off();
      instance.container.removeClass('chart-vertical-bar chart-pie column-chart line-chart bubble bullet-chart completion-chart chart-targeted-achievement chart-completion-target chart-targeted-achievement chart-completion').empty();
      $.removeData(instance.container[0], 'chart');
    };
    instance.setSelected = function() {};
    instance.toggleSelected = function(o) {
      this.setSelected(o, true);
    };
    instance._selected = [];
    instance.getSelected = function() {
      return this._selected;
    };

    if ($.isEmptyObject(chartInst)) {
     return;
    }

    setTimeout(function () {
      chartInst.initChartType(options);
      chartInst.handleResize();
    }, instance ? 0 : 300);

  });
};

  $.fn.colorpicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'colorpicker',
        defaults = {

          // Theme key: MUST match with theme file name (ie: [filename: 'light-theme.css' -> 'light-theme'])

          // BORDERS
          // Use (,) commas to separate themes or single entry for border as:
          // colors[{label: 'Slate', number: '01', value: 'F0F0F0', border: 'light-theme, high-contrast-theme'}]
          // and assign which swatch theborder should apply ['all' or 'matched-only']
          // themes: { 'high-contrast-theme': {'border': 'all'} }

          // CHECKMARKS
          // checkmark: {'one': [1, 2], 'two': [3, 10]}
          // will add class as "checkmark-{key}", where current colors number is in range [{value[0]} to {value[1]}]
          // will add class "checkmark-one", where current colors number is in range [1 to 3]
          // and will add class "checkmark-two", where current colors number is in range [3 to 10]
          themes: {
            'light': {'border': 'matched-only', checkmark: {'one': [1, 2], 'two': [3, 10]} },
            'dark': {'border': 'matched-only', checkmark: {'one': [1, 2], 'two': [3, 10]} },
            'high-contrast': {'border': 'all', checkmark: {'one': [1, 3], 'two': [4, 10]} }
          },
          colors: [
            {label: 'Slate', number: '10', value: '1a1a1a'},
            {label: 'Slate', number: '09', value: '292929'},
            {label: 'Slate', number: '08', value: '383838', border: 'dark'},
            {label: 'Slate', number: '07', value: '454545', border: 'dark'},
            {label: 'Slate', number: '06', value: '5C5C5C'},
            {label: 'Slate', number: '05', value: '737373'},
            {label: 'Slate', number: '04', value: '999999'},
            {label: 'Slate', number: '03', value: 'BDBDBD'},
            {label: 'Slate', number: '02', value: 'D8D8D8'},
            {label: 'Slate', number: '01', value: 'F0F0F0', border: 'light, high-contrast'},
            {label: 'Amber', number: '10', value: 'D66221'},
            {label: 'Amber', number: '09', value: 'DE7223'},
            {label: 'Amber', number: '08', value: 'E68425'},
            {label: 'Amber', number: '07', value: 'EB9728'},
            {label: 'Amber', number: '06', value: 'EFAA30'},
            {label: 'Amber', number: '05', value: 'F2BC41'},
            {label: 'Amber', number: '04', value: 'F4C951'},
            {label: 'Amber', number: '03', value: 'F7D475'},
            {label: 'Amber', number: '02', value: 'F8E09C'},
            {label: 'Amber', number: '01', value: 'FBE9BF'},
            {label: 'Ruby', number: '10', value: '880E0E'},
            {label: 'Ruby', number: '09', value: '941E1E'},
            {label: 'Ruby', number: '08', value: 'A13030'},
            {label: 'Ruby', number: '07', value: 'AD4242'},
            {label: 'Ruby', number: '06', value: 'B94E4E'},
            {label: 'Ruby', number: '05', value: 'C65F5F'},
            {label: 'Ruby', number: '04', value: 'D26D6D'},
            {label: 'Ruby', number: '03', value: 'DE8181'},
            {label: 'Ruby', number: '02', value: 'EB9D9D'},
            {label: 'Ruby', number: '01', value: 'F4BCBC'},
            {label: 'Turquoise', number: '10', value: '0E5B52'},
            {label: 'Turquoise', number: '09', value: '206B62'},
            {label: 'Turquoise', number: '08', value: '317C73'},
            {label: 'Turquoise', number: '07', value: '448D83'},
            {label: 'Turquoise', number: '06', value: '579E95'},
            {label: 'Turquoise', number: '05', value: '69ADA3'},
            {label: 'Turquoise', number: '04', value: '7BBFB5'},
            {label: 'Turquoise', number: '03', value: '8ED1C6'},
            {label: 'Turquoise', number: '02', value: 'A9E1D6'},
            {label: 'Turquoise', number: '01', value: 'C0EDE3'},
            {label: 'Emerald', number: '10', value: '397514'},
            {label: 'Emerald', number: '09', value: '44831F'},
            {label: 'Emerald', number: '08', value: '56932E'},
            {label: 'Emerald', number: '07', value: '66A140'},
            {label: 'Emerald', number: '06', value: '76B051'},
            {label: 'Emerald', number: '05', value: '89BF65'},
            {label: 'Emerald', number: '04', value: '9CCE7C'},
            {label: 'Emerald', number: '03', value: 'AFDC91'},
            {label: 'Emerald', number: '02', value: 'C3E8AC'},
            {label: 'Emerald', number: '01', value: 'D5F6C0'},
            {label: 'Amethyst', number: '10', value: '4B2A5E'},
            {label: 'Amethyst', number: '09', value: '5A3A6F'},
            {label: 'Amethyst', number: '08', value: '6C4B81'},
            {label: 'Amethyst', number: '07', value: '7D5F92'},
            {label: 'Amethyst', number: '06', value: '8E72A4'},
            {label: 'Amethyst', number: '05', value: 'A189B8'},
            {label: 'Amethyst', number: '04', value: 'B59ECA'},
            {label: 'Amethyst', number: '03', value: 'C7B4DB'},
            {label: 'Amethyst', number: '02', value: 'DACCEC'},
            {label: 'Amethyst', number: '01', value: 'EDE3FC'},
            {label: 'Azure', number: '10', value: '133C59'},
            {label: 'Azure', number: '09', value: '134D71'},
            {label: 'Azure', number: '08', value: '1D5F8A'},
            {label: 'Azure', number: '07', value: '2876A8'},
            {label: 'Azure', number: '06', value: '368AC0'},
            {label: 'Azure', number: '05', value: '4EA0D1'},
            {label: 'Azure', number: '04', value: '69B5DD'},
            {label: 'Azure', number: '03', value: '8DC9E6'},
            {label: 'Azure', number: '02', value: 'ADD8EB'},
            {label: 'Azure', number: '01', value: 'CBEBF4'}
          ],
          placeIn: null, // null|'editor'
          showLabel: false,
          editable: true,
          uppercase: true,
          colorOnly: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * The ColorPicker Component is a trigger field with a listing colors that can be selected.
    *
    * @class ColorPicker
    * @param {String} colors  &nbsp;-&nbsp; An array of objects of the form {label: 'Azure', number: '01', value: 'CBEBF4'} that can be used to populate the color grid.
    * @param {String} showLabel  &nbsp;-&nbsp; Show the label if true vs the hex value if false.
    * @param {String} editable  &nbsp;-&nbsp; If false, the field is readonly and transparent. I.E. The value cannot be typed only editable by selecting.
    * @param {String} uppercase  &nbsp;-&nbsp; If false, lower case hex is allowed. If true upper case hex is allowed. If showLabel is true this setting is ignored.
    * @param {String} colorOnly  &nbsp;-&nbsp; If true the field will be shrunk to only show the color portion.
    *
    */
    function ColorPicker(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ColorPicker.prototype = {

      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.build();
        this.handleEvents();
      },

      // Add the extra markup
      build: function() {
        this.isEditor = this.settings.placeIn === 'editor';
        var colorpicker = this.element,
          initialValue = this.isEditor ? this.element.attr('data-value') :  this.element.val();

        if (!this.isEditor) {
          //Add Button
          if (this.isInlineLabel) {
            this.inlineLabel.addClass('colorpicker-container');
          }
          else {
            this.container = $('<span class="colorpicker-container"></span>');
            colorpicker.wrap(this.container);
          }

          this.container = colorpicker.parent();
          this.swatch = $('<span class="swatch"></span>').prependTo(this.container);

          // Add Masking to show the #.
          // Remove the mask if using the "showLabel" setting
          if (!this.settings.showLabel) {

            var patternUpper = ['#', /[0-9A-F]/, /[0-9A-F]/, /[0-9A-F]/, /[0-9A-F]/, /[0-9A-F]/, /[0-9A-F]/ ],
              patternLower = ['#', /[0-9a-f]/, /[0-9a-f]/, /[0-9a-f]/, /[0-9a-f]/, /[0-9a-f]/, /[0-9a-f]/ ];

            colorpicker.mask({
              pattern: this.settings.uppercase ? patternUpper : patternLower
            });

          } else {
            var maskAPI = colorpicker.data('mask');
            if (maskAPI && typeof maskAPI.destroy === 'function') {
              maskAPI.destroy();
            }
          }
        }

        this.icon = $.createIconElement('dropdown')
          .appendTo(this.isEditor ? this.element : this.container);
        this.icon.wrap('<span class="trigger"></span>');

        // Handle initial values
        if (initialValue) {
          this.setColor(initialValue);
        }

        if (this.element.is(':disabled')) {
          this.disable();
        }

        if (this.element.prop('readonly')) {
          this.readonly();
        }

        if (!this.settings.editable) {
          this.readonly();
        }

        if (this.settings.colorOnly) {
          this.element.parent().addClass('color-only');
        }

        this.addAria();
      },

      /**
      * Get the hex value based on a label. Does not handle duplicates.
      * @param {String} label  &nbsp;-&nbsp; The label to search for in the color labels.
      */
      getHexFromLabel: function(label) {
        for (var i = 0; i < this.settings.colors.length; i++) {
          var data = this.settings.colors[i];

          if (label === data.label + data.number) {

            var hex = data.value;
            if (hex.substr(0,1) !== '#') {
              hex = '#' + hex;
            }

            return hex;
          }
        }
      },

      /**
      * Get the label value based on a hex. Does not handle duplicates.
      * Can pass with or without the #
      *
      * @param {String} hex  &nbsp;-&nbsp; The hex to search for in the color set.
      */
      getLabelFromHex: function(hex) {
        for (var i = 0; i < this.settings.colors.length; i++) {
          var data = this.settings.colors[i];

          if (hex.replace('#', '') === data.value.replace('#', '')) {
            return data.label + data.number;
          }
        }
      },

      /**
      * Add the necessary aria for accessibility.
      *
      * @private
      */
      addAria: function () {
        this.element.attr({
          'role': 'combobox',
          'aria-autocomplete': 'list'
        });

        $('label[for="'+ this.element.attr('id') + '"]')
          .append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
      },

      // Toggle / Open the List
      toggleList: function () {
        var self = this,
          menu =  $('#colorpicker-menu');

        if (self.element.is(':disabled') || (this.element.prop('readonly') && self.settings.editable)) {
          return;
        }

        if (menu.length) {
          var isPickerOpen = self.isPickerOpen;
          $(document).trigger($.Event('keydown', {keyCode: 27, which: 27})); // escape

          if (isPickerOpen) {
            return;
          }
        }

        //Append Color Menu
        menu =  self.updateColorMenu();

        var popupmenuOpts = {
          ariaListbox: true,
          menuId: 'colorpicker-menu',
          trigger: 'immediate',
          placementOpts: {
            containerOffsetX: 10,
            containerOffsetY: 10,
            parentXAlignment: (Locale.isRTL() ? 'right': 'left'),
            strategies: ['flip', 'nudge', 'shrink']
          },
          offset: {
            x: 0,
            y: 10
          }
        };

        // Show Menu
        self.element
        .popupmenu(popupmenuOpts)
        .on('open.colorpicker', function () {
          self.element.parent().addClass('is-open');
          self.isPickerOpen = true;
        })
        .on('close.colorpicker', function () {
          menu.on('destroy.colorpicker', function () {
            self.element.off('open.colorpicker selected.colorpicker close.colorpicker');
            $(this).off('destroy.colorpicker').remove();
          });
          self.element.parent().removeClass('is-open');
          self.isPickerOpen = false;

          self.element.trigger('listclosed', 'select');
        })
        .on('selected.colorpicker', function (e, item) {
          if (!self.isEditor) {
            self.setColor(item.data('value'), item.data('label'));
          }
          self.element.focus();
          self.element.trigger('change');
        });

        //Append Buttons
        this.menu = $('#colorpicker-menu');

        setTimeout(function () {
          self.menu.find('.is-selected').focus();
        }, 1);
      },

      /**
      * Set the Visible Color
      * @param {String} hex  &nbsp;-&nbsp; The hex value to use (can have the # or not).
      * @param {String} text  &nbsp;-&nbsp; The text to display
      */
      setColor: function (hex, label) {

        // Make sure there is always a hash
        if (hex.substr(0,1) !== '#') {
          hex = '#' + hex;
        }

        var isValidHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);

        // Simply return out if hex isn't valid
        if (!isValidHex) {

          if (!this.settings.showLabel) {
            return;
          }
          label = hex.replace('#','');
          hex = this.getHexFromLabel(label);
        }

        var targetAttr = this.isEditor ? 'data-value' : 'value';

        if (!label) {
          label = this.getLabelFromHex(hex);
        }

        // Set the value on the field
        this.element[0].value = this.settings.showLabel ? label : hex;
        this.element[0].setAttribute(targetAttr, hex);
        this.swatch[0].style.backgroundColor = hex;

        this.element[0].setAttribute('aria-describedby', label);
      },

      // Refresh and Append the Color Menu
      updateColorMenu: function () {
        var isMenu =  !!($('#colorpicker-menu').length),
          self = this,
          menu = $('<ul id="colorpicker-menu" class="popupmenu colorpicker"></ul>'),
          currentTheme = Soho.theme;

        var isBorderAll = (self.settings.themes[currentTheme].border === 'all'),
          checkmark = self.settings.themes[currentTheme].checkmark,
          checkmarkClass = '';

        for (var i = 0, l = self.settings.colors.length; i < l; i++) {
          var li = $('<li></li>'),
            a = $('<a href="#"><span class="swatch"></span></a>').appendTo(li),
            number = self.settings.colors[i].number,
            num = parseInt(number, 10),
            text = (Locale.translate(self.settings.colors[i].label, true) || self.settings.colors[i].label) + (settings.colors[i].number || ''),
            value = self.settings.colors[i].value,
            isBorder = false,
            regexp = new RegExp('\\b'+ currentTheme +'\\b'),
            elemValue = this.isEditor ? this.element.attr('data-value') : this.element.val();

          if (self.settings.showLabel && !this.isEditor) {
            elemValue = this.getHexFromLabel(elemValue);
          }

          // Set border to this swatch
          if (isBorderAll || regexp.test(self.settings.colors[i].border)) {
            isBorder = true;
          }

          if (elemValue && (elemValue + '').toLowerCase().replace('#', '') === (value + '').toLowerCase()) {
            // Set checkmark color class
            if (checkmark) {
              $.each(checkmark, function(k, v) {
                // checkmark: {'one': [1, 2], 'two': [3, 10]}
                // will add class "checkmark-one", where current colors number is in range [1 to 3]
                // and will add class "checkmark-two", where current colors number is in range [3 to 10]
                if ((num >= v[0]) && (num <= v[1])) {
                  checkmarkClass = ' checkmark-'+ k;
                }
              });
            }
            a.addClass('is-selected'+ checkmarkClass);
          }

          var swatch = a.find('.swatch');
          if (swatch[0]) {
            swatch[0].style.backgroundColor = '#'+ value;
          }
          swatch.addClass(isBorder ? 'is-border' : '');
          a.data('label', text)
            .data('value', value)
            .attr('title', text +' #'+ value)
            .tooltip();

          // menu.append(li);
          if (!isMenu) {
            menu.append(li);
          }
        }

        if (!isMenu) {
          $('body').append(menu);
        }

        return menu;
      },

      /**
      * Change the color picker from enabled to disabled.
      */
      enable: function() {
        this.element.prop('disabled', false);
        this.element.prop('readonly', false);
        this.element.parent().removeClass('is-disabled is-readonly');
      },

      /**
      * Make the color picker disabled
      */
      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent().addClass('is-disabled');
      },

      /**
      * Make the color picker readonly
      */
      readonly: function() {
        this.enable();
        this.element.prop('readonly', true);
        this.element.parent().addClass('is-readonly');

        if (!this.settings.editable) {
          this.element.parent().addClass('is-not-editable');
        }

      },

      /**
      * Returns true if the color picker is disabled.
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      decimal2rgb: function(n) {
        if (typeof n !== 'number') {
          return n;
        }
        return 'rgb('+
          (n & 0xFF) +', '+
          ((n & 0xFF00) >> 8) +', '+
          ((n & 0xFF0000) >> 16 ) +
        ')';
      },

      rgb2hex: function (rgb) {
        if (rgb.search('rgb') === -1) {
          return rgb;
        }
        else if (rgb === 'rgba(0, 0, 0, 0)') {
          return 'transparent';
        }
        else {
          var hex = function (x) {
            return ('0' + parseInt(x).toString(16)).slice(-2);
          };
          rgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
          return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
        }
      },

      /**
       * Updates the component instance.  Can be used after being passed new settings.
       * @returns {this}
       */
      updated: function() {
        return this
          .destroy()
          .init();
      },

      teardown: function() {
        this.element.off('keyup.colorpicker blur.colorpicker openlist.colorpicker change.colorpicker paste.colorpicker');
        this.swatch.off('click.colorpicker');
        this.swatch.remove();
        this.container.find('.trigger').remove();
        var input = this.container.find('.colorpicker');

        if (input.data('mask')) {
          input.data('mask').destroy();
        }

        input.unwrap();
        input.removeAttr('data-mask role aria-autocomplete');
      },

      /**
      * Detach events and restore DOM to default.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
        return this;
      },

      /**
      *  This component fires the following events.
      *
      * @fires About#events
      * @param {Object} change  &nbsp;-&nbsp; Fires when a color is typed or selected.
      * @param {Object} blur  &nbsp;-&nbsp; Fires as the input looses focus
      *
      */
      handleEvents: function () {
        var self = this;
        this.icon.parent().onTouchClick().on('click.colorpicker', function () {
          self.toggleList();
        });

        this.element.on('focus.colorpicker', function () {
          $(this).parent().addClass('is-focused');
        })
        .on('blur.colorpicker', function () {
          $(this).parent().removeClass('is-focused');
        })
        .on('openlist.colorpicker', function() {
          self.toggleList();
        });

        this.element.on('keyup.colorpicker blur.colorpicker paste.colorpicker change.colorpicker', function () {
          var val = $(this).val();
          self.setColor(val);
        });

        //Handle Key Down to open
        this.element.on('keydown.colorpicker', function (e) {
          if (e.keyCode === 38 || e.keyCode === 40) {
            self.toggleList();
          }
        });
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new ColorPicker(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.compositeform = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'compositeform',
        defaults = {
          breakpoint: 'phone-to-tablet',
          trigger: null,
          expandedText: Locale.translate('ShowLess'),
          collapsedText: Locale.translate('ShowMore'),
        },
        settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class CompositeForm
    * @param {String} breakpoint  &nbsp;-&nbsp; Defines the breakpoint at which the composite form will change into its responsive mode
    * @param {String} trigger  &nbsp;-&nbsp; Expandable area trigger selector. Passed to expandable area.
    * @param {String} expandedText  &nbsp;-&nbsp; Text to use for the expand button (Default localized)
    * @param {String} collapsedText  &nbsp;-&nbsp; Text to use for the collapse button (Default localized)
    *
    */
    function CompositeForm(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    CompositeForm.prototype = {
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      /**
       * Adds markup to the control and stores references to some sub-elements
       * @returns {this}
       */
      build: function() {
        var classList = this.element[0].classList;
        if (!classList.contains('composite-form')) {
          classList.add('composite-form');
        }

        // Get expandable area reference, if applicable
        var expandableArea = this.element.find('.expandable-area');
        if (expandableArea.length) {
          this.hasSummary = true;
          this.expandableArea = expandableArea;
          this.expandableAreaAPI = this.expandableArea.data('expandablearea');
          if (!this.expandableAreaAPI) {
            this.expandableArea.expandablearea({ trigger: this.settings.trigger });
            this.expandableAreaAPI = this.expandableArea.data('expandablearea');
          }

          // Get expandable trigger
          this.expander = this.expandableAreaAPI.expander;
          this.setExpanderText(this.settings.expandedText);
        } else {
          this.hasSummary = false;
        }

        // Check size and append class, if necessary
        this.checkResponsive();

        return this;
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       * @param {string} expanderText - the text content
       * @returns {undefined}
       */
      handleEvents: function() {
        var self = this;

        $('body').on('resize.' + pluginName, function(e) {
          self.checkResponsive(e);
        });

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        });

        function changeExpanderText() {
          var isExpanded = self.expandableAreaAPI.isExpanded();
          self.setExpanderText(self.settings[isExpanded ? 'expandedText' : 'collapsedText']);
        }

        if (this.hasSummary) {
          this.expandableArea
            .on('expand.' + pluginName, changeExpanderText)
            .on('collapse.' + pluginName, changeExpanderText);
        }

        return this;
      },

      /**
       * Checks if we've passed the breakpoint for switching into Responsive mode.
       * @returns {undefined}
       */
      checkResponsive: function() {
        var cl = this.element[0].classList;

        if (Soho.breakpoints.isBelow(this.settings.breakpoint)) {
          cl.add('is-in-responsive-mode');
        } else {
          cl.remove('is-in-responsive-mode');
          if (this.isSideOriented() && !this.expandableAreaAPI.isExpanded()) {
            this.expandableAreaAPI.open();
          }
        }
      },

      /**
       * Sets the text content of the Composite Form's Expandable Area Expander.
       * @param {string} expanderText - the text content
       * @returns {undefined}
       */
      setExpanderText: function(expanderText) {
        if (!this.hasSummary) {
          return;
        }

        if (!(expanderText instanceof String) || !expanderText.length) {
          return;
        }

        var textSpan = this.expander.find('span');
        if (!textSpan) {
          textSpan = this.expander;
        }
        textSpan.text(expanderText);
      },

      /***
       * Determines if this component is configured for "on-side" orientation of the Summary area.
       * @returns {boolean}
       */
      isSideOriented: function() {
        return this.element[0].classList.contains('on-side');
      },

      /**
       * Re-invokes the Composite Form
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
       * Simple Teardown - remove events & rebuildable markup.
       * @returns {this}
       */
      teardown: function() {
        $('body').off('resize.' + pluginName);
        this.element.off('updated.' + pluginName);

        if (this.hasSummary) {
          this.expandableArea.off('expand.' + pluginName + ' collapse.' + pluginName);
        }

        return this;
      },

      /**
       * Destroys the component instance by removing it from its associated element.
       * @returns {this}
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new CompositeForm(this, settings));
      }
    });
  };


  $.fn.contextualactionpanel = function(options) {

    // Settings and Options
    var pluginName = 'contextualactionpanel',
        defaults = {
          id: 'contextual-action-modal-' + (parseInt($('.modal').length, 10)+1),
          buttons: null, // List of buttons that will sit in the toolbar's Buttonset area
          title: 'Contextual Action Panel', // string that fits into the toolbar's Title field
          content: null, //Pass content through to modal
          initializeContent: true, // initialize content before opening
          trigger: 'click'
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function ContextualActionPanel(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ContextualActionPanel.prototype = {

      init: function() {
        this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        this.panel = this.element.next('.contextual-action-panel');
        if (this.panel[0]) {
          this.panel[0].style.display = 'none';
        }
        this.panel.addClass('is-animating');
        return this;
      },

      build: function() {
        var self = this;

        // Build the Content
        if (this.panel.length === 0) {
          if (this.settings.content  instanceof jQuery) {

            if (this.settings.content.is('.contextual-action-panel')) {
              this.panel = this.settings.content;
            } else {
              this.settings.content.wrap('<div class="contextual-action-panel"></div>');
              this.panel = this.settings.content.parent();
            }

            this.panel.addClass('modal').appendTo('body');

            if (this.settings.content.is('iframe')) {
              this.settings.content.ready(function () {
                self.completeBuild();
                self.settings.content.show();
              });
              return self;
            }
            this.settings.content.show();

          } else {
            this.panel = $('<div class="contextual-action-panel">'+ this.settings.content +'</div>').appendTo('body');
            this.panel.addClass('modal').attr('id', this.settings.id);
          }

        }

        this.completeBuild();
        return this;
      },

      completeBuild: function() {
        var self = this,
          children,
          isIframe = false,
          contents;

        this.panel.find('svg').icon();

        if (this.panel.find('.modal-content').length === 0) {
          children = this.panel.children();
          if (children.is('iframe')) {
            contents = children.contents();
            this.toolbar = contents.find('.toolbar');
            isIframe = true;
          }

          if (!isIframe) {
            children.wrapAll('<div class="modal-content"></div>').wrapAll('<div class="modal-body"></div>');
            this.panel.addClass('modal');
          }
        }

        if (this.panel.find('.modal-header').length === 0) {
          this.header = $('<div class="modal-header"></div>');
          this.header.insertBefore(this.panel.find('.modal-body'));

          if (!this.toolbar) {
            this.toolbar = this.panel.find('.toolbar');
          }

          if (!this.toolbar.length) {
            this.toolbar = $('<div class="toolbar"></div>');
          }

		      this.toolbar.searchField = this.toolbar.find('.searchfield');

          this.toolbar.appendTo(this.header);
          var toolbarTitle = this.toolbar.find('.title');
          if (!toolbarTitle.length) {
            toolbarTitle = $('<div class="title">' + this.settings.title + '</div>');
            this.toolbar.prepend(toolbarTitle);
          }

          var toolbarButtonset = this.toolbar.find('.buttonset');
          if (!toolbarButtonset.length) {
            toolbarButtonset = $('<div class="buttonset"></div>');
            toolbarButtonset.insertAfter(toolbarTitle);
          }
        }

        // Move to the body element to break stacking context issues.
        if (!isIframe) {
          this.panel.detach().appendTo('body');
        }

        this.element.attr('data-modal', this.settings.id);
        if (!this.panel.attr('id')) {
          this.panel.attr('id', this.settings.id);
        }

        this.panel.modal({
          buttons: self.settings.buttons,
          trigger: (self.settings.trigger ? self.settings.trigger : 'click')
        });

        this.buttons = this.panel.find('.buttonset').children('button');
        this.closeButton = this.buttons.filter('.btn-close, [name="close"], .icon-close');

        if (!this.toolbar) {
          this.toolbar = this.panel.find('.toolbar');
        }

        if (this.toolbar.length) {
          this.toolbar.toolbar();
        }

        Soho.utils.fixSVGIcons(this.element);
        return this;
      },

      handleEvents: function() {
        var self = this;

        // Convenience method that takes an event from the Modal control's panel element,
        // and triggers any listeners that may be looking at the Contextual Action Panel's trigger instead.
        function passEvent(e) {
          self.element.triggerHandler(e.type);
        }

        this.panel.addClass('is-animating').on('open.contextualactionpanel', function(e) {
          passEvent(e);
          self.panel.removeClass('is-animating');
        }).on('beforeclose.contextualactionpanel', function() {
          self.panel.addClass('is-animating');
        }).on('close.contextualactionpanel', function(e) {
          passEvent(e);
        }).on('beforeopen.contextualactionpanel', function(e) {
          if (self.settings.initializeContent) {
            $(this).initialize();
          }
          passEvent(e);
        }).on('afteropen.contextualactionpanel', function() {
          if (self.toolbar) {
            self.toolbar.trigger('recalculate-buttons');
          }

          // Select the proper element on the toolbar
          if (self.toolbar.length) {
            var selected = self.toolbar.find('.buttonset > .is-selected');
            if (!selected.length) {
              selected = self.toolbar.find('.buttonset > *:first-child');
              if (selected.is('.searchfield-wrapper')) {
                selected = selected.children('.searchfield');
              }
            }
            self.toolbar.data('toolbar').setActiveButton(selected, true);
          }

          // Focus the first focusable element inside the Contextual Panel's Body
          self.panel.find('.modal-body-wrapper').find(':focusable').first().focus();
          Soho.utils.fixSVGIcons(self.panel);
        }).on('click.contextualactionpanel', function() {
          if (self.ctrlPressed) {
            var searchfield = self.toolbar.find('.searchfield');
            if (searchfield.length) {
              searchfield[0].select();
            }
            self.ctrlPressed = false;
          }
        }).on('keydown.contextualactionpanel', function(event) {
          if (event.key === 'Control') {
            self.ctrlPressed = true;
          }
        }).on('beforedestroy.contextualactionpanel', function() {
          self.teardown();
        });

        if (self.toolbar)  {
          self.toolbar.children('.buttonset').children('.btn-close, [name="close"], .icon-close')
            .onTouchClick('contextualactionpanel').on('click.contextualactionpanel', function() {
            self.handleToolbarSelected();
          });

          self.ctrlPressed = false;
        }

        return this;
      },

      handleToolbarSelected: function() {
        this.close();
      },

      teardown: function() {
        var self = this,
          buttonset = self.toolbar.children('.buttonset');

        this.panel.off('open.contextualactionpanel close.contextualactionpanel ' +
          'beforeopen.contextualactionpanel afterclose.contextualactionpanel');

        buttonset.children('*:not(.searchfield)')
          .offTouchClick('contextualactionpanel').off('click.contextualactionpanel');

        var menuButtons = buttonset.children('.btn-menu');
        menuButtons.each(function() {
          var popup = $(this).data('popupmenu');
          if (popup) {
            popup.destroy();
          }
        });

        //self.panel.detach().insertAfter(self.element);
        var toolbar = self.toolbar.data('toolbar');
        if (toolbar) {
          if (toolbar.searchField instanceof $ && toolbar.searchField.length) {
            toolbar.searchField.off('keydown.contextualactionpanel');
            toolbar.searchField.off('click.contextualactionpanel');
          }
          toolbar.destroy();
        }

        if (self.header){
          self.header.remove();
        }

        var children = self.panel.find('.modal-body').children();
        children.first().unwrap().unwrap(); // removes $('.modal-body'), then $('.modal-content')

        self.element.removeAttr('data-modal');

        // Trigger an afterclose event on the Contextual Action Panel's trigger element (different from the panel, which is already removed).
        self.element.trigger('afterteardown');
      },

      close: function() {
        var destroy;
        if (this.settings.trigger === 'immediate') {
          destroy = true;
        }
        if (this.panel.data('modal')) {
          this.panel.data('modal').close(destroy);
        }
      },

      disable: function() {
        this.element.prop('disabled', true);
        if (this.panel.hasClass('is-visible')) {
          this.close();
        }
      },

      enable: function() {
        this.element.prop('disabled', false);
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        this.panel.data('modal').destroy();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {

        instance.settings = $.extend({}, instance.settings, options);
        if (settings.trigger === 'immediate') {
          instance = $.data(this, pluginName, new ContextualActionPanel(this, settings));
        }

      } else {
        instance = $.data(this, pluginName, new ContextualActionPanel(this, settings));
      }
    });
  };


  $.fn.datepicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'datepicker',
        defaults = {
          showTime: false,
          timeFormat: undefined,
          minuteInterval: undefined,
          secondInterval: undefined,
          mode: undefined,
          roundToInterval: undefined,
          dateFormat: 'locale', //or can be a specific format like 'yyyy-MM-dd' iso8601 format
          placeholder: false,
          /*  Disabling of dates
          **    dates: 'M/d/yyyy' or
          **      ['M/d/yyyy'] or
          **      ['M/d/yyyy', new Date('M/d/yyyy')] or
          **      ['M/d/yyyy', new Date('M/d/yyyy'), new Date(yyyy,(M-0),d)]
          **    minDate: 'M/d/yyyy'
          **    maxDate: 'M/d/yyyy'
          **    dayOfWeek: [2] or [0,6] - {0-sun, 1-mon, 2-tue, 3-wed, 4-thu, 5-fri, 6-sat}
          **    isEnable: false or true
          **/
          disable: {
            'dates'     : [],
            'minDate'   : '',
            'maxDate'   : '',
            'dayOfWeek' : [],
            'isEnable' : false
          },
          showLegend: false,
          customValidation: false,
          showMonthYearPicker: false,
          hideDays: false,
          advanceMonths: 5,
          legend: [
            //Legend Build up example
            //Color in level 6 - http://usmvvwdev53:424/controls/colors
            {name: 'Public Holiday', color: '#76B051', dates: []},
            {name: 'Weekends', color: '#EFA836', dayOfWeek: []}
          ]
        },
        settings = $.extend({}, defaults, options);

    /**
    * A component to support date entry.
    *
    * @class DatePicker
    * @param {Boolean} showTime  &nbsp;-&nbsp; If true the time selector will be shown.
    * @param {String} timeFormat  &nbsp;-&nbsp; The format to use on the time section fx HH:mm, defaults to current locale's settings.
    * @param {String} mode  &nbsp;-&nbsp; Time picker mode: options: 'standard', 'range', this controls the avilable selections in the time picker.
    * @param {Boolean} roundToInterval  &nbsp;-&nbsp; In time picker mode, if a non-matching minutes value is entered, rounds the minutes value to the nearest interval when the field is blurred.
    * @param {String} dateFormat  &nbsp;-&nbsp; Defaults to current locale but can be overriden to a specific format
    * @param {Boolean} disable  &nbsp;-&nbsp; Disabled Dates Build up. `{
      'dates'     : [],
      'minDate'   : '',
      'maxDate'   : '',
      'dayOfWeek' : [],
      'isEnable' : false
    }`
    * @param {Boolean} showMonthYearPicker  &nbsp;-&nbsp; If true the month and year will render as dropdowns.
    * @param {Boolean} hideDays  &nbsp;-&nbsp; If true the days portion of the calendar will be hidden. Usefull for Month/Year only formats.
    * @param {Boolean} customValidation  &nbsp;-&nbsp; If true the internal validation is disabled.
    * @param {Boolean} advanceMonths  &nbsp;-&nbsp; The number of months in each direction to show in the dropdown for months (when initially opening)
    * @param {Boolean} showLegend  &nbsp;-&nbsp; If true a legend is show to associate dates.
    * @param {Array} legend  &nbsp;-&nbsp; Legend Build up for example `[{name: 'Public Holiday', color: '#76B051', dates: []}, {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
    *
    */
    function DatePicker(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    DatePicker.prototype = {

      init: function() {
        this.build();
        this.handleEvents();
      },

      //Add any markup
      build: function() {

        // Add "is-disabled" css class to closest ".field" if element is disabled
        if (this.element.is(':disabled')) {
          this.element.closest('.field').addClass('is-disabled');
        }

        //Append a trigger button
        this.trigger = $.createIconElement('calendar').insertAfter(this.element);
        this.addAria();

        this.isIslamic = Locale.calendar().name === 'islamic-umalqura';
        this.conversions = Locale.calendar().conversions;
      },

      addAria: function () {
        this.label = $('label[for="'+ this.element.attr('id') + '"]');
        this.label.append('<span class="audible">' + Locale.translate('PressDown') + '</span>');
      },

      // Handle Keyboard Stuff
      handleKeys: function (elem) {
        var self = this;

        // Handle Keys while popup is open
        if (elem.is('#calendar-popup')) {
          elem.off('keydown.datepicker').on('keydown.datepicker', '.calendar-table', function (e) {
            var handled = false,
              key = e.keyCode || e.charCode || 0;

            //Arrow Down: select same day of the week in the next week
            if (key === 40) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() + 7);
              self.insertDate(self.currentDate);
            }

            //Arrow Up: select same day of the week in the previous week
            if (key === 38) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() - 7);
              self.insertDate(self.currentDate);
            }

            //Arrow Left
            if (key === 37) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() - 1);
              self.insertDate(self.currentDate);
            }

            //Arrow Right
            if (key === 39) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() + 1);
              self.insertDate(self.currentDate);
            }

            //Page Up Selects Same Day Prev Month
            if (key === 33 && !e.altKey) {
              handled = true;
              self.currentDate.setMonth(self.currentDate.getMonth() - 1);
              self.insertDate(self.currentDate);
            }

            //Page Down Selects Same Day Next Month
            if (key === 34 && !e.altKey) {
              handled = true;
              self.currentDate.setMonth(self.currentDate.getMonth() + 1);
              self.insertDate(self.currentDate);
            }

            //ctrl + Page Up Selects Same Day Next Year
            if (key === 33 && e.ctrlKey) {
              handled = true;
              self.currentDate.setFullYear(self.currentDate.getFullYear() + 1);
              self.insertDate(self.currentDate);
            }

            //ctrl + Page Down Selects Same Day Prev Year
            if (key === 34 && e.ctrlKey) {
              handled = true;
              self.currentDate.setFullYear(self.currentDate.getFullYear() - 1);
              self.insertDate(self.currentDate);
            }

            //Home Moves to End of the month
            if (key === 35) {
              handled = true;
              var lastDay =  new Date(self.currentDate.getFullYear(), self.currentDate.getMonth()+1, 0);
              self.currentDate = lastDay;
              self.insertDate(self.currentDate);
            }

            //End Moves to Start of the month
            if (key === 36) {
              var firstDay =  new Date(self.currentDate.getFullYear(), self.currentDate.getMonth(), 1);
              self.currentDate = firstDay;
              self.insertDate(self.currentDate);
            }

            // 't' selects today
            if (key === 84) {
              handled = true;
              self.setToday();
            }

            // Space or Enter closes Date Picker, selecting the Date
            if (key === 32 || key === 13) {
              self.closeCalendar();
              self.element.focus();
              handled = true;
            }

            // Tab closes Date Picker and goes to next field on the modal
            if (key === 9) {
              self.containFocus(e);
              handled = true;
            }

            // Esc closes Date Picker and goes back to field
            if (key === 27) {
              self.closeCalendar();
              self.element.focus();
            }

            if (handled) {
              e.stopPropagation();
              e.preventDefault();
              return false;
            }

          });

          elem.off('keydown.datepicker-tab').on('keydown.datepicker-tab', 'td, input, div.dropdown, button', function (e) {
            var key = e.keyCode || e.charCode || 0;

            // Tab closes Date Picker and goes to next field on the modal
            if (key === 9) {
              self.containFocus(e);
              e.stopPropagation();
              e.preventDefault();
              return false;
            }
          });

          return;
        }

        //Handle input keys
        elem.off('keydown.datepicker').on('keydown.datepicker', function (e) {
            var handled = false,
              key = e.keyCode || e.charCode || 0,
              focused = $(':focus'),
              focusedlabel = focused.attr('aria-label');

            // TODO: With new mask the code around key === 9 should not be needed.

            if (focusedlabel) {
              var focusedDate = new Date(focusedlabel);
              self.currentDate = new Date(focusedDate.getTime());
            } else if (focused.hasClass('alternate')) {
                var year = parseInt(self.header.find('.year').text()),
                month = parseInt(self.header.find('.month').attr('data-month')),
                day = parseInt(focused.text());

              if (self.settings.showMonthYearPicker) {
                month = parseInt(self.header.find('.month select').val());
                year = parseInt(self.header.find('.year select').val());
              }

              if (focused.hasClass('prev-month')) {
                if(month === 0) {
                  month = 11;
                  year--;
                }
                else {
                  month--;
                }
              } else if (focused.hasClass('next-month')) {
                if(month === 11) {
                  month = 0;
                  year++;
                }
                else {
                  month++;
                }
              }
              self.currentDate = new Date(year, month, day);
            }

           //Arrow Down or Alt first opens the dialog
            if (key === 40 && !self.isOpen()) {
              handled = true;
              self.openCalendar();

              setTimeout(function() {
                self.setFocusAfterOpen();
              }, 200);
            }

            // 't' selects today
            if (key === 84) {
              handled = true;
              self.setToday();
            }

            if (handled) {
              e.stopPropagation();
              e.preventDefault();
              return false;
            }

          });

      },

      /**
       * Focus the next prev focusable element on the popup
       * @private
       */
      containFocus: function (e) {
        var reverse = e.shiftKey;

        // Set focus on (opt: next|prev) focusable element
        var focusables = this.popup.find(':focusable'),
          index = focusables.index($(':focus'));

        index = (!reverse) ?
          ((index+1) >= focusables.length ? 0 : (index+1)) :
          ((index-1) < 0 ? focusables.length : (index-1));

        var elem = focusables.eq(index);
        elem.focus();

        if (elem.is('td')) {
          elem.addClass('is-selected');
          this.currentDate.setDate(elem.text());
          this.currentDate.setMonth(this.calendar.find('.month').attr('data-month'));
          this.insertDate(this.currentDate);
        }

      },

      //Parse the Date Format Options
      setFormat: function () {
        var localeDateFormat = ((typeof Locale === 'object' && Locale.calendar().dateFormat) ? Locale.calendar().dateFormat : null),
          localeTimeFormat = ((typeof Locale === 'object' && Locale.calendar().timeFormat) ? Locale.calendar().timeFormat : null);

        if (this.settings.dateFormat === 'locale') {
          this.pattern = localeDateFormat.short + (this.settings.showTime ? ' ' + (this.settings.timeFormat || localeTimeFormat) : '');
        } else {
          this.pattern = this.settings.dateFormat + (this.settings.showTime && this.settings.timeFormat ? ' ' + this.settings.timeFormat : '');
        }

        this.show24Hours = (this.pattern.match('HH') || []).length > 0;
        this.isSeconds = (this.pattern.match('ss') || []).length > 0;
      },

      // Add masking with the mask function
      mask: function () {
        this.setFormat();

        var validation = 'date availableDate',
          events = {'date': 'change blur enter', 'availableDate': 'change blur'},
          customValidation = this.element.attr('data-validate'),
          customEvents = this.element.attr('data-validation-events'),
          maskOptions = {
            process: 'date',
            keepCharacterPositions: true,
            patternOptions: {
              format: this.pattern
            }
          },
          mask = this.pattern.toLowerCase()
                   .replace(/yyyy/g,'####')
                   .replace(/mmmm/g,'*********')
                   .replace(/mmm/g,'***')
                   .replace(/mm/g,'##')
                   .replace(/dd/g,'##')
                   .replace(/hh/g,'##')
                   .replace(/ss/g,'##')
                   .replace(/[mdh]/g,'##')
                   .replace(/[a]/g,'am');

        //TO DO - Time seperator
        // '##/##/#### ##:## am' -or- ##/##/#### ##:##' -or- ##/##/####'
        // '##/##/#### ##:##:## am' -or- ##/##/#### ##:##:##'
        mask = (this.settings.showTime ?
          (this.show24Hours ? mask.substr(0, (this.isSeconds ? 19:16)) : mask) : mask);

        if (customValidation === 'required' && !customEvents) {
          validation = customValidation + ' ' + validation;
          $.extend(events, {'required': 'change blur'});
        } else if (!!customValidation && !!customEvents) {
          // Remove default validation, if found "no-default-validation" string in "data-validate" attribute
          if (customValidation.indexOf('no-default-validation') > -1) {
            validation = customValidation.replace(/no-default-validation/g, '');
            events = $.fn.parseOptions(this.element, 'data-validation-events');
          }
          // Keep default validation along custom validation
          else {
            validation = customValidation + ' ' + validation;
            $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
          }
        }

        this.element.mask(maskOptions);

        if (!this.settings.customValidation) {
          this.element
            .attr({
              'data-validate': validation,
              'data-validation-events': JSON.stringify(events)
            }).validate();
        }

        if (this.settings.placeholder && (!this.element.attr('placeholder') ||  this.element.attr('placeholder') === 'M / D / YYYY')) {
          this.element.attr('placeholder', this.pattern);
        }
      },

      /**
      * Return whether or not the calendar div is open.
      */
      isOpen: function () {
        return (this.popup && this.popup.is(':visible') &&
          !this.popup.hasClass('is-hidden'));
      },

      /**
      * Open the Calendar Popup.
      */
      open: function() {
        return this.openCalendar();
      },

      activeTabindex: function(elem, isFocus) {
        $('td', this.days).removeAttr('tabindex');
        elem.attr('tabindex', 0);

        if (isFocus) {
          elem.focus();
        }
        return elem;
      },

      // Open the calendar in a popup
      openCalendar: function () {
        var self = this,
          timeOptions = {};


        if (this.element.is(':disabled') || this.element.attr('readonly')) {
          return;
        }

        $('#validation-tooltip').addClass('is-hidden');


        this.element.addClass('is-active is-open').trigger('listopened');

        // Calendar Html in Popups
        var prevButton = '<button type="button" class="btn-icon prev">' + $.createIcon('caret-left') + '<span>'+ Locale.translate('PreviousMonth') +'</span></button>',
            nextButton = '<button type="button" class="btn-icon next">' + $.createIcon('caret-right') + '<span>'+ Locale.translate('NextMonth') +'</span></button>';

        this.table = $('<table class="calendar-table" aria-label="'+ Locale.translate('Calendar') +'" role="application"></table>');
        this.header = $('<div class="calendar-header"><span class="month">november</span><span class="year">2015</span>'+ (Locale.isRTL() ? prevButton + nextButton : prevButton + nextButton) +'</div>');
        this.dayNames = $('<thead><tr><th>SU</th> <th>MO</th> <th>TU</th> <th>WE</th> <th>TH</th> <th>FR</th> <th>SA</th> </tr> </thead>').appendTo(this.table);
        this.days = $('<tbody> <tr> <td class="alternate">26</td> <td class="alternate">27</td> <td class="alternate">28</td> <td class="alternate">29</td> <td class="alternate" >30</td> <td class="alternate">31</td> <td>1</td> </tr> <tr> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> </tr> <tr> <td>9</td> <td>10</td> <td>11</td> <td>12</td> <td>13</td> <td>14</td> <td>15</td> </tr> <tr> <td>16</td> <td>17</td> <td>18</td> <td>19</td> <td class="is-today">20</td> <td>21</td> <td>22</td> </tr> <tr> <td>23</td> <td>24</td> <td>25</td> <td>26</td> <td>27</td> <td>28</td> <td class="alternate">1</td> </tr> <tr> <td class="alternate">2</td> <td class="alternate">3</td> <td class="alternate">4</td> <td class="alternate">5</td> <td class="alternate">6</td> <td class="alternate">7</td> <td class="alternate">8</td> </tr> </tbody>').appendTo(this.table);
        this.timepickerContainer = $('<div class="datepicker-time-container"></div>');
        this.footer = $('<div class="popup-footer"> <button type="button" class="cancel btn-tertiary">'+ Locale.translate('Clear') +'</button> <button type="button" class="is-today btn-tertiary">'+Locale.translate('Today')+'</button> </div>');

        if (this.settings.hideDays) {
          this.table = '';
          this.footer = $('<div class="popup-footer"> <button type="button" class="select-month btn-tertiary">'+ Locale.translate('Select') +'</button></div>');
        }

        // Timepicker options
        if (this.settings.showTime) {
          if (this.settings.timeFormat === undefined) {
            // Getting time-format from date-format (dateFormat: 'M/d/yyyy HH:mm:ss')
            timeOptions.timeFormat = this.pattern.slice(this.pattern.indexOf(' '));
          }
          else {
            timeOptions.timeFormat = this.settings.timeFormat;
          }
          if (this.settings.minuteInterval !== undefined) {
            timeOptions.minuteInterval = this.settings.minuteInterval;
          }
          if (this.settings.secondInterval !== undefined) {
            timeOptions.secondInterval = this.settings.minuteInterval;
          }
          if (this.settings.mode !== undefined) {
            timeOptions.mode = this.settings.mode;
          }
          if (this.settings.roundToInterval !== undefined) {
            timeOptions.roundToInterval = this.settings.roundToInterval;
          }

        }

        this.calendar = $('<div class="calendar'+ (this.settings.showTime ? ' is-timepicker' : '') + (this.settings.hideDays ? ' is-monthyear' : '') +'"></div>')
          .append(
            this.header,
            this.table,
            (this.settings.showTime ? this.timepickerContainer : ''),
            this.footer
          );

        var placementParent = this.element,
          placementParentXAlignment = (Locale.isRTL() ? 'right' : 'left'),
          parent = this.element.parent();

        if (parent.is('.datagrid-cell-wrapper')) {
          placementParentXAlignment = 'center';
          placementParent = this.element.next('.icon');
        }

        var popoverOpts = {
          content: this.calendar,
          placementOpts: {
            parent: placementParent,
            parentXAlignment: placementParentXAlignment,
            strategies: ['flip', 'nudge', 'shrink']
          },
          placement : 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#calendar-popup'
        };

        this.trigger.popover(popoverOpts)
        .off('show.datepicker').on('show.datepicker', function () {
          if (Soho.env.os.name === 'ios') {
            $('head').triggerHandler('disable-zoom');
          }
          // Horizontal view on mobile
          if (window.innerHeight < 400) {
            self.popup.find('.arrow').hide();
            self.popup.css('min-height', (self.popupClosestScrollable[0].scrollHeight + 2) +'px');
            self.popupClosestScrollable.css('min-height', '375px');
          }
        })
        .off('hide.datepicker').on('hide.datepicker', function () {
          if (Soho.env.os.name === 'ios') {
            self.trigger.one('hide', function() {
              $('head').triggerHandler('enable-zoom');
            });
          }
          self.popupClosestScrollable.add(self.popup).css('min-height', 'inherit');
          self.closeCalendar();
        });

        this.handleKeys($('#calendar-popup'));
        $('.calendar-footer a', this.calendar).button();

        // Show Month
        this.setValueFromField();

        // Set timepicker
        if (this.settings.showTime) {

          //Set to 12:00
          if (this.element.val() === '') {
            this.currentDate.setHours(0);
            this.currentDate.setMinutes(0);
            this.currentDate.setSeconds(0);
          }

          timeOptions.parentElement = this.timepickerContainer;
          this.time = self.getTimeString(this.currentDate, self.show24Hours);
          this.timepicker = this.timepickerContainer.timepicker(timeOptions).data('timepicker');
          this.timepickerContainer.find('dropdown').dropdown();

          // Wait for timepicker to initialize
          setTimeout(function() {
            self.timepicker.initValues = self.timepicker.getTimeFromField(self.time);
            self.timepicker.afterShow(self.timepickerContainer);
            return;
          }, 1);
        }

        this.todayDate = new Date();
        this.todayMonth = this.todayDate.getMonth();
        this.todayYear = this.todayDate.getFullYear();
        this.todayDay = this.todayDate.getDate();

        if (this.isIslamic) {
          this.todayDateIslamic = this.conversions.fromGregorian(this.todayDate);
          this.todayYear = this.todayDateIslamic[0];
          this.todayMonth = this.todayDateIslamic[1];
          this.todayDay = this.todayDateIslamic[2];
        }

        this.showMonth(this.currentMonth, this.currentYear);
        this.popup = $('#calendar-popup');
        this.popupClosestScrollable = this.popup.closest('.scrollable');
        this.popup.attr('role', 'dialog');
        this.originalDate = this.element.val();

        // Calendar Day Events
        this.days.off('click.datepicker').on('click.datepicker', 'td', function () {
          var td = $(this);
          if (td.hasClass('is-disabled')) {
            self.activeTabindex(td, true);
          }
          else {
            self.days.find('.is-selected').removeClass('is-selected').removeAttr('aria-selected');

            var cell = $(this),
              year = parseInt(self.header.find('.year').text()),
              month = parseInt(self.header.find('.month').attr('data-month')),
              day = parseInt(cell.addClass('is-selected').attr('aria-selected', 'true').text());

            if (self.settings.showMonthYearPicker) {
              year = parseInt(self.header.find('.year select').val());
              month = parseInt(self.header.find('.month select').val());
            }

            if (cell.hasClass('prev-month')) {
              if(month === 0) {
                month = 11;
                year--;
              }
              else {
                month--;
              }
            }
            else if (cell.hasClass('next-month')) {
              if(month === 11) {
                month = 0;
                year++;
              }
              else {
                month++;
              }
            }

            self.currentDate = new Date(year, month, day);

            if (self.isIslamic) {
              self.currentDateIslamic[0] = year;
              self.currentDateIslamic[1] = month;
              self.currentDateIslamic[2] = day;
              self.currentYear = self.currentDateIslamic[0];
              self.currentMonth = self.currentDateIslamic[1];
              self.currentDay = self.currentDateIslamic[2];
              self.currentDate = self.conversions.toGregorian(self.currentDateIslamic[0], self.currentDateIslamic[1], self.currentDateIslamic[2]);
            }

            self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
            self.closeCalendar();
            self.element.focus();
          }
        });

        // Calendar Footer Events
        this.footer.off('click.datepicker').on('click.datepicker', 'button', function (e) {
          var btn = $(this);

          if (btn.hasClass('cancel')) {
            self.element.val('').trigger('change').trigger('input');
            self.currentDate = null;
            self.closeCalendar();
          }

          if (btn.hasClass('select-month')) {
            var year, month;
            year = parseInt(self.header.find('.year select').val());
            month = parseInt(self.header.find('.month select').val());

            self.currentDate = new Date(year, month, 1);

            if (self.isIslamic) {
              self.currentDateIslamic[0] = year;
              self.currentDateIslamic[1] = month;
              self.currentDateIslamic[2] = 1;
              self.currentYear = self.currentDateIslamic[0];
              self.currentMonth = self.currentDateIslamic[1];
              self.currentDay = self.currentDateIslamic[2];
              self.currentDate = self.conversions.toGregorian(self.currentDateIslamic[0], self.currentDateIslamic[1], self.currentDateIslamic[2]);
            }

            self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
            self.closeCalendar();
          }

          if (btn.hasClass('is-today')) {
            self.setToday();
            self.closeCalendar();
          }
          self.element.focus();
          e.preventDefault();
        });

        // Change Month Events
        this.header.off('click.datepicker').on('click.datepicker', 'button', function () {
          self.showMonth(self.currentMonth + ($(this).hasClass('next') ? 1 : -1), self.currentYear);
        });

        setTimeout(function() {
          self.setFocusAfterOpen();
        }, 200);

      },

      /**
      * Close the calendar popup.
      */
      close: function() {
        return this.closeCalendar();
      },

      // Close the calendar in a popup
      closeCalendar: function () {
        // Close timepicker
        if (this.settings.showTime && this.timepickerControl && this.timepickerControl.isOpen()) {
          this.timepickerControl.closeTimePopup();
        }

        if (this.popup && this.popup.length) {
          this.popup.hide().remove();
        }

        var popoverAPI = this.trigger.data('tooltip');
        if (popoverAPI) {
          popoverAPI.destroy();
        }

        if (this.element.hasClass('is-active')) {
          this.element.trigger('listclosed');
          this.element.removeClass('is-active is-open');
        }
      },

      // Check through the options to see if the date is disabled
      isDateDisabled: function (year, month, date) {
        var d, i, l,
          self = this,
          d2 = new Date(year, month, date),
          min = (new Date(this.settings.disable.minDate)).setHours(0,0,0,0),
          max = (new Date(this.settings.disable.maxDate)).setHours(0,0,0,0);

        //dayOfWeek
        if(this.settings.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
          return true;
        }

        d2 = d2.setHours(0,0,0,0);

        //min and max
        if ((d2 <= min) || (d2 >= max)) {
          return true;
        }

        //dates
        if (this.settings.disable.dates.length && typeof this.settings.disable.dates === 'string') {
          this.settings.disable.dates = [this.settings.disable.dates];
        }

        for (i=0, l=this.settings.disable.dates.length; i<l; i++) {
          d = new Date(self.settings.disable.dates[i]);
          if(d2 === d.setHours(0,0,0,0)) {
            return true;
          }
        }

        return false;
      },

      // Set disable Date
      setDisabled: function (elem, year, month, date) {
        var dateIsDisabled = this.isDateDisabled(year, month, date);
        elem.removeClass('is-disabled').removeAttr('aria-disabled');

        if ((dateIsDisabled && !this.settings.disable.isEnable) || (!dateIsDisabled && this.settings.disable.isEnable)) {
          elem
            .addClass('is-disabled').attr('aria-disabled','true')
            .removeClass('is-selected').removeAttr('aria-selected');
        }
      },

      //Add a Legend below the table
      addLegend: function () {
        if (!this.settings.showLegend) {
          return;
        }

        //Remove Legend
        if (this.legend && this.legend.length) {
          this.legend.remove();
        }

        this.legend = $('<div class="calendar-legend"></div>');

        for (var i = 0; i < this.settings.legend.length; i++) {
          var series = this.settings.legend[i],
            item = '<div class="calendar-legend-item">' +
              '<span class="calendar-legend-swatch" style="background-color:' + this.hexToRgba(series.color, 0.3) + '"></span>' +
              '<span class="calendar-legend-text">' + series.name + '</span></div>';

          this.legend.append(item);
        }

        this.table.after(this.legend);
      },

      // Set Color for the Legend settings
      setLegendColor: function (elem, year, month, date) {
        if (!this.settings.showLegend || !elem[0]) {
          return;
        }

        var hex = this.getLegendColor(year, month, date),
          self = this;

        elem[0].style.backgroundColor = '';

        if (hex) {
          //set color on elem at .3 of provided color as per design
          elem.addClass('is-colored');
          elem[0].style.backgroundColor = this.hexToRgba(hex, 0.3);

          var normalColor = self.hexToRgba(hex, 0.3),
            hoverColor = self.hexToRgba(hex, 0.7);

          //handle hover states
          elem.on('mouseenter', function () {
            var elem = $(this);
            elem[0].style.backgroundColor = hoverColor;
            elem.find('span')[0].style.backgroundColor = 'transparent';
          }).on('mouseleave', function () {
            var elem = $(this);
            elem[0].style.backgroundColor = normalColor;
            elem.find('span')[0].style.backgroundColor = '';
          });

        }
      },

      //This maybe can be later moved into a colors file along with getLuminousColorShade
      ///But convert the provided hex to an RGBA for states
      hexToRgba: function(hex, opacity) {
        var c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
            c = hex.substring(1).split('');

            if (c.length === 3) {
              c= [c[0], c[0], c[1], c[1], c[2], c[2]];
            }

            c = '0x' + c.join('');
            return 'rgba(' + [(c>>16)&255, (c>>8)&255, c&255].join(',') + ',' + opacity.toString() +')';
        }
        return '';
      },

      // Process Color Options to get the date color
      getLegendColor: function (year, month, date) {
        if (!this.settings.showLegend) {
          return;
        }

        var checkDate = new Date(year, month, date),
          checkHours = checkDate.setHours(0,0,0,0);

        for (var i = 0; i < this.settings.legend.length; i++) {
          var series = this.settings.legend[i];

          //Check Day of week
          if (series.dayOfWeek && series.dayOfWeek.indexOf(checkDate.getDay()) !== -1) {
            return series.color;
          }

          //Check for dates that match
          if (series.dates) {
            for (var j = 0; j < series.dates.length; j++) {
              var d = new Date(series.dates[j]);
              if (checkHours === d.setHours(0,0,0,0)) {
                return series.color;
              }
            }
          }

        }

        return '';
      },

      // Set focus after opening the calendar
      setFocusAfterOpen: function () {
        if (!this.calendar) {
          return;
        }
        this.activeTabindex(this.calendar.find('.is-selected'), true);

        if (this.settings.hideDays) {
          this.calendar.find('div.dropdown:first').focus();
        }

      },

      // Update the calendar to show the month (month is zero based)
      showMonth: function (month, year, skipYear) {
        var self = this;

        var elementDate = this.currentDate.getDate() ?
          this.currentDate : (new Date()).setHours(0,0,0,0);

        if (this.isIslamic) {
          elementDate = this.currentDateIslamic;
        }

        if (year.toString().length < 4) {
          year = new Date().getFullYear();
        }

        if (month === 12) {
          year ++;
          this.currentMonth = month = 0;
          this.currentYear = year;
          this.header.find('.year').text(' ' + year);
        }

        if (month < 0) {
          year --;
          this.currentMonth = month = 11;
          this.currentYear = year;
          this.header.find('.year').text(' ' + year);
        }

        if (!skipYear) {
          var days = Locale.calendar().days.narrow || Locale.calendar().days.narrow || Locale.calendar().days.abbreviated,
            monthName = Locale.calendar().months.wide[month];

          this.currentMonth = month;
          this.currentYear = year;

          // Set the Days of the week
          var firstDayofWeek = (Locale.calendar().firstDayofWeek || 0);
          this.dayNames.find('th').each(function (i) {
            $(this).text(days[(i + firstDayofWeek) % 7]);
          });

          //Localize Month Name
          this.yearFist = Locale.calendar().dateFormat.year && Locale.calendar().dateFormat.year.substr(1, 1) === 'y';
          this.header.find('.month').attr('data-month', month).text(monthName + ' ');
          this.header.find('.year').text(' ' + year);

          if (this.yearFist) {
            var translation = Locale.formatDate(elementDate, {date: 'year'}),
              justYear = translation.split(' ')[0];

            this.header.find('.year').text(justYear + ' ');
            this.header.find('.year').insertBefore(this.header.find('.month'));
          }

          this.appendMonthYearPicker(month, year);
        }

        //Adjust days of the week
        //lead days
        var firstDayOfMonth = this.firstDayOfMonth(year, month),
          leadDays = (firstDayOfMonth - (Locale.calendar().firstDayofWeek || 0) + 7) % 7,
          lastMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 1 : 0)),
          thisMonthDays = this.daysInMonth(year, month+ (this.isIslamic ? 0 : 1)),
          dayCnt = 1, nextMonthDayCnt = 1, exYear, exMonth, exDay;

        this.days.find('td').each(function (i) {
          var th = $(this).removeClass('alternate prev-month next-month is-selected is-today');
          th.removeAttr('aria-selected');

          if (i < leadDays) {
            exDay = lastMonthDays - leadDays + 1 + i;
            exMonth = (month === 0) ? 11 : month - 1;
            exYear = (month === 0) ? year - 1 : year;

            self.setDisabled(th, exYear, exMonth, exDay);
            self.setLegendColor(th, exYear, exMonth, exDay);
            th.addClass('alternate prev-month').html('<span aria-hidden="true">' + exDay + '</span>');
          }

          if (i >= leadDays && dayCnt <= thisMonthDays) {
            th.html('<span aria-hidden="true">' + dayCnt + '</span>');

            //Add Selected Class to Selected Date
            if (self.isIslamic) {
              if (year === elementDate[0] && month === elementDate[1] && dayCnt === elementDate[2]) {
                th.addClass('is-selected').attr('aria-selected', 'true');
              }
            } else {
              var tHours = elementDate.getHours(),
                tMinutes = elementDate.getMinutes(),
                tSeconds = self.isSeconds ? elementDate.getSeconds() : 0;

              if ((new Date(year, month, dayCnt)).setHours(tHours, tMinutes, tSeconds,0) === elementDate.setHours(tHours, tMinutes, tSeconds, 0)) {
                th.addClass('is-selected').attr('aria-selected', 'true');
              }
            }

            if (dayCnt === self.todayDay && self.currentMonth === self.todayMonth &&
              self.currentYear === self.todayYear) {
              th.addClass('is-today');
            }

            th.attr('aria-label', Locale.formatDate(new Date(self.currentYear, self.currentMonth, dayCnt), {date: 'full'}));

            self.setDisabled(th, year, month, dayCnt);
            self.setLegendColor(th, year, month, dayCnt);

            th.attr('role', 'link');
            dayCnt++;
            return;
          }

          if (dayCnt >= thisMonthDays + 1) {
            exDay = nextMonthDayCnt;
            exMonth = (month === 11) ? 0 : month + 1;
            exYear = (month === 11) ? year + 1 : year;

            self.setDisabled(th, exYear, exMonth, exDay);
            self.setLegendColor(th, exYear, exMonth, exDay);

            th.addClass('alternate next-month').html('<span aria-hidden="true">' + nextMonthDayCnt + '</span>');
            nextMonthDayCnt++;
          }

        });

        //Hide 6th Row if all disabled
        var row = this.days.find('tr').eq(5);
        if (row.find('td.alternate').length === 7) {
          row.hide();
        } else {
          row.show();
        }

        //Add Legend
        self.addLegend();
      },

      appendMonthYearPicker: function (month, year) {
        var self = this;

        if (!this.settings.showMonthYearPicker) {
          return;
        }

        this.header.addClass('is-monthyear');

        var monthDropdown = '<label for="month-dropdown" class="audible">'+ Locale.translate('Month') +'</label>'+
          '<select id="month-dropdown" class="dropdown">';

        var wideMonths = Locale.calendar().months.wide;
        wideMonths.map(function (monthMap, i) {
          monthDropdown += '<option '+ (i===month ? ' selected ' : '') + ' value="'+ i +'">'+ monthMap +'</option>';
        });
        monthDropdown +='</select>';

        var monthSpan = this.header.find('.month').empty().append(monthDropdown);
        monthSpan.find('select.dropdown').dropdown().off('change.datepicker')
          .on('change.datepicker', function () {
            var elem = $(this);
            self.currentMonth = parseInt(elem.val());
            self.showMonth(self.currentMonth, self.currentYear, true);
          });

        var yearDropdown = '<label for="year-dropdown" class="audible">'+ Locale.translate('Year') +'</label>'+
          '<select id="year-dropdown" class="dropdown year">';

        var years = [];

        for (var i = this.settings.advanceMonths; i >= 1; i--) {
          years.push(parseInt(year) - i);
        }
        years.push(year);
        for (var j = 1; j <= this.settings.advanceMonths; j++) {
          years.push(parseInt(year) + j);
        }

        years.map(function (yearMap) {
          yearDropdown += '<option '+ (year===yearMap ? ' selected ' : '') + ' value="'+ yearMap +'">'+ yearMap +'</option>';
        });
        yearDropdown +='</select>';

        var yearSpan = this.header.find('.year').empty().append(yearDropdown);
        yearSpan.find('select.dropdown').dropdown().off('change.datepicker')
          .on('change.datepicker', function () {
            var elem = $(this);
            self.currentYear = parseInt(elem.val());
            self.showMonth(self.currentMonth, self.currentYear, true);
          });

        if (this.yearFist) {
          yearSpan.find('.dropdown-wrapper').css('left', '0');
          monthSpan.find('.dropdown-wrapper').css('left', '10px');
        }

      },

      // Put the date in the field and select on the calendar
      insertDate: function (date, isReset) {
        var month = (date instanceof Array ? date[1] : date.getMonth()),
            year  = (date instanceof Array ? date[0] : date.getFullYear()),
            day = (date instanceof Array ? date[2] : date.getDate()).toString();

        // Make sure Calendar is showing that month
        if (this.currentMonth !== month || this.currentYear !== year) {
          this.showMonth(month, year);
        }

        if (!this.isOpen()) {
          return;
        }

        // Show the Date in the UI
        var dateTd = this.days.find('td:not(.alternate)').filter(function() {
          return $(this).text().toLowerCase() === day;
        });

        if (dateTd.hasClass('is-disabled')) {
          this.activeTabindex(dateTd, true);
        } else {
          if (this.settings.showTime) {
            if (isReset) {
              this.time = this.getTimeString(date, this.show24Hours);

              if (this.settings.roundToInterval) {
                $('#timepicker-minutes').val('');
                date = this.setTime(date);
              }
            }
            else {
              date = this.setTime(date);
            }
          }

          this.setValue(date, true);
          this.days.find('.is-selected').removeClass('is-selected').removeAttr('aria-selected').removeAttr('tabindex');
          dateTd.addClass('is-selected').attr({'aria-selected': true});
          this.activeTabindex(dateTd, true);
        }
      },

      // Convert a string to boolean
      getBoolean: function(val) {
        var num = +val;
        return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
      },

      // Find the day of the week of the first of a given month
      firstDayOfMonth: function (year, month) {

        if (this.isIslamic) {
		      var firstDay = this.conversions.toGregorian(year, month, 1);
			    return (firstDay === null ? 1 : firstDay.getDay());
        }
        return  (new Date(year, month, 1)).getDay();
      },

      islamicYearIndex: function (islamicYear) {
        var yearIdx = islamicYear - 1318;
        if (yearIdx < 0 || yearIdx >= this.conversions.yearInfo.length) {
          return 0; // for an out-of-range year, simply returns 0
        } else {
          return yearIdx;
        }
      },

      // Find the date of the Month (29, 30, 31 ect)
      daysInMonth: function (year, month) {

        if (this.isIslamic) {
		      var monthLengthBitmap = this.conversions.yearInfo[this.islamicYearIndex(year)][0];
    			var monthDayCount = 0;
    			for (var M = 0; M <= month; M++) {
    				monthDayCount = 29 + (monthLengthBitmap & 1);
    				if (M === month) {
    					return monthDayCount;
    				}
    				monthLengthBitmap = monthLengthBitmap >> 1;
    			}
    			return 0;
        }
        return  (new Date(year, month, 0)).getDate();
      },

      /**
      * Set the Formatted value in the input
      * @param {Date} date  &nbsp;-&nbsp; The date to set in date format.
      * @param {Boolean} trigger  &nbsp;-&nbsp; If true will trigger the change event.
      */
      setValue: function(date, trigger) {
        //TODO Document this as the way to get the date
        this.currentDate = date;

        if (date instanceof Array) {
          this.currentIslamicDate = date;
          this.currentDate = this.conversions.toGregorian(date[0], date[1], date[2]);
          date = new Date(date[0], date[1], date[2]);
        }

        this.element.val(Locale.formatDate(date, {pattern: this.pattern}));

        if (trigger) {
          this.element.trigger('change').trigger('input');
        }

      },

      //Get the value from the field and set the internal variables or use current date
      setValueFromField: function() {
        var self = this,
          fieldValue = this.element.val(),
          gregorianValue = fieldValue;

        if (this.isIslamic && fieldValue) {
          var islamicValue = Locale.parseDate(this.element.val(), this.pattern);
          gregorianValue = this.conversions.toGregorian(islamicValue.getFullYear(), islamicValue.getMonth(),  islamicValue.getDate());
        }

        this.currentDate = gregorianValue || new Date();
        if (typeof this.currentDate === 'string') {
          this.currentDate = Locale.parseDate(this.currentDate, this.pattern, false);
        }

        if (this.currentDate === undefined) {
          this.currentDate = Locale.parseDate(gregorianValue, this.pattern, false);
        }

        this.currentDate = this.currentDate || new Date();
        this.currentMonth = this.currentDate.getMonth();
        this.currentYear = this.currentDate.getFullYear();
        this.currentDay = this.currentDate.getDate();

        if (this.isIslamic) {
          this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
          this.currentYear = this.currentDateIslamic[0];
          this.currentMonth = this.currentDateIslamic[1];
          this.currentDay = this.currentDateIslamic[2];
        }

        // Check and fix two digit year for main input element
        self.element.checkValidation();
        self.element.one('isvalid.datepicker', function (e, isValid) {
          if (isValid && self.element.val().trim() !== '') {
            self.setValue(Locale.parseDate(self.element.val().trim(), self.pattern, false));
          }
        });

      },

      /**
      * Set input to enabled.
      */
      enable: function() {
        this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
      },

      /**
      * Set input to disabled.
      */
      disable: function() {
        this.enable();
        this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
      },

      /**
      * Set input to readonly.
      */
      readonly: function() {
        this.enable();
        this.element.attr('readonly', 'readonly');
      },

      /**
      * Set to todays date in current format.
      */
      setToday: function() {
        this.currentDate = new Date();

        if (this.element.val() === '') {
          this.currentDate.setHours(0);
          this.currentDate.setMinutes(0);
          this.currentDate.setSeconds(0);
        } else {
          if (this.timepicker && this.timepicker.hourSelect) {
            this.currentDate.setHours(this.timepicker.hourSelect.val());
          }

          if (this.timepicker && this.timepicker.minuteSelect) {
            this.currentDate.setMinutes(this.timepicker.minuteSelect.val());
          }

          if (this.timepicker && this.timepicker.secondSelect) {
            this.currentDate.setSeconds(this.timepicker.secondSelect.val());
          }
        }

        if (this.isIslamic) {
          this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
        }

        if (this.isOpen()) {
          this.insertDate(this.isIslamic ? this.currentDateIslamic : this.currentDate, true);
        } else {
          this.element.val(Locale.formatDate(this.currentDate, {pattern: this.pattern})).trigger('change').trigger('input');
        }

      },

      // Set time
      setTime: function(date) {
        var hours = $('#timepicker-hours').val(),
          minutes = $('#timepicker-minutes').val(),
          seconds = this.isSeconds ? $('#timepicker-seconds').val() : 0,
          period = $('#timepicker-period');


        hours = (period.length && period.val() === 'PM' && hours < 12) ? (parseInt(hours, 10) + 12) : hours;
        hours = (period.length && period.val() === 'AM' && parseInt(hours, 10) === 12) ? 0 : hours;

        date.setHours(hours, minutes, seconds);
        return date;
      },

      // Get Time String
      getTimeString: function (date, isHours24) {
        var twodigit = function (number) {
            return (number < 10 ? '0' : '') + number;
          },
          d = (date || new Date()),
          h = d.getHours(),
          m = twodigit(d.getMinutes()),
          s = twodigit(d.getSeconds()),
          h12 = (h % 12 || 12) +':'+ m + (this.isSeconds ? ':'+ s : '') +' ' + (h < 12 ? 'AM' : 'PM'),
          h24 = h + ':' + m + (this.isSeconds ? ':'+ s : '');

        return isHours24 ? h24 : h12;
      },

      // Change the order for execution jquery events were bound
      // http://stackoverflow.com/questions/2360655/jquery-event-handlers-always-execute-in-order-they-were-bound-any-way-around-t
      changeEventOrder: function (elements, names, newIndex) {
        // Allow for multiple events.
        $.each(names.split(' '), function (idx, name) {
          elements.each(function () {
            var handlers = $._data(this, 'events')[name.split('.')[0]];
            // Validate requested position.
            newIndex = Math.min(newIndex, handlers.length - 1);
            handlers.splice(newIndex, 0, handlers.pop());
          });
        });
      },

      /**
       * Updates the component instance.  Can be used after being passed new settings.
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      teardown: function() {
        if (this.isOpen()) {
          this.closeCalendar();
        }

        this.element.off('blur.datepicker');
        this.trigger.remove();
        this.element.attr('data-mask', '');

        if (this.calendar && this.calendar.length) {
          this.calendar.remove();
        }

        if (this.popup && this.popup.length) {
          this.popup.remove();
        }

        var api = this.element.data('mask');
        if (api) {
          api.destroy();
        }

        this.element.off('keydown.datepicker blur.validate change.validate keyup.validate focus.validate');

        return this;
      },

      /**
      * Remove all events and reset back to default.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Datepicker#events
       * @param {Object} listopened  &nbsp;-&nbsp; Fires as the calendar popup is opened
       * @param {Object} listclosed  &nbsp;-&nbsp; Fires as the calendar popup is closed
       * @param {Object} change  &nbsp;-&nbsp; Fires after the value in the input is changed by any means.
       * @param {Object} input  &nbsp;-&nbsp; Fires after the value in the input is changed by user interaction.
       *
       */
      handleEvents: function () {
        var self = this;

        this.trigger.on('click.datepicker', function () {
          if (self.isOpen()) {
            self.closeCalendar();
          } else {
            self.openCalendar();
          }
        });

        self.mask();
        this.handleKeys(this.element);

        // Fix two digit year for main input element
        self.element.on('blur.datepicker', function () {
          self.element.one('isvalid.datepicker', function (e, isValid) {
            if (isValid && self.element.val().trim() !== '') {
              self.setValueFromField();
            }
          });
        });

      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new DatePicker(this, settings));
      }
    });
  };

/**
* A object containing all the supported UI formatters.
* @private
*/
window.Formatters = {

  Text: function(row, cell, value) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str;
  },

  Input: function(row, cell, value, col) {
    if (col.inlineEditor) {
      var html = '<label for="datagrid-inline-input-' + row + '-' + cell +'" class="audible">'+ col.name +'</label>'+
          '<input id="datagrid-inline-input-' + row + '-' + cell +'" class="'+ (col.align === 'right' ? 'is-number-mask': '') + '" value="'+ value +'">';

      return html;
    }

    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str;
  },

  Ellipsis: function(row, cell, value, col) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    col.textOverflow = 'ellipsis';
    return str;
  },

  Password: function(row, cell, value) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str.replace(/./g, '*');
  },

  Readonly: function(row, cell, value) {
    return '<span class="is-readonly">' + ((value === null || value === undefined) ? '' : value) + '</span>';
  },

  Date: function(row, cell, value, col, isReturnValue) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      value2;

    if (typeof value === 'string' && value) {

      if (value === '0000' || value === '000000' || value === '00000000') { //Means no date in some applications
        return '';
      }

      if (!col.sourceFormat) {
        value2 = Locale.parseDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
      } else {
        value2 = Locale.parseDate(value, (typeof col.sourceFormat === 'string' ? {pattern: col.sourceFormat}: col.sourceFormat));
      }

      if (value2) {
        formatted = Locale.formatDate(value2, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
      } else {
        formatted = Locale.formatDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));

        if (formatted === 'NaN/NaN/NaN') { //show invalid dates not NA/NA/NA
          formatted = value;
        }

      }
    } else if (value) {
      formatted = Locale.formatDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
    }

    if (!col.editor || isReturnValue === true) {
      return formatted;
    }
    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'calendar', classes: ['icon-calendar'] });
  },

  Time: function(row, cell, value, col) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      localeDateFormat = ((typeof Locale === 'object' && Locale.calendar().dateFormat) ? Locale.calendar().dateFormat.short : null),
      localeTimeFormat = ((typeof Locale === 'object' && Locale.calendar().timeFormat) ? Locale.calendar().timeFormat : null),
      value2;

    var parseTime = function (timeString) {
      if (timeString === '') {
        return null;
      }
      var time = timeString.match(/(\d+)(?::(\d\d))(?::(\d\d))?\s*([pP]?)/i);
      if (time === null) {
        return null;
      }
      var d = new Date();
      d.setHours(parseInt(time[1]) + (time[4] ? 12 : 0));
      d.setMinutes(parseInt(time[2]) || 0);
      d.setSeconds(parseInt(time[3]) || 0);
      return d;
    };

    if (typeof value === 'string' && value) {
      value2 = Locale.formatDate(parseTime(value), { pattern: (localeDateFormat +' '+ (col.sourceFormat || col.timeFormat || localeTimeFormat)) });

      if (value2) {
        formatted = value2.slice(value2.indexOf(' '));
      }
    }

    // Remove extra space in begining
    formatted = formatted.replace(/^\s/, '');

    if (!col.editor) {
      return formatted;
    }
    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'clock', classes: ['icon-clock'] });

  },

  Autocomplete: function(row, cell, value) {
    var formatted = ((value === null || value === undefined) ? '' : value);
    return formatted;
  },

  Lookup: function(row, cell, value, col, item) {
    var formatted = ((value === null || value === undefined) ? '' : value);

    if (!col.editor) {
      return formatted;
    }

    if (col.editorOptions && typeof col.editorOptions.field === 'function') {
      formatted = col.editorOptions.field(item, null, null);
    }

    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'search-list', classes: ['icon-search-list'] });
  },

  Decimal:  function(row, cell, value, col) {
    var formatted = value;
    if (typeof Locale !== undefined &&
        formatted !== null && formatted !== undefined && formatted !== '') {
       formatted = Locale.formatNumber(+value, col.numberFormat);
    }
    return ((formatted === null || formatted === undefined) ? '' : formatted);
  },

  Integer:  function(row, cell, value, col) {
    var formatted = value;
    if (typeof Locale !== undefined &&
        formatted !== null && formatted !== undefined && formatted !== '') {
      formatted = Locale.formatNumber(+value, col.numberFormat || {style: 'integer'});
    }
    return (formatted === null || formatted === undefined) ? '' : formatted;
  },

  Hyperlink: function(row, cell, value, col, item, api) {
    var textValue,
      colHref = col.href || '#';

    //Support for dynamic links based on content
    if (col.href && typeof col.href === 'function') {
      colHref = col.href(row, cell, item, col);
      //Passing a null href will produce "just text" with no link
      if (colHref == null) {
        return col.text || value;
      }
    } else  {
      colHref = colHref.replace('{{value}}', value);
    }

    textValue = col.text || value;
    if (!textValue && !col.icon) {
      return '';
    }

    return col.icon ?
      ('<a href="'+ colHref +'" class="btn-icon row-btn '+ (col.cssClass || '') +'" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + (col.hyperlinkTooltip ? ' title="'+ col.hyperlinkTooltip + '"': '') + '>'+
          $.createIcon({ icon: col.icon, file: col.iconFile }) +
          '<span class="audible">'+ textValue +'</span>'+
        '</a>') :
      ('<a href="'+ colHref +'" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + ' role="presentation" class="hyperlink '+ (col.cssClass || '') + '"' + (col.target ? ' target="' + col.target + '"' : '') + (col.hyperlinkTooltip ? ' title="'+ col.hyperlinkTooltip + '"': '') + '>'+ textValue +'</a>');
  },

  Template: function(row, cell, value, col, item) {
    var tmpl = col.template,
      renderedTmpl = '';

    if (Tmpl && item && tmpl) {
      var compiledTmpl = Tmpl.compile('{{#dataset}}'+tmpl+'{{/dataset}}');
      renderedTmpl = compiledTmpl.render({dataset: item});
    }

    return renderedTmpl;
  },

  Drilldown: function () {
    var text = Locale.translate('Drilldown');

    if (text === undefined) {
      text = '';
    }

    return (
      '<button type="button" tabindex="-1" class="btn-icon small datagrid-drilldown">' +
         $.createIcon({icon: 'drilldown'}) +
        '<span>' + text + '</span>' +
      '</button>'
    );
  },

  RowReorder: function () {
    var text = Locale.translate('ReorderRows');

    if (text === undefined) {
      text = 'Reorder Rows';
    }

    return (
      '<div class="datagrid-reorder-icon">' +
         $.createIcon({icon: 'drag'}) +
        '<span class="audible">' + text + '</span>' +
      '</div>'
    );
  },

  Checkbox: function (row, cell, value, col, item, api) {
    var isChecked;

    // Use isChecked function if exists
    if (col.isChecked) {
      isChecked = col.isChecked(value);
    } else {
      //treat 1, true or '1' as checked
      isChecked = (value == undefined ? false : value == true); // jshint ignore:line
    }

    // We add hidden Yes/No text so that the exported excel spreadsheet shows this text in checkbox columns
    var hiddenText = '<span class="hidden" aria-hidden="true" role="presentation">' + Locale.translate(isChecked ? 'Yes' : 'No') + '</span>';

    var animate = api.wasJustUpdated;
    api.wasJustUpdated = false;
    return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="'+ col.name +'" class="datagrid-checkbox ' +
     (isChecked ? 'is-checked ' + (!animate ? ' no-animation' : ' ') : '') +'" aria-checked="'+isChecked+'"></span>' + hiddenText + '</div>';
  },

  SelectionCheckbox: function (row, cell, value, col, item, api) {
    var isChecked = (value==undefined ? false : value == true); // jshint ignore:line
    if (!value) {
      isChecked = api.isNodeSelected(item);
    }
    return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="'+ (col.name ? col.name : Locale.translate('Select'))  +'" class="datagrid-checkbox datagrid-selection-checkbox' +
     (isChecked ? ' is-checked no-animate' : '') +'" aria-checked="'+isChecked+'"></span></div>';
  },

  Actions: function (row, cell, value, col) {
    //Render an Action Formatter
    return (
      '<button type="button" class="btn-actions" aria-haspopup="true" aria-expanded="false" aria-owns="'+ col.menuId +'">' +
        '<span class="audible">'+ col.title +'</span>' +
        $.createIcon({ icon: 'more' }) +
      '</button>'
    );
  },

  // Multi Line TextArea
  Textarea: function (row, cell, value) {
    var formatted = ((value === null || value === undefined) ? '' : value);
    return '<span class="datagrid-multiline-text">'+ formatted + '</span>';
  },

  // Rich Text Editor
  Editor: function (row, cell, value, col) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      classes = 'is-editor';
    classes += col.singleline ? '' : ' datagrid-multiline-text';
    classes += col.contentTooltip ? ' content-tooltip' : '';
    return '<div class="'+ classes +'">'+ $.unescapeHTML(formatted) +'</div>';
  },

  // Expand / Collapse Button
  Expander: function (row, cell, value) {
    var button = '<button type="button" aria-label="' + Locale.translate('ExpandCollapse') + '" class="btn-icon datagrid-expand-btn" tabindex="-1">'+
      '<span class="icon plus-minus"></span>' +
      '</button>' + ( value ? '<span> ' + value + '</span>' : '');

    return button;
  },

  // Datagrid Group Row
  GroupRow: function (row, cell, value, col, item, api) {
    var groupSettings = api.settings.groupable,
      groups = '',
      isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

    if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
      isOpen = groupSettings.expanded(row, cell, value, col, item, api);
    }

    for (var i = 0; i < groupSettings.fields.length ; i++) {
      groups += item[groupSettings.fields[i]] + (i === 0 ? '' : ',');
    }

    if (groupSettings.groupRowFormatter) {
      groups = groupSettings.groupRowFormatter(row, cell, value, col, item, api);
    }

    var button = '<button type="button" class="btn-icon datagrid-expand-btn'+ (isOpen ? ' is-expanded' : '') +'" tabindex="-1"' +'>'+
    '<span class="icon plus-minus'+ (isOpen ? ' active' : '') +'"></span>' +
    '<span class="audible">'+ Locale.translate('ExpandCollapse') +'</span>' +
    '</button>'+ '<span> '+ groups +'</span>';

    return button;
  },

  GroupFooterRow: function (row, cell, value, col, item, api) {
    var groupSettings = api.settings.groupable,
      isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

    if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
      isOpen = groupSettings.expanded(row, cell, value, col, item, api);
    }

    var idx = api.columnIdxById(groupSettings.aggregate),
        html = '<td role="gridcell" colspan=' + (idx) + '><div class="datagrid-cell-wrapper"></div></td><td role="gridcell"><div class="datagrid-cell-wrapper"> '+ item.sum +'</div></td>';

    if (groupSettings.groupFooterRowFormatter) {
      html = groupSettings.groupFooterRowFormatter(idx, row, cell, value, col, item, api);
    }

    return html;
  },

  SummaryRow: function (row, cell, value, col) {
    var afterText = '',
        beforeText = col.summaryText ||  '<b class="datagrid-summary-totals">' + Locale.translate('Total') + ' </b>';

    if (col.summaryTextPlacement === 'after') {
      afterText = beforeText;
      beforeText = '';
    }

    if (typeof Locale !== undefined && col.numberFormat &&
      value !== null && value !== undefined && value !== '') {
        value = Locale.formatNumber(+value, col.numberFormat);
    }

    return (beforeText + ((value === null || value === undefined || value === '') ? '' : value.toString()) + afterText);
  },

  // Tree Expand / Collapse Button and Paddings
  Tree: function (row, cell, value, col, item, api) {
    var isOpen = item.expanded,
      depth = api.settings.treeDepth[row] ? api.settings.treeDepth[row].depth : 0,
      button = '<button type="button" class="btn-icon datagrid-expand-btn'+ (isOpen ? ' is-expanded' : '') +'" tabindex="-1"'+ (depth ? ' style="margin-left: '+ (depth ? (30* (depth -1)) +'px' : '') +'"' : '') +'>'+
      '<span class="icon plus-minus'+ (isOpen ? ' active' : '') +'"></span>' +
      '<span class="audible">'+ Locale.translate('ExpandCollapse') +'</span>' +
      '</button>'+ ( value ? '<span> '+ value +'</span>' : ''),
      node = '<span class="datagrid-tree-node"'+ (depth ? ' style="margin-left: '+ (depth ? (30* (depth-1)) +'px' : '') +'"' : '') +'> '+ value +'</span>';

    return (item[col.children ? col.children : 'children'] ? button : node);
  },

  // Badge / Tags and Visual Indictors
  ClassRange: function (row, cell, value, col) {
    var ranges = col.ranges,
      classes = '', text='';

    if (!ranges) {
      return {};
    }

    for (var i = 0; i < ranges.length; i++) {
      if (value >= ranges[i].min && value <= ranges[i].max) {
        classes = ranges[i].classes;
        text = (ranges[i].text ? ranges[i].text : classes.split(' ')[0]);
      }

      if (value === ranges[i].value) {
        classes = ranges[i].classes;
        text = (ranges[i].text ? ranges[i].text : value);
      }
    }

    return {'classes': classes, 'text': text};
  },

  // Badge (Visual Indictors)
  Badge: function (row, cell, value, col) {
    var colorClasses = col.color,
      text = col.name;

    if (col.ranges) {
      var ranges = Formatters.ClassRange(row, cell, value, col);
      colorClasses = ranges.classes;
      text = ranges.text;
    }
    return '<span class="badge ' + colorClasses +'">' + value +' <span class="audible">'+ text+ '</span></span>';
  },

  Tag: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col);
    return '<span class="tag ' + ranges.classes +'">'+ value + '</span>';
  },

  Alert: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col);
    var icon = $.createIcon({
      icon: ranges.classes, classes: [
        'icon',
        'datagrid-alert-icon',
        'icon-' + ranges.classes
      ]
    });
    return icon + '<span class="datagrid-alert-text">' + (ranges.text === 'value' ? value : ranges.text) + '</span>';
  },

  Image: function (row, cell, value, col) {

    return '<img class="datagrid-img"' + ' src="' + value +'" alt= "' + (col.alt ? col.alt : Locale.translate('Image')) +
     '"' + (col.dimensions ? ' style="height:'+col.dimensions.height+';width:'+col.dimensions.height+'"' : '') + '/>';
  },

  Color: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col),
      text = ((value === null || value === undefined || value === '') ? '' : value.toString());

    return '<span class="' + ranges.classes + '">' + text + '</span>';
  },

  Colorpicker: function(row, cell, value, col) {
    var html = ((value === null || value === undefined || value === '') ? '' : value.toString());
    if (col.inlineEditor) {
      return html;
    }
    html = '<span class="colorpicker-container trigger dropdown-trigger"><span class="swatch" style="background-color: ' + value + '"></span><input class="colorpicker" id="colorpicker-' + cell + '" name="colorpicker-' + cell + '" type="text" role="combobox" aria-autocomplete="list" value="' + value + '" aria-describedby="">';
    html += '<span class="trigger">' + $.createIcon({ icon: 'dropdown' }) + '</span></span>';

    return html;
  },

  Button: function (row, cell, value, col, item, api) {
    var text = col.text ? col.text : ((value === null || value === undefined || value === '') ? '' : value.toString()),
      markup ='<button type="button" class="'+ ( col.icon ? 'btn-icon': 'btn-secondary') + ' row-btn ' + (col.cssClass ? col.cssClass : '') + '"' + (!api.settings.rowNavigation ? '' : ' tabindex="-1"') +' >';

      if (col.icon) {
        markup += $.createIcon({ icon: col.icon, file: col.iconFile });
      }
      markup += '<span>' + text + '</span></button>';

    return markup;
  },

  Dropdown: function (row, cell, value, col) {
    var formattedValue = value, compareValue, i, option, optionValue;

    if (col.options && value !== undefined) {
      compareValue = col.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

      for (i = 0; i < col.options.length; i++) {
        option = col.options[i];
        optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;

        if (optionValue === compareValue) {
          formattedValue = option.label;
          break;
        }
      }
    }

    var html = '<span class="trigger dropdown-trigger">' + formattedValue + '</span>' + $.createIcon({ icon: 'dropdown' });

    if (col.inlineEditor) {
      html = '<label for="full-dropdown" class="audible">'+ col.name +'</label>'+
        '<select id="'+ 'datagrid-dropdown' + row +'" class="dropdown">';

      for (i = 0; i < col.options.length; i++) {
        var opt = col.options[i];
        html += '<option' + (opt.id === undefined ? '' : ' id="' + opt.id + '"') +
                  ' value="' + opt.value + '"' +
                  (opt.selected || opt.value === compareValue ? ' selected ' : '') +
                '>'+ (opt.label !== undefined ? opt.label : opt.value !== undefined ? opt.value : '') + '</option>';
      }

      html += '</select>'+
      '<div class="dropdown-wrapper is-inline">'+
        '<div class="dropdown"><span>'+ formattedValue +'</span></div>'+
        '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">'+
          '<use xlink:href="#icon-dropdown"></use>'+
        '</svg>'+
      '</div>';
    }

    return html;
  },

  Spinbox: function (row, cell, value, col) {
    var html = ((value === null || value === undefined || value === '') ? '' : value.toString());

    if (col.inlineEditor) {
      html = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>' +
        '<span class="spinbox-wrapper"><span class="spinbox-control down">-</span>' +
        '<input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="'+ value +'">'+
        '<span class="spinbox-control up">+</span></span>';
    }

    return html;
  },

  Favorite: function (row, cell, value, col, item, api) {
    var isChecked;

    // Use isChecked function if exists
    if (col.isChecked) {
      isChecked = col.isChecked(value);
    } else {
      isChecked = (value == undefined ? false : value == true); // jshint ignore:line
    }

    var isEditable = col.editor && api.settings.editable;

    if (isChecked) {
      return '<span aria-label="'+ Locale.translate('Favorite') +'" class="icon-favorite'+ (isEditable ? ' is-editable': '') + '">' + $.createIcon({ icon: 'star-filled' }) + '</span>';
    } else {
      return col.showEmpty ? '<span aria-label="'+ Locale.translate('Favorite') +'" class="icon-favorite'+ (isEditable ? ' is-editable': '') + '">' + $.createIcon({ icon: 'star-outlined' }) + '</span>' : '';
    }
  },

  Status: function (row, cell, value, col, item) {

    if (!item.rowStatus) {
      return '<span></span>';
    }

    return $.createIcon({ icon: item.rowStatus.icon, classes: ['icon', 'icon-' + item.rowStatus.icon, 'datagrid-alert-icon'] }) + '<span class="audible">' + item.rowStatus.text + '</span>';
  },

  TargetedAchievement: function (row, cell, value, col) {
    var perc = (100*value),
      ranges = Formatters.ClassRange(row, cell, perc, col),
      target = col.target;

    var isWhite = perc > 55;  //Maybe implement this later perc > 60;
    return '<div class="total bar chart-completion-target chart-targeted-achievement"><div class="target remaining bar" style="width: '+ (target || 0) +'%;"></div><div class="completed bar ' + (col.ranges && ranges.classes ? ranges.classes : 'primary') + '" style="width: '+ perc +'%;"></div>' + (col.showPercentText ? '<div class="chart-targeted-text" '+ (isWhite ? 'style="color: white"' : '') +'>'+ perc +'%</div></div>' : '');
  },
  // TODO Possible future Formatters
  // Multi Select
  // Sparkline
  // Progress Indicator (n of 100%)
  // Process Indicator
  // Currency
  // File Upload (Simple)
  // Menu Button
  // Color Picker (Low)
};

/**
*  A object containing all the supported Editors
* @private
*/
window.Editors = {

  //Supports, Text, Numeric, Integer via mask
  Input: function(row, cell, value, container, column, e, api, item) {

    this.name = 'input';
    this.originalValue = value;
    this.useValue = column.inlineEditor ? true : false;

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('input');
      } else {
        this.input = $('<input type="'+ (column.inputType || 'text') +'"/>')
          .appendTo(container);
      }

      if (column.align) {
        this.input.addClass('l-'+ column.align +'-text');
      }

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      if (column.uppercase) {
        this.input.addClass('uppercase-text');
      }

      if (column.mask && typeof column.mask === 'function') {
        var mask = column.mask(row, cell, value, column, item);
        this.input.mask({pattern: mask, mode: column.maskMode});
      } else if (column.mask) {
        this.input.mask({pattern: column.mask, mode: column.maskMode});
      }

      var defaults = {
        patternOptions: {allowNegative: true, allowDecimal: true,
        integerLimit: 4, decimalLimit: 2,
        symbols: {
          thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
          decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal  : '.',
          negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign  : '-'
        }},
        process: 'number'
      };

      var useMask = false;

      if (column.maskOptions) {
        useMask = true;
      }

      if (column.numberFormat) {
        useMask = true;
        defaults = {patternOptions : {decimalLimit: column.numberFormat.maximumFractionDigits }};
      }

      if (useMask) {
        column.maskOptions = Soho.utils.extend(true, {}, defaults, column.maskOptions);
        this.input.mask(column.maskOptions);
      }

      if (!column.align || column.align !== 'right') {
        this.input.removeClass('is-number-mask');
      }

    };

    this.val = function (value) {
      var thisValue;
      if (value) {
        this.input.val(value);
      }
      if (column && column.numberFormat && column.numberFormat.style === 'percent') {
        thisValue = this.input.val().trim().replace(/(\s%?|%)$/g, '');
        return Locale.parseNumber(thisValue) / 100;
      }
      return this.input.val();
    };

    this.focus = function () {
      this.input.focus().select();
    };

    this.destroy = function () {
      if (column.inlineEditor) {
        return;
      }

      var self = this;
      setTimeout(function() {
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Textarea: function(row, cell, value, container, column) {

    this.name = 'textarea';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<textarea class="textarea"></textarea>').appendTo(container);

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      if (column.uppercase) {
        this.input.addClass('uppercase-text');
      }

    };

    this.val = function (value) {
      if (value) {
        //note that focus will help move text to end of input.
        this.input.focus().val(value);
      }
      return this.input.val();
    };

    this.focus = function () {
      this.input.focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  // Rich Text Editor
  Editor: function(row, cell, value, container, column, e, api) {
    this.name = 'editor';
    this.originalValue = value;

    this.init = function () {
      var self = this,
        // Editor options
        editorOptions = $.extend({}, {
          buttons: { editor: ['bold','italic','underline','strikethrough','separator', 'foreColor'], source: [] },
          excludeButtons: { editor: [] }
        }, column.editorOptions);

      // Editor width
      this.editorWidth = api.setUnit(editorOptions.width || container.outerWidth());
      delete editorOptions.width;

      container.append(
        '<div class="editor-wrapper" style="width:'+ this.editorWidth +';">'+
          '<div class="editor" data-init="false">'+ $.unescapeHTML(value) +'</div>'+
        '</div>');
      this.td = container.closest('td');
      this.input = $('.editor', container);

      this.input
        .popover({
          content: $('.editor-wrapper', container),
          placementOpts: {
            x: 0,
            y: '-'+ (parseInt(container[0].style.height, 10) + 35),
            parent: this.td,
            parentXAlignment: Locale.isRTL() ? 'right' : 'left',
            strategies: ['flip', 'nudge', 'shrink'],
          },
          placement : 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#editor-popup',
          extraClass: 'editor-popup'
        })
        .editor(editorOptions)
        .on('hide.editor', function () {
          api.commitCellEdit(self.input);
        })
        .on('keydown.editor', function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          // Ctrl + Enter (Some browser return keyCode: 10, not 13)
          if ((e.ctrlKey || e.metaKey) && (key === 13 || key === 10)) {
            var apiPopover = self.input.data('tooltip');
            if (apiPopover) {
              apiPopover.hide();
              api.setNextActiveCell(e);
            }
          }
        });
      Soho.utils.fixSVGIcons($('#editor-popup'));
    };

    this.val = function () {
      return this.input.html();
    };

    this.focus = function () {
      var self = this;
      setTimeout(function() {
        self.input.focus();
      }, 0);
    };

    this.destroy = function () {
      var self = this;
      container.removeAttr('style');
      api.quickEditMode = false;
      self.input.off('hide.editor keydown.editor');
      setTimeout(function() {
        self.input.remove();
        // Reset tooltip
        var elem = self.td.find('.is-editor.content-tooltip');
        api.setupContentTooltip(elem, self.editorWidth);
      }, 0);
    };

    this.init();
  },

  Checkbox: function(row, cell, value, container, column, event, grid) {

    this.name = 'checkbox';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value

    this.init = function () {

      this.input = $('<input type="checkbox" class="checkbox"/>').appendTo(container);
      this.input.after('<label class="checkbox-label"></label>');

      if (column.align) {
        this.input.addClass('l-'+ column.align +'-text');
      }

    };

    this.val = function (value) {
      var isChecked;

      if (value === undefined) {
        return this.input.prop('checked');
      }

      // Use isChecked function if exists
      if (column.isChecked) {
        isChecked = column.isChecked(value);
      } else {
        isChecked = value;
      }

      //just toggle it if we click right on it
      if ((event.type === 'click' || (event.type === 'keydown' && event.keyCode === 32)) && !$(event.target).is('.datagrid-checkbox-wrapper, .datagrid-cell-wrapper')) {
        isChecked = !isChecked;
        grid.setNextActiveCell(event);
      }

      this.input.prop('checked', isChecked);
    };

    this.focus = function () {
      this.input.trigger('focusout');
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.next('.checkbox-label').remove();
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Colorpicker: function(row, cell, value, container, column, event, grid) {
    this.name = 'colorpicker';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value

    this.init = function () {
      this.input = $('<input id="colorpicker-' + cell + '" name="colorpicker-' + cell + '" class="colorpicker" value="' + value + '" type="text" />').appendTo(container);
      this.input.colorpicker(column.editorOptions);
    };

    this.val = function (value) {
      return value ? this.input.val(value) : this.input.val();
    };

    this.focus = function () {

      var self = this;

      this.input.trigger('openlist');
      this.input.focus().select();

      this.input.off('listclosed').on('listclosed', function () {
        grid.commitCellEdit(self.input);

        container.parent('td').focus();
        return;
      });

    };

    this.destroy = function () {
      //We dont need to destroy since it will when the list is closed
    };

    this.init();
  },

  Dropdown: function(row, cell, value, container, column, event, grid, rowData) {

    this.name = 'dropdown';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value
    this.cell = grid.activeCell;

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('select');
        return;
      }

      this.input = $('<select class="dropdown"></select>').appendTo(container);

      if (column.options) {
        var html, opt, optionValue;
        value = grid.fieldValue(rowData,column.field);

        var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

        for (var i = 0; i < column.options.length; i++) {
          html = $('<option></option>');
          opt = column.options[i];
          optionValue = column.caseInsensitive && typeof opt.value === 'string' ? opt.value.toLowerCase() : opt.value;

          if (opt.selected || compareValue === optionValue) {
            html.attr('selected', 'true');
            this.originalValue = optionValue;
          }

          html.attr('value', opt.value).attr('id', opt.id).attr('data-type', typeof opt.value);
          html.text(opt.label);
          this.input.append(html);
        }
      }

      var editorOptions = column.editorOptions || {};

      function hasEditingClass() {
        return editorOptions.cssClass && /is-editing/g.test(editorOptions.cssClass);
      }
      // Add the class to both the options being passed, as well as the column's original options
      if (!hasEditingClass()) {
        editorOptions.cssClass = editorOptions.cssClass || '';
        editorOptions.cssClass += ' is-editing';
      }

      // Append the Dropdown's sourceArguments with some row/col meta-data
      editorOptions.sourceArguments = $.extend({}, editorOptions.sourceArguments, {
        column: column,
        container: container,
        grid: grid,
        cell: cell,
        event: event,
        row: row,
        rowData: rowData,
        value: value
      });

      this.input.dropdown(editorOptions);
    };

    this.val = function (value) {

      if (value !== undefined) {
        var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;
        this.input.val(value);

        this.input.find('option').each(function () {
          var opt = $(this), valueAttr = opt.attr('value'), type = opt.attr('data-type');
          var optionValue = valueAttr;

          // Get option value in proper type before checking equality
          if (type === 'number') {
            optionValue = parseFloat(valueAttr);
          } else if (type === 'boolean') {
            optionValue = valueAttr === 'true';
          } else if (type === 'string' && column.caseInsensitive) {
            optionValue = valueAttr.toLowerCase();
          }

          if (optionValue === compareValue) {
            opt.attr('selected', 'true');
          }
        });
      }

      var selected = this.input.find(':selected'),
        val = selected.attr('value'), dataType = selected.attr('data-type');

      // For non-string option values (number, boolean, etc.), convert string attr value to proper type
      if (dataType === 'number') {
        val = parseFloat(val);
      } else if (dataType === 'boolean') {
        val = val === 'true';
      }

      if (val === undefined) {
        val = selected.text();
      }

      return val;
    };

    this.focus = function () {
      var self = this;

      //Check if isClick or cell touch and just open the list
      this.input.trigger('openlist');
      this.input.parent().find('div.dropdown').focus();

      this.input.off('listclosed').on('listclosed', function (e, type) {
        grid.commitCellEdit(self.input);

        if (type === 'select') {
          container.parent('td').focus();
          return;
        }

        if (type === 'tab') {
          setTimeout(function () {
            container.parent('td').focus();
          }, 100);
        }
      });

    };

    this.destroy = function () {
      //We dont need to destroy since it will when the list is closed
    };

    this.init();
  },

  Date: function(row, cell, value, container, column, event, grid) {

    this.name = 'date';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="datepicker"/>').appendTo(container);
      this.input.datepicker(column.editorOptions || { dateFormat: column.dateFormat });
    };

    this.val = function (value) {
      if (value) {
        //Note that the value should be formatted from the formatter.
        this.input.val(value);
      }
      return window.Formatters.Date(row, cell, this.input.val(), column, true);
    };

    this.focus = function () {
      var self = this;

      this.input.select().focus();

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click' && $(event.target).is('.icon')) {
        this.input.parent().find('.icon').trigger('click');
        this.input.closest('td').addClass('is-focused');
      }

      this.input.on('listclosed', function () {
        self.input.closest('td').removeClass('is-focused');

        setTimeout(function () {
          self.input.trigger('focusout');
          container.parent().focus();
          grid.setNextActiveCell(event);
        }, 1);

      });

    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();

  },

  Time: function(row, cell, value, container, column, event, grid) {
    this.name = 'time';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="timepicker"/>').appendTo(container);
      this.api = this.input.timepicker(column.editorOptions || '').data('timepicker');
    };

    this.val = function (value) {
      if (value) {
        //Note that the value should be formatted from the formatter.
        this.input.val(value);
      }

      return this.input.val();
    };

    this.focus = function () {
      var self = this;

      this.input.select().focus();

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click' && $(event.target).is('.icon')) {
        this.input.parent().find('.icon').trigger('click');
        this.input.closest('td').addClass('is-focused');
      }

      this.api.trigger.on('hide.editortime', function () {
        self.input.closest('td').removeClass('is-focused');

        setTimeout(function () {
          self.input.trigger('focusout');
          container.parent().focus();
          grid.setNextActiveCell(event);
        }, 1);

      });

    };

    this.destroy = function () {
      var self = this;
      if (self.api && self.api.trigger) {
        self.api.trigger.off('hide.editortime');
      }

      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();

  },

  Lookup: function(row, cell, value, container, column, event, grid) {
    this.name = 'lookup';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="lookup" data-init="false" />').appendTo(container);

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      if (column.uppercase) {
        this.input.addClass('uppercase-text');
      }

      this.input.lookup(column.editorOptions);
    };

    this.val = function (value) {
      var fieldValue = this.input.val();
      if (fieldValue && fieldValue.indexOf('|') > -1) {
        fieldValue = fieldValue.substr(0, fieldValue.indexOf('|'));
      }
      return value ? this.input.val(value) : fieldValue;
    };

    this.focus = function () {
      var self = this,
        api = self.input.data('lookup'),
        td = self.input.closest('td');

      // Using keyboard
      if (event.type === 'keydown') {
        self.input.select().focus();
        td.on('keydown.editorlookup', function (e) {
          if (e.keyCode === 40 && grid.quickEditMode) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click') {
        if ($(event.target).is('svg')) {
          api.openDialog(event);
        } else {
          self.input.select().focus();
          td.on('touchcancel.editorlookup touchend.editorlookup', '.trigger', function() {
            api.openDialog();
          });
        }
      }

      // Update on change from lookup
      self.input.on('change', function () {
        setTimeout(function () {
          container.parent().focus();
          grid.setNextActiveCell(event);
          grid.quickEditMode = false;
        }, 1);
      });

    };

    this.destroy = function () {
      var self = this,
        td = this.input.closest('td');
      setTimeout(function() {
        grid.quickEditMode = false;
        td.off('keydown.editorlookup')
          .find('.trigger').off('touchcancel.editorlookup touchend.editorlookup');
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Autocomplete: function(ow, cell, value, container, column, event, grid) {
    this.name = 'autocomplete';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="autocomplete datagrid-autocomplete" data-autocomplete="source" />').appendTo(container);

      if (!column.editorOptions) {
        column.editorOptions = {};
      }
      column.editorOptions.width = container.parent().width();
      column.editorOptions.offset = {left: -1, top: (grid.settings.rowHeight ==='medium' ? 1 : 5)};

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      if (column.uppercase) {
        this.input.addClass('uppercase-text');
      }

      this.input.autocomplete(column.editorOptions);
    };

    this.val = function (value) {
      return value ? this.input.val(value) : this.input.val();
    };

    this.focus = function () {
      grid.quickEditMode = true;
      this.input.select().focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Spinbox: function(ow, cell, value, container, column, event, grid) {
    this.name = 'spinbox';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('input');
        return;
      }

      var markup = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>' +
        '<span class="spinbox-wrapper"><span class="spinbox-control down">-</span>' +
        '<input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="'+ value +'">'+
        '<span class="spinbox-control up">+</span></span>';

      container.append(markup);
      this.input = container.find('input');

      if (!column.editorOptions) {
        column.editorOptions = {};
      }

      this.input.spinbox(column.editorOptions);
    };

    this.val = function (value) {
      return value ? parseInt(this.input.val(value)) : parseInt(this.input.val());
    };

    this.focus = function () {
      grid.quickEditMode = true;
      this.input.select().focus();
    };

    this.destroy = function () {
      if (column.inlineEditor) {
        return;
      }

      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Favorite: function(row, cell, value, container, column, event, grid) {
    this.name = 'favorite';
    this.useValue = true;
    this.originalValue = value;

    this.init = function () {
      this.input = $('<span class="icon-favorite">' +
            $.createIcon({ icon: value ? 'star-filled' : 'star-outlined' }) + '<input type="checkbox"></span>').appendTo(container);

      this.input = this.input.find('input');
    };

    this.val = function (value) {
      var isChecked;

      if (value === undefined) {
        return this.input.prop('checked');
      }

      // Use isChecked function if exists
      if (column.isChecked) {
        isChecked = column.isChecked(value);
      } else {
        isChecked = value;
      }

      //just toggle it when clicked
      if ((event.type === 'click' || (event.type === 'keydown' && event.keyCode === 32)) && (!$(event.target).is('.datagrid-cell-wrapper'))) {
        isChecked = !isChecked;
        grid.setNextActiveCell(event);
      }

      this.input.prop('checked', isChecked);
      this.input.find('use').attr('xlink:href', isChecked ? '#icon-star-filled' : '#icon-star-outlined');
    };

    this.focus = function () {
      this.input.trigger('focusout').focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.parent().remove();
      }, 0);
    };

    this.init();
  }
};

/**
* An api for grouping data by a given field (s)
* @private
*/
window.GroupBy = (function() {

  //Can also use in isEquivalent: function(obj1, obj2)  in datagrid.js
  var equals = window.Soho.utils.equals;

  //See if the object has these proprties or not
  var has = function(obj, target) {
    return obj.some(function(value) {
        return equals(value, target);
    });
  };

  //Return just the object properties matching the names
  var pick = function(obj, names) {
    var chosen = {};
    for (var i = 0; i < names.length; i++) {
      chosen[names[i]] = obj[names[i]];
    }
    return chosen;
  };

  //Return the specific keys from the object
  var keys = function(data, names) {
    return data.reduce(function(memo, item) {
      var key = pick(item, names);

      if (!has(memo, key)) {
        memo.push(key);
      }
      return memo;
    }, []);
  };

  //Look through each value in the list and return an array of all the values
  //that contain all of the key-value pairs listed in properties.
  var where = function (data, names) {
    var chosen = [];

    data.map(function(item) {
      var match = true;
      for (var prop in names) {
        if (names[prop] !== item[prop]) {
          match = false;
          return;
        }
      }
      chosen.push(item);
      return;
    });

    return chosen;
  };

  //Grouping Function with Plugins/Aggregator
  var group = function(data, names) {
    var stems = keys(data, names);

    return stems.map(function(stem) {
      return {
        key: stem,
        values: where(data, stem).map(function(item) {
          return item;
        })
      };
    });
  };

  //Register an aggregator
  group.register = function(name, converter) {
    return group[name] = function(data, names, extra) { // jshint ignore:line
      var that = this;
      that.extra = extra;
      return group(data, names).map(converter, that);
    };
  };

  return group;
}());

/**
* Register built in aggregators
* @private
*/
GroupBy.register('none', function(item) {
  return $.extend({}, item.key, {values: item.values});
});

GroupBy.register('sum', function(item) {
  var extra = this.extra;
  return $.extend({}, item.key, {values: item.values}, {sum: item.values.reduce(function(memo, node) {
      return memo + Number(node[extra]);
  }, 0)});
});

GroupBy.register('max', function(item) {
  var extra = this.extra;
  return $.extend({}, item.key, {values: item.values}, {max: item.values.reduce(function(memo, node) {
      return Math.max(memo, Number(node[extra]));
  }, Number.NEGATIVE_INFINITY)});
});

GroupBy.register('list', function(item) {
  var extra = this.extra;

  return $.extend({}, item.key, {values: item.values}, {list: item.values.map(function(item) {
    var list = [];

    for (var i = 0; i < extra.list.length; i++) {
      var exclude = extra.exclude ? item[extra.exclude] : false;
      if (item[extra.list[i]] && !exclude) {
        list.push({value: item[extra.list[i]], key: extra.list[i]});
      }
    }
    return list;
  })});
});

/**
* Simple Summary Row Accumlator
* @private
*/
window.Aggregators = {};
window.Aggregators.aggregate = function (items, columns) {
    var totals = {}, self = this;

    for (var i = 0; i < columns.length; i++) {
        if (columns[i].aggregator) {
            var field = columns[i].field;

            self.sum = function (sum, node) {
                var value;
                if (field.indexOf('.') > -1) {
                    value = field.split('.').reduce(function (o, x) {
                        return (o ? o[x] : '');
                    }, node);
                }
                else {
                    value = node[field];
                }
                return sum + Number(value);
            };

            var total = items.reduce(self[columns[i].aggregator], 0);

            if (field.indexOf('.') > -1) {
                var currentObj = totals;
                for (var j = 0; j < field.split('.').length; j++) {
                    if (j === field.split('.').length - 1) {
                        currentObj[field.split('.')[j]] = total;
                    }
                    else {
                        if (!(field.split('.')[j] in currentObj)) {
                            currentObj[field.split('.')[j]] = {};
                        }

                        currentObj = currentObj[field.split('.')[j]];
                    }
                }
            }
            else {
                totals[field] = total;
            }
        }
    }

    return totals;
};

/**
* Actual Datagrid jQuery Plugin
* @private
*/
$.fn.datagrid = function(options) {

  // Settings and Options
  var pluginName = 'datagrid',
      defaults = {
        // F2 - toggles actionableMode "true" and "false"
        // If actionableMode is "true”, tab and shift tab behave like left and right arrow key,
        // if the cell is editable it goes in and out of edit mode
        actionableMode: false,
        cellNavigation: true, // If cellNavigation is "false”, will show border around whole row on focus
        rowNavigation: true, // If rowNavigation is "false”, will NOT show border around the row
        alternateRowShading: false, //Sets shading for readonly grids
        columns: [],
        dataset: [],
        columnReorder: false, // Allow Column reorder
        saveColumns: false, //Save Column Reorder and resize
        saveUserSettings: {}, //Save one or all of the following to local storage : columns: true, rowHeight: true, sortOrder: true, pagesize: true, activePage: true, filter: true
        editable: false,
        isList: false, // Makes a readonly "list"
        menuId: null,  //Id to the right click context menu
        headerMenuId: null,  //Id to the right click context menu to use for the header
        menuSelected: null, //Callback for the grid level right click menu
        menuBeforeOpen: null, //Call back for the grid level before open menu event
        headerMenuSelected: null, //Callback for the header level right click menu
        headerMenuBeforeOpen: null, //Call back for the header level before open menu event
        uniqueId: null, //Unique ID for local storage reference and variable names
        rowHeight: 'normal', //(short, medium or normal)
        selectable: false, //false, 'single' or 'multiple'
        groupable: null, //Use Data grouping fx. {fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}
        clickToSelect: true,
        toolbar: false, // or features fx.. {title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}
        initializeToolbar: true, // can set to false if you will initialize the toolbar yourself
        //Paging Options
        paging: false,
        pagesize: 25,
        pagesizes: [10, 25, 50, 75],
        showPageSizeSelector: true, // Will show page size selector
        indeterminate: false, //removed ability to go to a specific page.
        source: null, //callback for paging
        hidePagerOnOnePage: false, //If true, hides the pager if there's only one page worth of results.
        //Filtering Options
        filterable: false,
        disableClientFilter: false, //Disable Filter Logic client side and let your server do it
        disableClientSort: false, //Disable Sort Logic client side and let your server do it
        resultsText: null,  // Can provide a custom function to adjust results text
        showFilterTotal : true, // Paging results show filtered count, false to not show.
        virtualized: false, // Prevent Unused rows from being added to the DOM
        virtualRowBuffer: 10, //how many extra rows top and bottom to allow as a buffer
        rowReorder: false, //Allows you to reorder rows. Requires rowReorder formatter
        showDirty: false,
        showSelectAllCheckBox: true, // Allow to hide the checkbox header (true to show, false to hide)
        allowOneExpandedRow: true, //Only allows one expandable row at a time
        enableTooltips: false,  //Process tooltip logic at a cost of performance
        disableRowDeactivation: false, // If a row is activated the user should not be able to deactivate it by clicking on the activated row
        sizeColumnsEqually: false, //If true make all the columns equal width
        expandableRow: false, // Supply an empty expandable row template
        redrawOnResize: true, //Run column redraw logic on resize
        exportConvertNegative: false, // Export data with trailing negative signs moved in front
        onPostRenderCell: null, //A call back function that will fire and send you the cell container and related information for any cells with postRender: true.
        onDestroyCell: null, //A call back that goes along with onPostRenderCell and will fire when this cell is destroyed and you need notification of that.
        emptyMessage: {title: (Locale ? Locale.translate('NoData') : 'No Data Available'), info: '', icon: 'icon-empty-no-data'}
      },
      settings = $.extend({}, defaults, options);

  /**
  * The Datagrid Component displays and process data in tabular format.
  *
  * @class Datagrid
  * @param {Boolean} actionableMode &nbsp;-&nbsp If actionableMode is "true”, tab and shift tab behave like left and right arrow key, if the cell is editable it goes in and out of edit mode. F2 - toggles actionableMode "true" and "false"
  * @param {Boolean} cellNavigation &nbsp;-&nbsp If cellNavigation is "false”, will show border around whole row on focus
  * @param {Boolean} rowNavigation  &nbsp;-&nbsp If rowNavigation is "false”, will NOT show border around the row
  * @param {Boolean} alternateRowShading  &nbsp;-&nbsp Sets shading for readonly grids
  * @param {Array} columns  &nbsp;-&nbsp an array of columns (see column options)
  * @param {Array} dataset  &nbsp;-&nbsp an array of data objects
  * @param {Boolean} columnReorder  &nbsp;-&nbsp Allow Column reorder
  * @param {Boolean} saveColumns  &nbsp;-&nbsp Save Column Reorder and resize
  * @param {Object} saveUserSettings  &nbsp;-&nbsp Save one or all of the following to local storage : columns: true, rowHeight: true, sortOrder: true, pagesize: true, activePage: true, filter: true
  * @param {Boolean} editable &nbsp;-&nbsp Enable editing in the grid, requires column editors.
  * @param {Boolean} isList  &nbsp;-&nbsp Makes the grid have readonly "list" styling
  * @param {String} menuId  &nbsp;-&nbspId of the menu to use for a row level right click context menu
  * @param {String} menuSelected  &nbsp;-&nbsp Callback for the grid level context menu
  * @param {String} menuBeforeOpen  &nbsp;-&nbsp Callback for the grid level beforeopen menu event
  * @param {String} headerMenuId  &nbsp;-&nbsp Id of the menu to use for a header right click context menu
  * @param {String} headerMenuSelected  &nbsp;-&nbsp Callback for the header level context menu
  * @param {String} headerMenuBeforeOpen  &nbsp;-&nbsp Callback for the header level beforeopen menu event
  * @param {String} uniqueId &nbsp;-&nbsp Unique ID to use as local storage reference and internal variable names
  * @param {String} rowHeight &nbsp;-&nbsp Controls the height of the rows / number visible rows. May be (short, medium or normal)
  * @param {String} selectable &nbsp;-&nbsp Controls the selection Mode this may be: false, 'single' or 'multiple' or 'mixed'
  * @param {Object} groupable &nbsp;-&nbsp  Controls fields to use for data grouping Use Data grouping fx. {fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}
  * @param {Boolean} clickToSelect &nbsp;-&nbsp Controls if using a selection mode if you can click the rows to select
  * @param {Object} toolbar  &nbsp;-&nbsp Toggles and appends toolbar features fx.. {title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}
  * @param {Boolean} initializeToolbar &nbsp;-&nbsp Set to false if you will initialize the toolbar yourself
  * @param {Boolean} paging &nbsp;-&nbsp Enable paging mode
  * @param {Number} pagesize &nbsp;-&nbsp Number of rows per page
  * @param {Array} pagesizes &nbsp;-&nbsp Array of page sizes to show in the page size dropdown.
  * @param {Boolean} indeterminate &nbsp;-&nbsp Disable the ability to go to a specific page when paging.
  * @param {Function} source  &nbsp;-&nbsp Callback function for paging
  * @param {Boolean} hidePagerOnOnePage  &nbsp;-&nbsp If true, hides the pager if there's only one page worth of results.
  * @param {Boolean} filterable &nbsp;-&nbsp Enable Column Filtering, This will require column filterTypes as well.
  * @param {Boolean} disableClientFilter &nbsp;-&nbsp Disable Filter Logic client side and let your server do it
  * @param {Boolean} disableClientSort &nbsp;-&nbsp Disable Sort Logic client side and let your server do it
  * @param {String} resultsText &nbsp;-&nbsp Can provide a custom function to adjust results text on the toolbar
  * @param {Boolean} showFilterTotal &nbsp;-&nbsp Paging results display filter count, change to false to not show filtered count
  * @param {Boolean} rowReorder &nbsp;-&nbsp If set you can reorder rows. Requires rowReorder formatter
  * @param {Boolean} showDirty &nbsp;-&nbsp  If true the dirty indicator will be shown on the rows
  * @param {Boolean} showSelectAllCheckBox &nbsp;-&nbsp Allow to hide the checkbox header (true to show, false to hide)
  * @param {Boolean} allowOneExpandedRow  &nbsp;-&nbsp Controls if you cna expand more than one expandable row.
  * @param {Boolean} enableTooltips &nbsp;-&nbsp Process tooltip logic at a cost of performance
  * @param {Boolean} disableRowDeactivation &nbsp;-&nbsp if a row is activated the user should not be able to deactivate it by clicking on the activated row
  * @param {Boolean} sizeColumnsEqually &nbsp;-&nbsp If true make all the columns equal width
  * @param {Boolean} expandableRow &nbsp;-&nbsp If true we append an expandable row area without the rowTemplate feature being needed.
  * @param {Boolean} redrawOnResize &nbsp;-&nbsp If set to false we skip redraw logic on the resize of the page.
  * @param {Boolean} exportConvertNegative &nbsp;-&nbsp If set to true export data with trailing negative signs moved in front.
  * @param {Boolean} onPostRenderCell &nbsp;-&nbsp A call back function that will fire and send you the cell container and related information for any cells cells with a component attribute in the column definition.
  * @param {Boolean} onDestroyCell &nbsp;-&nbsp A call back that goes along with onPostRenderCell and will fire when this cell is destroyed and you need noification of that.
  * @param {Boolean} emptyMessage &nbsp;-&nbsp An empty message will be displayed when there is no rows in the grid. This accepts an object of the form emptyMessage: {title: 'No Data Available', info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data', button: {text: 'xxx', click: <function>}} set this to null for no message or will default to 'No Data Found with an icon.'
  */
  function Datagrid(element) {
    this.element = $(element);
    Soho.logTimeStart(pluginName);
    this.init();
    Soho.logTimeEnd(pluginName);
  }

  /**
  * Actual Datagrid prototype
  * @private
  */
  Datagrid.prototype = {

    /**
    * Init the datagrid from its uninitialized state.
    * @private
    */
    init: function() {
      var self = this, html = $('html');

      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.isFirefoxMac = (navigator.platform.indexOf('Mac') !== -1 && navigator.userAgent.indexOf(') Gecko') !== -1);
      this.isIe = html.is('.ie');
      this.isIe9 = html.is('.ie9');
      this.isSafari = html.is('.is-safari');
      this.isWindows = (navigator.userAgent.indexOf('Windows') !== -1);
      this.settings = settings;
      this.initSettings();
      this.originalColumns = self.columnsFromString(JSON.stringify(this.settings.columns));
      this.removeToolbarOnDestroy = false;
      this.nonVisibleCellErrors = [];

      this.restoreColumns();
      this.restoreUserSettings();
      this.appendToolbar();
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.firstRender();
      this.handlePaging();
      this.handleEvents();
      this.handleKeys();

      setTimeout(function () {
        self.element.trigger('rendered', [self.element, self.headerRow, self.pagerBar]);
      }, 0);
    },

    /**
    * Initialize internal variables and states.
    * @private
    */
    initSettings: function () {

      this.sortColumn = {sortField: null, sortAsc: true};
      this.gridCount = $('.datagrid').length + 1;
      this.lastSelectedRow = 0;// Remember index to use shift key

      this.contextualToolbar = this.element.prev('.contextual-toolbar');
      this.contextualToolbar.addClass('datagrid-contextual-toolbar');
    },

    /**
    * Render or render both header and row area.
    */
    render: function () {
      this.loadData(this.settings.dataset);
    },

    /**
    * Run the first render on the Header and Rows.
    * @private
    */
    firstRender: function () {
      var self = this;

      self.contentContainer = $('<div class="datagrid-body"></div>');

      if (this.settings.dataset === 'table') {
        self.table = $(this.element).addClass('datagrid');

        var wrapper = $(this.element).closest('.datagrid-container');
        if (wrapper.length === 0) {
          self.table.wrap('<div class="datagrid-container"></div>');
          this.element = self.table.closest('.datagrid-container');
        }

        self.settings.dataset = self.htmlToDataset();
        self.table.remove();
        self.table = $('<table></table>').addClass('datagrid').attr('role', 'grid').appendTo(self.contentContainer);

      } else {
        self.table = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.contentContainer);
        this.element.addClass('datagrid-container').attr('x-ms-format-detection','none');
      }

      if (this.isWindows) {
        this.element.addClass('is-windows'); //need since scrollbars are visible
      }

      //initialize row height by a setting
      if (settings.rowHeight !== 'normal') {
        self.table.addClass(settings.rowHeight + '-rowheight');
        this.element.addClass(settings.rowHeight + '-rowheight');
      }

      //A treegrid is considered not editable unless otherwise specified.
      if (this.settings.treeGrid && !this.settings.editable) {
        self.table.attr('aria-readonly', 'true');
      }

      if (this.settings.isList) {
        $(this.element).addClass('is-gridlist');
      } else {
        $(this.element).removeClass('is-gridlist');
      }

      self.table.empty();
      self.clearHeaderCache();
      self.renderRows();
      self.element.append(self.contentContainer);
      self.renderHeader();
      self.container = self.element.closest('.datagrid-container');

      if (this.settings.emptyMessage) {
        var opts = this.settings.emptyMessage;
        //Object { title: "No Data Available", info: "", icon: "icon-empty-no-data" }

        self.emptyMessageContainer = $('<div class="datagrid-empty-message">'+
          (!opts.icon ? '' : '<div class="empty-icon">'+
            '<svg class="icon-empty-state" focusable="false" aria-hidden="true" role="presentation">'+
            '<use xlink:href="#'+opts.icon+'"></use>'+
            '</svg>'+
          '</div>')+
          '<div class="empty-title">'+
            opts.title +
          '</div>'+
          (!opts.info ? '' : '<div class="empty-info">'+
            opts.info +
          '</div>')+
          (!opts.button ? '' : '<div class="empty-actions">'+
            '<button type="button" class="btn-secondary hide-focus '+ opts.button.cssClass +'" id="'+ opts.button.id +'">'+
              '<span>'+ opts.button.text +'</span>'+
            '</button>'+
          '</div>')+
        '</div>');
        self.contentContainer.prepend(self.emptyMessageContainer);
      }

      self.settings.buttonSelector = '.btn, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split';
      $(self.settings.buttonSelector, self.table).button();
    },

    /**
    * If the datagrid is a html table, convert that table to an internal dataset to use.
    * @private
    */
    htmlToDataset: function () {
      var rows = $(this.element).find('tbody tr'),
        self = this,
        specifiedCols = (self.settings.columns.length > 0),
        dataset = [];

      //Geneate the columns if not supplier
      if (!specifiedCols) {
        var headers = $(this.element).find('thead th'),
          firstRow = self.element.find('tbody tr:first()');

        headers.each(function (i, col) {
          var colSpecs = {},
            column = $(col),
            colName = 'column'+i;

          colSpecs.id  = column.text().toLowerCase();
          colSpecs.name = column.text();
          colSpecs.field = colName;

          var link = firstRow.find('td').eq(i).find('a');
          if (link.length > 0) {
            colSpecs.formatter = Formatters.Hyperlink;
            colSpecs.href = link.attr('href');
          }

          self.settings.columns.push(colSpecs);
        });
      }

      rows.each(function () {
        var cols = $(this).find('td'),
          newRow = {};

        cols.each(function (i, col) {
          var column = $(col),
            colName = 'column'+i;

          if (self.settings.columns[i].formatter) {
            newRow[colName] = column.text();
          } else {
            newRow[colName] = column.html();
          }

          if (specifiedCols) {
            self.settings.columns[i].field = colName;
          }

        });

        dataset.push(newRow);
      });

      return dataset;
    },

    /**
    * Add a row of data to the grid and dataset.
    * @param {Object} data &nbsp;-&nbsp An data row object
    * @param {String} location &nbsp;-&nbsp Where to add the row. This can be 'top' or leave off for 'bottom'
    */
    addRow: function (data, location) {
      var self = this,
        isTop = false,
        row = 0,
        cell = 0,
        args,
        rowNode;

      if (!location || location === 'top') {
        location = 'top';
        isTop = true;
      }
      //Add row status
      data.rowStatus = {icon: 'new', text: 'New', tooltip: 'New'};

      // Add to array
      if (typeof location === 'string') {
        self.settings.dataset[isTop ? 'unshift' : 'push'](data);
      }
      else {
        self.settings.dataset.splice(location, 0, data);
      }

      // Add to ui
      self.renderRows();

      // Sync with others
      self.syncSelectedUI();

      // Set active and fire handler
      setTimeout(function () {
        row = isTop ? row : self.settings.dataset.length - 1;
        self.setActiveCell(row, cell);

        rowNode = self.tableBody.find('tr[aria-rowindex="'+ (row + 1) +'"]');
        args = {row: row, cell: cell, target: rowNode, value: data, oldValue: []};

        self.pagerRefresh(location);
        self.element.triggerHandler('addrow', args);
      }, 10);
    },

    /**
    * Refresh the pager based on the current page and dataset.
    * @param {Object} location &nbsp;-&nbsp Deprecated - Can be set to 'top' or left off for bottom pager.
    */
    pagerRefresh: function (location) {
      if (this.pager) {
        var activePage = this.pager.activePage;
        if (typeof location === 'string') {
          activePage = location === 'top' ? 1 : this.pager._pageCount;
        }
        else if (typeof location === 'number') {
          activePage = Math.floor(location / this.pager.settings.pagesize + 1);
        }

        this.pager.pagingInfo = $.extend({}, this.pager.pagingInfo, {
          activePage: activePage,
          total: this.settings.dataset.length,
          pagesize: this.settings.pagesize
        });

        this.renderPager(this.pager.pagingInfo);
      }
    },

    /**
    * Remove a row of data to the grid and dataset.
    * @param {Number} row &nbsp;-&nbsp The row index
    * @param {Boolean} nosync &nbsp;-&nbsp Dont sync the selected rows.
    */
    removeRow: function (row, nosync) {
      var rowNode = this.tableBody.find('tr[aria-rowindex="'+ (row + 1) +'"]'),
        rowData = this.settings.dataset[row];
      this.unselectRow(row, nosync);
      this.settings.dataset.splice(row, 1);
      this.renderRows();
      this.element.trigger('rowremove', {row: row, cell: null, target: rowNode, value: [], oldValue: rowData});
    },

    /**
    * Remove all selected rows from the grid and dataset.
    */
    removeSelected: function () {

      var self = this,
        selectedRows = this.selectedRows();

      for (var i = selectedRows.length-1; i >= 0; i--) {
        self.removeRow(selectedRows[i].idx, true);
      }
      this.pagerRefresh();
      this.syncSelectedUI();
    },

    /**
    * Send in a new data set to display in the datagrid.
    *
    * @param {Object} dataset &nbsp;-&nbsp The array of objects to show in the grid. Should match the column definitions.
    * @param {Object} pagerInfo &nbsp;-&nbsp The pager info object with information like activePage ect.
    */
    updateDataset: function (dataset, pagerInfo) {
      this.loadData(dataset, pagerInfo);
    },

    /**
    * Trigger the source method to call to the backend on demand.
    *
    * @param {Object} pagerInfo &nbsp;-&nbsp The pager info object with information like activePage ect.
    */
    triggerSource: function(pagerType, callback) {
      this.pager.pagerInfo = this.pager.pagerInfo || {};
      this.pager.pagerInfo.type = pagerType;

      if (pagerType !== 'refresh') {
        this.pager.pagerInfo.activePage = 1;
      }

      this.renderPager(this.pager.pagerInfo, false, function() {
        if (callback && typeof callback === 'function') {
          callback();
        }
      });
    },

    /**
    * Send in a new data set to display in the datagrid. Use better named updateDataset
    * @deprecated
    * @private
    * @param {Object} dataset &nbsp;-&nbsp The array of objects to show in the grid. Should match the column definitions.
    * @param {Object} pagerInfo &nbsp;-&nbsp The pager info object with information like activePage ect.
    * @param {Object} isResponse &nbsp;-&nbsp Called internally if the load data is response
    */
    loadData: function (dataset, pagerInfo, isResponse) {
      this.settings.dataset = dataset;

      if (!pagerInfo) {
        pagerInfo = {};
      }

      if (!pagerInfo.activePage) {
        pagerInfo.activePage = 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = -1;
        pagerInfo.type = 'initial';
      }

      if (this.pager) {
        if (pagerInfo.activePage > -1) {
          this.pager.activePage = pagerInfo.activePage;
        }
        this.pager.settings.dataset = dataset;
      }

      //Update Paging and Clear Rows
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();

      if (pagerInfo && !pagerInfo.preserveSelected) {
        this.unSelectAllRows();
      }

      //Resize and re-render if have a new dataset (since automatic column sizing depends on the dataset)
      if (pagerInfo.type === 'initial') {
        this.clearHeaderCache();
        this.restoreUserSettings();
        this.renderRows();
        this.renderHeader();
      } else {
        this.renderRows();
      }

      this.renderPager(pagerInfo, isResponse);
      this.syncSelectedUI();

    },

    /**
    * Generate a unique id based on the page and grid count. Add a suffix.
    * @deprecated
    * @private
    * @param {Object} suffix &nbsp;-&nbsp Add this string to make the id more unique
    */
    uniqueId: function (suffix) {
      var uniqueid = this.settings.uniqueId ?
        this.settings.uniqueId + '-' + suffix :
        (window.location.pathname.split('/').pop()
          .replace(/\.xhtml|\.shtml|\.html|\.htm|\.aspx|\.asp|\.jspx|\.jsp|\.php/g, '')
          .replace(/[^-\w]+/g, '')
          .replace(/\./g, '-')
          .replace(/ /g, '-')
          .replace(/%20/g, '-') +'-'+
            (this.element.attr('id') || 'datagrid') +'-'+ this.gridCount + suffix);

      return uniqueid.replace(/--/g, '-');
    },

    /**
    * Returns an array with all visible columns.
    * @param {Object} skipBuiltIn &nbsp;-&nbsp If true then built in columns like selectionCheckbox are skipped.
    */
    visibleColumns: function (skipBuiltIn) {
      var visible = [];
      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j];

        if (column.hidden) {
          continue;
        }

        if (skipBuiltIn && column.id === 'selectionCheckbox') {
          continue;
        }
        visible.push(column);
      }
      return visible;
    },

    /**
    * Returns the index of the last column.
    * @private
    */
    lastColumnIdx: function () {
      var last = 0;

      if (this.lastColumn) {
        return this.lastColumn;
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j];

        if (column.hidden) {
          continue;
        }

        last = j;
      }

      this.lastColumn = last;
      return last;
    },

    /**
    * Gets an If for the column group used for grouped headers.
    * @param {Object} idx &nbsp;-&nbsp The index of the column group
    */
    getColumnGroup: function(idx) {
      var total = 0,
        colGroups = this.settings.columnGroups;

      for (var l = 0; l < colGroups.length; l++) {
        total += colGroups[l].colspan;

        if (total >= idx) {
          return this.uniqueId('-header-group-' + l);
        }
      }
    },

    /**
    * Returns the text for a header adding built in defaults
    * @private
    * @param {Object} col &nbsp;-&nbsp The column id.
    */
    headerText: function (col) {
      var text = col.name ? col.name : '';

      if (!text && col.id === 'drilldown') {
        text = Locale.translate('Drilldown');
        return '<span class="audible">'+ text + '</span>';
      }

      return text;
    },

    /**
    * Render the header area.
    * @private
    */
    renderHeader: function() {
      var self = this,
        headerRow = '',
        headerColGroup = '<colgroup>',
        cols= '',
        uniqueId,
        hideNext = 0;

      // Handle Nested Headers
      var colGroups = this.settings.columnGroups;
      if (colGroups) {
        this.element.addClass('has-group-headers');

        var total = 0;

        headerRow += '<tr role="row" class="datagrid-header-groups">';

        for (var k = 0; k < colGroups.length; k++) {

          total += parseInt(colGroups[k].colspan);
          uniqueId = self.uniqueId('-header-group-' + k);

          headerRow += '<th colspan="' + colGroups[k].colspan + '" id="' + uniqueId + '"' + '><div class="datagrid-column-wrapper "><span class="datagrid-header-text">'+ colGroups[k].name +'</span></div></th>';
        }

        if (total < this.visibleColumns().length) {
          headerRow += '<th colspan="' + (this.visibleColumns().length - total) + '"></th>';
        }
        headerRow += '</tr><tr>';
      } else {
        headerRow += '<tr role="row">';
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j],
          id = self.uniqueId('-header-' + j),
          isSortable = (column.sortable === undefined ? true : column.sortable),
          isResizable = (column.resizable === undefined ? true : column.resizable),
          isExportable = (column.exportable === undefined ? true : column.exportable),
          isSelection = column.id === 'selectionCheckbox',
          alignmentClass = (column.align === 'center' ? ' l-'+ column.align +'-text' : '');// Disable right align for now as this was acting wierd

        if (hideNext <= 0) {
          headerRow += '<th scope="col" role="columnheader" class="' + (isSortable ? 'is-sortable' : '') + (isResizable ? ' is-resizable' : '') +
            (column.hidden ? ' is-hidden' : '') + (column.filterType ? ' is-filterable' : '') +
            (alignmentClass ? alignmentClass : '') + '"' + (column.colspan ? ' colspan="' + column.colspan + '"' : '') +
           ' id="' + id + '" data-column-id="'+ column.id + '"' + (column.field ? ' data-field="'+ column.field +'"' : '') +
           (column.headerTooltip ? 'title="' + column.headerTooltip + '"' : '') +
           (column.reorderable === false ? ' data-reorder="false"' : '') +
           (colGroups ? ' headers="' + self.getColumnGroup(j) + '"' : '') + (isExportable ? 'data-exportable="yes"' : 'data-exportable="no"') + '>';

          headerRow += '<div class="' + (isSelection ? 'datagrid-checkbox-wrapper ': 'datagrid-column-wrapper') + (column.align === undefined ? '' : ' l-'+ column.align +'-text') + '"><span class="datagrid-header-text'+ (column.required ? ' required': '') + '">' + self.headerText(settings.columns[j]) + '</span>';
          cols += '<col' + this.calculateColumnWidth(column, j) + (column.colspan ? ' span="' + column.colspan + '"' : '') + (column.hidden ? ' class="is-hidden"' : '') + '>';
        }

        if (isSelection) {
          if (self.settings.showSelectAllCheckBox) {
            headerRow += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox"></span>';
          } else {
            headerRow += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox" style="display:none"></span>';
          }
        }

        if (isSortable) {
          headerRow += '<div class="sort-indicator">' +
            '<span class="sort-asc">' + $.createIcon({ icon: 'dropdown' }) + '</span>' +
            '<span class="sort-desc">' + $.createIcon({ icon: 'dropdown' }) + '</div>';
        }

        // Skip the next column when using colspan
        if (hideNext > 0) {
          hideNext --;
        }

        if (column.colspan) {
          hideNext = column.colspan - 1;
        }
        headerRow += '</div>' + self.filterRowHtml(column, j) + '</th>';
      }
      headerRow += '</tr>';

      headerColGroup += cols + '</colgroup>';

      if (self.headerRow === undefined) {
        self.headerContainer = $('<div class="datagrid-header"><table role="grid" '+ this.headerTableWidth() + '></table></div>');
        self.headerTable = self.headerContainer.find('table');
        self.headerColGroup = $(headerColGroup).appendTo(self.headerTable);
        self.headerRow = $('<thead>' + headerRow + '</thead>').appendTo(self.headerContainer.find('table'));
        self.element.prepend(self.headerContainer);
      } else {
        self.headerContainer.find('table').css('width', this.totalWidth);
        self.headerRow.html(headerRow);
        self.headerColGroup.html(cols);
      }

      self.syncHeaderCheckbox(this.settings.dataset);

      if (this.settings.enableTooltips) {
        self.headerRow.find('th[title]').tooltip();
      }

      if (self.settings.columnReorder) {
        self.createDraggableColumns();
      }

      this.attachFilterRowEvents();

      if (this.restoreSortOrder) {
        this.setSortIndicator(this.sortColumn.sortId, this.sortColumn.sortAsc);
        this.restoreSortOrder = false;
      }

      if (this.restoreFilter) {
        this.applyFilter(this.savedFilter);
        this.restoreFilter = false;
        this.savedFilter = null;
      }
    },

    /**
    * Flag used to determine if the header is rendered or not.
    */
    filterRowRendered: false,

    /**
    * Returns the markup for a specific filter row area.
    * @private
    * @param {Object} columnDef &nbsp;-&nbsp The column object for the header
    * @param {Object} idx &nbsp;-&nbsp The column idx for the header
    */
    filterRowHtml: function (columnDef, idx) {
      var self = this,
        filterMarkup = '';

      //Generate the markup for the various Types
      //Supported Filter Types: text, integer, date, select, decimal, lookup, percent, checkbox, contents
      if (columnDef.filterType) {
          var col = columnDef,
            // id = self.uniqueId('-header-' + idx),
            // header = this.headerRow.find('#' + id),
            filterId = self.uniqueId('-header-filter-' + idx);

            filterMarkup = '<div class="datagrid-filter-wrapper" '+ (!self.settings.filterable ? ' style="display:none"' : '') +'>'+ this.filterButtonHtml(col) +'<label class="audible" for="'+ filterId +'">' +
              col.name + '</label>';

          switch (col.filterType) {
            case 'checkbox':
              //just the button
              break;
            case 'date':
              filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="datepicker" id="'+ filterId +'"/>';
              break;
            case 'integer':
              var integerDefaults = {
                patternOptions: {allowNegative: true, allowThousandsSeparator: false,
                  allowDecimal: false,
                  symbols: {
                    thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                    decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal  : '.',
                    negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign  : '-'
                  }},
                process: 'number'
              };

              col.maskOptions = Soho.utils.extend(true, {}, integerDefaults, col.maskOptions);
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'" />';
              break;
            case 'percent':
            case 'decimal':
              var decimalDefaults = {
                patternOptions: {allowNegative: true, allowDecimal: true,
                symbols: {
                  thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                  decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal  : '.',
                  negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign  : '-'
                }},
                process: 'number'
              };

              if (col.numberFormat) {
                integerDefaults = {patternOptions : {decimalLimit: col.numberFormat.maximumFractionDigits }};
              }

              col.maskOptions = Soho.utils.extend(true, {}, decimalDefaults, col.maskOptions);
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'" />';
              break;
            case 'contents':
            case 'select':

              filterMarkup += '<select ' + (col.filterDisabled ? ' disabled' : '') + (col.filterType ==='select' ? ' class="dropdown"' : ' multiple class="multiselect"') + 'id="'+ filterId +'">';
              if (col.options) {
                if (col.filterType ==='select') {
                  filterMarkup += '<option></option>';
                }

                for (var i = 0; i < col.options.length; i++) {
                  var option = col.options[i],
                  optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;
                  filterMarkup += '<option value = "' +optionValue + '">' + option.label + '</option>';
                }
              }
              filterMarkup += '</select><div class="dropdown-wrapper"><div class="dropdown"><span></span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg></div>';

              break;
            case 'time':
              filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="timepicker" id="'+ filterId +'"/>';
              break;
            default:
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'"/>';
              break;
          }

          filterMarkup += '</div>';
      }

      return filterMarkup;
    },

    /**
    * Attach Events and initialize plugins for the filter row.
    * @private
    */
    attachFilterRowEvents: function () {
      var self = this;

      if (!this.settings.filterable) {
        return;
      }

      this.element.addClass('has-filterable-columns');

      //Attach Keyboard support
      this.headerRow.off('click.datagrid-filter').on('click.datagrid-filter', '.btn-filter', function () {
        var popupOpts = {trigger: 'immediate', attachToBody: $('html').hasClass('ios'), offset: {y: 15}, placementOpts: {strategies: ['flip', 'nudge']}},
          popupmenu = $(this).data('popupmenu');

        if (popupmenu) {
          popupmenu.close(true, true);
        }
        else {
          $(this).popupmenu(popupOpts).off('selected.datagrid-filter').on('selected.datagrid-filter', function () {
            self.applyFilter();
          }).off('close.datagrid-filter').on('close.datagrid-filter', function () {
            var data = $(this).data('popupmenu');
            if (data) {
              data.destroy();
            }
          });
        }
        return false;
      });

      this.headerRow.off('keydown.datagrid').on('keydown.datagrid', '.datagrid-filter-wrapper input', function (e) {
        e.stopPropagation();

        if (e.which === 13) {
          e.preventDefault();
          $(this).trigger('change');
        }

      }).off('change.datagrid').on('change.datagrid', '.datagrid-filter-wrapper input', function () {
        self.applyFilter();
      });

      this.headerRow.find('tr:last th').each(function () {
        var col = self.columnById($(this).attr('data-column-id'))[0],
          elem = $(this);

        if (!col) { //No ID found
          return true;
        }

        elem.find('select.dropdown').dropdown(col.editorOptions).on('selected.datagrid', function () {
          self.applyFilter();
        });

        elem.find('select.multiselect').multiselect(col.editorOptions).on('selected.datagrid', function () {
          self.applyFilter();
        });

        if (col.maskOptions) {
          elem.find('input').mask(col.maskOptions);
        }

        if (col.mask) {
          elem.find('input').mask(col.mask);
        }

        elem.find('.datepicker').datepicker(col.editorOptions ? col.editorOptions : {dateFormat: col.dateFormat});
        elem.find('.timepicker').timepicker(col.editorOptions ? col.editorOptions : {timeFormat: col.timeFormat});

        // Attach Mask
        if (col.mask) {
          elem.find('input').mask({pattern: col.mask, mode: col.maskMode});
        }
      });

      self.filterRowRendered = true;
    },

    /**
    * Render one filter item as used in renderFilterButton
    * @private
    * @param {Object} icon &nbsp;-&nbsp The icon for the menu item
    * @param {Object} text &nbsp;-&nbsp The text for the menu item
    * @param {Object} checked &nbsp;-&nbsp If the menu item is selected
    */
    filterItemHtml: function (icon, text, checked) {
      var iconMarkup = $.createIcon({ classes: 'icon icon-filter', icon: 'filter-' + icon });
      return '<li '+ (checked ? 'class="is-checked"' : '') +'><a href="#">'+ iconMarkup +'<span>'+ Locale.translate(text) +'</span></a></li>';
    },

    /**
    * Render the Filter Button and Menu based on filterType - which determines the options
    * @private
    * @param {Object} col &nbsp;-&nbsp The column object
    */
    filterButtonHtml: function (col) {

      if (!col.filterType) {
        return '';
      }

      var self = this,
        filterType = col.filterType,
        isDisabled = col.filterDisabled,
        filterConditions = $.isArray(col.filterConditions) ? col.filterConditions : [],
        inArray = function (s, array) {
          array = array || filterConditions;
          return ($.inArray(s, array) > -1);
        },
        render = function (icon, text, checked) {
          return filterConditions.length && !inArray(icon) ?
            '' : self.filterItemHtml(icon, text, checked);
        },
        renderButton = function(defaultValue) {
          return '<button type="button" class="btn-menu btn-filter" data-init="false" ' + (isDisabled ? ' disabled' : '') + (defaultValue ? ' data-default="' + defaultValue+ '"' : '') + ' type="button"><span class="audible">Filter</span>' +
          '<svg class="icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-filter-{{icon}}"></use></svg>' +
          $.createIcon({icon: 'dropdown' , classes: 'icon-dropdown'}) +
          '</button>' + '<ul class="popupmenu has-icons is-translatable is-selectable">';
        }, btnMarkup = '';


      //Just the dropdown
      if (filterType === 'contents' || filterType === 'select') {
        return '';
      }

      if (filterType === 'text') {
        btnMarkup = renderButton('contains') +
          render('contains', 'Contains') +
          render('does-not-contain', 'DoesNotContain') +
          render('equals', 'Equals') +
          render('does-not-equal', 'DoesNotEqual') +
          render('is-empty', 'IsEmpty') +
          render('is-not-empty', 'IsNotEmpty');
        btnMarkup = btnMarkup.replace('{{icon}}', 'contains');
      }

      if (filterType === 'checkbox') {
        btnMarkup += renderButton('selected-notselected')+
          render('selected-notselected', 'All', true) +
          render('selected', 'Selected') +
          render('not-selected', 'NotSelected');
        btnMarkup = btnMarkup.replace('{{icon}}', 'selected-notselected');
      }

      if (filterType !== 'checkbox' && filterType !== 'text') {
        btnMarkup += renderButton('equals') +
          render('equals', 'Equals', (filterType === 'integer' || filterType === 'date' || filterType === 'time')) +
          render('does-not-equal', 'DoesNotEqual') +
          render('is-empty', 'IsEmpty') +
          render('is-not-empty', 'IsNotEmpty');
        btnMarkup = btnMarkup.replace('{{icon}}', 'equals');
      }

      if (/\b(integer|decimal|date|time|percent)\b/g.test(filterType)) {
        btnMarkup += ''+
          render('less-than', 'LessThan') +
          render('less-equals', 'LessOrEquals') +
          render('greater-than', 'GreaterThan') +
          render('greater-equals', 'GreaterOrEquals');
        btnMarkup = btnMarkup.replace('{{icon}}', 'less-than');
      }

      if (filterType === 'text') {
        btnMarkup += ''+
          render('end-with', 'EndsWith') +
          render('does-not-end-with', 'DoesNotEndWith') +
          render('start-with', 'StartsWith') +
          render('does-not-start-with', 'DoesNotStartWith');
        btnMarkup = btnMarkup.replace('{{icon}}', 'end-with');
      }

      btnMarkup += '</ul>';
      return btnMarkup ;
    },

    /**
    * Toggle the visibility of the filter row.
    */
    toggleFilterRow: function () {

      if (this.settings.filterable) {
        this.headerRow.removeClass('is-filterable');
        this.headerRow.find('.is-filterable').removeClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').hide();
        this.settings.filterable = false;
        this.filterRowRendered = false;
        this.element.removeClass('has-filterable-columns');
      } else {
        this.settings.filterable = true;

        if (!this.filterRowRendered) {
          this.render();
        }

        this.element.addClass('has-filterable-columns');

        this.headerRow.addClass('is-filterable');
        this.headerRow.find('.is-filterable').addClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').show();
      }
    },

    /**
    * Apply the Filter with the currently selected conditions, or the ones passed in.
    * @param {Object} conditions &nbsp;-&nbsp An array of objects with the filter conditions.
    */
    applyFilter: function (conditions) {
      var self = this;
      this.filteredDataset = null;

      if (conditions) {
        this.setFilterConditions(conditions);
      } else {
        conditions = this.filterConditions();
      }

      var checkRow = function (rowData) {
        var isMatch = true;

        for (var i = 0; i < conditions.length; i++) {
          var columnDef = self.columnById(conditions[i].columnId)[0],
            field = columnDef.field,
            rowValue = self.fieldValue(rowData, field),
            rowValueStr = (rowValue === null || rowValue === undefined) ? '' : rowValue.toString().toLowerCase(),
            conditionValue = conditions[i].value.toString().toLowerCase();

          //Percent filter type
          if (columnDef.filterType === 'percent') {
            conditionValue = (conditionValue / 100).toString();
            if ((columnDef.name + '').toLowerCase() === 'decimal') {
              rowValue = window.Formatters.Decimal(false, false, rowValue, columnDef);
              conditionValue = window.Formatters.Decimal(false, false, conditionValue, columnDef);
            } else if ((columnDef.name + '').toLowerCase() === 'integer') {
              rowValue = window.Formatters.Integer(false, false, rowValue, columnDef);
              conditionValue = window.Formatters.Integer(false, false, conditionValue, columnDef);
            }
          }

          //Run Data over the formatter
          if (columnDef.filterType === 'text') {
            rowValue = self.formatValue(columnDef.formatter, i , conditions[i].columnId, rowValue, columnDef, rowData, self);

            //Strip any html markup that might be in the formatters
            var rex = /(<([^>]+)>)|(&lt;([^>]+)&gt;)/ig;
            rowValue = rowValue.replace(rex , '').trim().toLowerCase();

            rowValueStr = (rowValue === null || rowValue === undefined) ? '' : rowValue.toString().toLowerCase();
          }

          if (columnDef.filterType === 'contents' || columnDef.filterType === 'select') {
            rowValue = rowValue.toLowerCase();
          }

          if ((typeof rowValue === 'number' || !isNaN(rowValue)) &&
              columnDef.filterType !== 'date' && columnDef.filterType !== 'time') {
            rowValue =  parseFloat(rowValue);
            conditionValue = Locale.parseNumber(conditionValue);
          }

          if (columnDef.filterType === 'date' || columnDef.filterType === 'time') {
            conditionValue = Locale.parseDate(conditions[i].value, conditions[i].format);
            if (conditionValue) {
              if (columnDef.filterType === 'time') {
                // drop the day, month and year
                conditionValue.setDate(1);
                conditionValue.setMonth(0);
                conditionValue.setYear(0);
              }
              conditionValue = conditionValue.getTime();
                }

            if (rowValue instanceof Date) {
              rowValue = rowValue.getTime();
            }
            else if (typeof rowValue === 'string' && rowValue) {
              if (!columnDef.sourceFormat) {
                rowValue = Locale.parseDate(rowValue, {pattern: conditions[i].format});
              } else {
                rowValue = Locale.parseDate(rowValue, (typeof columnDef.sourceFormat === 'string' ? {pattern: columnDef.sourceFormat}: columnDef.sourceFormat));
              }

              if (rowValue) {
                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  rowValue.setDate(1);
                  rowValue.setMonth(0);
                  rowValue.setYear(0);
                }
                rowValue = rowValue.getTime();
              }
            }
          }

          switch (conditions[i].operator) {
            case 'equals':

              //This case is multiselect
              if (conditions[i].value instanceof Array) {
                isMatch = false;

                for (var k = 0; k < conditions[i].value.length; k++) {
                  var match = conditions[i].value[k].toLowerCase().indexOf(rowValue) >= 0 && rowValue.toString() !== '';
                  if (match) {
                    isMatch = true;
                  }
                }
              } else {
                isMatch = (rowValue === conditionValue && rowValue !== '');
              }

              break;
            case 'does-not-equal':
              isMatch = (rowValue !== conditionValue);
              break;
            case 'contains':
              isMatch = (rowValueStr.indexOf(conditionValue) > -1 && rowValue.toString() !== '');
              break;
            case 'does-not-contain':
              isMatch = (rowValueStr.indexOf(conditionValue) === -1);
              break;
            case 'end-with':
              isMatch = (rowValueStr.lastIndexOf(conditionValue) === (rowValueStr.length - conditionValue.toString().length)  && rowValueStr !== '' && (rowValueStr.length >= conditionValue.toString().length));
              break;
            case 'start-with':
              isMatch = (rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'does-not-end-with':
              isMatch = (rowValueStr.lastIndexOf(conditionValue) === (rowValueStr.length - conditionValue.toString().length)  && rowValueStr !== '' && (rowValueStr.length >= conditionValue.toString().length));
              isMatch = !isMatch;
              break;
            case 'does-not-start-with':
              isMatch = !(rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'is-empty':
              isMatch = (rowValue === '');
              break;
            case 'is-not-empty':
              isMatch = (rowValue !== '');
              break;
            case 'less-than':
              isMatch = (rowValue < conditionValue && rowValue !== '');
              break;
            case 'less-equals':
              isMatch = (rowValue <= conditionValue && rowValue !== '');
              break;
            case 'greater-than':
              isMatch = (rowValue > conditionValue && rowValue !== '');
              break;
            case 'greater-equals':
              isMatch = (rowValue >= conditionValue && rowValue !== '');
              break;
            case 'selected':

              if (columnDef && columnDef.isChecked) {
                 isMatch = columnDef.isChecked(rowValue);
                 break;
              }
              isMatch = (rowValueStr === '1' || rowValueStr ==='true' || rowValue === true || rowValue === 1) && rowValueStr !== '';
              break;
           case 'not-selected':
              if (columnDef && columnDef.isChecked) {
                 isMatch = !columnDef.isChecked(rowValue);
                 break;
              }
              isMatch = (rowValueStr === '0' || rowValueStr ==='false' || rowValue === false || rowValue === 0) && rowValueStr !== '';
              break;
            case 'selected-notselected':
              isMatch = true;
              break;
            default:
          }

          if (!isMatch) {
            return false;
          }
        }
        return isMatch;
      };

      if (!this.settings.disableClientFilter) {
        var dataset, isFiltered, i, len;

        if (this.settings.treeGrid) {
          dataset = this.settings.treeDepth;
          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i].node);
            dataset[i].node.isFiltered = isFiltered;
          }
        }
        else {
          dataset = this.settings.dataset;
          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i]);
            dataset[i].isFiltered = isFiltered;
          }
        }
      }

      this.renderRows();
      this.setSearchActivePage();
      this.element.trigger('filtered', {op: 'apply', conditions: conditions});
      this.resetPager('filtered');
      this.saveUserSettings();

    },

    /**
    * Clear the Filter row Conditions and Reset the Data.
    */
    clearFilter: function () {
      if (!this.settings.filterable) {
        return;
      }

      this.headerRow.find('input, select').val('').trigger('updated');
      //reset all the filters to first item
      this.headerRow.find('.btn-filter').each(function () {
        var btn = $(this),
          ul = btn.next(),
          first = ul.find('li:first');

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + btn.attr('data-default'));
        ul.find('.is-checked').removeClass('is-checked');
        first.addClass('is-checked');
      });

      this.applyFilter();
      this.element.trigger('filtered', {op: 'clear', conditions: []});
    },

    /**
    * Set the Filter Conditions on the UI Only.
    * @param {Object} conditions &nbsp;-&nbsp An array of objects with the filter conditions.
    */
    setFilterConditions: function (conditions) {
      for (var i = 0; i < conditions.length; i++) {
        //Find the filter row
        var rowElem = this.headerRow.find('th[data-column-id="'+ conditions[i].columnId +'"]'),
          input = rowElem.find('input, select'),
          btn = rowElem.find('.btn-filter');

        if (conditions[i].value === undefined) {
          conditions[i].value = '';
        }

        input.val(conditions[i].value);

        if (input.is('select') && conditions[i].value instanceof Array) {
          for (var j = 0; j < conditions[i].value.length; j++) {
            input.find('option[value="'+ conditions[i].value[j] + '"]').prop('selected', true);
          }
          input.trigger('updated');
        }

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + conditions[i].operator);
      }
    },

    /**
    * Get filter conditions in array from whats set in the UI.
    */
    filterConditions: function () {
      // Do not modify keyword search filter expr
      if (this.filterExpr && this.filterExpr.length === 1 && this.filterExpr[0].keywordSearch) {
        delete this.filterExpr[0].keywordSearch;
        return this.filterExpr;
      }

      var self = this;
      this.filterExpr = [];

      //Create an array of objects with: field, id, filterType, operator, value
      this.headerRow.find('th').each(function () {
        var rowElem = $(this),
          btn = rowElem.find('.btn-filter'),
          input = rowElem.find('input, select'),
          isDropdown = input.is('select'),
          svg = btn.find('.icon-dropdown:first'),
          op,
          format;

        if (!btn.length && !isDropdown) {
          return;
        }

        op = isDropdown ? 'equals' : svg.getIconName().replace('filter-', '');

        if (op === 'selected-notselected') {
          return;
        }

        if (input.val() === '' && ['is-not-empty', 'is-empty', 'selected', 'not-selected'].indexOf(op) === -1) {
          return;
        }

        if (input.val() instanceof Array && input.val().length ===0) {
          return;
        }

        var value = input.val() ? input.val() : '';
        if (input.attr('data-mask-mode') && input.attr('data-mask-mode') === 'number') {
          value = Locale.parseNumber(value);
        }

        var condition = {columnId: rowElem.attr('data-column-id'),
          operator: op,
          value: value};

        if (input.data('datepicker')) {
          format = input.data('datepicker').settings.dateFormat;
          if (format === 'locale') {
            format = Locale.calendar().dateFormat.short;
          }
          condition.format = format;
        }

        if (input.data('timepicker')) {
          format = input.data('timepicker').settings.timeFormat;
          condition.format = format;
        }

        self.filterExpr.push(condition);

      });

      return self.filterExpr;
    },

    // Get height for current target in header
    getTargetHeight: function () {
      var h = this.settings.filterable ?
        {short: 48, medium: 51, normal: 56} : {short: 20, medium: 28, normal: 35};
      return h[this.settings.rowHeight];
    },

    /**
    * Create draggable columns
    * @private
    */
    createDraggableColumns: function () {
      var self = this,
        headers = self.headerNodes().not('[data-column-id="selectionCheckbox"]'),
        showTarget = $('.drag-target-arrows', self.element);

      if (!showTarget.length) {
        self.element.prepend('<span class="drag-target-arrows" style="height: '+ self.getTargetHeight() +'px;"></span>');
        showTarget = $('.drag-target-arrows', self.element);
      }

      headers.not('[data-reorder="false"]').prepend('</span><span class="handle">&#8286;</span>');
      headers.prepend('<span class="is-draggable-target"></span>');
      headers.last().append('<span class="is-draggable-target last"></span>');
      self.element.addClass('has-draggable-columns');

      // Initialize Drag api
      $('.handle', headers).each(function() {
        var clone, headerPos, offPos,
          handle = $(this),
          header = handle.parent();

        handle.on('mousedown.datagrid', function(e) {
          e.preventDefault();

          header.drag({clone: true, cloneAppendTo: headers.first().parent().parent(), clonePosIsFixed: true})
            .on('dragstart.datagrid', function (e, pos, thisClone) {
              var index;

              clone = thisClone;

              clone.removeAttr('id').addClass('is-dragging-clone')
                .css({left: pos.left, top: pos.top, height: header.height(), border: 0});

              $('.is-draggable-target', clone).remove();

              self.setDraggableColumnTargets();

              headerPos = header.position();
              offPos = {top: (pos.top - headerPos.top), left: (pos.left - headerPos.left)};

              index = self.targetColumn(headerPos);
              self.draggableStatus.startIndex = index;
              e.stopImmediatePropagation();
            })
            .on('drag.datagrid', function (e, pos) {
              clone[0].style.left = parseInt(pos.left) + 'px';
              clone[0].style.top =  parseInt(pos.top) + 'px';
              headerPos = {top: (pos.top - offPos.top), left: (pos.left - offPos.left)};

              var i, l, n, target, rect,
                index = self.targetColumn(headerPos);

              $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

              if (index !== -1) {
                for (i=0, l=self.draggableColumnTargets.length; i<l; i++) {
                  target = self.draggableColumnTargets[i];
                  n = i + 1;

                  if (target.index === index && target.index !== self.draggableStatus.startIndex) {
                    if (target.index > self.draggableStatus.startIndex && (n < l)) {
                      target = self.draggableColumnTargets[n];
                    }

                    target.el.addClass('is-over');
                    showTarget.addClass('is-over');
                    rect = target.el[0].getBoundingClientRect();
                    showTarget[0].style.left = parseInt(rect.left) + 'px';
                    showTarget[0].style.top =  (parseInt(rect.top) + 1) + 'px';

                  }
                }
              }

              e.stopImmediatePropagation();
            })
            .on('dragend.datagrid', function (e, pos) {
              clone[0].style.left = parseInt(pos.left) + 'px';
              clone[0].style.top =  parseInt(pos.top) + 'px';

              headerPos = {top: (pos.top - offPos.top), left: (pos.left - offPos.left)};

              var index = self.targetColumn(headerPos),
               dragApi = header.data('drag'),
               tempArray = [],
               i, l, indexFrom, indexTo, target;

              // Unbind drag from header
              if (dragApi && dragApi.destroy) {
                dragApi.destroy();
              }

              self.draggableStatus.endIndex = index;
              $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

              if (self.draggableStatus.endIndex !== -1) {
                if (self.draggableStatus.startIndex !== self.draggableStatus.endIndex) {
                  target = self.draggableColumnTargets[index];

                  //Swap columns
                  for (i=0, l=self.settings.columns.length; i < l; i++) {
                      if (!self.settings.columns[i].hidden &&
                          self.settings.columns[i].id !== 'selectionCheckbox') {
                        tempArray.push(i);
                      }
                    }

                    indexFrom = tempArray[self.draggableStatus.startIndex] || 0;
                    indexTo = tempArray[self.draggableStatus.endIndex] || 0;

                    self.arrayIndexMove(self.settings.columns, indexFrom, indexTo);
                    self.updateColumns(self.settings.columns);

                  }
              }

            });
        });
      });
    },

    /**
    * Set draggable columns target elements
    * @private
    */
    setDraggableColumnTargets: function () {
      var self = this,
        headers = self.headerNodes()
          .not('.is-hidden').not('[data-column-id="selectionCheckbox"]'),
        target, pos, extra;

      self.draggableColumnTargets = [];
      self.draggableStatus = {};

      // Move last target if not found in last header
      if (!$('.is-draggable-target.last', headers.last()).length) {
        headers.last().append($('.is-draggable-target.last', self.headerNodes()));
      }

      $('.is-draggable-target', headers).each(function (index) {
        var idx = ($(this).is('.last')) ? index - 1 : index; // Extra target for last header th
        target = headers.eq(idx);
        pos = target.position();
        // Extra space around, if dropped item bit off from drop area
        extra = 20;

        self.draggableColumnTargets.push({
          el: $(this),
          index: idx,
          pos: pos,
          width: target.outerWidth(),
          height: target.outerHeight(),
          dropArea: {
            x1: pos.left - extra, x2: pos.left + target.outerWidth() + extra,
            y1: pos.top - extra, y2: pos.top + target.outerHeight() + extra
          }
        });
      });
    },

    /**
    * Get column index for dragging columns
    * @private
    * @param {Object} pos &nbsp;-&nbsp The position index
    */
    targetColumn: function (pos) {
      var self = this,
        index = -1,
        target, i, l;

      for (i=0, l=self.draggableColumnTargets.length-1; i<l; i++) {
        target = self.draggableColumnTargets[i];
        if (pos.left > target.dropArea.x1 && pos.left < target.dropArea.x2 &&
            pos.top > target.dropArea.y1 && pos.top < target.dropArea.y2) {
          index = target.index;
        }
      }
      return index;
    },

    /**
    * Move an array element to a different position. May be dups of this function.
    * @private
    * @param {Array} arr &nbsp;-&nbsp The array
    * @param {Array} from &nbsp;-&nbsp The from position
    * @param {Array} to &nbsp;-&nbsp The to position
    */
    arrayIndexMove: function(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },

    /**
    * Attach Drag Events to Rows
    * @private
    */
    createDraggableRows: function () {
      var self = this;

      if (!this.settings.rowReorder) {
        return;
      }

      // Attach the Drag API
      this.tableBody.arrange({
          placeholder: '<tr class="datagrid-reorder-placeholder"><td colspan="'+ this.visibleColumns().length +'"></td></tr>',
          handle: '.datagrid-reorder-icon'
        })
        .on('beforearrange.datagrid', function(e, status) {
          if (self.isSafari) {
            status.start.css({'display': 'inline-block'});
          }
        })
        .on('arrangeupdate.datagrid', function(e, status) {
          if (self.isSafari) {
            status.end.css({'display': ''});
          }
          // Move the elem in the data set
          self.settings.dataset.splice(status.endIndex, 0, self.settings.dataset.splice(status.startIndex, 1)[0]);
          // Fire an event
          self.element.trigger('rowreorder', [status]);
        });

    },

    /**
    * Return the value in a field, taking into account nested objects. Fx obj.field.id
    * @param {Object} obj &nbsp;-&nbsp The object to use
    * @param {String} field &nbsp;-&nbsp The field as a string fx 'field' or 'obj.field.id'
    */
    fieldValue: function (obj, field) {
      if (!field || !obj) {
        return '';
      }

      if (field.indexOf('.') > -1) {
        return field.split('.').reduce(function(o, x) {
          return (o ? o[x] : '');
        }, obj);
      }

      var rawValue = obj[field],
        value = (rawValue || rawValue === 0 || rawValue === false ? rawValue : '');

      value = $.escapeHTML(value);
      return value;
    },

    /**
    * Setup internal tree root nodes array.
    * @private
    */
    setTreeRootNodes: function() {
      this.settings.treeRootNodes = this.settings.treeDepth
        .filter(function(node) {
          return node.depth === 1;
        });
    },

    /**
    * Setup internal tree depth array.
    * @private
    */
    setTreeDepth: function(dataset) {
      var self = this,
        idx = 0,
        iterate = function(node, depth) {
          idx++;
          self.settings.treeDepth.push({idx: idx, depth: depth, node: node});
          var children = node.children || [];
          for (var i = 0, len = children.length; i < len; i++) {
            iterate(children[i], depth + 1);
          }
        };

      dataset = dataset || this.settings.dataset;
      self.settings.treeDepth = [];

      for (var i = 0, len = dataset.length; i < len; i++) {
        iterate(dataset[i], 1);
      }
    },

    /**
    * Setup internal row grouping
    * @private
    */
    setRowGrouping: function () {
      var groupSettings = this.settings.groupable;
      if (!groupSettings) {
        return;
      }

      this.originalDataset = this.settings.dataset.slice();

      if (!groupSettings.aggregator || groupSettings.aggregator === 'none') {
        this.settings.dataset = GroupBy.none(this.settings.dataset, groupSettings.fields);
        return;
      }

      if (groupSettings.aggregator === 'sum') {
        this.settings.dataset = GroupBy.sum(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'max') {
        this.settings.dataset = GroupBy.max(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'list') {
        this.settings.dataset = GroupBy.list(this.settings.dataset, groupSettings.fields, groupSettings.aggregatorOptions);
        return;
      }

      this.settings.dataset = window.GroupBy(this.settings.dataset, groupSettings.fields);
    },

    /**
    * Clear the table body and rows.
    * @private
    */
    renderRows: function() {
      var tableHtml = '',
        self = this, i,
        s = self.settings,
        activePage = self.pager ? self.pager.activePage : 1,
        pagesize = s.pagesize,
        dataset = s.dataset;

      var body = self.table.find('tbody');
      self.bodyColGroupHtml = '<colgroup>';
      self.triggerDestroyCell();  // Trigger Destroy on previous cells

      // Prevent flashing message area on filter / reload
      if (this.settings.emptyMessage && self.emptyMessageContainer) {
        self.emptyMessageContainer.hide();
      }

      if (body.length === 0) {
        self.tableBody = $('<tbody></tbody>');
        self.table.append(self.tableBody);
      }

      self.groupArray = [];

      self.recordCount = 0;
      self.filteredCount = 0;

      // Reset recordCount for paging
      if (s.treeGrid && s.paging && !s.source && activePage > 1) {
        self.recordCount = s.treeRootNodes[(pagesize * activePage) - pagesize].idx-1;
      }

      if (this.restoreSortOrder) {
        this.sortDataset();
      }

      for (i = 0; i < dataset.length; i++) {

        //For better performance dont render out of page
        if (s.paging && !s.source) {

          if (activePage === 1 && (i - this.filteredCount) >= pagesize){
            if (!dataset[i].isFiltered) {
              this.recordCount++;
            } else {
              this.filteredCount++;
            }
            continue;
          }

          if (activePage > 1 && !((i - this.filteredCount) >= pagesize*(activePage-1) && (i - this.filteredCount) < pagesize*activePage)) {
            if (!dataset[i].isFiltered) {
              if (this.filteredCount) {
                this.recordCount++;
              }
            } else {
              this.filteredCount++;
            }
            continue;
          }
        }

        if (s.virtualized) {
          if (!this.isRowVisible(this.recordCount)) {
            this.recordCount++;
            continue;
          }
        }

        //Exclude Filtered Rows
        if ((s.treeGrid ? s.treeRootNodes[i].node : dataset[i]).isFiltered) {
          this.filteredCount++;
          continue;
        }

        //Handle Grouping
        if (this.settings.groupable) {
          //First push group row
          if (!this.settings.groupable.suppressGroupRow) {
            //Show the grouping row
            tableHtml += self.rowHtml(dataset[i], this.recordCount, i, true);
          }

          if (this.settings.groupable.showOnlyGroupRow && dataset[i].values[0]) {
            var rowData = dataset[i].values[0];

            if (dataset[i].list) {
              rowData.list = dataset[i].list;
            }

            rowData.values = dataset[i].values;

            tableHtml += self.rowHtml(rowData, this.recordCount, i);
            this.recordCount++;
            self.groupArray.push({group: i, node: 0});
            continue;
          }

          //Now Push Groups
          for (var k = 0; k < dataset[i].values.length; k++) {
            tableHtml += self.rowHtml(dataset[i].values[k], this.recordCount, i);
            this.recordCount++;
            self.groupArray.push({group: i, node: k});
          }

          // Now Push summary rowHtml
          if (this.settings.groupable.groupFooterRow) {
            tableHtml += self.rowHtml(dataset[i], this.recordCount, i, true, true);
          }

          continue;
        }

        tableHtml += self.rowHtml(dataset[i], s.treeGrid ? this.recordCount : i, i);

        this.recordCount++;
      }

      //Append a Summary Row
      if (this.settings.summaryRow) {
        tableHtml += self.rowHtml(self.calculateTotals(), this.recordCount, null, false, true);
      }

      if (self.bodyColGroupHtml !== '<colgroup>') {
        self.bodyColGroupHtml += '</colgroup>';

        if (self.bodyColGroup) {
          self.bodyColGroup.remove();
        }

        self.bodyColGroup = $(self.bodyColGroupHtml);
        self.tableBody.before(self.bodyColGroup);
      }

      self.tableBody.html(tableHtml);
      self.setVirtualHeight();
      self.setScrollClass();
      self.setupTooltips();
      self.afterRender();

    },

    /**
    * Fire events and do steps needed after a full render.
    * @private
    */
    afterRender: function() {
      var self = this;

      // Column column postRender functions
      if (this.settings.onPostRenderCell) {
        for (var i = 0; i < this.settings.columns.length; i++) {
          var col = this.settings.columns[i];

          if (col.component) {
            self.tableBody.find('tr').each(function () {
              var row = $(this),
                rowIdx = row.attr('data-index'),
                colIdx = self.columnIdxById(col.id),
                args = {
                  row: rowIdx,
                  cell: colIdx,
                  value: self.settings.dataset[rowIdx],
                  col: col,
                  api: self
                };

                self.settings.onPostRenderCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        }
      }

      //Init Inline Elements
      self.tableBody.find('select.dropdown').dropdown();

      //Commit Edits for inline editing
      self.tableBody.find('.dropdown-wrapper.is-inline').prev('select')
        .on('listclosed', function () {
           var elem = $(this),
            newValue = elem.val(),
            row = elem.closest('tr');

            self.updateCellNode(row.attr('aria-rowindex'), elem.closest('td').index(), newValue, false, true);
         });

      self.tableBody.find('.spinbox').spinbox();

      //Set UI elements after dataload
      setTimeout(function () {

        if (!self.settings.source) {
          self.displayCounts();
        } else {
          self.checkEmptyMessage();
        }

        self.setAlternateRowShading();
        self.createDraggableRows();

        if (!self.activeCell || !self.activeCell.node) {
          self.activeCell = {node: self.cellNode(0, 0, true).attr('tabindex', '0'), isFocused: false, cell: 0, row: 0};
        }

        if (self.activeCell.isFocused) {
          self.setActiveCell(self.activeCell.row, self.activeCell.cell);
        }

        //Update Selected Rows Across Page
        if (self.settings.paging && self.settings.source) {
          self.syncSelectedUI();
        }

        self.element.trigger('afterrender', {body: self.tableBody, header: self.headerRow, pager: self.pagerBar});
      }, 0);

    },

    /**
    * Trigger the onDestroyCell for each cell
    * @private
    */
    triggerDestroyCell: function () {
      var self = this;

      if (!self.tableBody) {
        return;
      }

      // Call onDestroyCell
      if (this.settings.onPostRenderCell && this.settings.onDestroyCell) {
        var rows = self.tableBody.find('tr');

        if (rows.length === 0) {
          return;
        }

        for (var i = 0; i < this.settings.columns.length; i++) {
          var col = this.settings.columns[i];

          if (col.component) {
            rows.each(function () {
              var row = $(this),
                rowIdx = row.index(),
                colIdx = self.columnIdxById(col.id),
                args = {
                  row: row.index(),
                  cell: colIdx,
                  value: self.settings.dataset[rowIdx],
                  col: col,
                  api: self
                };

                self.settings.onDestroyCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        }
      }

    },

    cacheVirtualStats: function () {
      var containerHeight = this.element[0].offsetHeight,
        scrollTop = this.contentContainer[0].scrollTop,
        headerHeight = this.settings.rowHeight === 'normal' ? 40 : (this.settings.rowHeight === 'medium' ? 30 : 25),
        bodyHeight = containerHeight-headerHeight,
        rowHeight = this.settings.rowHeight === 'normal' ? 50 : (this.settings.rowHeight === 'medium' ? 40 : 30);

      this.virtualRange = {rowHeight: rowHeight,
                         top: Math.max(scrollTop - ((this.settings.virtualRowBuffer-1) * rowHeight), 0),
                         bottom: scrollTop + bodyHeight + ((this.settings.virtualRowBuffer-1) * rowHeight),
                         totalHeight: rowHeight * this.settings.dataset.length,
                         bodyHeight: bodyHeight};
    },

    // Check if the row is in the visble scroll area + buffer
    // Just call renderRows() on events that change
    isRowVisible: function(rowIndex) {
      if (!this.settings.virtualized) {
        return true;
      }

      if (rowIndex === 0) {
        this.cacheVirtualStats();
      }

      //determine if the row is in view
      var pos = rowIndex * this.virtualRange.rowHeight;

      if (pos >= this.virtualRange.top && pos < this.virtualRange.bottom) {
        return true;
      }

      return false;
    },

    // Set the heights on top or bottom based on scroll position
    setVirtualHeight: function () {
      if (!this.settings.virtualized || !this.virtualRange) {
        return;
      }

      var bottom = this.virtualRange.totalHeight - this.virtualRange.bottom,
        top = this.virtualRange.top;

      this.topSpacer = this.tableBody.find('.datagrid-virtual-row-top');
      this.bottomSpacer = this.tableBody.find('.datagrid-virtual-row-bottom');

      if (top > 0 && !this.topSpacer.length) {
        this.topSpacer = $('<tr class="datagrid-virtual-row-top" style="height: '+ top + 'px"><td colspan="'+ this.visibleColumns().length +'"></td></tr>');
        this.tableBody.prepend(this.topSpacer);
      }

      if (top > 0 && this.topSpacer.length) {
        this.topSpacer.css('height', top + 'px');
      }

      if (top ===0 && this.topSpacer.length || this.virtualRange.topRow <= 1) {
        this.topSpacer.remove();
      }

      if (bottom > 0 && !this.bottomSpacer.length) {
        this.bottomSpacer = $('<tr class="datagrid-virtual-row-bottom" style="height: '+ bottom + 'px"><td colspan="'+ this.visibleColumns().length +'"></td></tr>');
        this.tableBody.append(this.bottomSpacer);
      }

      if (bottom > 0 && this.bottomSpacer.length) {
        this.bottomSpacer.css('height', bottom + 'px');
      }

      if (bottom <= 0 && this.bottomSpacer.length || (this.virtualRange.bottomRow >= this.settings.dataset.length)) {
        this.bottomSpacer.remove();
      }
    },

    // Set the alternate shading for tree
    setAlternateRowShading: function() {
      if (this.settings.alternateRowShading && this.settings.treeGrid) {
        $('tr[role="row"]:visible', this.tableBody)
          .removeClass('alt-shading').filter(':odd').addClass('alt-shading');
      }
    },

    formatValue: function (formatter, row, cell, fieldValue, columnDef, rowData, api) {
      var formattedValue;
      api = api || this;

      //Use default formatter if undefined
      if (formatter === undefined) {
        formatter = this.defaultFormatter;
      }

      if (typeof formatter ==='string') {
        formattedValue = window.Formatters[formatter](row, cell, fieldValue, columnDef, rowData, api).toString();
      } else {
        formattedValue = formatter(row, cell, fieldValue, columnDef, rowData, api).toString();
      }
      return formattedValue;
    },

    recordCount: 0,

    rowHtml: function (rowData, dataRowIdx, actualIndex, isGroup, isFooter) {
      var isEven = false,
        self = this,
        isSummaryRow = this.settings.summaryRow && !isGroup && isFooter,
        activePage = self.pager ? self.pager.activePage : 1,
        pagesize = self.settings.pagesize,
        rowHtml = '',
        spanNext = 0,
        d = self.settings.treeDepth ? self.settings.treeDepth[dataRowIdx] : 0,
        depth, d2, i, l, isHidden, isSelected, isActivated;

      if (!rowData) {
        return '';
      }

      // Default
      d = d ? d.depth : 0;
      depth = d;

      // Setup if this row will be hidden or not
      for (i = dataRowIdx; i >= 0 && d > 1 && !isHidden; i--) {
        d2 = self.settings.treeDepth[i];
        if (d !== d2.depth && d > d2.depth) {
          d = d2.depth;
          isHidden = !d2.node.expanded;
        }
      }

      if (this.settings.groupable) {
        var groupSettings = this.settings.groupable;
        isHidden  = (groupSettings.expanded === undefined ? false : !groupSettings.expanded);

        if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
          isHidden = !groupSettings.expanded(dataRowIdx, 0, null, null, rowData, this);
        }
      }

      //Group Rows
      if (this.settings.groupable && isGroup && !isFooter) {
        rowHtml = '<tr class="datagrid-rowgroup-header ' + (isHidden ? '' : 'is-expanded') + '" role="rowgroup"><td role="gridcell" colspan="'+ this.visibleColumns().length +'">' +
          Formatters.GroupRow(dataRowIdx, 0, null, null, rowData, this) +
          '</td></tr>';
        return rowHtml;
      }

      if (this.settings.groupable && isGroup && isFooter) {
        rowHtml = '<tr class="datagrid-row datagrid-rowgroup-footer ' + (isHidden ? '' : 'is-expanded') + '" role="rowgroup">' +
          Formatters.GroupFooterRow(dataRowIdx, 0, null, null, rowData, this) +
          '</tr>';
        return rowHtml;
      }

      var ariaRowindex = ((dataRowIdx + 1) + (self.settings.source  ? ((activePage-1) * pagesize) : 0));

      isEven = (this.recordCount % 2 === 0);
      isSelected = this.isNodeSelected(rowData);
      isActivated = rowData._rowactivated;

      rowHtml = '<tr role="row" aria-rowindex="' + ariaRowindex + '"' +
                ' data-index="' + actualIndex + '"' +
                (self.settings.treeGrid && rowData.children ? ' aria-expanded="' + (rowData.expanded ? 'true"' : 'false"') : '') +
                (self.settings.treeGrid ? ' aria-level= "' + depth + '"' : '') +
                (isSelected ? ' aria-selected= "true"' : '') +
                ' class="datagrid-row'+
                (isHidden ? ' is-hidden' : '') +
                (isActivated ? ' is-rowactivated' : '') +
                (isSelected ? this.settings.selectable === 'mixed' ? ' is-selected hide-selected-color' : ' is-selected' : '') +
                (self.settings.alternateRowShading && !isEven ? ' alt-shading' : '') +
                (isSummaryRow ? ' datagrid-summary-row' : '') +
                (!self.settings.cellNavigation ? ' is-clickable' : '' ) +
                (self.settings.treeGrid ? (rowData.children ? ' datagrid-tree-parent' : (depth > 1 ? ' datagrid-tree-child' : '')) : '') +
                 '"' + '>';

      for (var j = 0; j < self.settings.columns.length; j++) {
        var col = self.settings.columns[j],
          cssClass = '',
          formatter = isSummaryRow ? col.summaryRowFormatter || col.formatter || self.defaultFormatter : col.formatter || self.defaultFormatter,
          formatted = self.formatValue(
            formatter,
            dataRowIdx,
            j,
            self.fieldValue(rowData, self.settings.columns[j].field),
            self.settings.columns[j],
            rowData,
            self
          );

        if (formatted.indexOf('<span class="is-readonly">') === 0) {
          col.readonly = true;
        }

        if (formatted.indexOf('datagrid-checkbox') > -1 ||
          formatted.indexOf('btn-actions') > -1) {
          cssClass += ' l-center-text';
        }

        if (formatted.indexOf('trigger') > -1) {
          cssClass += ' datagrid-trigger-cell';
        }

        if (col.expanded) {
          self.treeExpansionField = col.expanded;
        }

        if (col.align) {
          cssClass += ' l-'+ col.align +'-text';
        }

        if (col.textOverflow === 'ellipsis') {
          cssClass += ' text-ellipsis';
        }

        if (col.uppercase) {
          cssClass += ' uppercase-text';
        }

        // Add Column Css Classes

        //Add a readonly class if set on the column
        cssClass += (col.readonly ? ' is-readonly' : '');
        cssClass += (col.hidden ? ' is-hidden' : '');

        //Run a function that helps check if editable
        if (col.isEditable && !col.readonly) {
          var canEdit = col.isEditable(ariaRowindex - 1, j, self.fieldValue(rowData, self.settings.columns[j].field), col, rowData);

          if (!canEdit) {
            cssClass += ' is-readonly';
          }
        }

        //Run a function that helps check if readonly
        var ariaReadonly = (col.id !== 'selectionCheckbox' &&
          (col.readonly || col.editor === undefined)) ?
          'aria-readonly="true"': '';

        if (col.isReadonly && !col.readonly && col.id !== 'selectionCheckbox') {
          var isReadonly = col.isReadonly(this.recordCount, j, self.fieldValue(rowData, self.settings.columns[j].field), col, rowData);

          if (isReadonly) {
            cssClass += ' is-cell-readonly';
            ariaReadonly = 'aria-readonly="true"';
          }
        }

        var cellValue = self.fieldValue(rowData, self.settings.columns[j].field);

        //Run a function that dynamically adds a class
        if (col.cssClass && typeof col.cssClass === 'function') {
          cssClass += ' ' + col.cssClass(this.recordCount, j, cellValue, col, rowData);
        }

        if (col.cssClass && typeof col.cssClass === 'string') {
          cssClass += ' ' + col.cssClass;
        }

        cssClass += (col.focusable ? ' is-focusable' : '');

        var rowspan = this.calculateRowspan(cellValue, dataRowIdx, col);

        if (rowspan === '') {
          continue;
        }

        //Set Width of table col / col group elements
        var colWidth = '';
        if (this.recordCount === 0 || this.recordCount - ((activePage-1) * pagesize) === 0) {
          colWidth = this.calculateColumnWidth(col, j);

          self.bodyColGroupHtml += spanNext > 0 ? '' :'<col' + colWidth + (col.hidden ? ' class="is-hidden"' : '') + (col.colspan ? ' span="' + col.colspan + '"' : '') + '></col>';

          if (spanNext > 0 ) {
            spanNext--;
          }
          if (col.colspan) {
            this.hasColSpans = true;
            spanNext = col.colspan-1;
          }
        }

        rowHtml += '<td role="gridcell" ' + ariaReadonly + ' aria-colindex="' + (j+1) + '" '+
            ' aria-describedby="' + self.uniqueId('-header-' + j) + '"' +
          (isSelected ? ' aria-selected= "true"' : '') +
           (cssClass ? ' class="' + cssClass + '"' : '') +
           (col.tooltip && typeof col.tooltip === 'string' ? ' title="' + col.tooltip.replace('{{value}}', cellValue) + '"' : '') +
           (col.id === 'rowStatus' && rowData.rowStatus && rowData.rowStatus.tooltip ? ' title="' + rowData.rowStatus.tooltip + '"' : '') +
           (self.settings.columnGroups ? 'headers = "' + self.uniqueId('-header-' + j) + ' ' + self.getColumnGroup(j) + '"' : '') +
           (rowspan ? rowspan : '' ) +
           '><div class="datagrid-cell-wrapper">';

        if (col.contentVisible) {
          var canShow = col.contentVisible(dataRowIdx + 1, j, cellValue, col, rowData);
          if (!canShow) {
            formatted = '';
          }
        }

        if (self.settings.onPostRenderCell && col.component) {
          rowHtml += '<div class="content"></div>';
          formatted = '';
        }

        rowHtml += formatted + '</div></td>';
      }

      rowHtml += '</tr>';

      if (self.settings.rowTemplate) {
        var tmpl = self.settings.rowTemplate,
          item = rowData,
          renderedTmpl = '';

        if (Tmpl && item) {
          var compiledTmpl = Tmpl.compile('{{#dataset}}'+tmpl+'{{/dataset}}');
          renderedTmpl = compiledTmpl.render({dataset: item});
        }

        rowHtml += '<tr class="datagrid-expandable-row"><td colspan="'+ this.visibleColumns().length +'">' +
          '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding">'+ renderedTmpl + '</div></div>' +
          '</td></tr>';
      }

      if (self.settings.expandableRow) {
        rowHtml += '<tr class="datagrid-expandable-row"><td colspan="'+ this.visibleColumns().length +'">' +
          '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding"></div></div>' +
          '</td></tr>';
      }

      //Render Tree Children
      if (rowData.children) {
        for (i=0, l=rowData.children.length; i<l; i++) {
          this.recordCount++;
          rowHtml += self.rowHtml(rowData.children[i], this.recordCount, i);
        }
      }

      return rowHtml;
    },

    canvas:  null,
    totalWidth: 0,

    //This Function approximates the table auto widthing
    //Except use all column values and compare the text width of the header as max
    calculateTextWidth: function (columnDef) {
      var max = 0,
        self = this,
        field = columnDef.field,
        maxText = '',
        title = columnDef.name || '',
        chooseHeader = false;

      //Get max cell value length for this column
      for (var i = 0; i < this.settings.dataset.length; i++) {
        var val = this.fieldValue(this.settings.dataset[i], field),
           len = 0;

        //Get formatted value (without html) so we have accurate string that will display for this cell
        val = self.formatValue(columnDef.formatter, i, null, val, columnDef, this.settings.dataset[i], self);
        val = val.replace(/<\/?[^>]+(>|$)/g, '');

        len = val.toString().length;

        if (len > max) {
          max = len;
          maxText = val;
        }
      }

      //Use header text length as max if bigger than all data cells
      if (title.length > max) {
        max = title.length;
        maxText = title;
        chooseHeader = true;
      }

      if (maxText === '' || this.settings.dataset.length === 0) {
        maxText = columnDef.name || ' Default ';
        chooseHeader = true;
      }

      // if given, use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');
      context.font = '14px arial';
      var metrics = context.measureText(maxText);
      return Math.round(metrics.width + (chooseHeader ? 60 : 52));  //Add padding and borders
    },

    headerWidths: [], //Cache

    headerTableWidth: function () {
      var cacheWidths = this.headerWidths[this.settings.columns.length-1];

      if (!cacheWidths) {
        return '';
      }
      this.setScrollClass();

      if (cacheWidths.widthPercent) {
        return 'style = "width: 100%"';
      } else if (!isNaN(this.totalWidth)) {
        return 'style = "width: ' + parseFloat(this.totalWidth) + 'px"';
      }

      return '';
    },

    setScrollClass: function () {
      var height = parseInt(this.contentContainer[0].offsetHeight),
          hasScrollBar = parseInt(this.contentContainer[0].scrollHeight) > height + 2;

      this.element.removeClass('has-vertical-scroll has-less-rows');

      if (hasScrollBar) {
        this.element.addClass('has-vertical-scroll');
      }

      if (!hasScrollBar && this.tableBody[0].offsetHeight <  height) {
        this.element.addClass('has-less-rows');
      }

    },

    clearHeaderCache: function () {
      this.headerWidths = [];
      this.totalWidth = 0;
      this.elemWidth = 0;
      this.lastColumn = null;
    },

    //Calculate the width for a column (upfront with no rendering)
    //https://www.w3.org/TR/CSS21/tables.html#width-layout
    calculateColumnWidth: function (col, index) {
      var colPercWidth,
        visibleColumns = this.visibleColumns(true),
        lastColumn = (index === this.lastColumnIdx());

      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) { // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }
        if (!this.elemWidth || this.elemWidth === 0) { // handle on invisible modal
          this.elemWidth = this.element.closest('.modal-contents').outerWidth();
        }

        this.widthSpecified = false;
        this.widthPixel = false;
      }

      // use cache
      if (this.headerWidths[index]) {
        var cacheWidths = this.headerWidths[index];

        if (cacheWidths.width === 'default') {
          return '';
        }

        if (this.widthSpecified && !cacheWidths.width) {
          return '';
        }

        return ' style="width: '+ cacheWidths.width + (cacheWidths.widthPercent ? '%' :'px') + '"';
      }

      //A column element with a value other than 'auto' for the 'width' property sets the width for that column.
      if (col.width) {
        this.widthSpecified = true;
        this.widthPercent = false;
      }

      if (!this.widthPixel && col.width) {
        this.widthPixel = typeof col.width !== 'string';
      }

      var colWidth = col.width;

      if (typeof col.width === 'string' && col.width.indexOf('px') === -1) {
        this.widthPercent = true;
        colPercWidth = col.width.replace('%', '');
      }

      var textWidth = this.calculateTextWidth(col);  //reasonable default on error

      if (!this.widthSpecified || !colWidth) {
        colWidth = Math.max(textWidth, colWidth || 0);
      }

      lastColumn = index === this.lastColumnIdx() && this.totalWidth !== colWidth;

      // Simulate Auto Width Algorithm
      if ((!this.widthSpecified || col.width === undefined) && this.settings.sizeColumnsEqually &&
        (['selectionCheckbox', 'expander', 'drilldown', 'rowStatus', 'favorite'].indexOf(col.id) === -1)) {

        var percentWidth = Math.round(this.elemWidth / visibleColumns.length);
        colWidth = percentWidth - (lastColumn ? 2 : 0); //borders causing scroll

        //Handle Columns where auto width is bigger than the percent width
        if (percentWidth < textWidth) {
          colWidth = textWidth;
        }

      }

      //Some Built in columns
      if (col.id === 'selectionCheckbox' || col.id === 'favorite') {
        colWidth = 43;
        col.width = colWidth;
      }

      if (col.id === 'expander') {
        colWidth = 55;
        col.width = colWidth;
      }

      if (col.id === 'rowStatus') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'drilldown') {
        colWidth = 78;
        col.width = colWidth;
      }

      // cache the header widths
      this.headerWidths[index] = {id: col.id, width: (this.widthPercent ? colPercWidth : colWidth), widthPercent: this.widthPercent};
      this.totalWidth += col.hidden || lastColumn ? 0 : colWidth;

      //For the last column stretch it if it doesnt fit the area
      if (lastColumn) {
        var diff = this.elemWidth - this.totalWidth;

        if ((diff > 0) && (diff  > colWidth) && !this.widthPercent && !col.width) {
          colWidth = diff - 2 - 10; //borders and last edge padding
          this.headerWidths[index] = {id: col.id, width: colWidth, widthPercent: this.widthPercent};
          this.totalWidth =  this.elemWidth - 2;
        }

        if (this.widthPercent) {
          this.table.css('width', '100%');
        } else if (!isNaN(this.totalWidth)) {
          this.table.css('width', this.totalWidth);
        }
      }

      if (!this.widthPercent && colWidth === undefined) {
        return '';
      }

      return ' style="width: '+ (this.widthPercent ? colPercWidth + '%' : colWidth + 'px') + '"';
    },

    widthPercent: false,
    rowSpans: [],

    calculateRowspan: function (value, row, col) {
      var cnt = 0, min = null;

      if (!col.rowspan) {
        return;
      }

      for (var i = 0; i < this.settings.dataset.length; i++) {
        if (value === this.settings.dataset[i][col.field]) {
          cnt++;
          if (min === null) {
            min = i;
          }
        }
      }

      if (row === min) {
        return ' rowspan ="'+ cnt + '"';
      }
      return '';
    },

    //Summary Row Totals use the aggregators
    calculateTotals: function() {
      this.settings.totals = Aggregators.aggregate(this.settings.dataset, this.settings.columns);
      return this.settings.totals;
    },

    // Set unit type (pixel or percent)
    setUnit: function(v) {
      return v + (/(px|%)/i.test(v + '') ? '' : 'px');
    },

    // Content tooltip for rich text editor
    setupContentTooltip: function (elem, width, td) {
      if (elem.text().length > 0) {
        var content = elem.clone();

        elem.tooltip({
          content: content,
          extraClass: 'alternate content-tooltip',
          placementOpts: {
            parent: elem,
            parentXAlignment: 'center',
            strategies: ['flip', 'nudge', 'shrink']
          }
        });

        if (width) {
          content[0].style.width = width;
        } else {
          elem.on('beforeshow.datagrid', function () {
            elem.off('beforeshow.datagrid');
            content[0].style.width = td[0].offsetWidth + 'px';
          });
        }
      }
    },

    setupTooltips: function () {
      if (!this.settings.enableTooltips) {
        return;
      }

      var self = this;
      // Implement Tooltip on cells with title attribute
      this.tableBody.find('td[title]').tooltip({placement: 'left', offset: {left: -5, top: 0}});
      this.tableBody.find('a[title]').tooltip();

      // Implement Tooltip on cells with ellipsis
      this.table.find('td.text-ellipsis').tooltip({content: function() {
        var cell = $(this),
          text = cell.text(),
          inner = cell.children('.datagrid-cell-wrapper');

        if (cell[0] && inner[0] && (inner[0].offsetWidth)< inner[0].scrollWidth && cell.data('tooltip')) {
          var w = inner.width();
          cell.data('tooltip').settings.maxWidth = w;
          return text;
        }

        return '';
      }});

      // Rich text editor content tooltip
      this.table.find('td .is-editor.content-tooltip').each(function() {
        var elem = $(this),
          td = elem.closest('td'),
          cell = td.attr('aria-colindex') - 1,
          col = self.columnSettings(cell),
          width = col.editorOptions && col.editorOptions.width ? self.setUnit(col.editorOptions.width) : false;

        self.setupContentTooltip(elem, width, td);
      });
    },

    //Returns all header nodes (not the groups)
    headerNodes: function () {
      return this.headerRow.find('tr:not(.datagrid-header-groups) th');
    },

    //Refresh one row in the grid
    updateRow: function (idx, data) {
      var rowData = (data ? data : this.settings.dataset[idx]);

      for (var j = 0; j < this.settings.columns.length; j++) {
        var col = this.settings.columns[j];

        if (col.hidden) {
          continue;
        }

        if (col.id && ['selectionCheckbox', 'expander'].indexOf(col.id) > -1) {
          continue;
        }

        this.updateCellNode(idx, j, this.fieldValue(rowData, col.field), true);
      }

    },

    //given a new column set update the rows and reload
    updateColumns: function(columns, columnGroups) {
      this.settings.columns = columns;

      if (columnGroups) {
        this.settings.columnGroups = columnGroups;
      }

      this.clearHeaderCache();
      this.renderRows();
      this.renderHeader();
      this.resetPager('updatecolumns');
      this.element.trigger('columnchange', [{type: 'updatecolumns', columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();

    },

    saveColumns: function () {
      if (!this.settings.saveColumns) {
        return;
      }

      //Save to local storage
      if (this.canUseLocalStorage()) {
        localStorage[this.uniqueId('columns')] = JSON.stringify(this.settings.columns);
      }

    },

    // Omit events and save to local storage for supported settings
    saveUserSettings: function () {

      // Emit Event
      this.element.trigger('settingschanged', [{rowHeight: this.settings.rowHeight,
        columns: this.settings.columns,
        sortOrder: this.sortColumn,
        pagesize: this.settings.pagesize,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.pager ? this.pager.activePage : 1,
        filter: this.filterConditions()}]);

      // Save to Local Storage if the options are set
      var options = this.settings.saveUserSettings;
      if ($.isEmptyObject(options) || !this.canUseLocalStorage()) {
        return;
      }

      // Save Columns
      if (options.columns) {
        localStorage[this.uniqueId('usersettings-columns')] = JSON.stringify(this.settings.columns);
      }

      // Save Row Height
      if (options.rowHeight) {
        localStorage[this.uniqueId('usersettings-row-height')] = this.settings.rowHeight;
      }

      // Save Sort Order
      if (options.sortOrder) {
        localStorage[this.uniqueId('usersettings-sort-order')] = JSON.stringify(this.sortColumn);
      }

      // Save Page Size
      if (options.pagesize) {
        localStorage[this.uniqueId('usersettings-pagesize')] = this.settings.pagesize;
      }

      // Save Show Page Size Selector
      if (options.showPageSizeSelector) {
        localStorage[this.uniqueId('usersettings-show-pagesize-selector')] = this.settings.showPageSizeSelector;
      }

      // Save Page Num
      if (options.activePage && this.pager) {
        localStorage[this.uniqueId('usersettings-active-page')] = this.pager.activePage;
      }

      // Filter Conditions
      if (options.filter) {
        localStorage[this.uniqueId('usersettings-filter')] = JSON.stringify(this.filterConditions());
      }

    },

    canUseLocalStorage: function () {
      try {
        if (localStorage.getItem) {
          return true;
        }
      } catch (exception) {
        return false;
      }
    },

    columnsFromString: function(columnStr) {
      if (!columnStr) {
        return;
      }

      var self = this,
        columns = JSON.parse(columnStr);

      if (!columns) {
        return [];
      }

      //Map back the missing functions/objects
      for (var i = 0; i < columns.length; i++) {
        var isHidden,
          orgCol = self.columnById(columns[i].id);

        if (orgCol) {
          orgCol = orgCol[0];
          isHidden = columns[i].hidden;

          $.extend(columns[i], orgCol);

          if (isHidden !== undefined) {
            columns[i].hidden = isHidden;
          }
        }
      }

      return columns;
    },

    /**
    * Restore the columns from a provided list or local storage
    * @param {Array} cols - The columns list to restore, if you saved the settings manually.
    */
    restoreColumns: function (cols) {
      if (!this.settings.saveColumns || !this.canUseLocalStorage()) {
        return;
      }

      if (cols) {
        this.updateColumns(cols);
        return;
      }

      //Done on load as apposed to passed in
      var lsCols = localStorage[this.uniqueId('columns')];

      if (!cols && lsCols) {
        this.originalColumns = this.settings.columns;
        this.settings.columns = this.columnsFromString(lsCols);
        return;
      }

    },

    restoreUserSettings: function (settings) {
      var options = this.settings.saveUserSettings;

      if (!settings && ($.isEmptyObject(options) || !this.canUseLocalStorage())) {
        return;
      }

      // Restore The data thats passed in
      if (settings) {

        if (settings.columns) {
          this.updateColumns(settings.columns);
        }

        if (settings.rowHeight) {
          this.rowHeight(settings.rowHeight);
        }

        if (settings.sortOrder) {
          this.setSortColumn(settings.sortOrder.sortId, settings.sortOrder.sortAsc);
        }

        if (settings.pagesize) {
          this.settings.pagesize = parseInt(settings.pagesize);
          this.pager.settings.pagesize = parseInt(settings.pagesize);
          this.pager.setActivePage(1, true);
        }

        if (settings.showPageSizeSelector) {
          this.settings.showPageSizeSelector = settings.showPageSizeSelector;
          this.pager.showPageSizeSelector(settings.showPageSizeSelector);
        }

        if (settings.activePage) {
          this.pager.setActivePage(parseInt(settings.activePage), true);
        }

        if (settings.filter) {
          this.applyFilter(settings.filter);
        }
        return;
      }

      // Restore Column Width and Order
      if (options.columns) {
        var savedColumns = localStorage[this.uniqueId('usersettings-columns')];
        if (savedColumns) {
          this.originalColumns = this.settings.columns;
          this.settings.columns = this.columnsFromString(savedColumns);
        }
      }

      // Restore Row Height
      if (options.rowHeight) {
        var savedRowHeight = localStorage[this.uniqueId('usersettings-row-height')];

        if (savedRowHeight) {
          this.settings.rowHeight = savedRowHeight;
        }
      }

      // Restore Sort Order
      if (options.sortOrder) {
        var savedSortOrder = localStorage[this.uniqueId('usersettings-sort-order')];
        if (savedSortOrder) {
          this.sortColumn = JSON.parse(savedSortOrder);
          this.restoreSortOrder = true;
        }
      }

      // Restore Page Size
      if (options.pagesize) {
        var savedPagesize = localStorage[this.uniqueId('usersettings-pagesize')];
        if (savedPagesize) {
          this.settings.pagesize = parseInt(savedPagesize);
        }
      }

      // Restore Show Page Size Selector
      if (options.showPageSizeSelector) {
        var savedShowPageSizeSelector = localStorage[this.uniqueId('usersettings-show-pagesize-selector')];
        savedShowPageSizeSelector = (savedShowPageSizeSelector + '').toLowerCase() === 'true';
        if (savedShowPageSizeSelector) {
          this.settings.showPageSizeSelector = savedShowPageSizeSelector;
        }
      }

      // Restore Active Page
      if (options.activePage) {
        var savedActivePage = localStorage[this.uniqueId('usersettings-active-page')];
        if (savedActivePage) {
          this.savedActivePage = parseInt(savedActivePage);
          this.restoreActivePage = true;
        }
      }

      if (options.filter) {
        var savedFilter = localStorage[this.uniqueId('usersettings-filter')];
        if (savedFilter) {
          this.savedFilter = JSON.parse(savedFilter);
          this.restoreFilter = true;
        }
      }

    },

    // Reset Columns from the Menu Option
    resetColumns: function () {
      if (this.canUseLocalStorage()) {
        localStorage.removeItem(this.uniqueId('columns'));
      }

      if (this.originalColumns) {
        this.updateColumns(this.originalColumns);
        this.originalColumns = this.columnsFromString(JSON.stringify(this.settings.columns));
      }
    },

    /**
    * Hide a column.
    * @param {String} id &nbsp;-&nbsp The id of the column to hide.
    */
    hideColumn: function(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = true;
      this.headerRow.find('th').eq(idx).addClass('is-hidden');
      this.tableBody.find('td:nth-child('+ (idx+1) +')').addClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).addClass('is-hidden');
      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).addClass('is-hidden');
      }

      // Handle colSpans if present on the column
      if (this.hasColSpans) {
        var colSpan = this.headerRow.find('th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan = colSpan - 1;
          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find('td:nth-child('+ (idx+1) +')').addClass('is-hidden');
          }
        }
      }

      this.element.trigger('columnchange', [{type: 'hidecolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
    },

    /**
    * Show a hidden column.
    * @param {String} id &nbsp;-&nbsp The id of the column to show.
    */
    showColumn: function(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = false;
      this.headerRow.find('th').eq(idx).removeClass('is-hidden');
      this.tableBody.find('td:nth-child('+ (idx+1) +')').removeClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).removeClass('is-hidden');
      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).removeClass('is-hidden');
      }

      // Handle colSpans if present on the column
      if (this.hasColSpans) {
        var colSpan = this.headerRow.find('th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan = colSpan - 1;
          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find('td:nth-child('+ (idx+1) +')').removeClass('is-hidden');
          }
        }
      }

      this.element.trigger('columnchange', [{type: 'showcolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
    },

    /**
    * Export the grid contents to csv
    * @param {String} fileName &nbsp;-&nbsp The desired export filename in the download.
    * @param {String} customDs &nbsp;-&nbsp An optional customized version of the data to use.
    */
    exportToCsv: function (fileName, customDs) {
      fileName = (fileName ||
        this.element.closest('.datagrid-container').attr('id') ||
        'datagrid') +'.csv';

      var csvData,
        self = this,
        cleanExtra = function(table) {
          $('tr, th, td, div, span', table).each(function () {
            var el = this,
              elm = $(this);

            if (elm.is('.is-hidden')) {
              elm.remove();
              return;
            }

            $('.is-hidden, .is-draggable-target, .handle, .sort-indicator, .datagrid-filter-wrapper', el).remove();
            while(el.attributes.length > 0) {
              el.removeAttribute(el.attributes[0].name);
            }

            // White Hat Security Violation. Remove Excel formulas
            // Excel Formulas Start with =SOMETHING
            var text = elm.text();
            if (text.substr(0, 1) === '=' && text.substr(1, 1) !== '') {
              elm.text('\'' + text);
            }
          });
          return table;
        },
        appendRows = function(dataset, table) {
          var tableHtml,
            body = table.find('tbody').empty();

          for (var i = 0; i < dataset.length; i++) {
            if (!dataset[i].isFiltered) {
              tableHtml += self.rowHtml(dataset[i], i, i);
            }
          }

          body.append(tableHtml);
          return table;
        },
        base64 = function(s) {
          if (window.btoa) {
            return 'data:application/csv;base64,' + window.btoa(unescape(encodeURIComponent(s)));
          } else {
            return 'data:application/csv;,' + unescape(encodeURIComponent(s));
          }
        },
        formatCsv = function(table) {
          var csv = [],
            rows = table.find('tr'),
            row, cols, content;

          //CHECK EXPORTABLE
          var nonExportables = [];
          $.each($('th').not('.is-hidden'), function(index, item) {
            if ($(item)[0].getAttribute('data-exportable') && $(item)[0].getAttribute('data-exportable') === 'no') {
              nonExportables.push(index);
            }
          });

          for (var i = 0, l = rows.length; i < l; i++) {
            row = [];
            cols = $(rows[i]).find('td, th');
            for (var i2 = 0; i2 < cols.length; i2++) {
              if (nonExportables.indexOf(i2) <= -1) {
                content = cols[i2].innerText.replace('"', '""');

                // Exporting data with trailing negative signs moved in front
                if (self.settings.exportConvertNegative) {
                  content = content.replace(/^(.+)(\-$)/, '$2$1');
                }
                row.push(content);
              }
            }
            csv.push(row.join('","'));
          }
          return '"'+ csv.join('"\n"') +'"';
        },
        table = self.table.clone();

      table = appendRows(customDs || this.settings.dataset, table);
      if (!table.find('thead').length) {
        self.headerRow.clone().insertBefore(table.find('tbody'));
      }

      table = cleanExtra(table);
      csvData = formatCsv(table);

      if (this.isIe) {
        if (this.isIe9) {
          var IEwindow = window.open();
          IEwindow.document.write('sep=,\r\n' + csvData);
          IEwindow.document.close();
          IEwindow.document.execCommand('SaveAs', true, fileName);
          IEwindow.close();
        }
        else if (window.navigator.msSaveBlob) {
          var blob = new Blob([csvData], {
            type: 'application/csv;charset=utf-8;'
          });
          navigator.msSaveBlob(blob, fileName);
        }
      }
      else {
        var link = document.createElement('a');
        link.href = base64(csvData);
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    },

    /**
    * Export the grid contents to xls format. This may give a warning when opening the file. exportToCsv may be prefered.
    * @param {String} fileName &nbsp;-&nbsp The desired export filename in the download.
    * @param {String} worksheetName &nbsp;-&nbsp A name to give the excel worksheet tab.
    * @param {String} customDs &nbsp;-&nbsp An optional customized version of the data to use.
    */
    exportToExcel: function (fileName, worksheetName, customDs) {
      var self = this,
        template = ''+
          '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">'+
            '<head>'+
              '<!--[if gte mso 9]>'+
                '<xml>'+
                  '<x:ExcelWorkbook>'+
                    '<x:ExcelWorksheets>'+
                      '<x:ExcelWorksheet>'+
                        '<x:Name>{worksheet}</x:Name>'+
                        '<x:WorksheetOptions>'+
                          '<x:Panes></x:Panes>'+
                          '<x:DisplayGridlines></x:DisplayGridlines>'+
                        '</x:WorksheetOptions>'+
                      '</x:ExcelWorksheet>'+
                    '</x:ExcelWorksheets>'+
                  '</x:ExcelWorkbook>'+
                '</xml>'+
              '<![endif]-->'+
              '<meta http-equiv="content-type" content="text/plain; charset=UTF-8"/>'+
            '</head>'+
            '<body>'+
              '<table border="1px solid #999999">{table}</table>'+
            '</body>'+
          '</html>',

        cleanExtra = function(table) {
          $('tr, th, td, div, span', table).each(function () {
            var el = this,
              elm = $(this);

            if (elm.is('.is-hidden')) {
              elm.remove();
              return;
            }

            $('.is-hidden, .is-draggable-target, .handle, .sort-indicator, .datagrid-filter-wrapper', el).remove();
            while(el.attributes.length > 0) {
              el.removeAttribute(el.attributes[0].name);
            }

            // White Hat Security Violation. Remove Excel formulas
            // Excel Formulas Start with =SOMETHING
            var text = elm.text();
            if (text.substr(0, 1) === '=' && text.substr(1, 1) !== '') {
              elm.text('\'' + text);
            }
          });
          return table;
        },

        base64 = function(s) {
          if (window.btoa) {
            return 'data:application/vnd.ms-excel;base64,' + window.btoa(unescape(encodeURIComponent(s)));
          } else {
            return 'data:application/vnd.ms-excel;,' + unescape(encodeURIComponent(s));
          }
        },

        format = function(s, c) {
          return s.replace(/{(\w+)}/g, function(m, p) {
            return c[p];
          });
        },

        appendRows = function(dataset, table) {
          var tableHtml,
            body = table.find('tbody').empty();

          for (var i = 0; i < dataset.length; i++) {
            if (!dataset[i].isFiltered) {
              tableHtml += self.rowHtml(dataset[i], i, i);
            }
          }

          body.append(tableHtml);
          return table;
        };

      var table = self.table.clone();
      table = appendRows(customDs || this.settings.dataset, table);

      if (!table.find('thead').length) {
        self.headerRow.clone().insertBefore(table.find('tbody'));
      }

      table = cleanExtra(table);

      // Exporting data with trailing negative signs moved in front
      if (self.settings.exportConvertNegative) {
        table.find('td').each(function() {
          var td = $(this),
            content = td.text();
          td.text(content.replace(/^(.+)(\-$)/, '$2$1'));
        });
      }

      var ctx = { worksheet: (worksheetName || 'Worksheet'), table: table.html() };

      fileName = (fileName ||
        self.element.closest('.datagrid-container').attr('id') ||
        'datagrid') +'.xls';

      if (this.isIe) {
        if (this.isIe9) {
          var IEwindow = window.open();
          IEwindow.document.write('sep=,\r\n' + format(template, ctx));
          IEwindow.document.close();
          IEwindow.document.execCommand('SaveAs', true, fileName);
          IEwindow.close();
        }
        else if (window.navigator.msSaveBlob) {
          var blob = new Blob([format(template, ctx)], {
            type: 'application/csv;charset=utf-8;'
          });
          navigator.msSaveBlob(blob, fileName);
        }
      }
      else {
        var link = document.createElement('a');
        link.href = base64(format(template, ctx));
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    },

    /**
    * Open the personalization dialog.
    * @private
    */
    personalizeColumns: function () {
      var self = this,
        spanNext = 0,
        markup = '<div class="listview-search alternate-bg"><label class="audible" for="gridfilter">Search</label><input class="searchfield" placeholder="'+ Locale.translate('SearchColumnName') +'" name="searchfield" id="gridfilter"></div>';
        markup += '<div class="listview alternate-bg" id="search-listview"><ul>';

        for (var i = 0; i < this.settings.columns.length; i++) {
          var col = this.settings.columns[i],
            name = col.name;

          if (name && spanNext <= 0) {
            name = name.replace('<br>', ' ').replace('<br/>', ' ').replace('<br />', ' ');
            markup += '<li><a href="#" target="_self" tabindex="-1"> <label class="inline"><input tabindex="-1" ' + (col.hideable ===false ? 'disabled' : '') + ' type="checkbox" class="checkbox" '+ (col.hidden ? '' : ' checked') +' data-column-id="'+ (col.id || i) +'"><span class="label-text">' + name + '</span></label></a></li>';
          }

          if (spanNext > 0) {
            spanNext--;
          }

          if (col.colspan) {
            spanNext = col.colspan-1;
          }

        }
        markup += '</ul></div>';

        $('body').modal({
          title: Locale.translate('PersonalizeColumns'),
          content: markup,
          cssClass: 'full-width datagrid-columns-dialog',
          buttons: [{
              text: Locale.translate('Close'),
              click: function(e, modal) {
                modal.close();
                $('body').off('open.datagrid');
              }
            }]
        }).on('beforeopen.datagrid', function () {
          self.isColumnsChanged = false;
        }).on('open.datagrid', function (e, modal) {
          modal.element.find('.searchfield').searchfield({clearable: true});
          modal.element.find('.listview').listview({searchable: true, selectOnFocus: false})
            .on('selected', function (e, args) {
              var chk = args.elem.find('.checkbox'),
                  id = chk.attr('data-column-id'),
                  isChecked = chk.prop('checked');

              args.elem.removeClass('is-selected hide-selected-color');

              if (chk.is(':disabled')) {
                return;
              }
              self.isColumnsChanged = true;

              if (!isChecked) {
                self.showColumn(id);
                chk.prop('checked', true);
              } else {
                self.hideColumn(id);
                chk.prop('checked', false);
              }
            });

          modal.element.on('close.datagrid', function () {
            self.isColumnsChanged = false;
          });

      });
    },

    // Explicitly Set the Width of a column
    setColumnWidth: function(idOrNode, width, diff) {
      var self = this,
        percent = parseFloat(width),
        columnNode = idOrNode,
        columnSettings = this.columnById(typeof idOrNode === 'string' ? idOrNode : idOrNode.attr('data-column-id'))[0];

      if (!percent) {
        return;
      }

      if (typeof idOrNode === 'string') {
        self.headerNodes().each(function () {
          var col = $(this);

          if (col.attr('data-column-id') === idOrNode) {
            columnNode = col;
          }

        });
      }

      //Handles min width on some browsers
      if ((columnSettings.minWidth && width > parseInt(columnSettings.minWidth))) {
        return;
      }

      //calculate percentage
      if (typeof width !=='number') {
        width = percent / 100 * self.element.width();
      }

      //Prevent Sub Pixel Thrashing
      if (Math.abs(width - columnSettings.width) < 2) {
        return;
      }

      //Handle Col Span - as the width is calculated on the total
      if (columnSettings.colspan) {
        width = width / columnSettings.colspan;
      }

      // Save the column back in settings for later
      if (columnSettings) {
        columnSettings.width = width;
      }

      var idx = columnNode.index();
      self.headerColGroup.find('col').eq(idx)[0].style.width = (width + 'px');

      if (self.settings.dataset.length > 0) {
        self.bodyColGroup.find('col').eq(idx)[0].style.width = (width + 'px');
      }

      if (self.tableWidth && diff) {
        self.headerTable.css('width', parseInt(self.tableWidth) + diff);
        self.table.css('width', parseInt(self.tableWidth) + diff);
      }

      this.element.trigger('columnchange', [{type: 'resizecolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
      this.clearHeaderCache();
    },

    /**
    * Generate the ui handles used to resize columns.
    *
    * @private
    */
    createResizeHandle: function() {
      var self = this;
      if (this.resizeHandle) {
        return;
      }

      this.resizeHandle = $('<div class="resize-handle" aria-hidden="true"></div>');
      if (this.settings.columnGroups) {
        this.resizeHandle[0].style.height = '80px';
      }

      if (this.settings.filterable) {
        this.resizeHandle[0].style.height = '62px';
      }

      this.headerContainer.find('table').before(this.resizeHandle);

      var columnId, startingLeft, columnStartWidth, columnDef;

      this.resizeHandle.drag({axis: 'x', containment: 'parent'})
        .on('dragstart.datagrid', function () {
          if (!self.currentHeader) {
            return;
          }

          self.dragging = true;

          columnId = self.currentHeader.attr('data-column-id');
          columnDef = self.columnById(columnId)[0];

          startingLeft = self.currentHeader.position().left + self.table.scrollLeft() - 10;
          self.tableWidth = self.table[0].offsetWidth;
          columnStartWidth = self.currentHeader[0].offsetWidth;
        })
        .on('drag.datagrid', function (e, ui) {
          if (!self.currentHeader || !columnDef) {
            return;
          }

          var width = (ui.left - startingLeft -1),
            minWidth = columnDef.minWidth || 12,
            maxWidth = columnDef.maxWidth || 1000;

          if (width < minWidth || width> maxWidth) {
            self.resizeHandle.css('cursor', 'inherit');
            return;
          }

          width = Math.round(width);

          self.setColumnWidth(self.currentHeader, width, width - columnStartWidth);
        })
        .on('dragend.datagrid', function () {
          self.dragging = false;
        });
    },

    //Show Summary and any other count info
    displayCounts: function(totals) {
      var self = this,
        count = self.tableBody.find('tr:visible').length,
        isClientSide = self.settings.paging && !(self.settings.source);

      if (isClientSide || (!totals)) {
        this.recordCount = count = self.settings.dataset.length;
      }

      //Update Selected
      if (self.contextualToolbar && self.contextualToolbar.length) {
        self.contextualToolbar.find('.selection-count').text(self.selectedRows().length + ' ' + Locale.translate('Selected'));
      }

      if (self.settings.source && !totals) {
        self.checkEmptyMessage();
        return;
      }

      if (totals && totals !== -1) {
        count = totals;
      }

      var countText;
      if (self.settings.showFilterTotal && self.filteredCount > 0) {
        countText = '(' + Locale.formatNumber(count - self.filteredCount, {style: 'integer'}) + ' of ' + Locale.formatNumber(count, {style: 'integer'}) + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      } else {
        countText = '(' + Locale.formatNumber(count, {style: 'integer'}) + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      }

      if (self.settings.resultsText) {
        if (typeof self.settings.resultsText === 'function') {
          countText = self.settings.resultsText(self, count, count - self.filteredCount);
        } else {
          countText = self.settings.resultsText;
        }
      }

      if (self.toolbar) {
        self.toolbar.find('.datagrid-result-count').html(countText);
        self.toolbar.attr('aria-label',  self.toolbar.find('.title').text());
        self.toolbar.find('.datagrid-row-count').text(count);
      }
      self.element.closest('.modal').find('.datagrid-result-count').html(countText);

      this.checkEmptyMessage();
    },

    checkEmptyMessage: function () {
      if (this.settings.emptyMessage && this.emptyMessageContainer) {
        if (this.filteredCount ===  this.recordCount || this.recordCount === 0) {
          this.emptyMessageContainer.show();
          this.element.addClass('is-empty');
        } else {
          this.emptyMessageContainer.hide();
          this.element.removeClass('is-empty');
        }
      }
    },
    //Trigger event on parent and compose the args
    triggerRowEvent: function (eventName, e, stopPropagation) {
      var self = this,
          cell = $(e.target).closest('td').index(),
          row = self.dataRowIndex($(e.target).closest('tr')),
          item = self.settings.dataset[row];

      if ($(e.target).is('a')) {
        stopPropagation = false;
      }

      if (stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      self.element.trigger(eventName, [{row: row, cell: cell, item: item, originalEvent: e}]);
      return false;
    },

    //Returns a cell node
    cellNode: function (row, cell, includeGroups) {
      var cells,
        rowNode = this.tableBody.find('tr:not(.datagrid-expandable-row)[aria-rowindex="'+ (row + 1) +'"]');

      if (row instanceof jQuery) {
        rowNode = row;
      }

      if (includeGroups && this.settings.groupable) {
        rowNode = this.tableBody.prevAll('.datagrid-rowgroup-header').eq(row);
        if (rowNode) {
          rowNode = this.tableBody.find('.datagrid-rowgroup-header').eq(row);
        }
      }

      if (cell === -1) {
        return $();
      }

      cells = rowNode.find('td');
      return cells.eq(cell >= cells.length ? cells.length-1 : cell);
    },

    scrollLeft: 0,
    scrollTop: 0,

    handleScroll: function() {
      var left = this.contentContainer[0].scrollLeft;

      if (left !== this.scrollLeft && this.headerContainer) {
        this.scrollLeft = left;
        this.headerContainer[0].scrollLeft = this.scrollLeft;
      }

    },

    handleResize: function () {
      var self = this;
      self.clearHeaderCache();
      self.renderRows();
      self.renderHeader();
    },

    // Attach All relevant events
    handleEvents: function() {
      var self = this,
        isMultiple = this.settings.selectable === 'multiple',
        isMixed = this.settings.selectable === 'mixed';

      // Set Focus on rows
      if (!self.settings.cellNavigation && self.settings.rowNavigation) {
        self.table
        .on('focus.datagrid', 'tbody > tr', function () {
            $(this).addClass('is-active-row');
        })
        .on('blur.datagrid', 'tbody > tr', function () {
          $('tbody > tr', self.table).removeClass('is-active-row');
        });
      }

      //Sync Header and Body During scrolling
      self.contentContainer
        .on('scroll.table',function () {
          self.handleScroll();
        });

      if (this.settings.virtualized) {
        var oldScroll = 0, oldHeight = 0;

        self.contentContainer
          .on('scroll.vtable', Soho.utils.debounce(function () {

            var scrollTop = this.scrollTop,
              buffer = 25,
              hitBottom = scrollTop > (self.virtualRange.bottom - self.virtualRange.bodyHeight - buffer),
              hitTop = scrollTop < (self.virtualRange.top + buffer);

            if (scrollTop !== oldScroll && (hitTop || hitBottom)) {
              oldScroll = this.scrollTop;
              self.renderRows();
              return;
            }
          }, 0));

        $('body').on('resize.vtable', function () {
          var height = this.offsetHeight;

          if (height !== oldHeight) {
            oldHeight = this.scrollTop;
            self.renderRows();
          }

        });
      }

      // Handle Resize - Re do the columns
      if (self.settings.redrawOnResize) {
        var oldWidth = $('body')[0].offsetWidth;

        $('body').on('resize.datagrid', function () {
          var width = this.offsetWidth;
          if (width !== oldWidth) {
            oldWidth = width;
            self.handleResize();
          }
        });
      }

      //Handle Sorting
      this.element
        .off('click.datagrid')
        .on('click.datagrid', 'th.is-sortable, th.btn-filter', function (e) {

          if ($(e.target).parent().is('.datagrid-filter-wrapper')) {
            return;
          }

          self.setSortColumn($(this).attr('data-column-id'));
        });

      //Prevent redirects
      this.table
        .off('mouseup.datagrid touchstart.datagrid')
        .on('mouseup.datagrid touchstart.datagrid', 'a', function (e) {
        e.preventDefault();
      });

      //Handle Row Clicking
      var tbody = this.table.find('tbody');
      tbody.off('click.datagrid').on('click.datagrid', 'td', function (e) {
        var rowNode, dataRowIdx,
          target = $(e.target);

        if (target.closest('.datagrid-row-detail').length === 1) {
          return;
        }

        self.triggerRowEvent('click', e, true);
        self.setActiveCell(target.closest('td'));

        //Dont Expand rows or make cell editable when clicking expand button
        if (target.is('.datagrid-expand-btn') || (target.is('.datagrid-cell-wrapper') && target.find('.datagrid-expand-btn').length)) {
          rowNode = $(this).closest('tr');
          dataRowIdx = self.dataRowIndex(rowNode);

          self.toggleRowDetail(dataRowIdx);
          self.toggleGroupChildren(rowNode);
          self.toggleChildren(e, dataRowIdx);
          return false;
        }

        var isSelectionCheckbox = target.is('.datagrid-selection-checkbox') ||
                                  target.find('.datagrid-selection-checkbox').length === 1,
          canSelect = self.settings.clickToSelect ? true : isSelectionCheckbox;

        if (target.is('.datagrid-drilldown')) {
          canSelect = false;
        }

        if (isMixed) {
          canSelect = isSelectionCheckbox;

          //Then Activate
          if (!canSelect) {
            self.toggleRowActivation(target.closest('tr'));
          }
        }

        if (canSelect && isMultiple && e.shiftKey) {
          self.selectRowsBetweenIndexes([self.lastSelectedRow, target.closest('tr').index()]);
          e.preventDefault();
        } else if (canSelect) {
          self.toggleRowSelection(target.closest('tr'));
        }

        self.lastClicked = target;
        var isEditable = self.makeCellEditable(self.activeCell.dataRow, self.activeCell.cell, e);

        //Handle Cell Click Event
        var elem = $(this).closest('td'),
          cell = elem.parent().children(':visible').index(elem),
          col = self.columnSettings(cell, true);

        if (col.click && typeof col.click === 'function' && (target.is('button, input[checkbox], a') || target.parent().is('button'))) {

          var rowElem = $(this).closest('tr'),
            rowIdx = self.dataRowIndex(rowElem),
            item = self.settings.treeGrid ?
              self.settings.treeDepth[rowIdx].node :
              self.settings.dataset[self.pager && self.settings.source ? rowElem.index() : rowIdx];

          if (elem.hasClass('is-focusable')) {
            if (!target.is(self.settings.buttonSelector)) {
              if (!target.parent('button').is(self.settings.buttonSelector)) {
                return;
              }
            }
          }

          if (!elem.hasClass('is-cell-readonly') && (target.is('button, input[checkbox], a') || target.parent().is('button'))) {
            col.click(e, [{row: rowIdx, cell: self.activeCell.cell, item: item, originalEvent: e}]);
          }
        }

        //Handle Context Menu on Some
        if (col.menuId) {
          var btn = $(this).find('button');
          btn.popupmenu({attachToBody: true, autoFocus: false, mouseFocus: true,  menuId: col.menuId, trigger: 'immediate', offset: { y: 5 }});

          if (col.selected) {
            btn.on('selected.datagrid', col.selected);
          }
        }

        // Apply Quick Edit Mode
        if (isEditable) {
          setTimeout(function() {
            if ($('textarea, input', elem).length &&
                (!$('.dropdown,' +
                '[type=image],' +
                '[type=button],' +
                '[type=submit],' +
                '[type=reset],' +
                '[type=checkbox],' +
                '[type=radio]', elem).length)) {
              self.quickEditMode = true;
            }
          }, 0);
        }

      });

      tbody.off('dblclick.datagrid').on('dblclick.datagrid', 'tr', function (e) {
        self.triggerRowEvent('dblclick', e, true);
      });

      //Handle Context Menu Option
      tbody.off('contextmenu.datagrid').on('contextmenu.datagrid', 'tr', function (e) {

        if (!self.isSubscribedTo(e, 'contextmenu')) {
          return;
        }

        self.triggerRowEvent('contextmenu', e, (self.settings.menuId ? true : false));
        e.preventDefault();

        if (self.settings.menuId) {
          $(e.currentTarget).popupmenu({
            menuId: self.settings.menuId,
            eventObj: e,
            beforeOpen: self.settings.menuBeforeOpen,
            trigger: 'immediate'})
          .off('selected').on('selected', function (e, args) {
            if (self.settings.menuSelected) {
              self.settings.menuSelected(e, args);
            }
          });
        }

        return false;
      });

      // Move the drag handle to the end or start of the column
      this.headerRow
        .off('mousemove.datagrid')
        .on('mousemove.datagrid', 'th', function (e) {
          if (self.dragging) {
            return;
          }

          self.currentHeader = $(e.target).closest('th');

          if (!self.currentHeader.hasClass('is-resizable')) {
            return;
          }

          var headerDetail = self.currentHeader.closest('.header-detail'),
            extraMargin = headerDetail.length ? parseInt(headerDetail.css('margin-left'), 10) : 0,
            leftEdge = parseInt(self.currentHeader.position().left) - (extraMargin || 0) + self.element.scrollLeft(),
            rightEdge = leftEdge + self.currentHeader.outerWidth(),
            alignToLeft = (e.pageX - leftEdge > rightEdge - e.pageX),
            leftPos = 0;

          //TODO: Test Touch support - may need handles on each column
          leftPos = (alignToLeft ? (rightEdge - 6): (leftEdge - 6));

          //Ignore First Column
          if (self.currentHeader.index() === 0 && !alignToLeft) {
            leftPos = '-999';
          }

          if (!alignToLeft) {
            self.currentHeader = self.currentHeader.prevAll(':visible').not('.is-hidden').first();
          }

          if (!self.currentHeader.hasClass('is-resizable')) {
            return;
          }

          self.createResizeHandle();
          self.resizeHandle[0].style.left = leftPos +'px';
          self.resizeHandle[0].style.cursor = '';
        }).off('contextmenu.datagrid').on('contextmenu.datagrid', 'th', function (e) {

          // Add Header Context Menu Support
          e.preventDefault();

          if (self.settings.headerMenuId) {

            $(e.currentTarget)
            .popupmenu({
              menuId: self.settings.headerMenuId,
              eventObj: e,
              attachToBody: true,
              beforeOpen: self.settings.headerMenuBeforeOpen,
              trigger: 'immediate'})
              .off('selected.gridpopup')
              .on('selected.gridpopup', function (e, args) {
                self.settings.headerMenuSelected(e, args);
              });

          }

          return false;
        });

      // Handle Clicking Header Checkbox
      this
        .headerRow
        .off('click.datagrid')
        .on('click.datagrid', 'th .datagrid-checkbox', function () {
          var checkbox = $(this);

          if (!checkbox.hasClass('is-checked')) {
            checkbox.addClass('is-checked').attr('aria-checked', 'true');

            self.selectAllRows();

          } else {
            checkbox.removeClass('is-checked').attr('aria-checked', 'true');
            self.unSelectAllRows();
          }
        });

      // Implement Editing Auto Commit Functionality
      tbody.off('focusout.datagrid').on('focusout.datagrid', 'td input, td textarea, div.dropdown', function (e) {

        // Keep icon clickable in edit mode
        var target = e.target;

        if ($(target).is('input.lookup, input.timepicker, input.datepicker, input.spinbox, input.colorpicker')) {
          // Wait for modal popup, if did not found modal popup means
          // icon was not clicked, then commit cell edit
          setTimeout(function() {
            if (!$('.lookup-modal.is-visible, #timepicker-popup, #calendar-popup, #colorpicker-menu').length &&
                !!self.editor && self.editor.input.is(target)) {

              if ($('*:focus').is('.spinbox')) {
                return;
              }
              self.commitCellEdit(self.editor.input);
            }

          }, 150);

          return;
        }

        //Popups are open
        if ($('#dropdown-list, .autocomplete.popupmenu.is-open, #timepicker-popup').is(':visible')) {
          return;
        }

        if (self.editor && self.editor.input) {
          self.lastClicked = null;
          self.commitCellEdit(self.editor.input);
        }

      });

    },

    //Check if the event is subscribed to
    isSubscribedTo: function (e, eventName) {
      var self = this;

      for (var event in $._data(self.element[0]).events) {
        if (event === eventName) {
          return true;
        }
      }

      return false;
    },

    // Adjust to set a changed row height
    refreshSelectedRowHeight: function () {
      var toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)'),
        short = toolbar.find('[data-option="row-short"]'),
        med = toolbar.find('[data-option="row-medium"]'),
        normal = toolbar.find('[data-option="row-normal"]');

      if (this.settings.rowHeight === 'short') {
        short.parent().addClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'medium') {
        short.parent().removeClass('is-checked');
        med.parent().addClass('is-checked');
        normal.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'normal') {
        short.parent().removeClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().addClass('is-checked');
      }

      // Set draggable targets arrow height
      $('.drag-target-arrows', this.element).css('height', this.getTargetHeight() +'px');
    },

    appendToolbar: function () {
      var toolbar, title = '', more, self = this;

      if (!settings.toolbar) {
        return;
      }

      //Allow menu to be added manually
      if (this.element.parent().find('.toolbar:not(.contextual-toolbar)').length === 1) {
        toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
        this.refreshSelectedRowHeight();
      } else {
        toolbar = $('<div class="toolbar" role="toolbar"></div>');
        this.removeToolbarOnDestroy = true;

        if (settings.toolbar.title) {
          title = $('<div class="title">' + settings.toolbar.title + '  </div>');
        }

        if (!title) {
          title = toolbar.find('.title');
        }
        toolbar.append(title);

        if (settings.toolbar.results) {
          //Actually value filled in displayResults
          title.append('<span class="datagrid-result-count"></span>');
        }

        var buttonSet = $('<div class="buttonset"></div>').appendTo(toolbar);

        if (settings.toolbar.keywordFilter) {
          var labelMarkup = $('<label class="audible" for="gridfilter">'+ Locale.translate('Keyword') +'</label>'),
            searchfieldMarkup = $('<input class="searchfield" name="searchfield" placeholder="' + Locale.translate('Keyword') + '" id="gridfilter">');

          buttonSet.append(labelMarkup);

          if (!settings.toolbar.collapsibleFilter) {
            searchfieldMarkup.attr('data-options', '{ collapsible: false }');
          }

          buttonSet.append(searchfieldMarkup);
        }

        if (settings.toolbar.dateFilter) {
          buttonSet.append('<button class="btn" type="button">' + $.createIcon({ icon: 'calendar' }) + '<span>' + Locale.translate('Date') + '</span></button>');
        }

        if (settings.toolbar.actions) {
          more = $('<div class="more"></div>').insertAfter(buttonSet);
          more.append('<button class="btn-actions" title="More" type="button">' + $.createIcon({ icon: 'more' }) + '<span class="audible">Grid Features</span></button>');
          toolbar.addClass('has-more-button');
        }

        var menu = $('<ul class="popupmenu"></ul>');

        if (settings.toolbar.personalize) {
          menu.append('<li><a href="#" data-option="personalize-columns">' + Locale.translate('PersonalizeColumns') + '</a></li>');
        }

        if (settings.toolbar.resetLayout) {
          menu.append('<li><a href="#" data-option="reset-layout">' + Locale.translate('ResetDefault') + '</a></li>');
        }

        if (settings.toolbar.exportToExcel) {
          menu.append('<li><a href="#" data-option="export-to-excel">' + Locale.translate('ExportToExcel') + '</a></li>');
        }

        if (settings.toolbar.advancedFilter) {
          menu.append('<li><a href="#">' + Locale.translate('AdvancedFilter') + '</a></li>');
        }

        if (settings.toolbar.views) {
          menu.append('<li><a href="#">' + Locale.translate('SaveCurrentView') + '</a></li> ' +
            '<li class="separator"></li> ' +
            '<li class="heading">' + Locale.translate('SavedViews') + '</li>' +
            '<li><a href="#">View One</a></li>');
        }

        if (settings.toolbar.rowHeight) {
          menu.append('<li class="separator single-selectable-section"></li>' +
            '<li class="heading">' + Locale.translate('RowHeight') + '</li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'short' ? ' is-checked' : '') + '"><a data-option="row-short">' + Locale.translate('Short') + '</a></li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'medium' ? ' is-checked' : '') + '"><a data-option="row-medium">' + Locale.translate('Medium') + '</a></li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'normal' ? ' is-checked' : '') + '"><a data-option="row-normal">' + Locale.translate('Normal') + '</a></li>');
        }

        if (settings.toolbar.filterRow) {
          menu.append('<li class="separator"></li>' +
            '<li class="heading">' + Locale.translate('Filter') + '</li>' +
            '<li class="' + (settings.filterable ? 'is-checked ' : '') + 'is-toggleable"><a data-option="show-filter-row">' + Locale.translate('ShowFilterRow') + '</a></li>' +
            '<li class="is-indented"><a data-option="run-filter">' + Locale.translate('RunFilter') + '</a></li>' +
            '<li class="is-indented"><a data-option="clear-filter">' + Locale.translate('ClearFilter') + '</a></li>');
        }

        if (settings.toolbar.actions) {
          more.append(menu);
        }

        if (this.element.prev().is('.contextual-toolbar')) {
          this.element.prev().before(toolbar);
        } else {
          this.element.before(toolbar);
        }
      }

      toolbar.find('.btn-actions').popupmenu().on('selected', function(e, args) {
        var action = args.attr('data-option');
        if (action === 'row-short' || action === 'row-medium' || action === 'row-normal') {
          self.rowHeight(action.substr(4));
        }

        if (action === 'personalize-columns') {
          self.personalizeColumns();
        }

        if (action === 'reset-layout') {
          self.resetColumns();
        }

        if (action === 'export-to-excel') {
          // self.exportToExcel();
          self.exportToCsv();
        }

        //Filter actions
        if (action === 'show-filter-row') {
          self.toggleFilterRow();
        }
        if (action === 'run-filter') {
          self.applyFilter();
        }
        if (action === 'clear-filter') {
          self.clearFilter();
        }
      });

      if (settings.initializeToolbar && !toolbar.data('toolbar')) {
        var opts = $.fn.parseOptions(toolbar);

        if (settings.toolbar.fullWidth) {
          opts.rightAligned = true;
        }

        toolbar.toolbar(opts);
      }

      if (settings.toolbar && settings.toolbar.keywordFilter) {

        var thisSearch = toolbar.find('.searchfield'),
          xIcon = thisSearch.parent().find('.close.icon');

        thisSearch.off('keypress.datagrid').on('keypress.datagrid', function (e) {
          if (e.keyCode === 13 || e.type==='change') {
            e.preventDefault();
            self.keywordSearch(thisSearch.val());
          }
        });

        xIcon.off('click.datagrid').on('click.datagrid', function () {
          self.keywordSearch(thisSearch.val());
        });

      }

      this.toolbar = toolbar;
      this.element.addClass('has-toolbar');
    },

    //Get or Set the Row Height
    rowHeight: function(height) {
      if (height) {
        settings.rowHeight = height;
      }

      this.element.add(this.table)
        .removeClass('short-rowheight medium-rowheight normal-rowheight')
        .addClass(settings.rowHeight + '-rowheight');

      if (this.virtualRange && this.virtualRange.rowHeight) {
        this.virtualRange.rowHeight = (height === 'normal' ? 40 : (height === 'medium' ? 30 : 25));
      }

      this.saveUserSettings();
      this.refreshSelectedRowHeight();
      return settings.rowHeight;
    },

    //Search a Term across all columns
    keywordSearch: function(term) {
      this.tableBody.find('tr[role="row"]').removeClass('is-filtered').show();
      this.filterExpr = [];

        this.tableBody.find('.datagrid-expandable-row').each(function () {
          var row = $(this);
          //Collapse All rows
          row.prev().find('.datagrid-expand-btn').removeClass('is-expanded');
          row.prev().find('.plus-minus').removeClass('active');
          row.removeClass('is-expanded').css('display', '');
          row.find('.datagrid-row-detail').css('height', '');
        });

      this.tableBody.find('.search-mode').each(function () {
        var cell = $(this),
          text = cell.text();
        cell.text(text.replace('<i>','').replace('</i>',''));
      });

      term = (term || '').toLowerCase();
      this.filterExpr.push({column: 'all', operator: 'contains', value: term, keywordSearch: true});

      this.filterKeywordSearch();
      this.renderRows();
      this.resetPager('searched');
      this.setSearchActivePage();

      if (!this.settings.paging) {
        this.highlightSearchRows(term);
      }
    },

    // Set search active page
    setSearchActivePage: function () {
      if (this.pager && this.filterExpr.length === 1) {
        if (this.filterExpr[0].value !== '') {
          if (this.pager.searchActivePage === undefined) {
            this.pager.searchActivePage = this.pager.activePage;
          }
          this.pager.setActivePage(1, true);
        }
        else if (this.filterExpr[0].value === '' && this.pager.searchActivePage > -1) {
          this.pager.setActivePage(this.pager.searchActivePage, true);
          delete this.pager.searchActivePage;
        }
      }
      else if (this.pager && this.pager.searchActivePage > -1) {
        this.pager.setActivePage(this.pager.searchActivePage, true);
        delete this.pager.searchActivePage;
      }
    },

    // Filter to keyword search
    filterKeywordSearch: function () {
      var self = this,
        dataset, isFiltered, i, len,
        filterExpr = self.filterExpr,

        checkRow = function (data, row) {
          var isMatch = false,

            checkColumn = function (columnId) {
              var column = self.columnById(columnId)[0],
                fieldValue = self.fieldValue(data, column.field),
                value, cell = self.settings.columns.indexOf(column);

              // Use the formatted value (what the user sees in the cells) since it's a more reliable match
              value = self.formatValue(column.formatter, row, cell, fieldValue, column, data, self).toLowerCase();

              // Strip any html markup that might be in the formatted value
              value = value.replace(/(<([^>]+)>)|(&lt;([^>]+)&gt;)/ig, '');

              return value.indexOf(filterExpr.value) > -1;
            };

          // Check in all visible columns
          if (filterExpr.column === 'all') {
            self.headerRow.find('th:visible').each(function () {
              var th = $(this),
                columnId = th.attr('data-column-id');

              isMatch = checkColumn(columnId);
              if (isMatch) {
                return false;
              }
            });
          }
          // Check in only one column, given by columnId
          else if (filterExpr.columnId) {
            isMatch = checkColumn(filterExpr.columnId);
          }
          return isMatch;
        };

      // Make sure not more/less than one filter expr
      if (!filterExpr || filterExpr.length !== 1) {
        return;
      } else {
        filterExpr = filterExpr[0];
      }

      // Check in dataset
      if (self.settings.treeGrid) {
        dataset = self.settings.treeDepth;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i].node, i);
          dataset[i].node.isFiltered = isFiltered;
        }
      }
      else {
        dataset = self.settings.dataset;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i], i);
          dataset[i].isFiltered = isFiltered;
        }
      }
    },

    highlightSearchRows: function (term) {
      // Move across all visible cells and rows, highlighting
      this.tableBody.find('tr').each(function () {
        var found = false,
          row = $(this);

          row.find('td').each(function () {
            var cell =  $(this),
              cellText = cell.text().toLowerCase();

            if (cellText.indexOf(term) > -1) {
              found = true;
              cell.find('*').each(function () {
                if (this.innerHTML === this.textContent) {
                  var contents = this.textContent,
                    node = $(this),
                    exp = new RegExp('(' + term + ')', 'i');

                  node.addClass('search-mode').html(contents.replace(exp, '<i>$1</i>'));
                }
              });
            }

          });

          // Hide non matching rows
          if (!found) {
            row.addClass('is-filtered').hide();
          } else if (found && row.is('.datagrid-expandable-row')) {
            row.prev().show();
            row.prev().find('.datagrid-expand-btn').addClass('is-expanded');
            row.prev().find('.plus-minus').addClass('active');
            row.addClass('is-expanded').css('display', 'table-row');
            row.find('.datagrid-row-detail').css('height', 'auto');
          }

      });

    },

    selectAllRows: function () {
      var rows = [],
        s = this.settings,
        dataset = s.treeGrid ? s.treeDepth : s.dataset;

      for (var i = 0, l = dataset.length; i < l; i++) {
        if (this.filterRowRendered) {
          if (!dataset[i].isFiltered) {
            rows.push(i);
          }
        } else {
          rows.push(i);
        }
      }

      this.dontSyncUi = true;
      this.selectRows(rows, true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this.selectedRows(), 'selectall']);
    },

    unSelectAllRows: function () {
      var selectedRows = this.selectedRows();
      this.dontSyncUi = true;
      for (var i = 0, l = selectedRows.length; i < l; i++) {
        this.unselectRow(selectedRows[i].idx, true, true);
      }
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this.selectedRows(), 'deselectall']);
    },

    /**
    * Check if node index is exists in selected nodes
    * @private
    */
    isNodeSelected: function (node) {
      // As of 4.3.3, return the rows that have _selected = true
      return node._selected === true;
    },

    //Toggle selection on a single row
    selectRow: function (idx, nosync, noTrigger) {
      var rowNode, dataRowIndex,
        self = this,
        checkbox = null,
        s = this.settings;

      if (idx === undefined || idx === -1 || !s.selectable) {
        return;
      }

      rowNode = this.visualRowNode(idx);
      dataRowIndex = this.dataRowIndex(rowNode);

      if (isNaN(dataRowIndex)) {
        dataRowIndex = idx;
      }

      if (!rowNode) {
        return;
      }

      var selectedRows = this.selectedRows();
      if (s.selectable === 'single' && selectedRows.length > 0) {
        this.unselectRow(selectedRows[0].idx, true, true);
      }

      if (!rowNode.hasClass('is-selected')) {
        var rowData,
          // Select it
          selectNode = function(elem, index, data) {
            // do not add if already exists in selected
            if (self.isNodeSelected(data)) {
              return;
            }
            checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
            elem.addClass('is-selected' + (self.settings.selectable === 'mixed' ? ' hide-selected-color' : '')).attr('aria-selected', 'true')
              .find('td').attr('aria-selected', 'true');
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked').attr('aria-checked', 'true');

            data._selected = true;
          };

        if (s.treeGrid) {
          if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
            // Select node and node-children
            rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function() {
              var elem = $(this),
                index = elem.attr('aria-rowindex') -1,
                data = s.treeDepth[index].node;
              selectNode(elem, index, data);
            });
          }
          // Single element selection
          else {
            rowData = s.treeDepth[self.pager && s.source ? rowNode.index() : dataRowIndex].node;
            selectNode(rowNode, dataRowIndex, rowData);
          }
          self.setNodeStatus(rowNode);
        }
        else {
          dataRowIndex = self.pager && s.source ? rowNode.index() : dataRowIndex;
          rowData = s.dataset[dataRowIndex];
          if (s.groupable) {
            var gData = self.groupArray[dataRowIndex];
            rowData = s.dataset[gData.group].values[gData.node];
          }
          selectNode(rowNode, dataRowIndex, rowData);
          self.lastSelectedRow = idx;// Rememeber index to use shift key
        }
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        this.element.triggerHandler('selected', [this.selectedRows(), 'select']);
      }
    },

    dontSyncUi: false,

    // Select rows between indexes
    selectRowsBetweenIndexes: function(indexes) {
      indexes.sort(function(a, b) { return a-b; });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        this.selectRow(i);
      }
    },

    syncHeaderCheckbox: function (rows) {
      var headerCheckbox = this.headerRow.find('.datagrid-checkbox'),
        selectedRows = this.selectedRows(),
        status = headerCheckbox.data('selected');

      // Do not run if checkbox in same state
      if ((selectedRows.length > 0 && status === 'partial') ||
        (selectedRows.length === rows.length && status === 'all') ||
        (selectedRows.length === 0 && status === 'none')) {
        return;
      }

      //Sync the header checkbox
      if (selectedRows.length > 0) {
        headerCheckbox.data('selected', 'partial')
          .addClass('is-checked is-partial');
      }

      if (selectedRows.length === rows.length) {
        headerCheckbox.data('selected', 'all')
          .addClass('is-checked').removeClass('is-partial');
      }

      if (selectedRows.length === 0) {
        headerCheckbox.data('selected', 'none')
          .removeClass('is-checked is-partial');
      }
    },

    //Set ui elements based on selected rows
    syncSelectedUI: function () {
      var s = this.settings,
        dataset = s.treeGrid ? s.treeDepth : s.dataset,
        rows = dataset;

      if (this.filterRowRendered) {
        rows = [];
        for (var i = 0, l = dataset.length; i < l; i++) {
          if (!dataset[i].isFiltered) {
            rows.push(i);
          }
        }
      }

      this.syncHeaderCheckbox(rows);

      //Open or Close the Contextual Toolbar.
      if (this.contextualToolbar.length !== 1 || this.dontSyncUi) {
        return;
      }

      var selectedRows = this.selectedRows();

      if (selectedRows.length === 0) {
        this.contextualToolbar.animateClosed();
      }

      if (selectedRows.length > 0 && this.contextualToolbar.height() === 0) {
        this.contextualToolbar.css('display', 'block').one('animateopencomplete.datagrid', function() {
          $(this).triggerHandler('recalculate-buttons');
        }).animateOpen();
      }

    },

    // activate a row when in mixed selection mode
    activateRow: function(idx) {
      if (this.activatedRow()[0].row !== idx) {
        this.toggleRowActivation(idx);
      }
    },

    // deactivate the currently activated row
    deactivateRow: function() {
      var idx = this.activatedRow()[0].row;
      if (idx >= 0) {
        this.toggleRowActivation(idx);
      }
    },

    // Gets the currently activated row
    activatedRow: function() {
      if (!this.tableBody) {
        return [{ row: -1, item: undefined, elem: undefined }];
      }

      var activatedRow = this.tableBody.find('tr.is-rowactivated');

      if (activatedRow.length) {
        var rowIndex = this.dataRowIndex(activatedRow);

        if (this.settings.indeterminate) {
          rowIndex = this.actualArrayIndex(activatedRow);
        }

        return [{ row: rowIndex, item: this.settings.dataset[rowIndex], elem: activatedRow }];
      } else {
        //Activated row may be filtered or on another page, so check all until find it
        for (var i = 0; i < this.settings.dataset.length; i++) {
          if (this.settings.dataset[i]._rowactivated) {
            return [{ row: i, item: this.settings.dataset[i], elem: undefined }];
          }
        }

        return [{ row: -1, item: undefined, elem: activatedRow }];
      }
    },

    toggleRowActivation: function (idx) {
      var row = (typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]') : idx),
        rowIndex = (typeof idx === 'number' ? idx : ((this.pager && this.settings.source) ? this.actualArrayIndex(row) : this.dataRowIndex(row))),
        item = this.settings.dataset[rowIndex],
        isActivated = item ? item._rowactivated : false;

      if (typeof idx === 'number' && this.pager && this.settings.source && this.settings.indeterminate) {
        var rowIdx = idx + ((this.pager.activePage -1) * this.settings.pagesize);
        row = this.tableBody.find('tr[aria-rowindex="'+ (rowIdx + 1) +'"]');
        rowIndex = idx;
      }

      if (isActivated) {
        if (!this.settings.disableRowDeactivation) {
          row.removeClass('is-rowactivated');
          delete this.settings.dataset[rowIndex]._rowactivated;
          this.element.triggerHandler('rowdeactivated', [{row: rowIndex, item: this.settings.dataset[rowIndex]}]);
        }
      } else {
        //Deselect old row
        var oldActivated = this.tableBody.find('tr.is-rowactivated');
        if (oldActivated.length) {
          oldActivated.removeClass('is-rowactivated');

          var oldIdx = this.dataRowIndex(oldActivated);
          if (this.settings.dataset[oldIdx]) { // May have changed page
            delete this.settings.dataset[oldIdx]._rowactivated;
          }
          this.element.triggerHandler('rowdeactivated', [{row: oldIdx, item: this.settings.dataset[oldIdx]}]);
        } else {
          // Old active row may be filtered or on another page, so check all until find it
          for (var i = 0; i < this.settings.dataset.length; i++) {
            if (this.settings.dataset[i]._rowactivated) {
              delete this.settings.dataset[i]._rowactivated;
              this.element.triggerHandler('rowdeactivated', [{row: i, item: this.settings.dataset[i]}]);
              break;
            }
          }
        }

        //Activate new row
        row.addClass('is-rowactivated');
        if (this.settings.dataset[rowIndex]) { // May have changed page
          this.settings.dataset[rowIndex]._rowactivated = true;
          this.element.triggerHandler('rowactivated', [{row: rowIndex, item: this.settings.dataset[rowIndex]}]);
        }
      }

    },

    toggleRowSelection: function (idx) {
      var row = (typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]') : idx),
        isSingle = this.settings.selectable === 'single',
        rowIndex = (typeof idx === 'number' ? idx :
        (this.settings.treeGrid || this.settings.groupable) ?
        this.dataRowIndex(row) : this.actualArrayIndex(row));

      if (this.settings.selectable === false) {
        return;
      }

      if (this.editor && row.hasClass('is-selected')) {
        return;
      }

      if (isSingle && row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
        this.displayCounts();
        return this.selectedRows();
      }

      if (row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
      } else {
        this.selectRow(rowIndex);
      }

      this.displayCounts();

      return this.selectedRows();
    },

    unselectRow: function (idx, nosync, noTrigger) {
      var self = this,
        s = self.settings,
        rowNode = self.visualRowNode(idx),
        checkbox = null;

      if (!rowNode || idx === undefined) {
        return;
      }

      // Unselect it
      var unselectNode = function(elem, index) {
        var removeSelected = function (node) {
          delete node._selected;
          self.selectedRowCount--;
        };
        checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
        elem.removeClass('is-selected hide-selected-color').removeAttr('aria-selected')
          .find('td').removeAttr('aria-selected');
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
          .removeClass('is-checked no-animate').attr('aria-checked', 'false');

        if (s.treeGrid) {
          for (var i = 0; i < s.treeDepth.length; i++) {
            if (self.isNodeSelected(s.treeDepth[i].node)) {
              if (typeof index !== 'undefined') {
                if (index === s.treeDepth[i].idx -1) {
                  removeSelected(s.treeDepth[i].node);
                }
              } else {
                removeSelected(s.treeDepth[i].node);
              }
            }
          }
        } else {
          var selIdx = elem.length ? self.actualArrayIndex(elem) : index,
            rowData;

          if (selIdx !== undefined && selIdx > -1) {
            rowData = self.settings.dataset[selIdx];
          }
          if (s.groupable) {
            var gData = self.groupArray[idx];
            rowData = s.dataset[gData.group].values[gData.node];
          }
          if (rowData !== undefined) {
            removeSelected(rowData);
          }
        }
      };

      if (s.treeGrid) {
        if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
          // Select node and node-children
          rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function() {
            var elem = $(this),
              index = elem.attr('aria-rowindex') -1;
            unselectNode(elem, index);
          });
        }
        // Single element unselection
        else {
          unselectNode(rowNode, idx);
        }
        self.setNodeStatus(rowNode);
      }
      else {
        unselectNode(rowNode, idx);
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        self.element.triggerHandler('selected', [self.selectedRows(), 'deselect']);
      }
    },

    setNodeStatus: function(node) {
      var self = this,
        isMultiselect = self.settings.selectable === 'multiple',
        checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox')),
        nodes;

      // Not multiselect
      if (!isMultiselect) {
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
          .removeClass('is-checked is-partial').attr('aria-checked', 'false');

        if (node.is('.is-selected')) {
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
            .addClass('is-checked').attr('aria-checked', 'true');
        }
        return;
      }

      var setStatus = function (nodes, isFirstSkipped) {
        nodes.each(function() {
          var node = $(this),
            checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox')),
            status = self.getSelectedStatus(node, isFirstSkipped);

          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
            .removeClass('is-checked is-partial').attr('aria-checked', 'false');

          if (status === 'mixed') {
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked is-partial').attr('aria-checked', 'mixed');
          }
          else if (status) {
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked').attr('aria-checked', 'true');
          }
        });
      };

      // Multiselect
      nodes = node.add(node.nextUntil('[aria-level="1"]')).filter('.datagrid-tree-parent');
      setStatus(nodes);

      nodes = node;
      if (+node.attr('aria-level') > 1) {
        nodes = nodes.add(node.prevUntil('[aria-level="1"]'))
        .add(node.prevAll('[aria-level="1"]:first'));
      }
      nodes = nodes.filter('.datagrid-tree-parent');
      setStatus(nodes);
    },

    getSelectedStatus: function(node) {
      var status,
        total = 0,
        selected = 0,
        unselected = 0;

      node.add(node.nextUntil('[aria-level="1"]')).each(function() {
        total++;
        if ($(this).is('.is-selected')) {
          selected++;
        } else {
          unselected++;
        }
      });

      status = ((total === selected) ? true : ((total === unselected) ? false : 'mixed'));
      return status;
    },

    //Set the selected rows by passing the row index or an array of row indexes
    selectedRows: function () {
      var self = this,
        s = self.settings,
        dataset = s.treeGrid ? s.treeDepth : s.dataset,
        selectedRows = [],
        idx = -1;

      for (var i = 0, data; i < dataset.length; i++) {

        if (s.groupable) {
          for (var k = 0; k < dataset[i].values.length; k++) {
            idx++;
            data = dataset[i].values[k];
            if (self.isNodeSelected(data)) {
              selectedRows.push({
                idx: idx,
                data: data,
                elem: self.dataRowNode(idx),
                group: dataset[i]
              });
            }
          }
        }
        else {
          data = s.treeGrid ? dataset[i].node : dataset[i];
          if (self.isNodeSelected(data)) {
            selectedRows.push({idx: i, data: data, elem: self.visualRowNode(i)});
          }
        }

      }
      return selectedRows;
    },

    //Set the selected rows by passing the row index or an array of row indexes
    selectRows: function (row, nosync, selectAll) {
      var idx = -1,
          s = this.settings,
          isSingle = s.selectable === 'single',
          isMultiple = s.selectable === 'multiple' || s.selectable === 'mixed',
          dataset = s.treeGrid ? s.treeDepth : s.dataset,
          gIdx = idx;

      // As of 4.3.3, return the rows that have _selected = true
      var selectedRows = this.selectedRows();

      if (!row || row.length === 0) {
        return selectedRows;
      }

      if (isSingle) {
        //Unselect
        if (selectedRows.length) {
          this.unselectRow(selectedRows[0].idx, true, true);
        }

        //Select - may be passed array or int
        idx = ((Object.prototype.toString.call(row) === '[object Array]' ) ? row[0] : row.index());
        this.selectRow(idx, true, true);
      }

      if (isMultiple) {
        if (Object.prototype.toString.call(row) === '[object Array]' ) {
          for (var i = 0; i < row.length; i++) {
            if (s.groupable) {
              for (var k = 0; k < dataset[i].values.length; k++) {
                gIdx++;
                this.selectRow(gIdx, true, true);
              }
            }
            else {
              this.selectRow(row[i], true, true);
            }
          }

          if (row.length === 0) {
            for (var j=0, l=dataset.length; j < l; j++) {
              this.unselectRow(j, true, true);
            }
          }

        } else {
          this.selectRow(row.index(), true, true);
        }
      }

      selectedRows = this.selectedRows();
      this.displayCounts();

      if (!nosync) {
        this.syncSelectedUI();
      }
      if (!selectAll) {
        this.element.triggerHandler('selected', [selectedRows, 'select']);
      }

      return selectedRows;
    },

    //Set the row status
    rowStatus: function(idx, status, tooltip) {
      var rowStatus;

      if (!status) {
        delete this.settings.dataset[idx].rowStatus;
        this.updateRow(idx);
        return;
      }

      if (!this.settings.dataset[idx]) {
        return;
      }

      this.settings.dataset[idx].rowStatus = {};
      rowStatus = this.settings.dataset[idx].rowStatus;

      rowStatus.icon = status;
      status = status.charAt(0).toUpperCase() + status.slice(1);
      status = status.replace('-progress', 'Progress');
      rowStatus.text = Locale.translate(status);

      tooltip = tooltip ? tooltip.charAt(0).toUpperCase() + tooltip.slice(1) : rowStatus.text;
      rowStatus.tooltip = tooltip;

      this.updateRow(idx);
    },

    //Get the column object by id
    columnById: function(id) {
      return $.grep(this.settings.columns, function(e) { return e.id === id; });
    },

    //Get the column index from the col's id
    columnIdxById: function(id) {
      var cols = this.settings.columns,
        idx = -1;

      for (var i = 0; i < cols.length; i++) {
       if (cols[i].id === id) {
        idx = i;
       }
      }
      return idx;
    },

    // Current Active Cell
    activeCell: {node: null, cell: null, row: null},

    // Handle all keyboard behavior
    handleKeys: function () {
      var self = this,
        isMultiple = self.settings.selectable === 'multiple',
        checkbox = $('th .datagrid-checkbox', self.headerRow);

      // Handle header navigation
      self.headerTable.on('keydown.datagrid', 'th', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          th = $(this),
          index = th.siblings(':visible').addBack().index(th),
          last = self.visibleColumns().length -1,
          triggerEl, move;

        if ($(e.target).closest('.popupmenu').length > 0) {
          return;
        }

        // Enter or Space
        if (key === 13 || key === 32) {
          triggerEl = (isMultiple && index === 0) ? $('.datagrid-checkbox', th) : th;
          triggerEl.trigger('click.datagrid').focus();

          if (key === 32) { // Prevent scrolling with space
            e.preventDefault();
          }
        }

        //Press Home, End, Left and Right arrow to move to first, last, previous or next
        if ([35, 36, 37, 39].indexOf(key) !== -1) {
          move = index;

          //Home, End or Ctrl/Meta + Left/Right arrow to move to the first or last
          if (/35|36/i.test(key) || ((e.ctrlKey || e.metaKey) && /37|39/i.test(key))) {
            if (Locale.isRTL()) {
              move = (key === 36 || ((e.ctrlKey || e.metaKey) && key === 37)) ? last : 0;
            } else {
              move = (key === 35 || ((e.ctrlKey || e.metaKey) && key === 39)) ? last : 0;
            }
          }

          // Left and Right arrow
          else {
            if (Locale.isRTL()) {
              move = key === 39 ? (index > 0 ? index-1 : index) : (index < last ? index+1 : last);
            } else {
              move = key === 37 ? (index > 0 ? index-1 : index) : (index < last ? index+1 : last);
            }
          }
          // Update active cell
          self.activeCell.cell = move;

          // Making move
          th.removeAttr('tabindex').removeClass('is-active');
          $('th:not(.is-hidden)', this.header).eq(move).attr('tabindex', '0').addClass('is-active').focus();
          e.preventDefault();
        }

        // Down arrow
        if (key === 40) {
          th.removeAttr('tabindex');
          self.activeCell.node = self.cellNode(0, self.settings.groupable ? 0 : self.activeCell.cell, true).attr('tabindex', '0').focus();
          e.preventDefault();
        }

      });

      //Handle Editing / Keyboard
      self.table.on('keydown.datagrid', 'td, input', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          handled = false;

        // F2 - toggles actionableMode "true" and "false"
        if (key === 113) {
          self.settings.actionableMode = self.settings.actionableMode ? false : true;
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });

      //Press PageUp or PageDown to open the previous or next page and set focus to the first row.
      //Press Alt+Up or Alt+Down to set focus to the first or last row on the current page.
      //Press Alt+PageUp or Alt+PageDown to open the first or last page and set focus to the first row.

      //Handle rest of the keyboard
      self.table.on('keydown.datagrid', 'td', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          handled = false,
          isRTL = Locale.isRTL(),
          node = self.activeCell.node,
          rowNode = $(this).parent(),
          prevRow = rowNode.prevAll(':not(.is-hidden, .datagrid-expandable-row)').first(),
          nextRow = rowNode.nextAll(':not(.is-hidden, .datagrid-expandable-row)').first(),
          row = self.activeCell.row,
          cell = self.activeCell.cell,
          col = self.columnSettings(cell),
          isGroupRow = rowNode.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer'),
          item = self.settings.dataset[self.dataRowIndex(node)],
          visibleRows = self.tableBody.find('tr:visible'),
          getVisibleRows = function(index) {
            var row = visibleRows.filter('[aria-rowindex="'+ (index + 1) +'"]');
            if (row.is('.datagrid-rowgroup-header')) {
              return row.index();
            }
            return self.dataRowIndex(row);
          },
          getGroupCell = function(currentCell, lastCell, prev) {
            var n = self.activeCell.groupNode || node;
            var nextCell = currentCell + (prev ? -1 : +1);

            if (nextCell > lastCell) {
              nextCell = prev ?
                n.prevAll(':visible').last() : n.nextAll(':visible').last();
            } else {
              nextCell = prev ?
                n.prevAll(':visible').first() : n.nextAll(':visible').first();
            }
            return nextCell;
          },
          getNextVisibleCell = function(currentCell, lastCell, prev) {
            if (isGroupRow) {
              return getGroupCell(currentCell, lastCell, prev);
            }
            var nextCell = currentCell + (prev ? -1 : +1);
            if (nextCell > lastCell) {
             return lastCell;
            }
            while (self.settings.columns[nextCell] && self.settings.columns[nextCell].hidden) {
              nextCell = prev ? nextCell-1 : nextCell+1;
            }
            return nextCell;
          },
          isSelectionCheckbox = !!($('.datagrid-selection-checkbox', node).length),
          lastRow, lastCell;

        lastCell = self.settings.columns.length-1;
        lastRow = visibleRows.last();

        //Tab, Left and Right arrow keys.
        if ([9, 37, 39].indexOf(key) !== -1) {
          if (key === 9 && !self.settings.actionableMode) {
            return;
          }

          if (key !== 9 && e.altKey) {
            //[Alt + Left/Right arrow] to move to the first or last cell on the current row.
            cell = ((key === 37 && !isRTL) || (key === 39 && isRTL)) ? 0 : lastCell;
            self.setActiveCell(row, cell);
          }
          //Tab, Shift-tab, Left and Right arrow keys to navigate by cell.
          else if (!self.quickEditMode || (key === 9)) {
            if ((!isRTL && (key === 37 || key === 9 && e.shiftKey)) ||
                (isRTL && (key === 39 || key === 9))) {
              cell = getNextVisibleCell(cell, lastCell, true);
            } else {
              cell = getNextVisibleCell(cell, lastCell);
            }
            if (cell instanceof jQuery) {
              self.setActiveCell(cell);
            } else {
              self.setActiveCell(row, cell);
            }
            self.quickEditMode = false;
            handled = true;
          }
        }

        //Up arrow key
        if (key === 38 && !self.quickEditMode) {
          //Press [Control + Up] arrow to move to the first row on the first page.
          if (e.altKey || e.metaKey) {
            self.setActiveCell(getVisibleRows(0), cell);
            handled = true;
          } else { //Up arrow key to navigate by row.

            if (row === 0 && !prevRow.is('.datagrid-rowgroup-header')) {
              node.removeAttr('tabindex');
              self.headerRow.find('th').eq(cell).attr('tabindex', '0').focus();
              return;
            }
            self.setActiveCell(prevRow, cell);
            handled = true;
          }
        }

        //Down arrow key
        if (key === 40 && !self.quickEditMode) {
          //Press [Control + Down] arrow to move to the last row on the last page.
          if (e.altKey|| e.metaKey) {
            self.setActiveCell(lastRow, cell);
            handled = true;
          } else { //Down arrow key to navigate by row.
            self.setActiveCell(nextRow, cell);
            handled = true;
          }
        }

        //Press Control+Spacebar to announce the current row when using a screen reader.
        if (key === 32 && e.ctrlKey && node) {
          var string = '';
          row = node.closest('tr');

          row.children().each(function () {
            var cell = $(this);
            //Read Header
            //string += $('#' + cell.attr('aria-describedby')).text() + ' ' + cell.text() + ' ';
            string += cell.text() + ' ';
          });

          $('body').toast({title: '', audibleOnly: true, message: string});
          handled = true;
        }

        //Press Home or End to move to the first or last cell on the current row.
        if (key === 36) {
          self.setActiveCell(row, 0);
          handled = true;
        }

        //Home to Move to the end of the current row
        if (key === 35) {
          self.setActiveCell(row, lastCell);
          handled = true;
        }

        //End to Move to last row of current cell
        if (key === 34) {
          self.setActiveCell(lastRow, cell);
          handled = true;
        }

        //End to Move to first row of current cell
        if (key === 33) {
          self.setActiveCell(getVisibleRows(0), cell);
          handled = true;
        }

        // For mode 'Selectable':
        // Press Space to toggle row selection, or click to activate using a mouse.
        if (key === 32 && (!self.settings.editable || isSelectionCheckbox)) {
          row = node.closest('tr');

          if ($(e.target).closest('.datagrid-row-detail').length === 1) {
            return;
          }
          e.preventDefault();

          // Toggle datagrid-expand with Space press
          var btn = $(e.target).find('.datagrid-expand-btn, .datagrid-drilldown');
          if (btn && btn.length) {
            btn.trigger('click.datagrid');
            e.preventDefault();
            return;
          }

          if (isMultiple && e.shiftKey) {
            self.selectRowsBetweenIndexes([self.lastSelectedRow, row.index()]);
          } else {
            self.toggleRowSelection(row);
          }

        }

        // For Editable mode - press Enter or Space to edit or toggle a cell, or click to activate using a mouse.
        if (self.settings.editable && key === 32) {
          if (!self.editor) {
            self.makeCellEditable(row, cell, e);
          }
        }

        // if column have click function to fire [ie. action button]
        if (key === 13 && col.click && typeof col.click === 'function') {
          if (!node.hasClass('is-cell-readonly')) {
            col.click(e, [{row: row, cell: cell, item: item, originalEvent: e}]);
          }
        }

        if (self.settings.editable && key === 13) {
          //Allow shift to add a new line
          if ($(e.target).is('textarea') && e.shiftKey) {
            return;
          }

          if (self.editor) {
            self.quickEditMode = false;
            self.commitCellEdit(self.editor.input);
            self.setNextActiveCell(e);
          }
          else {
            self.makeCellEditable(row, cell, e);
            if (self.isContainTextfield(node) && self.notContainTextfield(node)) {
              self.quickEditMode = true;
            }
          }
          handled = true;
        }

        //Any printable character - well make it editable
        if ([9, 13, 32, 35, 36, 37, 38, 39, 40, 113].indexOf(key) === -1 &&
          !e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey && self.settings.editable) {
          if (!self.editor) {
            self.makeCellEditable(row, cell, e);
          }
        }

        // If multiSelect is enabled, press Control+A to toggle select all rows
        if (isMultiple && !self.editor && ((e.ctrlKey || e.metaKey) && key === 65)) {
          checkbox
            .addClass('is-checked')
            .removeClass('is-partial')
            .attr('aria-checked', 'true');
          self.selectAllRows();
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

      });
    },

    isContainTextfield: function(container) {
      var noTextTypes = ['image', 'button', 'submit', 'reset', 'checkbox', 'radio'],
        selector = 'textarea, input',
        l = noTextTypes.length, i;

      selector += l ? ':not(' : '';
      for(i = 0; i < l; i++) {
        selector += '[type='+ noTextTypes[i] +'],';
      }
      selector = l ? (selector.slice(0, -1) + ')') : '';

      return !!($(selector, container).length);
    },

    notContainTextfield: function(container) {
      var selector = '.dropdown, .datepicker';
      return !($(selector, container).length);
    },

    //Current Cell Editor thats in Use
    editor: null,

    isCellEditable: function(row, cell) {

      if (!this.settings.editable) {
        return false;
      }

      var col = this.columnSettings(cell);
      if (col.readonly) {
        return false;
      }

      //Check if cell is editable via hook function
      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper'),
        cellValue = (cellNode.text() ? cellNode.text() : this.fieldValue(this.settings.dataset[row], col.field));

      if (col.isEditable) {
        var canEdit = col.isEditable(row, cell, cellValue, col, this.settings.dataset[row]);

        if (!canEdit) {
          return false;
        }
      }

      if (!col.editor) {
        return false;
      }

      return true;
    },

    // Invoked in three cases: 1) a row click, 2) keyboard and enter, 3) In actionable mode and tabbing
    makeCellEditable: function(row, cell, event) {
      if (this.activeCell.node.closest('tr').hasClass('datagrid-summary-row')) {
        return;
      }

      if (this.editor && this.editor.input) {
        if (this.editor.input.is('.timepicker, .datepicker, .lookup, .spinbox, #colorpicker-menu') && !$(event.target).prev().is(this.editor.input)) {
          this.commitCellEdit(this.editor.input);
        }
      }

      //Locate the Editor
      var col = this.columnSettings(cell);

      //Select the Rows if the cell is editable
      if (!col.editor) {
        if (event.keyCode === 32 && !$(event.currentTarget).find('.datagrid-selection-checkbox').length) {
          this.toggleRowSelection(this.activeCell.node.closest('tr'));
        }
        return false;
      }

      var dataRowIndex = this.dataRowIndex(this.dataRowNode(row)),
        rowData = this.settings.treeGrid ?
          this.settings.treeDepth[dataRowIndex].node :
          this.settings.dataset[dataRowIndex],
        cellNode = this.activeCell.node.find('.datagrid-cell-wrapper'),
        cellParent = cellNode.parent('td'),
        cellWidth = cellParent.outerWidth(),
        isEditor = $('.is-editor', cellParent).length > 0,
        cellValue = (cellNode.text() ?
          cellNode.text() : this.fieldValue(rowData, col.field));

      if (isEditor) {
        cellValue = this.fieldValue(rowData, col.field);
      }

      if (!this.isCellEditable(dataRowIndex, cell)) {
        return false;
      }

      if (cellParent.hasClass('is-editing') || cellParent.hasClass('is-editing-inline')) {
        //Already in edit mode
        cellNode.find('input').focus();
        return false;
      }

      // In Show Ediitor mode the editor is on form already
      if (!col.inlineEditor) {

        if (isEditor) {
          cellNode.css({'position': 'static', 'height': cellNode.outerHeight()});
        }
        // initialis Editor
        cellParent
          .addClass('is-editing')
          .css({'max-width': cellWidth, 'min-width': cellWidth, 'width': cellWidth});

        cellNode.empty();
      } else {
        cellParent.addClass('is-editing-inline');
      }

      this.editor = new col.editor(dataRowIndex, cell, cellValue, cellNode, col, event, this, rowData);

      if (this.settings.onEditCell) {
        this.settings.onEditCell(this.editor);
      }

      if (this.editor.useValue) {
        cellValue = this.fieldValue(rowData, col.field);
      }
      this.editor.val(cellValue);
      this.editor.focus();
      this.element.triggerHandler('entereditmode', [{row: dataRowIndex, cell: cell, item: rowData, target: cellNode, value: cellValue, column: col, editor: this.editor}]);

      return true;
    },

    commitCellEdit: function(input) {
      var newValue, cellNode,
        isEditor = input.is('.editor'),
        isUseActiveRow = !(input.is('.timepicker, .datepicker, .lookup, .spinbox .colorpicker'));

      if (!this.editor) {
        return;
      }

      //Editor.getValue
      newValue = this.editor.val();

      if (isEditor) {
        cellNode = this.editor.td;
      } else {
        cellNode = input.closest('td');
        newValue = $.escapeHTML(newValue);
      }

      //Format Cell again
      var isInline = cellNode.hasClass('is-editing-inline');
      cellNode.removeClass('is-editing is-editing-inline');

      //Editor.destroy
      this.editor.destroy();
      this.editor = null;

      var rowIndex;
      if (this.settings.source !== null && isUseActiveRow) {
        rowIndex = this.activeCell.row;
      } else {
        rowIndex = this.dataRowIndex(cellNode.parent());
      }

      var cell = cellNode.index();
      var col = this.columnSettings(cell);
      var rowData = this.settings.treeGrid ? this.settings.treeDepth[rowIndex].node : this.settings.dataset[rowIndex];
      var oldValue = this.fieldValue(rowData, col.field);

      //Save the Cell Edit back to the data set
      this.updateCellNode(rowIndex, cell, newValue, false, isInline);
      var value = this.fieldValue(rowData, col.field);
      this.element.triggerHandler('exiteditmode', [{row: rowIndex, cell: cell, item: rowData, target: cellNode, value: value, oldValue: oldValue, column: col, editor: this.editor}]);
    },

    //Validate a particular cell if it has validation on the column and its visible
    validateCell: function (row, cell) {
      var self = this,
        column = this.columnSettings(cell),
        validate = column.validate,
        validationType;

      if (!validate) {
        return;
      }

      var rules = column.validate.split(' '),
        validator = $.fn.validation,
        cellValue = this.fieldValue(this.settings.dataset[row], column.field),
        isValid = true,
        messages = [],
        messageText = '', i;

      for (i = 0; i < rules.length; i++) {
        var rule = validator.rules[rules[i]],
          gridInfo = {row: row, cell: cell, item: this.settings.dataset[row], column: column, grid: self},
          ruleValid = rule.check(cellValue, $('<input>').val(cellValue), gridInfo);

        validationType = $.fn.validation.ValidationTypes[rule.type] || $.fn.validation.ValidationTypes.error;
        messageText = '';
        if (messages[validationType.type]) {
          messageText = messages[validationType.type];
        }

        if (!ruleValid) {
          if (messageText) {
            messageText = ((/^\u2022/.test(messageText)) ? '' : '\u2022 ') + messageText;
            messageText += '<br>' + '\u2022 ' + rule.message;
          } else {
            messageText = rule.message;
          }

          messages[validationType.type] = messageText;

          isValid = false;
        }
      }

      for (var props in $.fn.validation.ValidationTypes) {
        messageText = '';
        validationType = $.fn.validation.ValidationTypes[props];
        if (messages[validationType.type]) {
          messageText = messages[validationType.type];
        }
        if (messageText !== '') {
          self.showCellError(row, cell, messageText, validationType.type);
          self.element.trigger('cell' + validationType.type, {row: row, cell: cell, message: messageText, target: this.cellNode(row, cell), value: cellValue, column: column});
        } else {
          self.clearCellError(row, cell, validationType.type);
        }
      }
    },

    showCellError: function (row, cell, message, type) {
      var node = this.cellNode(row, cell);

      // clear the table nonVisibleCellErrors for the row and cell
      this.clearNonVisibleCellErrors(row, cell, type);

      if (!node.length) {
        // Store the nonVisibleCellError
        this.nonVisibleCellErrors.push({ row: row, cell: cell, message: message, type: type });
        this.showNonVisibleCellErrors();
        return;
      }

      //Add icon and classes
      node.addClass(type).attr('data-' + type + 'message', message);
      var icon = $($.createIcon({ classes: ['icon-' + type], icon: type }));

      //Add and show tooltip
      if (node.find('.icon-' + type).length === 0) {
        node.find('.datagrid-cell-wrapper').append(icon);
        icon.tooltip({placement: 'bottom', isErrorColor: (type === 'error'), content: message});
        icon.data('tooltip').show();
      }

    },

    showNonVisibleCellErrors: function () {

      // Create empty toolbar
      if (!this.toolbar) {
        settings.toolbar = { title: ' ' };
        this.appendToolbar();
      }
      // process via type
      for (var props in $.fn.validation.ValidationTypes) {
        var validationType = $.fn.validation.ValidationTypes[props].type;
        this.showNonVisibleCellErrorType($.grep(this.nonVisibleCellErrors, function (error) { return error.type === validationType; }), validationType);
      }
    },

    showNonVisibleCellErrorType: function (nonVisibleCellErrors, type) {
      var messages, tableerrors, icon, i,
        nonVisiblePages = [],
        validationType = $.fn.validation.ValidationTypes[type] || $.fn.validation.ValidationTypes.error;

      if (this.toolbar.parent().find('.table-errors').length === 1) {
        tableerrors  = this.toolbar.parent().find('.table-errors');
      }

      if (nonVisibleCellErrors.length === 0) {
        // clear the displayed message
        if (tableerrors  && tableerrors.length) {
          icon = tableerrors .find('.icon-' + validationType.type);
          var tooltip = icon.data('tooltip');
          if (tooltip) {
            tooltip.hide();
          }
          tableerrors.find('.icon-' + validationType.type).remove();
        }
        return;
      }

      // Process message type, so it displays one message per page
      for (i = 0; i < nonVisibleCellErrors.length; i++) {
        var page =  Math.floor((nonVisibleCellErrors[i].row + this.settings.pagesize) / this.settings.pagesize);
        if($.inArray(page, nonVisiblePages) === -1) {
          nonVisiblePages.push(page);
        }
      }

      for (i = 0; i < nonVisiblePages.length; i++) {
        messages = (messages ? messages + '<br>' : '') + Locale.translate(validationType.pagingMessageID) + ' ' + nonVisiblePages[i];
      }

      if (this.toolbar.parent().find('.table-errors').length === 0) {
        tableerrors  = $('<div class="table-errors"></div>');
      }
      icon = tableerrors .find('.icon-' + type);
      if (!icon.length) {
        icon = $($.createIcon({ classes: ['icon-' + type], icon: type }));
        tableerrors .append(icon);
      }


      if (this.element.hasClass('has-toolbar')) {
        //Add Error to the Toolbar
        this.toolbar.children('.title').append(tableerrors);
      }

      icon.tooltip({placement: 'bottom', isErrorColor: (type === 'error'), content: messages});
    },

    clearCellError: function (row, cell, type) {
      this.clearNonVisibleCellErrors(row, cell, type);
      var node = this.cellNode(row, cell);

      if (!node.length) {
        return;
      }

      this.clearNodeErrors(node, type);
    },

    clearNonVisibleCellErrors: function (row, cell, type) {

      if (!this.nonVisibleCellErrors.length) {
        return;
      }

      this.nonVisibleCellErrors = $.grep(this.nonVisibleCellErrors, function (error) {
        if (!(error.row === row && error.cell === cell && error.type === type)) {
          return error;
        }
      });

      if (!this.nonVisibleCellErrors.length) {
        this.showNonVisibleCellErrors();
      }
    },

    clearRowError: function (row) {
      var rowNode = this.dataRowNode(row);

      rowNode.removeClass('error alert');
      this.rowStatus(row, '', '');
    },

    clearAllErrors: function () {
      var self = this;

      this.tableBody.find('td.error').each(function () {
        var node = $(this);
        self.clearNodeErrors(node, 'error');
      });

      this.tableBody.find('td.alert').each(function () {
        var node = $(this);
        self.clearNodeErrors(node, 'alert');
      });

      this.tableBody.find('td.info').each(function () {
        var node = $(this);
        self.clearNodeErrors(node, 'info');
      });
    },

    clearNodeErrors: function (node, type) {
      node.removeClass(type).removeAttr('data-' + type + 'message');

      var icon = node.find('.icon-' + type),
        tooltip = icon.data('tooltip');

      if (tooltip) {
        tooltip.hide();
      }
      node.find('.icon-' + type).remove();
    },

    resetRowStatus: function () {
      for (var i = 0; i < this.settings.dataset.length; i++) {
        this.rowStatus(i, '');
      }
    },

    dirtyRows: function () {
      var rows = [],
        data = this.settings.dataset;

      for (var i = 0; i < data.length; i++) {
        if (data[i].rowStatus && data[i].rowStatus.icon === 'dirty') {
          rows.push(data[i]);
        }
      }
      return rows;
    },

    //Validate all visible cells in a row if they have validation on the column
    //Row Id, Error Text and 'error' or 'alert' (default alert)
    showRowError: function (row, message, type) {
      var messageType = type || 'error',
        rowNode = this.dataRowNode(row);

      rowNode.addClass(type);
      this.rowStatus(row, messageType, message);
    },

    //Validate all visible cells in a row if they have validation on the column
    //Row Id, Error Text and 'error' or 'alert' (default alert)
    validateRow: function (row) {
      for (var i = 0; i < this.settings.columns.length; i++) {
        this.validateCell(row, i);
      }
    },

    //Validate all rows and cells with validation on them
    validateAll: function () {
      for (var j = 0; j < this.settings.dataset.length; j++) {
        for (var i = 0; i < this.settings.columns.length; i++) {
          this.validateCell(j, i);
        }
      }
    },

    columnSettings: function (cell, onlyVisible) {
      var column = settings.columns[cell];

      if (onlyVisible) {
        column = this.visibleColumns()[cell];
      }

      return column || {};
    },

    //Attempt to serialize the value back into the dataset
    coerceValue: function (value, oldVal, col, row, cell) {
      var newVal;

      if (col.serialize) {
        newVal = col.serialize(value, oldVal, col, row, cell, this.settings.dataset[row]);
        return newVal;
      } else if (typeof oldVal === 'number' && value) {
        newVal = Locale.parseNumber(value); //remove thousands sep , keep a number a number
      }

      return newVal;
    },

    updateCell: function(row, cell, value) {
      var col = this.columnSettings(cell);

      if (value === undefined) {
        value = this.fieldValue(this.settings.dataset[row], col.field);
      }

      this.updateCellNode(row, cell, value, true);
    },

    updateCellNode: function (row, cell, value, fromApiCall, isInline) {
      var coercedVal, escapedVal,
        rowNode = this.visualRowNode(row),
        cellNode = rowNode.find('td').eq(cell),
        col = this.settings.columns[cell] || {},
        formatted = '',
        formatter = (col.formatter ? col.formatter : this.defaultFormatter),
        isEditor = $('.editor', cellNode).length > 0,
        isTreeGrid = this.settings.treeGrid,
        rowData = isTreeGrid ?
          this.settings.treeDepth[row].node :
          this.settings.dataset[row];

      var oldVal = (col.field ? rowData[col.field] : '');

      //Coerce/Serialize value if from cell edit
      if (!fromApiCall) {
        coercedVal = this.coerceValue(value, oldVal, col, row, cell);

        //coerced value may be coerced to empty string, null, or 0
        if (coercedVal === undefined) {
          coercedVal = value;
        }
      } else {
        coercedVal = value;
      }

      //Setup/Sync tooltip
      if (cellNode.data('tooltip')){
        cellNode.data('tooltip').destroy();
      }

      //Update the value in the dataset
      if (col.id === 'rowStatus' && rowData.rowStatus && rowData.rowStatus.tooltip) {
        cellNode.attr('title', rowData.rowStatus.tooltip);
        cellNode.tooltip({placement: 'right',
          isErrorColor: rowData.rowStatus.icon === 'error'
        });
      }

      coercedVal = $.unescapeHTML(coercedVal);

      if (col.field && coercedVal !== oldVal) {
        if (col.field.indexOf('.') > -1 ) {
          var parts = col.field.split('.');
          if (parts.length === 2) {
            rowData[parts[0]][parts[1]] = coercedVal;
          }

          if (parts.length === 3) {
            rowData[parts[0]][parts[1]][parts[2]] = coercedVal;
          }

        } else {
          rowData[col.field] = coercedVal;
        }
      }

      //update cell value
      escapedVal = $.escapeHTML(coercedVal);
      formatted = this.formatValue(formatter, (isTreeGrid ? row+1 : row), cell, (isEditor ? coercedVal : escapedVal), col, rowData);

      if (col.contentVisible) {
        var canShow = col.contentVisible(row, cell, escapedVal, col, rowData);
        if (!canShow) {
          formatted = '';
        }
      }

      if (!isInline) {
        cellNode.find('.datagrid-cell-wrapper').html(formatted);
      }

      if (!fromApiCall) {
        //Validate the cell
          this.validateCell(row, cell);
      }

      if (coercedVal !== oldVal && !fromApiCall) {
        var args = {row: row, cell: cell, target: cellNode, value: coercedVal, oldValue: oldVal, column: col};
        args.rowData = isTreeGrid && this.settings.treeDepth[row] ?
          this.settings.treeDepth[row].node : rowData;

        this.element.trigger('cellchange', args);
        this.wasJustUpdated = true;

        if (this.settings.showDirty) {
          this.rowStatus(row, 'dirty');
        }
      }

    },

    //For the row node get the index - adjust for paging / invisible rowsCache
    visualRowIndex: function (row) {
      return this.tableBody.find('tr:visible').index(row);
    },

    visualRowNode: function (idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source) {
        rowIdx = rowIdx + ((this.pager.activePage -1) * this.settings.pagesize);
      }

      return this.tableBody.find('tr[aria-rowindex="'+ (rowIdx + 1) +'"]');
    },

    dataRowNode: function (idx) {
      return this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]');
    },

    dataRowIndex: function (row) {
     return row.attr('aria-rowindex') - 1;
    },

    actualArrayIndex: function (rowElem) {
     return parseInt(rowElem.attr('data-index'));
    },

    // Update a specific Cell
    setActiveCell: function (row, cell) {
      var self = this,
        prevCell = self.activeCell,
        rowElem = row, rowNum, dataRowNum,
        isGroupRow = row instanceof jQuery && row.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');

      if (row instanceof jQuery && row.length === 0) {
        return;
      }

      if (typeof row === 'number') {
        rowNum = row;
        rowElem = this.tableBody.find('tr:visible').eq(row);
        dataRowNum = this.dataRowIndex(rowElem);
      }

      //Support passing the td in
      if (row instanceof jQuery && row.is('td')) {
        isGroupRow = row.parent().is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        if (isGroupRow) {
          rowElem = row.parent();
        }
        cell = row.index();
        rowNum = this.visualRowIndex(row.parent());
        dataRowNum = this.dataRowIndex(row.parent());
        rowElem = row.parent();
      }

      if (row instanceof jQuery && row.is('tr')) {
        rowNum = this.visualRowIndex(row);
        dataRowNum = this.dataRowIndex(row);
        rowElem = row;
      }

      if (rowNum < 0 || cell < 0) {
        return;
      }

      //Remove previous tab index
      if (prevCell.node && prevCell.node.length ===1) {
        self.activeCell.node
          .removeAttr('tabindex')
          .removeClass('is-active');
      }

      //Hide any cell tooltips (Primarily for validation)
      if (prevCell.cell !== cell || prevCell.row !== row) {
        $('#tooltip').hide();
      }

      //Find the cell if it exists
      self.activeCell.node = self.cellNode((isGroupRow ? rowElem : (dataRowNum > -1 ? dataRowNum : rowNum)), (cell)).attr('tabindex', '0');

      if (self.activeCell.node && prevCell.node.length === 1) {
        self.activeCell.row = rowNum;
        self.activeCell.cell = cell;
        dataRowNum = this.dataRowIndex(self.activeCell.node.parent());
      } else {
        self.activeCell = prevCell;
      }

      if (!$('input, button:not(.btn-secondary, .row-btn, .datagrid-expand-btn, .datagrid-drilldown, .btn-icon)', self.activeCell.node).length) {
        self.activeCell.node.focus();
        if (isGroupRow) {
          self.activeCell.groupNode = self.activeCell.node;
        }
      }
      if (self.activeCell.node.hasClass('is-focusable')) {
        self.activeCell.node.find('button').focus();
      }

      if (dataRowNum !== undefined) {
        self.activeCell.dataRow = dataRowNum;
      }
      var colSpan = +rowElem.find('td[colspan]').attr('colspan');

      if (isGroupRow && self.activeCell.node && prevCell.node && !(row instanceof jQuery && row.is('td'))) {
        if (cell < colSpan) {
          rowElem.find('td[colspan]').attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td[colspan]');
        }
        else if (cell >= colSpan) {
          rowElem.find('td').eq(cell-colSpan + 1).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell-colSpan + 1);
        } else {
          rowElem.find('td').eq(cell).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell);
        }
      }

      if (isGroupRow && row instanceof jQuery && row.is('td')) {
        self.activeCell.cell = (colSpan - 1) + cell;
        if (row.is('[colspan]')) {
          self.activeCell.cell = cell;
        }
      }

      if (this.settings.cellNavigation) {
        var headers = self.headerNodes(),
          prevSpans = 0;

        //Check if any previous rows are spanned
        if (this.hasColSpans) {
            prevSpans = 0;

            headers.eq(cell).prevAll('[colspan]').each(function (i, elem) {
              var span = $(elem).attr('colspan')-1;
              prevSpans += span;
            });

          cell = cell - prevSpans;
        }

        headers.removeClass('is-active');
        headers.eq(cell).addClass('is-active');
      }
      this.activeCell.isFocused = true;

      // Expand On Activate Feature
      var col = this.settings.columns[cell];
      if (col && col.expandOnActivate && this.activeCell && this.activeCell.node) {
        self.activeCell.node.addClass('is-active');
      }

      self.element.trigger('activecellchange', [{node: this.activeCell.node, row: this.activeCell.row, cell: this.activeCell.cell}]);
    },

    setNextActiveCell: function (e) {
      if (e.type === 'keydown') {
        if (this.settings.actionableMode) {
          var evt = $.Event('keydown.datagrid');
          evt.keyCode = 40; // move down
          this.activeCell.node.trigger(evt);
        }
        else {
          this.setActiveCell(this.activeCell.row, this.activeCell.cell);
        }
      }
    },

    // Add children to treegrid dataset
    addChildren: function(parent, data) {
      if (!data || (data && !data.length) || parent < 0) {
        return;
      }
      var node = this.settings.treeDepth[parent].node;
      node.children = node.children || [];

      // Make sure it's not reference pointer to data object, make copy of data
      data = JSON.parse(JSON.stringify(data));

      for (var i = 0, len = data.length; i < len; i++) {
        node.children.push(data[i]);
      }
      this.updateDataset(this.settings.dataset);
    },

    // Set expanded property in Dataset
    setExpandedInDataset: function(dataRowIndex, isExpanded) {
      this.settings.treeDepth[dataRowIndex].node.expanded = isExpanded;
    },

    //expand the tree rows
    toggleChildren: function(e, dataRowIndex) {
      var self = this,
        rowElement = this.visualRowNode(dataRowIndex),
        expandButton = rowElement.find('.datagrid-expand-btn'),
        level = parseInt(rowElement.attr('aria-level'), 10),
        children = rowElement.nextUntil('[aria-level="'+ level +'"]'),
        isExpanded = expandButton.hasClass('is-expanded'),
        args = [{grid: self, row: dataRowIndex, item: rowElement, children: children}];

      if (self.settings.treeDepth[dataRowIndex]) {
        args[0].rowData = self.settings.treeDepth[dataRowIndex].node;
      }

      if (!rowElement.hasClass('datagrid-tree-parent') ||
          (!$(e.target).is(expandButton) &&
            (self.settings.editable || self.settings.selectable))) {
        return;
      }

      var toggleExpanded = function() {
        rowElement = self.visualRowNode(dataRowIndex);
        expandButton = rowElement.find('.datagrid-expand-btn');
        children = rowElement.nextUntil('[aria-level="'+ level +'"]');

        if (isExpanded) {
          rowElement.attr('aria-expanded', false);
          expandButton.removeClass('is-expanded')
            .find('.plus-minus').removeClass('active');
        } else {
          rowElement.attr('aria-expanded', true);
          expandButton.addClass('is-expanded')
            .find('.plus-minus').addClass('active');
        }
        self.setExpandedInDataset(dataRowIndex, !isExpanded);

        var setChildren = function (rowElement, level, isExpanded) {
          var nodes = rowElement.nextUntil('[aria-level="'+ level +'"]');

          if (isExpanded) {
            nodes.each(function () {
              var node = $(this),
              nodeLevel = parseInt(node.attr('aria-level'), 10);
              if (nodeLevel > level) {
                node.addClass('is-hidden');
              }
            });
          }
          else {
            nodes.each(function () {
              var node = $(this),
                nodeLevel = parseInt(node.attr('aria-level'), 10);
              if (nodeLevel === (level + 1)) {
                node.removeClass('is-hidden');

                if (node.is('.datagrid-tree-parent')) {
                  var nodeIsExpanded = node.find('.datagrid-expand-btn.is-expanded').length > 0;
                  if (nodeIsExpanded) {
                    setChildren(node, nodeLevel, !nodeIsExpanded);
                  }
                }
              }
            });
          }
        };
        setChildren(rowElement, level, isExpanded);
        self.setAlternateRowShading();
      };

      $.when(self.element.triggerHandler(isExpanded ? 'collapserow' : 'expandrow', args)).done(function() {
        toggleExpanded();
      });
    },

    //Expand Detail Row Or Tree Row
    toggleRowDetail: function(dataRowIndex) {

      var self = this,
        rowElement = self.visualRowNode(dataRowIndex),
        expandRow = rowElement.next(),
        expandButton = rowElement.find('.datagrid-expand-btn'),
        detail = expandRow.find('.datagrid-row-detail'),
        item = self.settings.dataset[self.actualArrayIndex(rowElement)];

      if (rowElement.hasClass('datagrid-tree-parent')) {
        return;
      }

      if (self.settings.allowOneExpandedRow && self.settings.groupable === null) {
        //collapse any other expandable rows
        var prevExpandRow = self.tableBody.find('tr.is-expanded'),
          parentRow = prevExpandRow.prev(),
          parentRowIdx = parentRow.attr('aria-rowindex');

        if (prevExpandRow.length && expandRow.index() !== prevExpandRow.index()) {
          var prevDetail = prevExpandRow.find('.datagrid-row-detail');

          prevExpandRow.removeClass('is-expanded');
          parentRow.removeClass('is-rowactivated');
          parentRow.find('.plus-minus').removeClass('active');
          prevDetail.animateClosed().on('animateclosedcomplete', function () {
            prevExpandRow.css('display', 'none').removeClass('is-expanded');
            self.element.triggerHandler('collapserow', [{grid: self, row: parentRowIdx, detail: prevDetail, item: self.settings.dataset[parentRowIdx] }]);
          });

          var prevActionBtn = prevExpandRow.prev().find('.btn-primary');
          if (prevActionBtn.length) {
            prevActionBtn.attr('class', prevActionBtn.attr('class').replace('btn-primary','btn-secondary'));
          }
        }

        //Toggle the button to make it primary
        var isExpanded = !expandRow.hasClass('is-expanded'),
          actionButton = expandRow.prev().find(isExpanded ? '.btn-secondary' : '.btn-primary');

        if (actionButton.length > 0 && parentRow && actionButton) {
          var currentClass = actionButton.attr('class') || '';

          actionButton.attr('class', currentClass.replace(isExpanded ? 'btn-secondary' : 'btn-primary',
              isExpanded ? 'btn-primary' : 'btn-secondary') );
        }
      }

      if (expandRow.hasClass('is-expanded')) {
        expandRow.removeClass('is-expanded');
        expandButton.removeClass('is-expanded')
          .find('.plus-minus').removeClass('active');

        if (self.settings.allowOneExpandedRow) {
          rowElement.removeClass('is-rowactivated');
        }

        detail.animateClosed().on('animateclosedcomplete', function () {
          expandRow.css('display', 'none');
          self.element.triggerHandler('collapserow', [{grid: self, row: dataRowIndex, detail: detail, item: item}]);
        });

      } else {
        expandRow.addClass('is-expanded');
        expandButton.addClass('is-expanded')
          .find('.plus-minus').addClass('active');

        expandRow.css('display', 'table-row');

        //Optionally Contstrain the width
        expandRow.find('.constrained-width').css('max-width', this.element.outerWidth());

        if (self.settings.allowOneExpandedRow) {
          rowElement.addClass('is-rowactivated');
        }

        detail.animateOpen();
        self.element.triggerHandler('expandrow', [{grid: self, row: dataRowIndex, detail: detail, item: item}]);
      }
    },

    toggleGroupChildren: function(rowElement) {
      if (!this.settings.groupable) {
        return;
      }

      var self = this,
        children = rowElement.nextUntil('.datagrid-rowgroup-header'),
        expandButton = rowElement.find('.datagrid-expand-btn');

      if (rowElement.hasClass('is-expanded')) {
        expandButton.removeClass('is-expanded')
          .find('.plus-minus').removeClass('active');

        children.hide();
        children.addClass('is-hidden');
        self.element.triggerHandler('collapserow', [{grid: self, row: rowElement.index(), detail: children, item: {}}]);

        rowElement.removeClass('is-expanded');
      } else {
      expandButton.addClass('is-expanded')
        .find('.plus-minus').addClass('active');

        children.show();
        children.removeClass('is-hidden');
        self.element.triggerHandler('expandrow', [{grid: self, row: rowElement.index(), detail: children, item: {}}]);

        rowElement.addClass('is-expanded');
      }

    },

    //Api Event to set the sort Column
    setSortColumn: function(id, ascending) {
      //Set Direction based on if passed in or toggling existing field
      if (ascending !== undefined) {
        this.sortColumn.sortAsc = ascending;
      } else {
        if (this.sortColumn.sortId === id) {
          this.sortColumn.sortAsc = !this.sortColumn.sortAsc;
        } else {
           this.sortColumn.sortAsc = true;
        }
        ascending = this.sortColumn.sortAsc;
      }

      this.sortColumn.sortId = id;
      this.sortColumn.sortField = (this.columnById(id)[0] ? this.columnById(id)[0].field : id);
      this.sortColumn.sortAsc = ascending;

      //Do Sort on Data Set
      this.setSortIndicator(id, ascending);
      this.sortDataset();

      var wasFocused = this.activeCell.isFocused;
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.renderRows();
      // Update selected and Sync header checkbox
      this.syncSelectedUI();

      if (wasFocused && this.activeCell.node.length === 1) {
        this.setActiveCell(this.activeCell.row, this.activeCell.cell);
      }

      this.resetPager('sorted');
      this.tableBody.removeClass('is-loading');
      this.saveUserSettings();
      this.element.trigger('sorted', [this.sortColumn]);
    },

    sortDataset: function() {
      if (this.originalDataset) {
        this.settings.dataset = this.originalDataset;
      }
      var sort = this.sortFunction(this.sortColumn.sortId, this.sortColumn.sortAsc);

      if (!this.settings.disableClientSort) {
        settings.dataset.sort(sort);
      }
    },

    setSortIndicator: function(id, ascending) {
      if (!this.headerRow) {
        return;
      }

      //Set Visual Indicator
      this.headerRow.find('.is-sorted-asc, .is-sorted-desc').removeClass('is-sorted-asc is-sorted-desc').attr('aria-sort', 'none');
      this.headerRow.find('[data-column-id="' +id + '"]')
        .addClass(ascending ? 'is-sorted-asc' : 'is-sorted-desc')
        .attr('aria-sort', ascending ? 'ascending' : 'descending');
    },

    /**
    * Overridable function to conduct array sorting
    * @param {String} id &nbsp;-&nbsp The matching field/id in the array to sort on
    * @param {Boolean} ascending &nbsp;-&nbsp Determines direction of the sort.
    */
    sortFunction: function(id, ascending) {
      var column = this.columnById(id),
        field = column.length === 0 ? id : column[0].field; //Assume the field and id match if no column found

      var key, self = this,
      primer = function(a) {
        a = (a === undefined || a === null ? '' : a);

        if (typeof a === 'string') {
          a = a.toUpperCase();

          if ($.isNumeric(a)) {
            a = parseFloat(a);
          }

        }
        return a;
      };

      key = function(x) { return primer(self.fieldValue(x, field)); };

      ascending = !ascending ? -1 : 1;

      return function (a, b) {
        a = key(a);
        b = key(b);

        if (typeof a !== typeof b) {
          a = a.toString().toLowerCase();
          b = b.toString().toLowerCase();
        }

        return ascending * ((a > b) - (b > a));
      };
    },

    /**
    * Determine equality for two deeply nested JavaScript objects
    * @private
    */
    isEquivalent: function(obj1, obj2) {
      function _equals(obj1, obj2) {
        return JSON.stringify(obj1) === JSON.stringify($.extend(true, {}, obj1, obj2));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    },

    /**
    * The default formatter to use (just plain text). When no formatter is specified.
    * @private
    */
    defaultFormatter: function(row, cell, value) {
      return ((value === null || value === undefined || value === '') ? '' : value.toString());
    },

    /**
    * Add the pager and paging functionality.
    * @private
    */
    handlePaging: function () {
      var self = this;

      if (!this.settings.paging) {
        return;
      }

      var pagerElem = this.tableBody;
      this.element.addClass('paginated');
      pagerElem.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        hideOnOnePage: this.settings.hidePagerOnOnePage,
        source: this.settings.source,
        pagesize: this.settings.pagesize,
        indeterminate: this.settings.indeterminate,
        rowTemplate: this.settings.rowTemplate,
        pagesizes: this.settings.pagesizes,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.restoreActivePage ? parseInt(this.savedActivePage) : 1
      });

      if (this.restoreActivePage) {
        this.savedActivePage = null;
        this.restoreActivePage = false;
      }

      this.pager = pagerElem.data('pager');

      pagerElem.off('afterpaging')
      .on('afterpaging', function (e, args) {

        // Hide the entire pager bar if we're only showing one page, if applicable
        if (self.pager.hidePagerBar(args)) {
          self.element.removeClass('paginated');
        } else {
          self.element.addClass('paginated');
        }

        self.recordCount = args.total;
        self.displayCounts(args.total);

        //Handle row selection across pages
        self.syncSelectedUI();

        if (self.filterExpr && self.filterExpr[0] && self.filterExpr[0].column === 'all') {
          self.highlightSearchRows(self.filterExpr[0].value);
        }
      });

    },

    /**
    * Add the pager and paging functionality.
    * @param {String} pagingInfo &nbsp;-&nbsp The paging object with activePage ect used by pager.js
    * @param {Boolean} isResponse &nbsp;-&nbsp Internal flag used to prevent callbacks from rexecuting.
    */
    renderPager: function (pagingInfo, isResponse, callback) {
      var api = this.pager;

      if (!api) {
        return;
      }

      api.updatePagingInfo(pagingInfo);

      if (!isResponse) {
        api.renderPages(pagingInfo.type, callback);
      }

      // Update selected and Sync header checkbox
      this.syncSelectedUI();
    },

    /**
    * Reset the pager to the first page.
    * @param {String} type &nbsp;-&nbsp The action type, which gets sent to the source callback.
    */
    resetPager: function(type) {
      if (!this.pager) {
        return;
      }

      if (!this.pager.pagingInfo) {
        this.pager.pagingInfo = {};
      }

      this.pager.pagingInfo.type = type;
      this.pager.pagingInfo.activePage = 1;
      this.renderPager(this.pager.pagingInfo);
    },

    /**
    * Unwrap the grid back to a simple div, and destory all events and pointers.
    */
    destroy: function() {
      //Remove the toolbar, clean the div out and remove the pager
      this.element.off().empty().removeClass('datagrid-container');
      var toolbar = this.element.prev('.toolbar');

      this.triggerDestroyCell();

      if (this.removeToolbarOnDestroy && settings.toolbar && settings.toolbar.keywordFilter) {
        var searchfield = toolbar.find('.searchfield');
        if (searchfield.data('searchfield')) {
          searchfield.data('searchfield').destroy();
        }
        if (searchfield.data('toolbarsearchfield')) {
          searchfield.data('toolbarsearchfield').destroy();
        }
        searchfield.removeData('options');
      }

      if (this.removeToolbarOnDestroy) {
        // only remove toolbar if it was created by this datagrid
        if (toolbar.data('toolbar')) {
          toolbar.data('toolbar').destroy();
        }
        toolbar.remove();
      }
      this.element.next('.pager-toolbar').remove();
      $.removeData(this.element[0], pluginName);

      //TODO Test Memory Leaks in Chrome - null out fx this.table
      $(document).off('touchstart.datagrid touchend.datagrid touchcancel.datagrid click.datagrid touchmove.datagrid');
      this.contentContainer.off().remove();
      $('body').off('resize.vtable resize.datagrid');

    }

  };

  // Initialize the plugin (Once) or set settings
  return this.each(function() {
    var instance = $.data(this, pluginName);
    if (instance) {
      instance.settings = $.extend({}, defaults, options);
    } else {
      instance = $.data(this, pluginName, new Datagrid(this, settings));
    }
  });

};

  $.fn.dropdown = function(options) {

    'use strict';

    // Dropdown Settings and Options
    var pluginName = 'dropdown',
        defaults = {
          closeOnSelect: true,
          cssClass: null,
          filterMode: 'contains',
          maxSelected: undefined, //If in multiple mode, sets a limit on the number of items that can be selected
          moveSelected: 'none',
          moveSelectedToTop: undefined,
          multiple: false, //Turns the dropdown into a multiple selection box
          noSearch: false,
          showEmptyGroupHeaders: false,
          showSelectAll: false, // If true, on Multiselect dropdowns, will show an additional option at the top of the list labeled "select all".
          source: undefined,
          sourceArguments: {},
          reloadSourceOnOpen: false,
          empty: false,
          delay: 300,
          maxWidth: null
        },
        moveSelectedOpts = ['none', 'all', 'group'],
        settings = $.extend({}, defaults, options);

    /**
    * The Dropdown allows users to select from a list. Like an Html Select.
    *
    * @class Dropdown
    * @param {Boolean} closeOnSelect  &nbsp;-&nbsp; When an option is selected, the list will close if set to "true".  List stays open if "false".
    * @param {String} cssClass  &nbsp;-&nbsp; Append an optional css class to dropdown-list
    * @param {String} filterMode  &nbsp;-&nbsp; Search mode to use between 'startsWith' and 'contains', false will not allow client side filter
    * @param {Boolean} noSearch  &nbsp;-&nbsp; If true, disables the ability of the user to enter text in the Search Input field in the open combo box
    * @param {Boolean} showEmptyGroupHeaders  &nbsp;-&nbsp; If true, displays <optgroup> headers in the list even if no selectable options are present underneath.
    * @param {Boolean} source  &nbsp;-&nbsp; A function that can do an ajax call.
    * @param {Boolean} sourceArguments  &nbsp;-&nbsp; If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
    * @param {Boolean} sourceArguments  &nbsp;-&nbsp; If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
    * @param {Boolean} reloadSourceOnOpen  &nbsp;-&nbsp; If set to true, will always perform an ajax call whenever the list is opened.  If false, the first AJAX call's results are cached.
    * @param {Boolean} empty  &nbsp;-&nbsp; Initialize Empty Value
    * @param {Boolean} delay  &nbsp;-&nbsp; Typing Buffer Delay in ms
    * @param {Number} maxWidth &nbsp;-&nbsp; If set the width of the dropdown is limited to this pixel width. Fx 300 for the 300 px size fields. Default is size of the largest data.
    *
    */
    function Dropdown(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual DropDown Code
    Dropdown.prototype = {
      init: function() {
        var orgId = this.element.attr('id');

        this.isIe10 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '10');
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');

        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');

        if (orgId === undefined) {
          orgId = this.element.uniqueId('dropdown');
          this.element.attr('id', orgId);
          this.element.parent().find('label').first().attr('for', orgId);
        }

        if (Soho.env.os.name === 'ios' || Soho.env.os.name === 'android') {
          this.settings.noSearch = true;
        }

        // convert <select> tag's size css classes for the pseudo element
        var elemClassList = this.element[0].classList;
        if (elemClassList.length === 0) {
          this.element[0].classList = 'dropdown';
        }
        var pseudoClassString = elemClassList.contains('dropdown-xs') ? 'dropdown input-xs' :
            elemClassList.contains('dropdown-sm') ? 'dropdown input-sm' :
            elemClassList.contains('dropdown-lg') ? 'dropdown input-lg' : 'dropdown';

        //Detect Inline Styles
        var style = this.element.attr('style');
        this.isHidden = style && style.indexOf('display: none') >= 0;

        // Build the wrapper if it doesn't exist
        var baseElement = this.isInlineLabel ? this.inlineLabel : this.element;
        this.wrapper = baseElement.next('.dropdown-wrapper');
        this.isWrapped = this.wrapper.length > 0;

        if (!this.isWrapped) {
          this.wrapper = $('<div class="dropdown-wrapper"></div>').insertAfter(baseElement);
        }

        if (this.isWrapped) {
          this.pseudoElem = this.wrapper.find('.' + pseudoClassString);
          this.trigger = this.wrapper.find('.trigger');
        } else {
          this.pseudoElem = $('div#'+ orgId + '-shdo');
        }

        if(elemClassList.contains('text-align-reverse')) {
          pseudoClassString += ' text-align-reverse';
        } else if (elemClassList.contains('text-align-center')){
          pseudoClassString += ' text-align-center';
        }

        // Build sub-elements if they don't exist
        this.label = $('label[for="'+ orgId +'"]');

        if (!this.pseudoElem.length) {
          this.pseudoElem = $('<div class="'+ pseudoClassString + '">');
        } else {
          this.pseudoElem[0].setAttribute('class', pseudoClassString);
        }

        if (!this.isWrapped) {
          this.pseudoElem.append($('<span></span>'));
        }

        var toExclude = ['data-validate'],
          attributes = Soho.DOM.getAttributes(this.element[0]),
          attributesToCopy = this.getDataAttributes(attributes, toExclude);

        this.pseudoElem
          .attr(attributesToCopy.obj)
          .attr({
            'role': 'combobox',
            'aria-autocomplete': 'list',
            'aria-controls': 'dropdown-list',
            'aria-readonly': 'true',
            'aria-expanded': 'false',
            'aria-label': this.label.text()
          });

        // Pass disabled/readonly from the original element, if applicable
        // "disabled" is a stronger setting than "readonly" - should take precedent.
        function handleStates(self) {
          var disabled = self.element.prop('disabled'),
            readonly = self.element.prop('readonly');

          if (disabled) {
            return self.disable();
          }

          if (readonly) {
            return self.readonly();
          }

          return self.enable();
        }
        handleStates(this);

        if (!this.isWrapped) {
          this.wrapper.append(this.pseudoElem, this.trigger);
        }

        // Check for and add the icon
        this.icon = this.wrapper.find('.icon');
        if (!this.icon.length) {
          this.icon = $.createIconElement('dropdown');
          this.wrapper.append(this.icon);
        }

        // Setup the incoming options that can be set as properties/attributes
        if (this.element.prop('multiple') && !this.settings.multiple) {
          this.settings.multiple = true;
        }
        var dataSource = this.element.attr('data-source');
        if (dataSource && dataSource !== 'source') {
          this.settings.source = dataSource;
        }
        var dataMaxselected = this.element.attr('data-maxselected');
        if (dataMaxselected && !isNaN(dataMaxselected)) {
          this.settings.maxSelected = parseInt(dataMaxselected, 10);
        }

        // TODO: deprecate "moveSelectedToTop" in favor of "moveSelected"
        // _getMoveSelectedSetting()_ converts the old setting to the new text type.
        function getMoveSelectedSetting(incomingSetting, useText) {
          switch (incomingSetting) {
            case (useText ? 'true' : true):
              return 'all';
            case (useText ? 'false' : false):
              return 'none';
            default:
              if (moveSelectedOpts.indexOf(incomingSetting) > -1) {
                return incomingSetting;
              }
              return 'none';
          }
        }

        // Backwards compatibility for deprecated "moveSelectedToTop" setting.
        if (this.settings.moveSelectedToTop !== undefined) {
          this.settings.moveSelected = this.settings.moveSelectedToTop;
        }

        var dataMoveSelected = this.element.attr('data-move-selected');
        if (dataMoveSelected) {
          this.settings.moveSelected = getMoveSelectedSetting(dataMoveSelected, true);
        } else {
          this.settings.moveSelected = getMoveSelectedSetting(this.settings.moveSelected);
        }

        var dataCloseOnSelect = this.element.attr('data-close-on-select');
        if (dataCloseOnSelect && !this.settings.closeOnSelect) {
          this.settings.closeOnSelect = dataCloseOnSelect === 'true';
        }
        var dataNoSearch = this.element.attr('data-no-search');
        if (dataNoSearch && !this.settings.noSearch) {
          this.settings.noSearch = dataNoSearch === 'true';
        }

        // Persist sizing defintions
        var sizingStrings = ['-xs', '-sm', '-md', '-lg'],
          classString = this.element.attr('class'),
          s;

        for (var i = 0; i < sizingStrings.length; i++) {
          s = sizingStrings[i];
          if (classString.match(s)) {
            this.pseudoElem.addClass('dropdown' + s);
          }
        }

        // Cached dataset (from AJAX, if applicable)
        this.dataset = [];

        this.listfilter = new ListFilter({
          filterMode: this.settings.filterMode
        });

        this.setListIcon();
        this.setValue();
        this.setInitial();
        this.setWidth();

        this.element.triggerHandler('rendered');

        return this.handleEvents();
      },

      // Used for preventing menus from popping open/closed when they shouldn't.
      // Gets around the need for timeouts everywhere
      inputTimer: function() {
        if (this.inputTimeout) {
          return false;
        }

        var self = this;

        this.inputTimeout = setTimeout(function inputTimeout(){
          clearTimeout(self.inputTimeout);
          self.inputTimeout = null;
        }, 100);

        return true;
      },

      // Set Field Width
      setWidth: function() {
        var style = this.element[0].style;

        if (style.width) {
          this.pseudoElem[0].style.width = style.width;
        }
        if (style.position === 'absolute') {
          this.pseudoElem[0].style.position = 'absolute';
          this.pseudoElem[0].style.left = style.left;
          this.pseudoElem[0].style.top = style.top;
          this.pseudoElem[0].style.bottom = style.bottom;
          this.pseudoElem[0].style.right = style.right;
        }
      },

      // Set list item icon
      setItemIcon: function(listIconItem) {
        var self = this;
        if (self.listIcon.hasIcons) {
          var specColor = null;

          if (listIconItem.icon) {

            // Set icon properties
            if (typeof listIconItem.icon === 'object') {
              listIconItem.obj = listIconItem.icon;
              listIconItem.icon = listIconItem.icon.icon;

              // Color
              if (listIconItem.obj.color) {
                specColor = listIconItem.obj.color.indexOf('#') === 0;
                if (specColor) {
                  listIconItem.specColor = listIconItem.obj.color;
                } else {
                  listIconItem.classList = ' '+ listIconItem.obj.color;
                }
              }
              // Class
              else if (listIconItem.obj.class) {
                specColor = listIconItem.obj.class.indexOf('#') === 0;
                if (specColor) {
                  listIconItem.specColor = listIconItem.obj.class;
                } else {
                  listIconItem.classList = ' '+ listIconItem.obj.class;
                }
              }

              // Color Over
              if (listIconItem.obj.colorOver) {
                specColor = listIconItem.obj.colorOver.indexOf('#') === 0;
                if (specColor) {
                  listIconItem.specColorOver = listIconItem.obj.colorOver;
                } else {
                  listIconItem.classListOver = ' '+ listIconItem.obj.colorOver;
                }
              }
              // Class Over
              else if (listIconItem.obj.classOver) {
                specColor = listIconItem.obj.classOver.indexOf('#') === 0;
                if (specColor) {
                  listIconItem.specColorOver = listIconItem.obj.classOver;
                } else {
                  listIconItem.classListOver = ' '+ listIconItem.obj.classOver;
                }
              }

            }

            // Set flags
            if (listIconItem.icon && listIconItem.icon.length) {
              listIconItem.isIcon = true;
            }
            if (listIconItem.specColor && listIconItem.specColor.length) {
              listIconItem.isSpecColor = true;
            }
            if (listIconItem.classList && listIconItem.classList.length) {
              listIconItem.isClassList = true;
            }
            if (listIconItem.specColorOver && listIconItem.specColorOver.length) {
              listIconItem.isSpecColorOver = true;
            }
            if (listIconItem.classListOver && listIconItem.classListOver.length) {
              listIconItem.isClassListOver = true;
            }
          }

          // Build icon
          listIconItem.html = $.createIcon({
            icon: listIconItem.isIcon ? listIconItem.icon : '',
            class: 'listoption-icon' + (listIconItem.isClassList ? ' '+ listIconItem.classList : '')
          });
          if (listIconItem.isSpecColor) {
            listIconItem.html = listIconItem.html.replace('<svg', ('<svg '+ 'style="fill:'+ listIconItem.specColor +';"'));
          }
        }
        self.listIcon.items.push(listIconItem);
      },

      // Set list icon
      setListIcon: function() {
        var self = this,
          hasIcons = self.settings.multiple ? false : self.element.find('[data-icon]').length > 0,
          opts = hasIcons ? this.element.find('option') : [];

        self.listIcon = {hasIcons: hasIcons, items: []};

        if (hasIcons) {
          var count = 0;

          opts.each(function(i) {
            var iconAttr = $(this).attr('data-icon'),
              icon;

            if (typeof iconAttr !== 'string') {
              return;
            }

            if (iconAttr.indexOf('{') !== 0) {
              icon = iconAttr;
            } else {
              icon = $.fn.parseOptions(this, 'data-icon');
            }
            self.setItemIcon({html: '', icon: icon});

            if (self.listIcon.items[i].isIcon) {
              count++;
            }
          });

          hasIcons = count > 0;
        }

        if (hasIcons) {
          self.pseudoElem.prepend($.createIcon({icon:'', class:'listoption-icon'}));
          self.listIcon.pseudoElemIcon = self.pseudoElem.find('> .listoption-icon');
          self.listIcon.idx = -1;
        }

        self.listIcon.hasIcons = hasIcons;
      },

      // Set over color for list item icon,
      // if run without pram {target}, it will make on only
      setItemIconOverColor: function(target) {
        var self = this;
        if (self.listIcon.hasIcons) {
          var targetIcon = target ? target.find('.listoption-icon') : null;
          self.list.find('li').each(function(i) {
            var li = $(this),
              icon = li.find('.listoption-icon');

            // make it on
            if (li.is('.is-focused')) {
              if (self.listIcon.items[i].isClassListOver) {
                icon.removeClass(self.listIcon.items[i].classListOver)
                    .addClass(self.listIcon.items[i].classList);
              }
              if (self.listIcon.items[i].isSpecColorOver) {
                icon.css({fill: self.listIcon.items[i].specColor});
              }
            }
            // make it over
            if (targetIcon && li.is(target)) {
              if (self.listIcon.items[i].isClassListOver) {
                targetIcon.removeClass(self.listIcon.items[i].classList);
                targetIcon.addClass(self.listIcon.items[i].classListOver);
              }
              if (self.listIcon.items[i].isSpecColorOver) {
                targetIcon.css({fill: self.listIcon.items[i].specColorOver});
              }
            }
          });
        }
      },

      // Update list item icon
      updateItemIcon: function(opt) {
        var self = this;
        if (self.listIcon.hasIcons) {
          var target = self.listIcon.pseudoElemIcon,
            i = opt.index(),
            idx = self.listIcon.idx,
            icon = self.listIcon.items[i].isIcon ? self.listIcon.items[i].icon : '';

          // Reset class and color
          if (idx > -1) {
            target.removeClass(
              self.listIcon.items[idx].classList +' '+
              self.listIcon.items[idx].classListOver
            );
            target[0].style.fill = '';
          }

          // Update new stuff
          self.listIcon.idx = i;
          target.changeIcon(icon);
          if (self.listIcon.items[i].isClassList) {
            target.addClass(self.listIcon.items[i].classList);
          }
          if (self.listIcon.items[i].isSpecColor) {
            target.css({fill: self.listIcon.items[i].specColor});
          }
        }
      },

      // Keep a generated list of items and update as needed
      updateList: function() {
        var self = this,
          isMobile = self.isMobile(),
          listExists = self.list !== undefined && self.list !== null && self.list.length > 0,
          listContents = '',
          ulContents = '',
          upTopOpts = 0,
          hasOptGroups = this.element.find('optgroup').length,
          reverseText = '',
          isMultiselect = this.settings.multiple === true,
          moveSelected = '' + this.settings.moveSelected,
          showSelectAll = this.settings.showSelectAll === true;

        if(this.element[0].classList.contains('text-align-reverse')){
          reverseText = ' text-align-reverse';
        } else if (this.element[0].classList.contains('text-align-center')){
          reverseText = ' text-align-center';
        }

        if (!listExists) {
          listContents = '<div class="dropdown-list' + reverseText +
            (isMobile ? ' mobile' : '') +
            (this.settings.multiple ? ' multiple' : '') + '" id="dropdown-list" role="application" ' + (this.settings.multiple ? 'aria-multiselectable="true"' : '') + '>' +
            '<label for="dropdown-search" class="audible">' + Locale.translate('Search') + '</label>' +
            '<input type="text" class="dropdown-search' + reverseText +
            '" role="combobox" aria-expanded="true" id="dropdown-search" aria-autocomplete="list">' +
            '<span class="trigger">' +
              (isMobile ? $.createIcon({ icon: 'close', classes: ['close'] }) : $.createIcon('dropdown')) +
              '<span class="audible">' + (isMobile ? Locale.translate('Close') : Locale.translate('Collapse')) + '</span>' +
            '</span>' +
            '<ul role="listbox">';
        }

        // Get a current list of <option> elements
        // If none are available, simply return out
        var opts = this.element.find('option');
        var groups = this.element.find('optgroup');
        var selectedOpts = opts.filter(':selected');
        var groupsSelectedOpts = [];

        function buildLiHeader(textContent) {
          return '<li role="presentation" class="group-label" focusable="false">' +
              textContent +
            '</li>';
        }

        function buildLiOption(option, index) {
          var liMarkup = '',
            attributes = Soho.DOM.getAttributes(option),
            text = option.innerHTML,
            value = attributes.getNamedItem('value'),
            title = attributes.getNamedItem('title'),
            badge = attributes.getNamedItem('data-badge'),
            badgeColor = attributes.getNamedItem('data-badge-color'),
            isSelected = option.selected,
            isDisabled = option.disabled,
            cssClasses = option.className,
            toExclude = ['data-badge', 'data-badge-color', 'data-val', 'data-icon'],
            attributesToCopy = self.getDataAttributes(attributes, toExclude),
            trueValue = value && value.value ? value.value : text,
            iconHtml = self.listIcon.hasIcons ? self.listIcon.items[index].html : '';

          if (cssClasses.indexOf('clear') > -1) {
            if (text === '') {
              text = Locale.translate('ClearSelection');
            }
          }

          liMarkup += '' +
            '<li role="presentation" class="dropdown-option' +
              (isSelected ? ' is-selected' : '') +
              (isDisabled ? ' is-disabled' : '') +
              (cssClasses ? ' '+ cssClasses.value : '' ) + '"' +
              attributesToCopy.str +
              ' data-val="'+ trueValue.replace('"', '/quot/') + '"' +
              (title ? '" title="' + title.value + '"' : '') +
              ' tabindex="' + (index && index === 0 ? 0 : -1) + '">' +
                '<a role="option" href="#" class="' +
                  (cssClasses.indexOf('clear') > -1 ?
                    ' clear-selection' : '' ) + '"' +
                  'id="list-option'+ index +'">' +
                    iconHtml + text +
                '</a>' +
                (badge ? '<span class="badge ' +
                  (badgeColor ? badgeColor.value : 'azure07') +
                '"> '+ badge.value + '</span>' : '') +
            '</li>';

          return liMarkup;
        }

        // In multiselect scenarios, shows an option at the top of the list that will
        // select all available options if checked.
        if (isMultiselect && showSelectAll) {
          var allSelected = opts.not('[disabled], .hidden').length === selectedOpts.not('[disabled], .hidden').length;

          ulContents += '<li role="presentation" class="dropdown-select-all-list-item'+ (allSelected ? ' is-selected' : '') + '">' +
            '<a role="option" href="#" id="dropdown-select-all-anchor" class="dropdown-select-all-anchor">' +
              Locale.translate('SelectAll') +
            '</a>' +
          '</li>';
        }

        // Move selected options in each group to just underneath their corresponding group headers.
        if (moveSelected === 'group') {
          // If no optgroups exist, change to "all" and skip this part.
          if (!groups || !groups.length) {
            moveSelected = 'all';
          } else {

            // Break apart selectedOpts into groups.
            // These selected items are applied when the header is generated.
            groups.each(function(i, g) {
              var els = selectedOpts.filter(function() {
                return $.contains(g, this);
              });
              groupsSelectedOpts.push(els);
            });

          }
        }

        // Move all selected options to the top of the list if the setting is true.
        // Also adds a group heading if other option groups are found in the <select> element.
        if (moveSelected === 'all') {
          opts = opts.not(selectedOpts);

          // Show a "selected" header if there are selected options
          if (selectedOpts.length > 0) {
            ulContents += buildLiHeader(Locale.translate('Selected') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
          }

          selectedOpts.each(function(i) {
            ulContents += buildLiOption(this, i);
            upTopOpts++;
          });

          // Only show the "all" header beneath the selected options if there are no other optgroups present
          if (!hasOptGroups && opts.length > 0) {
            ulContents += buildLiHeader(Locale.translate('All') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
          }
        }

        opts.each(function(i) {
          var count = i + upTopOpts,
            option = $(this),
            parent = option.parent(),
            optgroupIsNotDrawn,
            optgroupIndex;

          // Add Group Header if this is an <optgroup>
          // Remove the group header from the queue.
          if (parent.is('optgroup') && groups.length) {
            optgroupIndex = parent.index();
            optgroupIsNotDrawn = groups.index(parent) > -1;

            if (optgroupIsNotDrawn) {
              groups = groups.not(parent);
              ulContents += buildLiHeader('' + parent.attr('label'));

              // Add all selected items for this group
              if (moveSelected === 'group') {
                groupsSelectedOpts[optgroupIndex].each(function(i) {
                  ulContents += buildLiOption(this, i);
                  upTopOpts++;
                });
              }
            }
          }

          if (moveSelected !== 'none' && option.is(':selected')) {
            return;
          }

          ulContents += buildLiOption(this, count);
        });

        // Render the new list contents to the page.
        // Build the entire thing and set references if this is the first opening.
        // Otherwise, simply replace the elements inside the <ul>.
        if (!listExists) {
          listContents += ulContents + '</ul>' +
            '</div>';

          // Append markup to the DOM
          this.list = $(listContents);

          // Get references
          this.listUl = this.list.find('ul');
          this.searchInput = this.list.find('#dropdown-search');
        } else {
          this.listUl.html(ulContents);
        }

        if (this.listIcon.hasIcons) {
          this.list.addClass('has-icons');
          this.listIcon.pseudoElemIcon.clone().appendTo(this.list);
        }

        if (hasOptGroups) {
          this.listUl.addClass('has-groups');
        }

        this.listUl.find('[title]').addClass('has-tooltip').tooltip();
      },

      // Set the value based on selected options
      setValue: function () {
        var opts = this.element.find('option:selected'),
          text = this.getOptionText(opts);

        if (opts.hasClass('clear')) {
          text = '';
        }

        if (this.settings.empty && opts.length === 0) {
          this.pseudoElem.find('span').text('');
          return;
        }

        //Set initial values for the edit box
        this.setPseudoElemDisplayText(text);
        if (this.element.attr('maxlength')) {
           this.setPseudoElemDisplayText(text.substr(0, this.element.attr('maxlength')));
        }

        //Set the "previousActiveDescendant" to the first of the items
        this.previousActiveDescendant = opts.first().val();

        this.updateItemIcon(opts);
        this.setBadge(opts);
      },

      // Sets only the display text of the Dropdown/Mutliselect
      // Can be used for setting a pre-populated value when working with an AJAX call.
      setPseudoElemDisplayText: function(text) {
        this.pseudoElem.find('span').text(text);
      },

      copyClass: function(from, to, prop) {
        if (from.hasClass(prop)) {
          to.addClass(prop);
        }
      },

      // Copy initial stuff from the drop down.
      setInitial: function() {

        if (this.element.is(':disabled')) {
          this.disable();
        }
        if (this.element.is('[readonly]')) {
          this.readonly();
        }
        if (this.isHidden) {
          this.pseudoElem.hide().prev('label').hide();
          this.pseudoElem.next('svg').hide();
        }

        if (this.element.attr('placeholder')) {
          this.pseudoElem.attr('placeholder', this.element.attr('placeholder'));
          this.element.removeAttr('placeholder');
        }
      },

      ignoreKeys: function (input, e) {
        var charCode = e.which;

        //Needed for browsers that use keypress events to manipulate the window.
        if (e.altKey && (charCode === 38 || charCode === 40)) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        if (charCode === 8 && input.hasClass('dropdown')) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        if (input.is(':disabled') || input.hasClass('is-readonly')) {
          return;
        }

        return true;
      },

      //handle events while search is focus'd
      handleSearchEvents: function () {
        var self = this, timer;

        if (this.settings.noSearch) {
          this.searchInput.prop('readonly', true);
        }

        // Used to determine how spacebar should function.  False means space will select/deselect.  True means
        // Space will add a space inside the search input.
        this.searchKeyMode = false;

        this.searchInput.on('keydown.dropdown', function(e) {
          var searchInput = $(this);

          if (!self.ignoreKeys(searchInput, e)) {
            return;
          }

          if (!self.handleKeyDown(searchInput, e)) {
            return;
          }

          if (self.settings.noSearch === false && !self.settings.source) {
            clearTimeout(timer);
            timer = setTimeout(function () {
              if (searchInput.val() === '') {
                self.resetList();
              } else {
                self.filterList(searchInput.val().toLowerCase());
              }
            }, 100);
          }
        }).on('keypress.dropdown', function (e) {
          self.isFiltering = true;
          self.handleAutoComplete(e);
        });

      },

      filterList: function(term) {
        var self = this,
          selected = false,
          list = $('.dropdown-option', this.listUl),
          headers = $('.group-label', this.listUl),
          results;

        if (!list.length || !this.list || this.list && !this.list.length) {
          return;
        }

        if (!term) {
          term = '';
        }

        if (term && term.length) {
          results = this.listfilter.filter(list, term);
        }

        this.list.addClass('search-mode');
        this.list.find('.icon').attr('class', 'icon search').changeIcon('search');
        this.searchInput.removeAttr('aria-activedescendant');

        this.unhighlightOptions();

        if (!results || !results.length && !term) {
          this.resetList();
          return;
        }

        list.not(results).add(headers).addClass('hidden');
        list.filter(results).each(function(i) {
          var li = $(this);
          li.attr('tabindex', i === 0 ? '0' : '-1');

          if (!selected) {
            self.highlightOption(li);
            selected = true;
          }

          //Highlight Term
          var exp = new RegExp('(' + term + ')', 'i');
          var text = li.text().replace(exp, '<i>$1</i>');
          li.removeClass('hidden').children('a').html(text);
        });

        headers.each(function() {
          var children = $(this).nextUntil('.group-label, .selector').not('.hidden');
          if (self.settings.showEmptyGroupHeaders || children.length) {
            $(this).removeClass('hidden');
          }
        });

        term = '';
        this.position();
      },

      // Removes filtering from an open Dropdown list and turns off "search mode"
      resetList: function() {
        if (!this.list || this.list && !this.list.length) {
          return;
        }
        var isMobile = this.isMobile(),
          cssClass = 'icon' + (isMobile ? ' close' : ''),
          icon = $.getBaseURL(isMobile ? 'close' : 'dropdown');

        this.list.removeClass('search-mode');
        this.list.find('.icon').attr('class', cssClass) // needs to be 'attr' here because .addClass() doesn't work with SVG
          .changeIcon(icon);

        function stripHtml(obj) {
          if (!obj[0]) {
            return '';
          }

          return obj[0].textContent || obj[0].innerText;
        }

        var lis = this.listUl.find('li');
        lis.removeAttr('style').each(function() {
          var a = $(this).children('a');
          a.text(stripHtml(a));
        });

        //Adjust height / top position
        if (this.list.hasClass('is-ontop')) {
          this.list[0].style.top = (this.pseudoElem.offset().top - this.list.height() + this.pseudoElem.outerHeight() - 2) +'px';
        }

        if (this.settings.multiple) {
          this.updateList();
        }

        lis.removeClass('hidden');
        this.position();
      },

      selectBlank: function() {
        var blank = this.element.find('option').filter(function() {
          return !this.value || $.trim(this.value).length === 0;
        });

        if (blank.length > 0) {
          blank[0].selected = true;
          this.element.triggerHandler('updated').triggerHandler('change');
        }

      },

      handleKeyDown: function(input, e) {
        var selectedIndex = this.element[0].selectedIndex || -1,
            options = this.element[0].options,
            key = e.which,
            self = this,
            excludes = 'li:visible:not(.separator):not(.group-label):not(.is-disabled)',
            next;

        if (this.isLoading()) {
          return;
        }

        //Down arrow, Up arrow, or Spacebar to open
        if (!self.isOpen() && (key === 38 || key === 40 || key === 32)) {
          self.toggleList();
          return;
        }

        if (e.metaKey) {
          return ;
        }

        if (self.isOpen()) {
          options = this.listUl.find(excludes);
          selectedIndex = -1;
          $(options).each(function(index) {
            if ($(this).is('.is-focused')) {
              selectedIndex = index;
            }
          });
        }

        switch (key) {
          case 37: //backspace
          case 8: //del & backspace
          case 46: { //del

            if (!self.isOpen()) {
              self.selectBlank();
              // Prevent Backspace from returning to the previous page.
              e.stopPropagation();
              e.preventDefault();
              return false;
            }
            break;
          }
          case 9: {  //tab - save the current selection
            // If "search mode" is currently off, Tab should turn this mode on and place focus back
            // into the SearchInput.  If search mode is on, Tab should 'select' the currently highlighted
            // option in the list, update the SearchInput and close the list.
            if (self.isOpen()) {
              self.selectOption($(options[selectedIndex])); // store the current selection
              self.closeList('tab');
              this.activate();
            }
            // allow tab to propagate otherwise
            return true;
          }
          case 27: { //Esc - Close the Combo and Do not change value
            if (self.isOpen()) {
              // Close the option list
              self.element.closest('.modal.is-visible').data('listclosed', true);
              self.closeList('cancel');
              self.activate();
              e.stopPropagation();
              return false;
            }
            // Allow Esc to propagate if the menu was closed, since some other Controls
            // that rely on dropdown may need to trigger routines when the Esc key is pressed.
            break;
          }
          case 32: // spacebar // TODO: Figure Out what to do about using Spacebar.
          case 13: { //enter
            if (self.isOpen()) {
              if (key === 32 && self.searchKeyMode === true) {
                break;
              }

              e.preventDefault();

              self.selectOption($(options[selectedIndex])); // store the current selection
              if (self.settings.closeOnSelect) {
                self.closeList('select');  // Close the option list
                self.activate();
              }
            }
            e.stopPropagation();
            return false;
          }
          case 38: {  //up
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex > 0) {
              next = $(options[selectedIndex - 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next);
              // NOTE: Do not also remove the ".is-selected" class here!  It's not the same as ".is-focused"!
              // Talk to ed.coyle@infor.com if you need to know why.
              next.parent().find
              ('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          case 40: {  //down
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex < options.length - 1) {
              next = $(options[selectedIndex + 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next);
              // NOTE: Do not also remove the ".is-selected" class here!  It's not the same as ".is-focused"!
              // Talk to ed.coyle@infor.com if you need to know why.
              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          case 35: { //end
            this.searchKeyMode = false;

            var last = $(options[options.length - 1]);
            this.highlightOption(last);

            e.stopPropagation();
            return false;
          }
          case 36: {  //home
            this.searchKeyMode = false;

            var first = $(options[0]);
            this.highlightOption(first);

            e.stopPropagation();
            return false;
          }
        }

        if (self.isOpen() && self.isControl(key) && key !== 8) {
          return false;
        }

        var isSearchInput = self.searchInput && self.searchInput.length;

        self.initialFilter = false;

        if (!self.isOpen() && !self.isControl(key) && !this.settings.source && !this.settings.noSearch) {
          //Make this into Auto Complete
          self.initialFilter = true;
          self.isFiltering = true;
          self.filterTerm = $.actualChar(e);
          if (isSearchInput) {
            self.searchInput.val($.actualChar(e));
          }
          self.toggleList();
        }

        this.searchKeyMode = true;
        if (self.searchInput) {
          self.searchInput.attr('aria-activedescendant', '');
        }
        return true;
      },

      timer: null,
      filterTerm: '',

      handleAutoComplete: function(e) {
        if (this.isLoading()) {
          return;
        }

        var self = this;
        clearTimeout(this.timer);

        if (!self.settings.source) {
          return;
        }

        self.initialFilter = true;
        self.filterTerm += $.actualChar(e);

        this.timer = setTimeout(function () {
          if (!self.isOpen()) {
            self.searchInput.val(self.filterTerm);
            self.toggleList();
          } else {
            self.filterList(self.searchInput.val().toLowerCase());
          }
        }, self.settings.delay);
      },

      isControl: function(keycode) {
        var valid =
          (keycode > 7 && keycode < 48)   || // control chars
          (keycode > 90 && keycode < 94)   || // windows keys
          (keycode > 111 && keycode < 146);  // function keys

          return valid;
      },

      /**
      * Focus the input Element
      */
      activate: function (useSearchInput) {
        var self = this,
          input = this.pseudoElem;

        if (useSearchInput || self.isMobile()) {
          input = this.searchInput;
        }

        if (useSearchInput && (input.hasClass('is-readonly') || input.prop('readonly') === true)) {
          return;
        }

        function selectText() {
          if (self.isMobile()) {
            return;
          }

          if (input[0].setSelectionRange) {
            input[0].setSelectionRange(0, input[0].value.length);  //scroll to left
          } else {
            if (input[0].tagName === 'INPUT') { // using Search Input instead of Pseudo Div
              input[0].select();
            }
          }
        }

        selectText();

        if (document.activeElement !== input[0] &&
          $(document.activeElement).is('body, .dropdown.is-open')) {
          input[0].focus();
        }

        if (self.isIe10 || self.isIe11) {
          setTimeout(function() {
            input[0].focus();
          }, 0);
        }
      },

      // Retrieves a string containing all text for currently selected options delimited by commas
      getOptionText: function(opts) {
        var text = '';

        if (!opts) {
          opts = this.element.find('option:selected');
        }

        opts.each(function() {
          if (text.length > 0) {
            text += ', ';
          }
          text += $(this).text();
        });

        return text;
      },

      // Prep for opening list,make ajax call ect...
      open: function() {
        var self = this;

        if (!this.inputTimer()) {
          return;
        }

        if (this.element.is(':disabled') || this.pseudoElem.hasClass('is-disabled') || this.pseudoElem.hasClass('is-readonly')) {
          return;
        }

        if (!self.callSource(function () {
          self.updateList();
          self.openList();
        })) {
          self.updateList();
          this.openList();
        }
      },

      // Actually Show The List
      openList: function () {
        var current = this.previousActiveDescendant ? this.list.find('.dropdown-option[data-val="'+ this.previousActiveDescendant.replace('"', '/quot/') +'"]') : this.list.find('.is-selected'),
          self =  this,
          touchPrevented = false,
          threshold = 10,
          isEmpty = true,
          pos;

        if (current.length > 0) {
          isEmpty = true;
        }

        if (Soho.env.os.name === 'ios') {
          $('head').triggerHandler('disable-zoom');
        }

        // Persist the "short" input field
        var isShort = (this.element.closest('.field-short').length === 1);

        this.pseudoElem
          .attr('aria-expanded', 'true')
          .addClass('is-open');

        this.pseudoElem.attr('aria-label', this.label.text());
        this.searchInput.attr('aria-activedescendant', current.children('a').attr('id'));

        //Close any other drop downs.
        $('select').each(function () {
          var data = $(this).data();
          if (data.dropdown) {
            data.dropdown.closeList('cancel');
          }
        });

        this.list.appendTo('body').show();

        //In a grid cell
        this.isInGrid = this.pseudoElem.closest('.datagrid-row').length === 1;
        if (this.pseudoElem.parent().hasClass('is-inline')) {
          this.isInGrid = false;
        }

        if (this.isInGrid) {
          var rowHeight = this.pseudoElem.closest('.datagrid').attr('class').replace('datagrid', '');
          this.list.addClass('datagrid-dropdown-list ' + rowHeight);
        }

        if (this.pseudoElem.closest('.datagrid-filter-wrapper').length === 1) {
          this.list.addClass('datagrid-filter-dropdown');
        }

        var cssClass = this.settings.cssClass;
        if (cssClass && typeof cssClass === 'string') {
          this.list.addClass(cssClass);
        }

        this.position();

        // Limit the width
        if (this.settings.maxWidth) {
          this.list.css('max-width', this.settings.maxWidth + 'px');
        }

        if (!this.settings.multiple && this.initialFilter) {
          setTimeout(function () {
            self.searchInput.val(self.filterTerm);
            self.filterList(self.searchInput.val());
          }, 0);
          this.initialFilter = false;
        } else {
          // Change the values of both inputs and swap out the active descendant
          this.searchInput.val(this.pseudoElem.find('span').text().trim());
        }

        var noScroll = this.settings.multiple;
        this.highlightOption(current, noScroll);
        if (this.settings.multiple && this.listUl.find('.is-selected').length > 0) {
          this.highlightOption(this.listUl.find('.dropdown-option').eq(0));
          setTimeout(function() {
            self.listUl.scrollTop(0);
          }, 0);
        }

        if (!this.settings.multiple && !isEmpty) {
          this.searchInput.val(current.find('a').text());
        }

        this.handleSearchEvents();
        this.activate(true); // Focus the Search Input
        this.element.trigger('listopened');

        if (this.isMobile()) {
          // iOS-specific keypress event that listens for when you click the "done" button
          self.searchInput.on('keypress.dropdown', function(e) {
            if (e.which === 13) {
              self.closeList('select');
            }
          });
        }

        function listItemClickHandler(e) {
          var target = $(e.target),
            ddOption = target.closest('li');

          if (ddOption.length) {
            // Do nothing for group labels or separators
            if (ddOption.is('.separator, .group-label')) {
              return;
            }

            target = ddOption;
          }

          if (target.is('.dropdown-select-all-anchor')) {
            target = target.parent();
          }

          // If this is the Select All option, select/deselect all.
          if (self.settings.multiple && target.is('.dropdown-select-all-list-item')) {
            var doSelectAll = !(target.is('.is-selected'));
            if (doSelectAll) {
              target.addClass('is-selected');
              self.selectOptions(self.element.find('option:not(:selected)'), true);
            } else {
              target.removeClass('is-selected');
              self.selectOptions(self.element.find('option:selected'), true);
            }

            return true;
          }

          e.preventDefault();
          e.stopPropagation();

          var val = target.attr('data-val').replace('"','/quot/'),
            cur = self.element.find('option[value="'+ val +'"]');
          //Try matching the option's text if 'cur' comes back empty or overpopulated.
          //Supports options that don't have a 'value' attribute
          //And also some special &quote handling
          if (cur.length === 0 || cur.length > 1) {
            cur = self.element.find('option').filter(function() {
              var elem = $(this),
                attr = elem.attr('value');
              return elem.text() === val || (attr && attr.replace('"','/quot/') === val);
            });
          }

          //Select the clicked item
          if (cur.is(':disabled')) {
            return false;
          }

          self.selectOption(cur);

          if (self.settings.closeOnSelect) {
            self.closeList('select');
          }

          if (self.isMobile()) {
            return true;
          }

          self.activate(!self.settings.closeOnSelect);
          return true;
        }

        self.list
          .removeClass('dropdown-tall')
          .addClass(isShort ? 'dropdown-short' : '')
          .onTouchClick('list', 'li')
          .on('click.list', 'li', listItemClickHandler)
          .on('mouseenter.list', 'li', function() {
            var target = $(this);

            if (target.is('.separator, .group-label')) {
              return;
            }

            self.setItemIconOverColor(target);
            self.list.find('li').removeClass('is-focused');
            target.addClass('is-focused');
          });

        // Some list-closing events are on a timer to prevent immediate list close
        // There would be several things to check with a setTimeout, so this is done with a CSS
        // class to keep things a bit cleaner
        setTimeout(function delayedListCloseEvents() {
          self.list.addClass('is-closable');
        }, 100);

        // Is the jQuery Element a component of the current Dropdown list?
        function isDropdownElement(target) {
          return target.closest('.dropdown, .multiselect').length > 0 ||
            target.closest('.dropdown-list').length > 0 ||
            self.touchmove === true;
        }

        // Triggered when the user scrolls the page.
        // Ignores Scrolling on Mobile, and will not close the list if accessing an item within the list
        function scrollDocument(e) {
          if (touchPrevented || isDropdownElement($(e.target))) {
            return;
          }
          self.closeList('cancel');
        }

        // Triggered when the user clicks anywhere in the document
        // Will not close the list if the clicked target is anywhere inside the dropdown list.

        function clickDocument(e) {
          var target = $(e.target);
          if (touchPrevented || (isDropdownElement(target) && !target.is('.icon'))) {
            e.preventDefault();

            touchPrevented = false;
            return;
          }

          self.closeList('cancel');
        }

        function touchStartCallback(e) {
          touchPrevented = false;

          pos = {
            x: e.originalEvent.touches[0].pageX,
            y: e.originalEvent.touches[0].pageY
          };

          $(document).on('touchmove.dropdown', function touchMoveCallback(e) {
            var newPos = {
              x: e.originalEvent.touches[0].pageX,
              y: e.originalEvent.touches[0].pageY
            };

            if ((newPos.x >= pos.x + threshold) || (newPos.x <= pos.x - threshold) ||
                (newPos.y >= pos.y + threshold) || (newPos.y <= pos.y - threshold)) {
              touchPrevented = true;
            }
          });
        }

        function touchEndCallback(e) {
          $(document).off('touchmove.dropdown');
          e.preventDefault();

          if (touchPrevented) {
            return false;
          }

          clickDocument(e);
        }

        // Need to detect whether or not scrolling is happening on a touch-capable device
        // The dropdown list should not close on mobile if scrolling is occuring, but should close
        // if the user is simply tapping outside the list.
        $(document)
          .on('touchstart.dropdown', touchStartCallback)
          .on('touchend.dropdown touchcancel.dropdown', touchEndCallback)
          .on('click.dropdown', clickDocument);

        var modalScroll = $('.modal.is-visible .modal-body-wrapper'),
          parentScroll = self.element.closest('.scrollable').length ? self.element.closest('.scrollable') : $(document);
        parentScroll = self.element.closest('.scrollable-y').length ? self.element.closest('.scrollable-y') : parentScroll;
        parentScroll = modalScroll.length ? modalScroll : parentScroll;
        parentScroll.on('scroll.dropdown', scrollDocument);

        $('body').on('resize.dropdown', function() {
          self.position();

          // in desktop environments, close the list on viewport resize
          if (window.orientation === undefined) {
            self.closeList('cancel');
          }
        });

        // In mobile environments, close the list on an orientation change.
        // Don't do this on mobile against a resize because of the software keyboard's potential
        // to cause a "resize" event to fire.
        if (window.orientation !== undefined) {
          $(window).on('orientationchange.dropdown', function() {
            self.closeList('cancel');
          });
        }

        if (Soho.env.os.name === 'ios') {
          $('head').triggerHandler('enable-zoom');
        }
      },

      /**
       * Set size and positioning of the list
       * @private
       */
      position: function() {
        var self = this,
          positionOpts = {
            parentXAlignment: 'left',
            placement: 'bottom',
            strategies: ['flip', 'shrink-y']
          };

        function dropdownAfterPlaceCallback(e, placementObj) {
          // Turn upside-down if flipped to the top of the pseudoElem
          if (placementObj.wasFlipped === true) {
            self.list.addClass('is-ontop');
            self.listUl.prependTo(self.list);
          }

          // Set the <UL> height to 100% of the `.dropdown-list` minus the size of the search input
          var ulHeight = parseInt(window.getComputedStyle(self.listUl[0]).height),
            listHeight = parseInt(window.getComputedStyle(self.list[0]).height),
            searchInputHeight = 34;
          if (ulHeight + searchInputHeight > listHeight) {
            self.listUl[0].style.height = (listHeight - searchInputHeight) + 'px';
          }

          return placementObj;
        }

        // Reset styles that may have been appended to the list
        this.list[0].removeAttribute('style');
        this.listUl[0].removeAttribute('style');

        var parentElement = this.pseudoElem;
        if (this.isInGrid) {
          parentElement = this.element.closest('.datagrid-cell-wrapper');
        }

        // If the list would end up being wider parent,
        // use the list's width instead of the parent's width
        var parentElementStyle = window.getComputedStyle(parentElement[0]),
          parentElementBorderWidth = parseInt(parentElementStyle.borderLeftWidth) * 2,
          parentElementWidth = Math.round(parseInt(parentElement[0].clientWidth) + parentElementBorderWidth),
          listDefaultWidth, useParentWidth;

        // Temporarily shrink the value of the search input, and compare the size of the list to
        // the parent element.
        this.searchInput[0].style.cssText = 'width: '+ parentElementWidth +'px !important';
        listDefaultWidth = Math.round(this.list.width());
        useParentWidth = listDefaultWidth <= parentElementWidth;
        this.searchInput[0].style.width = '';

        // Add parent info to positionOpts
        positionOpts.parent = parentElement;
        positionOpts.useParentWidth = useParentWidth;

        // use negative height of the pseudoElem to get the Dropdown list to overlap the input.
        var isRetina = window.devicePixelRatio > 1,
          isChrome = Soho.env.browser.name === 'chrome';
        positionOpts.y = -(parseInt(parentElement[0].clientHeight) + parseInt(parentElementStyle.borderTopWidth) + parseInt(parentElementStyle.borderBottomWidth) - (!isChrome && isRetina ? 1 : 0));
        positionOpts.x = 0;

        this.list.one('afterplace.dropdown', dropdownAfterPlaceCallback).place(positionOpts);
        this.list.data('place').place(positionOpts);
      },

      // Alias that works with the global "closeChildren" method.  See "js/lifecycle.js"
      close: function() {
        return this.closeList('cancel');
      },

      //Close list and detach events
      closeList: function(action) {
        if (!this.list || !this.list.is(':visible') || !this.isListClosable()) {
          return;
        }

        if (!this.inputTimer()) {
          return;
        }

        if (this.touchmove) {
          this.touchmove = false;
        }

        this.filterTerm = '';
        this.searchInput.off('keydown.dropdown keypress.dropdown keypress.dropdown');

        //Destroy any tooltip items
        this.listUl.find('.has-tooltip').each(function () {
          var api = $(this).data('tooltip');
          if (api) {
            api.destroy();
          }
        });

        this.list
          .off('click.list touchmove.list touchend.list touchcancel.list mousewheel.list mouseenter.list')
          .remove();

        this.pseudoElem
          .removeClass('is-open')
          .attr('aria-expanded', 'false');

        this.searchInput
          .removeAttr('aria-activedescendant');

        $(document)
          .off('click.dropdown scroll.dropdown touchmove.dropdown touchend.dropdown touchcancel.dropdown');

        $('body').off('resize.dropdown');
        $(window).off('orientationchange.dropdown');
        this.element.trigger('listclosed', action);
        this.activate();
        this.list = null;
        this.searchInput = null;
        this.listUl = null;
      },

      //Set option into view
      scrollToOption: function(current) {
        var self = this;
        if (!current) {
          return;
        }
        if (current.length === 0) {
          return;
        }
        // scroll to the currently selected option
        self.listUl.scrollTop(0);
        self.listUl.scrollTop(current.offset().top - self.listUl.offset().top - self.listUl.scrollTop() - 40);
      },

      //Blur and Close List
      handleBlur: function() {
        var self = this;

        if (this.isOpen()) {
          this.timer = setTimeout(function() {
            self.closeList('cancel');
          }, 40);
        }

        return true;
      },

      // returns true if the field is attempting to load via AJAX.
      isLoading: function() {
        return this.element.is('.is-loading') &&  this.element.is('.is-blocked') ;
      },

      // Return true/false if the list is open
      isOpen: function() {
        return (this.list && this.list.is(':visible')) ? true : false;
      },

      // Hide or Show list
      toggleList: function() {
        if (this.isOpen() || this.isLoading()) {
          this.closeList('cancel');
          return;
        }
        this.open();
      },

      highlightOption: function(listOption, noScroll) {
        if (!listOption) {
          return listOption;
        }

        if (listOption.length === 0) {
          listOption = this.list.find('.dropdown-option').eq(0);
        }

        // Get corresponding option from the list
        var option = this.element.find('option[value="' + listOption.attr('data-val') + '"]');

        if (option.hasClass('.is-disabled') || option.is(':disabled')) {
          return;
        }

        if (this.isOpen()) {
          this.setItemIconOverColor();
          this.list.find('.is-focused').removeClass('is-focused').attr({'tabindex':'-1'});
          if (!option.hasClass('clear')) {
            this.setItemIconOverColor(listOption);
            listOption.addClass('is-focused').attr({'tabindex': '0'});
          }

          // Set activedescendent for new option
          //this.pseudoElem.attr('aria-activedescendant', listOption.attr('id'));
          this.searchInput.attr('aria-activedescendant', listOption.children('a').attr('id'));

          if (!noScroll || noScroll === false || noScroll === undefined) {
            this.scrollToOption(listOption);
          }
        }

        return;
      },

      unhighlightOptions: function(listOptions, noScroll) {
        if (!listOptions || !listOptions.length) {
          listOptions = this.list.find('.is-selected');
        }
        this.setItemIconOverColor();
        listOptions.removeClass('is-focused').attr({'tabindex': '-1'});

        this.searchInput.removeAttr('aria-activedescendant');

        if (!noScroll || noScroll === false || noScroll === undefined) {
          this.scrollToOption(listOptions.first());
        }
      },

      /**
       * Convenience method for running _selectOption()_ on a set of list options.
       * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
       * @private
       * @param {Array / jQuery[]} options - incoming options
       * @param {Boolean} noTrigger - if true, causes the 'selected' and 'change' events not to fire on each list item.
       */
      selectOptions: function(options, noTrigger) {
        // Use a jQuery selector if the incoming options are inside an array
        if (Array.isArray(options)) {
          options = $(options);
        }

        var self = this;
        options.each(function() {
          self.selectOption($(this), noTrigger);
        });
      },

      /**
       * Select an option and conditionally trigger events.
       * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
       * @private
       * @param {jQuery} option - the incoming li option
       * @param {boolean} noTrigger - if true, causes the 'selected' and 'change' events not to fire on the list item.
       */
      selectOption: function(option, noTrigger) {
        if (!option) {
          return option;
        }
        var li;

        if (option.is('li')) {
          li = option;
          option = this.element.find('option[value="' + option.attr('data-val') + '"]');

          //Try matching the option's text if 'cur' comes back empty.
          //Supports options that don't have a 'value' attribute.
          if (option.length === 0) {
            option = this.element.find('option').filter(function() {
              return $(this).text() === li.attr('data-val');
            });
          }
        }

        var value = option.val();
        if (!option) {
          return;
        }

        if (!li && typeof value === 'string') {
          li = this.listUl.find('li[data-val="'+ value.replace('"', '/quot/') +'"]');
        }

        if (option.hasClass('is-disabled') || option.is(':disabled')) {
          return;
        }

        var code = option.val(),
          val = this.element.val(),
          oldText = this.pseudoElem.text(),
          text = '',
          trimmed = '',
          clearSelection = false,
          isAdded = true; // Sets to false if the option is being removed from a multi-select instead of added

        if (option.hasClass('clear') || !li) {
          clearSelection = true;
        }

        if (this.settings.multiple) {
          // Working with a select multiple allows for the "de-selection" of items in the list
          if (!val) {
            val = [];
          }
          if ($.inArray(code, val) !== -1) {
            val = $.grep(val, function(optionValue) {
              return optionValue !== code;
            });
            li.removeClass('is-selected');
            this.previousActiveDescendant = undefined;
            isAdded = false;
          } else {
            if (!isNaN(this.settings.maxSelected) && this.element.find('option:selected').length >= this.settings.maxSelected) {
              return;
            }

            val = typeof val === 'string' ? [val] : val;
            val.push(code);
            li.addClass('is-selected');
            this.previousActiveDescendant = option.val();
          }

          var newOptions = this.element.find('option').filter(function() {
            return $.inArray($(this)[0].value, val) !== -1;
          });
          text = this.getOptionText(newOptions);
        } else {
          // Working with a single select
          val = code;
          this.listUl.find('li.is-selected').removeClass('is-selected');
          if (!clearSelection) {
            li.addClass('is-selected');
          }
          this.previousActiveDescendant = option.val();
          text = option.text();
        }
        if (!clearSelection) {
          this.element.find('option').each(function () {
            if (this.value === code) {
              this.selected = true;
              return false;
            }
          });
        }
        // If we're working with a single select and the value hasn't changed, just return without
        // firing a change event
        if (text === oldText) {
          return;
        }

        // Change the values of both inputs and swap out the active descendant
        if (!clearSelection) {
          this.pseudoElem.find('span').text(text);
          this.searchInput.val(text);
        } else {
          this.pseudoElem.find('span').text('');
          this.searchInput.val('');
        }

        if (this.element.attr('maxlength')) {
          trimmed = text.substr(0, this.element.attr('maxlength'));
          this.pseudoElem.find('span').text(trimmed);
          this.searchInput.val(trimmed);
        }

        // Set the new value on the <select>
        this.element.val(val);
        this.updateItemIcon(option);

        // Fire the change event with the new value if the noTrigger flag isn't set
        if (!noTrigger) {
          this.element.trigger('change').triggerHandler('selected', [option, isAdded]);
        }

        // If multiselect, reset the menu to the unfiltered mode
        if (this.settings.multiple) {
          if (this.list.hasClass('search-mode')) {
            this.resetList();
          }
          this.activate(true);
        }

        this.setBadge(option);
      },

      /**
       * Select an option by the value.
       *
       * @param {value} option - A string containing the value to look for. (Case insensitive)
       */
      selectValue: function(value) {

        if (typeof value === 'string') {
          var option = this.element.find('option[value="' + value + '"]');
          this.element.find('option:selected').removeAttr('selected');
          option.attr('selected', 'true');
          this.updated();
        }

      },

      setBadge: function (option) {
        //Badge Support
        if (this.badges) {
          var badge = this.element.parent().find('.badge');

          if (badge.length === 0) {
            this.element.parent().find('.dropdown-wrapper').append('<span class="badge">1</span>');
            badge = this.element.parent().find('.badge');
          }

          badge.attr('class', 'badge ' + (option.attr('data-badge-color') ? option.attr('data-badge-color') : 'azure07'))
            .text(option.attr('data-badge'));
        }
      },

      // Execute the source ajax option
      callSource: function(callback) {
        var self = this, searchTerm = '';

        if (this.settings.source) {
          this.isFiltering = false;

          var sourceType = typeof this.settings.source,
            response = function (data, isManagedByTemplate) {
            //to do - no results back do not open.
            var list = '',
              val = self.element.val();

            function replaceDoubleQuotes(content) {
              return content.replace('"', '\'');
            }

            function buildOption(option) {
              if (option === null || option === undefined) {
                return;
              }

              var isString = typeof option === 'string',
                stringContent = option;

              if (isString) {
                option = {
                  value: stringContent
                };
              }

              if (option.value !== undefined) {
                option.value = replaceDoubleQuotes(option.value);
              }

              if (option.id !== undefined) {
                if (!isNaN(option.id)) {
                  option.id = '' + option.id;
                }
                option.id = replaceDoubleQuotes(option.id);
              }

              if (option.label !== undefined) {
                option.label = replaceDoubleQuotes(option.label);
              }

              if (!option.selected && option.value === val) {
                option.selected = true;
              }

              list += '<option' + (option.id === undefined ? '' : ' id="' + option.id + '"') +
                        ' value="' + option.value + '"' +
                        (option.selected ? ' selected ' : '') +
                      '>'+ (option.label !== undefined ? option.label : option.value !== undefined ? option.value : '') + '</option>';
            }

            // If the incoming dataset is different than the one we started with,
            // replace the contents of the list, and rerender it.
            if (!self.isFiltering && !Soho.utils.equals(data, self.dataset)) {
              self.dataset = data;

              if (!isManagedByTemplate) {
                self.element.empty();
                for (var i=0; i < data.length; i++) {
                  var opts;

                  if (data[i].group) {
                    opts = data[i].options;
                    list += '<optgroup label="' + data[i].group + '">';
                    for (var ii = 0; ii < opts.length; ii++) {
                      buildOption(opts[ii]);
                    }
                    list += '</optgroup>';
                  } else {
                    buildOption(data[i]);
                  }
                }

                self.element.append(list);
              }
              self.updateList();
            }

            self.element.triggerHandler('complete'); // For Busy Indicator
            self.element.trigger('requestend', [searchTerm, data]);
            callback();
            return;
          };

          self.element.triggerHandler('start'); // For Busy Indicator
          self.element.trigger('requeststart');

          if (sourceType === 'function') {
            // Call the 'source' setting as a function with the done callback.
            this.settings.source(response, searchTerm, this.settings.sourceArguments);
          } else if (sourceType === 'object') {
            // Use the 'source' setting as pre-existing data.
            // Sanitize accordingly.
            var sourceData = $.isArray(this.settings.source) ? this.settings.source : [this.settings.source];
            response(sourceData);
          } else {
            // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
            var sourceURL = this.settings.source.toString(),
              request = $.getJSON(sourceURL);

            request.done(function(data) {
              response(data);
            }).fail(function() {
              response([]);
            });
          }

          return true;
        }
        return false;
      },

      /**
       * Get data attributes from passed list of attributes
       * @param {Array} attr - List of all attributes.
       * @param {Array} attrToExclude - List of attributes to be excluded from passed list.
       * @returns {Object} It will return an object containing two keys
       * str - string of attributes
       * obj - object of attributes
       */
      getDataAttributes: function(attr, attrToExclude) {
        if (!attr) {
          return;
        }
        else if (typeof attr === 'string') {
          attr = [attr];
        }

        var toExclude = attrToExclude || [];
        if (typeof toExclude === 'string') {
          toExclude = [toExclude];
        }
        var attrToCopy = {
          obj: {},
          str: '',
          isExclude: function(attr) {
            return $.inArray(attr, toExclude) > -1;
          }
        };
        for (var key in attr) {
          if (!attr.hasOwnProperty(key)) {
            continue;
          }
          attrToCopy.name = attr[key].name + '';
          attrToCopy.isData = attrToCopy.name.substr(0, 5) === 'data-';
          if (attrToCopy.isData && !attrToCopy.isExclude(attrToCopy.name)) {
            attrToCopy.obj[attrToCopy.name] = attr[key].value;
            attrToCopy.str += ' '+
              attrToCopy.name +'="'+ attr[key].value +'"';
          }
        }
        return { str: attrToCopy.str, obj: attrToCopy.obj };
      },

      /**
       * External Facing function to set value by code - Depricated set on select and trigger updated.
       *
       * @param {String} code - The value to match and set on the value element.
       */
      setCode: function(code) {
        var self = this,
          doSetting = function ()  {
            self.element.val(code);
            self.updated();
          };

        if (!self.callSource(doSetting)) {
          doSetting();
        }
      },

      isMobile: function() {
        return ['ios', 'android'].indexOf(Soho.env.os.name) > -1;
      },

      isListClosable: function() {
        return this.list.hasClass('is-closable');
      },

      /**
       * Disable the input element.
       */
      disable: function() {
        this.element
          .prop('disabled', true)
          .prop('readonly', false);

        if (this.pseudoElem.is($(document.activeElement))) {
          this.pseudoElem.blur();
        }

        this.pseudoElem
          .addClass('is-disabled')
          .removeClass('is-readonly')
          .attr('tabindex', '-1')
          .prop('readonly', false)
          .prop('disabled', true);
        this.closeList('cancel');
      },

      /**
      * Returns true if the dropdown is disabled.
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Enable the input element.
       */
      enable: function() {
        this.element
          .prop('disabled', false)
          .prop('readonly', false);
        this.pseudoElem
          .prop('disabled', false)
          .prop('readonly', false)
          .attr('tabindex', '0')
          .removeClass('is-disabled')
          .removeClass('is-readonly');
      },

      /**
       * Make the input element readonly.
       */
      readonly: function() {
        this.element
          .prop('disabled', false)
          .prop('readonly', true);
        this.pseudoElem
          .removeClass('is-disabled')
          .addClass('is-readonly')
          .attr('tabindex', '0')
          .prop('disabled', false)
          .prop('readonly', true);
        this.closeList('cancel');
      },

      // Triggered whenever the plugin's settings are changed
      updated: function() {
        this.closeList('cancel');

        // Update the 'multiple' property
        if (this.settings.multiple && this.settings.multiple === true) {
          this.element.prop('multiple', true);
        } else {
          this.element.prop('multiple', false);
        }

        // update "readonly" prop
        if (this.element.prop('readonly') === true) {
          this.readonly();
        } else {
          this.pseudoElem.removeClass('is-readonly');
        }

        // update "disabled" prop
        this.pseudoElem[ this.element.prop('disabled') ? 'addClass' : 'removeClass' ]('is-disabled');

        // update the list and set a new value, if applicable
        this.updateList();
        this.setValue();

        this.element.trigger('has-updated');

        return this;
      },

      /**
       * Tear down events and restore to default.
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.closeList('cancel');
        this.label.remove();
        this.pseudoElem.off().remove();
        this.icon.remove();
        this.wrapper.remove();
        this.listfilter.destroy();
        this.element.removeAttr('style');
      },

      /**
       *  This component fires the following events.
       *
       * @fires Dropdown#events
       * @param {Object} listopened  &nbsp;-&nbsp; Fires as the calendar popup is opened
       * @param {Object} listclosed  &nbsp;-&nbsp; Fires as the calendar popup is closed
       * @param {Object} change  &nbsp;-&nbsp; Fires after the value in the input is changed by any means.
       * @param {Object} input  &nbsp;-&nbsp; Fires after the value in the input is changed by user interaction.
       *
       */
      handleEvents: function() {
        var self = this;

        this.pseudoElem.on('keydown.dropdown', function(e) {
          self.ignoreKeys($(this), e);
          self.handleKeyDown($(this), e);
        }).on('keypress.dropdown', function(e) {
          if (e.keyCode === 9) {
            return;
          }
          self.ignoreKeys($(this), e);

          if (!self.settings.noSearch && e.keyCode !== 27) {
            self.toggleList();
          }
          self.handleAutoComplete(e);
        }).on('click.dropdown', function(e) {
          // landmark would like the click event to bubble up if ctrl and shift are pressed
          if (!(e.originalEvent.ctrlKey && e.originalEvent.shiftKey)) {
            e.stopPropagation();
          }
        }).on('mouseup.dropdown', function(e) {
          if (e.button === 2) {
            return;
          }
          self.toggleList();
        }).on('touchend.dropdown touchcancel.dropdown', function(e) {
          e.stopPropagation();
          self.toggleList();
          e.preventDefault();
        });

        self.element.on('activated.dropdown', function () {
          self.label.trigger('click');
        }).on('updated.dropdown', function (e) {
          e.stopPropagation();
          self.updated();
        }).on('openlist.dropdown', function() {
          self.toggleList();
        });

        //for form resets.
        self.element.closest('form').on('reset.dropdown', function() {
          setTimeout(function () {
            self.element.triggerHandler('updated');
          }, 1);
        });

        //Handle Label click
        this.label.onTouchClick().on('click', function () {
          self.pseudoElem.focus();
        });

      }

    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);

      if (instance) {
        instance.settings = $.extend({}, settings, instance.settings);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Dropdown(this, settings));
      }
    });
  };


  $.fn.drag = function(options) {
    //TODO: Resize: http://stackoverflow.com/questions/8258232/resize-an-html-element-using-touches
    // Similar: https://github.com/desandro/draggabilly
    'use strict';

    // Settings and Options
    var pluginName = 'drag',
      defaults = {
        axis: null,
        clone: false,
        cloneCssClass: 'is-clone',
        clonePosIsFixed: false,
        cloneAppendTo: null,
        containment: false,
        obstacle: false,
        underElements: false,
        containmentOffset: {left: 0, top: 0}
      },
      settings = $.extend({}, defaults, options);

    /**
    * Drag/Drop functions with touch support.
    *
    * @class Drag
    * @param {String} axis  &nbsp;-&nbsp; Constrains dragging to either axis. Possible values: null, 'x', 'y'
    * @param {Boolean} clone  &nbsp;-&nbsp;  Set to true to clone the object to drag. In many situations this is needed to break out of layout.
    * @param {String} cloneCssClass  &nbsp;-&nbsp; Css class added to clone element (defaults to is-clone)
    * @param {Boolean} clonePosIsFixed  &nbsp;-&nbsp; if true cloned object will use css style "position: fixed"
    * @param {String} cloneAppendTo  &nbsp;-&nbsp; Selector to append to for the clone ['body'|'parent'|'jquery object'] default:'body'
    * @param {Boolean} containment  &nbsp;-&nbsp; Constrains dragging to within the bounds of the specified element or region. Possible values: "parent", "document", "window".
    * @param {String} obstacle  &nbsp;-&nbsp; jQuery Selector of object(s) that you cannot drag into,
    * @param {Boolean} underElements  &nbsp;-&nbsp; If set to true will return list of elements that are "underneath" the drag element
    * @param {String} containmentOffset  &nbsp;-&nbsp; How close to the containment object should we be allowed to drag in position form. `{left: 0, top: 0}`
    *
    */
    function Drag(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Drag.prototype = {

      init: function() {
        this.handleEvents();
      },

      //Trigger events and remove clone
      finish: function (left, top) {
        var pos = {top: top, left: left};

        this.element.off('mouseup.draggable');
        $(document).off('mousemove.draggable mouseup.draggable');
        if (this.settings.underElements) {
          pos.underElements = this.getElementsFromPoint(pos.left, pos.top);
        }

        this.element.trigger('dragend', pos);
        this.element.removeClass('is-dragging');

        if (this.clone) {
          if (settings.axis === 'x') {
            delete pos.top;
          }

          if (settings.axis === 'y') {
            delete pos.left;
          }
          //this.element.css(pos);
          this.clone.remove();
          this.clone = null;
        }

        //Clear Cached Sizes
        if (this.obstacle) {
          this.obstacle = null;
        }
        if (this.upperYLimit) {
          this.upperYLimit = null;
        }
        if (this.upperXLimit) {
          this.upperXLimit = null;
        }
        $('body').removeClass('disable-select');
      },

      //Move the object from the event coords
      move: function(left, top) {
        var self = this;

        var css = {
          left: left,
          top: top
        };

        //X-Y Axis
        if (settings.axis === 'x') {
          delete css.top;
        }

        if (settings.axis === 'y') {
          delete css.left;
        }

        if (settings.containment) {

          if (settings.containment === 'parent') {
            this.container = this.element.parent();
          } else if (settings.containment === 'window') {
            this.container = $(window);
          } else if (settings.containment === 'container') {
            this.container = this.element.closest('.page-container');
          } else {
            this.container = $(document);
          }

          if (!this.upperXLimit) {
            this.upperXLimit = this.container.width() - this.element.outerWidth() + settings.containmentOffset.left;
          }
          if (!this.upperYLimit) {
            this.upperYLimit = this.container.height() - this.element.outerHeight() + settings.containmentOffset.top;
          }
          if (css.top > this.upperYLimit) {
            css.top = this.upperYLimit;
          }

          if (css.left > this.upperXLimit) {
            css.left = this.upperXLimit;
          }

          if (css.top < 0) {
            css.top = 0;
          }

          if (css.left < 0) {
            css.left = 0;
          }

          if (settings.containment === 'container' && css.left <= 1) {
            css.left = 1;
          }
        }

        if (settings.obstacle) {
          var elemOffset = (this.clone ? this.clone.offset() : this.element.offset()),
            elemWidth = (this.clone ? this.clone.outerWidth() : this.element.outerWidth()),
            movingRight = css.left > elemOffset.left;

          // Caching this so drag is not jaggie
          if (!this.obstacle) {
            this.obstacle = $(settings.obstacle).not(this.element);
            var obstacleOffset = $(this.obstacle).offset();

            this.constraints = {
              top: obstacleOffset.top,
              left: obstacleOffset.left,
              bottom: obstacleOffset.top + this.obstacle.outerHeight(),
              right: obstacleOffset.left + this.obstacle.outerWidth()
            };
          }

          if (!movingRight && self.originalPos.left > this.constraints.left && css.left <= this.constraints.right) {
            css.left = this.constraints.right;
          }

          if (movingRight && self.originalPos.left + elemWidth <= this.constraints.left && css.left + elemWidth >= this.constraints.left) {
            css.left = (this.constraints.left - this.obstacle.outerWidth());
          }

          //TODO: Moving Down
        }

        var applyCssStyle = function(el, css, prop) {
          if (typeof css[prop] !== 'undefined') {
            el[0].style[prop] = css[prop] +'px';
          }
        };
        applyCssStyle((this.clone || this.element), css, 'top');
        applyCssStyle((this.clone || this.element), css, 'left');

        if (this.settings.underElements) {
          css.underElements = this.getElementsFromPoint(css.left, css.top);
        }

        this.element.trigger('drag', css);
      },

      /**
      * Get elements from given point.
      * @param {number} x &nbsp;-&nbsp; The x-coordinate of the Point.
      * @param {number} y &nbsp;-&nbsp; The y-coordinate of the Point.
      * @return {Array} List of all elements at the given point.
      */
      getElementsFromPoint: function(x, y) {
        var elements = [];

        if (document.elementsFromPoint) {
          elements = document.elementsFromPoint(x, y);
        }
        else if (document.msElementsFromPoint) {
          elements = document.msElementsFromPoint(x, y);
        }
        else {
          var i, l, d, current,
            max = 999,
            pointerEvents = [];

          while ((current = document.elementFromPoint(x,y)) && elements.indexOf(current) === -1 && current !== null && max > -1) {
            max--;
            // push the element and its current style
            elements.push(current);
            pointerEvents.push({
              value: current.style.getPropertyValue('pointer-events') || '',
              priority: current.style.getPropertyPriority('pointer-events')
            });
            // add "pointer-events: none", to get to the underlying element
            current.style.setProperty('pointer-events', 'none', 'important');
          }
          // restore the previous pointer-events values
          for (i = 0, l = elements.length; i < l; i++) {
            d = pointerEvents[i];
            elements[i].style.setProperty('pointer-events', d.value, d.priority);
          }
        }
        return elements;
      },

      /**
      * Detach all functionality and events.
      */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('touchstart.draggable MSPointerDown.draggable pointerdown.draggable touchmove.draggable touchend.draggable touchcancel.draggable mousedown.draggable');
      },

      /**
       *  This component fires the following events.
       *
       * @fires Drag#events
       * @param {Object} dragstart  &nbsp;-&nbsp; When the dragging is initiated. Use this to customize/style the drag/drop objects in the DOM.
       * @param {Object} drag  &nbsp;-&nbsp; Fires (many times) while dragging is occuring. Use this for DOM feedback but be careful about what you do in here for performance.
       * @param {Object} dragend  &nbsp;-&nbsp; Fires after the drag is completed. Use this to remove / set drag feedback off.
       *
       */
      handleEvents: function() {
        var self = this;
        self.offset = null;

        //Touch and Drag Support
        self.element.attr('draggable', false);

        if ('onpointerdown' in window || 'onmspointerdown' in window) {
          // TODO: Setup Pointer Events for IE10/11 - pointerdown MSPointerDown, pointermove MSPointerMove, pointerup MSPointerUp
        } else {

          //Touch-only Drag Support
          self.element.on('touchstart.draggable gesturestart.draggable', function(e) {
            var pos = $(this).position(),
                orig = e.originalEvent;

            self.offset = {
              x:  orig.changedTouches[0].pageX - pos.left,
              y:  orig.changedTouches[0].pageY - pos.top
            };

            self.originalPos = pos;
            self.element.addClass('is-dragging');
            self.element.trigger('dragstart', pos);
          })

          // Move
          .on('touchmove.draggable gesturechange.draggable', function(e) {
            e.preventDefault();
            var orig = e.originalEvent;

            // do now allow two touch points to drag the same element
            if (orig.targetTouches.length > 1) {
              return;
            }
            self.move(orig.changedTouches[0].pageX - self.offset.x, orig.changedTouches[0].pageY - self.offset.y);
          })

          //Finish Touch Dragging
          .on('touchend.draggable gestureend.draggable touchcancel.draggable', function (e) {
            e.preventDefault();
            var touch = e.originalEvent.changedTouches[0];
            self.finish(touch.pageX - self.offset.x, touch.pageY - self.offset.y);
          });

        }

        // Always bind mousedown in either scenario, in the event that a mouse is used
        self.element.on('mousedown.draggable', function(e) {
          e.preventDefault();

          var pos = settings.clonePosIsFixed ?
            self.element[0].getBoundingClientRect() : self.element.position();

          //Save offset
          self.offset = {
            x: e.pageX - pos.left,
            y: e.pageY - pos.top
          };

          self.originalPos = pos;

          //Prevent Text Selection
          $('body').addClass('disable-select');

          //Handle Mouse Press over draggable element
          $(document).on('mousemove.draggable', function (e) {
            e.preventDefault();
            self.move(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          //Handle Mouse release over draggable element close out events and trigger
          $(document).on('mouseup.draggable', function (e) {
            e.preventDefault();
            self.finish(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          self.element.on('mouseup.draggable', function (e) {
            e.preventDefault();
            self.finish(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          //Trigger dragging
          //Clone
          if (!self.clone && settings.clone) {
            self.clone = self.element.clone(true);
            if (settings.cloneAppendTo === 'parent') {
              settings.cloneAppendTo = self.element.parent();
            }
            self.clone
              .addClass(settings.cloneCssClass)
              .appendTo(settings.cloneAppendTo || 'body');

          }

          self.element.addClass('is-dragging');
          self.element.trigger('dragstart', [pos, self.clone]);
        });

      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Drag(this, settings));
      }
    });
  };


  $.fn.editor = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'editor',
      defaults = {
        buttons: {
          editor: [
            'header1', 'header2',
            'separator', 'bold', 'italic', 'underline', 'strikethrough',
            'separator', 'foreColor', 'backColor',
            'separator', 'justifyLeft', 'justifyCenter', 'justifyRight',
            'separator', 'quote', 'orderedlist', 'unorderedlist',
            'separator', 'anchor',
            'separator', 'image',
            'separator', 'source'
          ],
          source: [
            'visual'
          ]
        },
        excludeButtons: {
          editor: ['backColor'],
          source: []
        },
        delay: 200,
        firstHeader: 'h3',
        secondHeader: 'h4',
        placeholder: null,
        pasteAsPlainText: false,
        // anchor > target: 'Same window'|'New window'| any string value
        anchor: {url: 'http://www.example.com', class: 'hyperlink', target: 'New window', isClickable: false, showIsClickable: false},
        image: {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}
      },
      settings = $.extend({}, defaults, options);

    /**
    * The Editor Component is displays and edits markdown.
    *
    * @class Editor
    * @param {String} firstHeader  &nbsp;-&nbsp; Allows you to set if the first header inserted is a h3 or h4 element. You should set this to match the structure of the parent page for accessibility
    * @param {Boolean} secondHeader  &nbsp;-&nbsp; Allows you to set if the second header inserted is a h3 or h4 element. You should set this to match the structure of the parent page for accessibility
    * @param {String} productName  &nbsp;-&nbsp; Additional product name information to display
    * @param {String} pasteAsPlainText  &nbsp;-&nbsp; If true, when you paste into the editor the element will be unformatted to plain text.
    * @param {String} anchor  &nbsp;-&nbsp; Info object to populate the link dialog defaulting to `{url: 'http://www.example.com', class: 'hyperlink', target: 'New window', isClickable: false, showIsClickable: false},`
    * @param {String} image  &nbsp;-&nbsp; Info object to populate the image dialog defaulting to ` {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}`
    */
    function Editor(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);

      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Editor.prototype = {

      init: function() {
        this.isIe = Soho.env.browser.name === 'ie';
        this.isIeEdge = Soho.env.browser.name === 'edge';
        this.isIe11 = this.isIe && Soho.env.browser.version === '11';
        this.isMac = Soho.env.os.name === 'Mac OS X';
        this.isFirefox = Soho.env.browser.name === 'firefox';

        this.parentElements = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre'];
        this.id = this.element.uniqueId('editor') + 'Unique';
        this.container = this.element.parent('.field, .field-short').addClass('editor-container');

        settings.anchor = $.extend({}, defaults.anchor, settings.anchor);
        settings.image = $.extend({}, defaults.image, settings.image);

        settings.anchor.defaultUrl = settings.anchor.url;
        settings.anchor.defaultClass = settings.anchor.class;
        settings.anchor.defaultTargetText = settings.anchor.target;
        settings.anchor.defaultIsClickable = settings.anchor.isClickable;

        settings.anchor.targets = {
          'Same window': '',
          'New window': '_blank'
        };
        $.each(settings.anchor.targets, function(key, val) {
          if ((settings.anchor.defaultTargetText).toLowerCase() === (key).toLowerCase()) {
            settings.anchor.target = val;
            settings.anchor.defaultTarget = val;
          }
        });
        if (!settings.anchor.defaultTarget) {
          if(settings.anchor.target && $.trim(settings.anchor.target).length) {
            settings.anchor.defaultTarget = settings.anchor.target;
          } else {
            settings.anchor.defaultTargetText = 'Same window';
            settings.anchor.defaultTarget = settings.anchor.targets[settings.anchor.defaultTargetText];
          }
        }
        return this.setup();
      },

      setup: function () {
        this.isActive = true;
        this.modals = {};
        this.initElements()
          .bindSelect()
          .bindPaste()
          .setPlaceholders()
          .bindWindowActions()
          .setupKeyboardEvents()
          .onPasteTriggered();
      },

      initElements: function () {
        var i,
          elem = this.element;

        //Make it an editor
        elem.attr({'contentEditable': true, 'aria-multiline': true, 'role': 'textbox'});

        //Bind functionality for Pre elements. We dont use this yet but could if we want to edit code blocks.
        elem.attr('data-editor', true);
        this.bindParagraphCreation(i).bindTab(i);

        this.initToolbar()
          .bindButtons()
          .bindModals()
          .bindAnchorPreview();

        //Build the textarea that will be used as source view and for content serialization
        this.initTextarea();
        return this;
      },

      // Returns true if the source view is currently active.
      sourceViewActive: function() {
        return this.element.hasClass('source-view-active');
      },

      //Bind Events for the place holder
      setPlaceholders: function () {
        var self = this;

        self.element.on('blur.editor', function () {
          self.togglePlaceHolder();
        }).on('keypress', function () {
          self.togglePlaceHolder();
        });

        self.togglePlaceHolder();
        return this;
      },

      togglePlaceHolder: function () {
        var self = this.element;

        if (self.text().trim() === '') {
          self.addClass('editor-placeholder');
        } else {
          self.removeClass('editor-placeholder');
        }
      },

      // Returns the currently visible element - either the main editor window, or the source-view textarea
      getCurrentElement: function() {
        return this.sourceViewActive() ? this.textarea : this.element;
      },

      bindParagraphCreation: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        currentElement.on('keyup.editor', function (e) {
          var node = self.getSelectionStart(),
              tagName;

          if (node && node.getAttribute('data-editor') && node.children.length === 0) {
            document.execCommand('formatBlock', false, 'p');
          }

          if (e.which === 13) {
            node = self.getSelectionStart();
            tagName = node.tagName.toLowerCase();

            if (tagName !== 'li' && !self.isListItemChild(node)) {
              if (!e.shiftKey) {
                  document.execCommand('formatBlock', false, 'p');
              }
              if (tagName === 'a') {
                  document.execCommand('unlink', false, null);
              }
            }
          }
        });
        return this;
      },

      bindTab: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        currentElement.on('keydown.editor', function (e) {
          if (e.which === 9) {
            // Override tab only for pre nodes
            var tag = self.getSelectionStart().tagName.toLowerCase();
            if (tag === 'pre') {
              e.preventDefault();
              document.execCommand('insertHtml', null, '    ');
            }
            // Tab to indent list structures!
            if ( tag === 'li' ) {
              // If Shift is down, outdent, otherwise indent
              if ( e.shiftKey ) {
                document.execCommand('outdent', e);
              } else {
                document.execCommand('indent', e);
              }
            }
          }
        });
        return this;
      },

      // Builds a fake element and gets the name of the event that will be used for "paste"
      // Used for cross-browser compatability.
      getPasteEvent: function() {
        var el = document.createElement('input'),
            name = 'onpaste';
        el.setAttribute(name, '');
        return ((typeof el[name] === 'function') ? 'paste' : 'input') + '.editor';
      },

      initToolbar: function () {
        if (this.toolbar) {
            return this;
        }
        this.toolbar = this.createToolbar();
        this.toolbarActions = this.toolbar;
        this.toolbar.toolbar();
        return this;
      },

      // Set excluded buttons
      setExcludedButtons: function() {
        var self = this,
          excludeButtons = function(elements, toExclude) {
            var separatorIndex = -1,
              numOfExcluded = 0;

            return elements.filter(function(x, i) {
              var r = true;
              // Exclude matching buttons but keep separator/s
              if (toExclude.indexOf(x) > -1 && x !== 'separator') {
                numOfExcluded++;
                r = false;
              }
              // Exclude extra separator/s
              else if (x === 'separator' && ((i - numOfExcluded - 1) === separatorIndex)) {
                numOfExcluded = 0;
                r = false;
              }
              if (x === 'separator') {
                separatorIndex = i;
              }
              return r;
            });
          },

          // Run only if it needs (excludeButtons)
          setButtons = function() {
            var s = self.settings,
              btns = s.buttons,
              exBtns = s.excludeButtons;
            return (self.sourceViewActive()) ?
              (exBtns && exBtns.source && exBtns.source.length ?
                excludeButtons(btns.source, exBtns.source) : btns.source) :
              (exBtns && exBtns.editor && exBtns.editor.length ?
                excludeButtons(btns.editor, exBtns.editor) : btns.editor);
          };

        return setButtons();
      },

      createToolbar: function () {
        var toolbar = $('<div class="toolbar editor-toolbar formatter-toolbar"></div>').attr('id', 'editor-toolbar-' + this.id);
        this.toolbarButtons(toolbar);
        toolbar.insertBefore(this.sourceViewActive() ? this.element.prev() : this.element);
        toolbar.find('button').tooltip();
        return toolbar;
      },

      toolbarButtons: function (toolbar) {
        var btns = this.setExcludedButtons(),
            buttonset = toolbar.find('.buttonset'),
            i, btn;

        if (!buttonset.length) {
          buttonset = $('<div class="buttonset"></div>').appendTo(toolbar);
        }

        for (i = 0; i < btns.length; i += 1) {
          btn = this.buttonTemplate(btns[i]);

          if (btn) {
            buttonset.append(btn);
          }
        }
        // Invoke colorpicker
        var cpElements = $('[data-action="foreColor"], [data-action="backColor"]', buttonset);
        cpElements.colorpicker({placeIn: 'editor'});
        $('.trigger', cpElements).off('click.colorpicker');
      },

      /**
      * Switch between source and editing toolbar.
      */
      switchToolbars: function() {
        this.destroyToolbar();

        // Rebind everything to the new element
        this.setupTextareaEvents().initToolbar().bindButtons().bindModals().bindAnchorPreview();
        this.bindSelect().bindPaste().setupKeyboardEvents();
        this.toolbar.find('button').button();
      },

      initTextarea: function() {
        var self = this;
        if (this.textarea) {
          return this;
        }
        this.textarea = this.createTextarea();

        // fill the text area with any content that may already exist within the editor DIV
        this.textarea.text(this.element.html().toString());

        this.element.on('input.editor keyup.editor', Soho.utils.debounce( function(){
          self.textarea.val(self.element.html().toString());
          // setting the value via .val doesn't trigger the change event
          $(this).trigger('change');
        }, 500 ));

        this.setupTextareaEvents();
        return this.textarea;
      },

      createTextarea: function() {
        this.sourceView = $('<div></div>').attr({
          'class' : 'editor-source editable hidden',
          'id' : 'editor-source-' + this.id
        }).insertBefore(this.element);

        $('<ul></ul>').addClass('line-numbers').appendTo(this.sourceView);
        var textareaContainer = $('<div class="text-container"></div>').appendTo(this.sourceView),
          newTextareaID = 'source-textarea-' + ($('[id^="source-textarea-"]').length+1),
          labelContents = this.element.prev('.label').addClass('audible').text() + ' - HTML Source View';

        $('<label class="audible" for="'+ newTextareaID +'">'+ labelContents +'</label>').appendTo(textareaContainer);
        var textarea = $('<textarea id="'+ newTextareaID +'" class="editable"></textarea>').appendTo(textareaContainer);
        return textarea;
      },

      triggerClick: function(e, btn) {
        $('button[data-action="'+ btn +'"]', this.toolbar).trigger('click.editor');
      },

      setupKeyboardEvents: function() {
        var self = this,
          currentElement = this.getCurrentElement(),
          keys = {
            b  : 66, // {Ctrl + B} bold
            e  : 69, // {Ctrl + E} justifyCenter
            h  : 72, // {Ctrl + H} anchor
            i  : 73, // {Ctrl + I} italic --------with SHIFT: {Ctrl + Shift + I} image
            l  : 76, // {Ctrl + L} justifyLeft
            bl : 55, // {Ctrl + + Shift + 7} bullet list
            n  : 56, // {Ctrl + Shift + 8} numbered list
            q  : 81, // {Ctrl + Q} blockquotes
            r  : 82, // {Ctrl + R} justifyRight
            u  : 85, // {Ctrl + U} underline
            h3 : 51, // {Ctrl + 3} h3
            h4 : 52, // {Ctrl + 4} h4
            sv : 192 // {Ctrl + ~} toggle source -or- visualview
          };

        currentElement.on('keydown.editor', function(e) {
          e = (e) ? e : window.event;
          keys.charCode = (e.which) ? e.which : ((e.keyCode) ? e.keyCode : false);

          switch (e.ctrlKey && keys.charCode) {
            case keys.h3:
              self.triggerClick(e, 'append-' + settings.firstHeader);
              break;
            case keys.h4:
              self.triggerClick(e, 'append-' + settings.secondHeader);
              break;
            case keys.b:
              self.triggerClick(e, 'bold');
              e.preventDefault();
              break;
            case keys.e:
              self.triggerClick(e, 'justifyCenter');
              break;
            case keys.h:
              self.triggerClick(e, 'anchor');
              e.preventDefault();
              break;
            case keys.i:
              self.triggerClick(e, e.shiftKey ? 'image' : 'italic');
              if (!e.shiftKey) {
                e.preventDefault();
              }
              break;
            case keys.bl:
              if (e.shiftKey) {
                self.triggerClick(e, 'insertunorderedlist');
              }
              e.preventDefault();
              break;
            case keys.l:
              if (!e.shiftKey) {
                self.triggerClick(e, 'justifyLeft');
              }
              e.preventDefault();
              break;
            case keys.n:
              if (e.shiftKey) {
                self.triggerClick(e, 'insertorderedlist');
              }
              break;
            case keys.q:
              self.triggerClick(e, 'append-blockquote');
              break;
            case keys.r:
              self.triggerClick(e, 'justifyRight');
              break;
            case keys.u:
              self.triggerClick(e, 'underline');
              e.preventDefault();
              break;
            case keys.sv:
              self.triggerClick(e, currentElement === self.element ? 'source' : 'visual');
              break;
          }
        });

        // Open link in new windows/tab, if clicked with command-key(for mac) or ctrl-key(for windows)
        self.element.on('mousedown.editor', 'a', function(e) {
          var href = $(this).attr('href');
          if(!self.isFirefox && ((self.isMac && e.metaKey) || (!self.isMac && e.ctrlKey))) {
            window.open(href, '_blank');
            e.preventDefault();
          }
        });

        return self;
      },

      setupTextareaEvents: function() {
        var self = this;
        // Adjust line numbers on input
        this.textarea.on('input.editor keyup.editor', function() {
          if (!(self.sourceView.hasClass('hidden'))) {
            self.adjustSourceLineNumbers();
          }
        }).on('focus.editor', function() {
          self.sourceView.addClass('is-focused');
        }).on('blur.editor', function(e) {
          self.sourceView.removeClass('is-focused');
          self.element.empty().html($.sanitizeHTML(self.textarea.val()));

          if (self.element.data('validate')) {
            self.element.data('validate').validate(self.element, true, e);
          }
        });

        return this;
      },

      adjustSourceLineNumbers: function() {

        var container = this.textarea.parent(),
          lineHeight = parseInt(getComputedStyle(this.textarea[0]).lineHeight),
          YPadding = (this.textarea.innerHeight() - this.textarea.height());

        this.textarea[0].style.height = '';

        var scrollHeight = this.textarea[0].scrollHeight,
          lineNumberCount = Math.floor((scrollHeight - YPadding) / lineHeight),
          numberList = this.sourceView.find('.line-numbers'),
          lastIdx = numberList.find('li').length,
          list = '',
          i = 0;

        if (!this.lineNumbers || lineNumberCount !== this.lineNumbers) {
          if (!this.lineNumbers) {
            // Build the list of line numbers from scratch
            this.lineNumbers = lineNumberCount;
            while (i < this.lineNumbers) {
              list += '<li role="presentation"><span>'+ (i + 1) +'</span></li>';
              i++;
            }
            numberList.append(list);
          } else if (this.lineNumbers < lineNumberCount) {
            // Add extra line numbers to the bottom
            while (i < (lineNumberCount - this.lineNumbers)) {
              list += '<li role="presentation"><span>'+ (lastIdx + i + 1) +'</span></li>';
              i++;
            }
            numberList.append(list);
          } else if (this.lineNumbers > lineNumberCount) {
            // Remove extra line numbers from the bottom
            i = this.lineNumbers - lineNumberCount;
            numberList.find('li').slice(-(i)).remove();
          }
          this.lineNumbers = lineNumberCount;
          container[0].style.width = 'calc(100% - ' + (numberList.outerWidth() + 1) + 'px)';
        }
        if (scrollHeight !== this.textarea[0].scrollHeight) {
          this.adjustSourceLineNumbers();
          return;
        }

        this.textarea[0].style.height = numberList[0].scrollHeight + 'px';
      },

      wrapTextInTags: function(insertedText, selectedText, action) {
        var tags,
          finalText;
        switch(action) {
          case 'bold':
            tags = ['<b>','</b>'];
            break;
          case 'italic':
            tags = ['<i>','</i>'];
            break;
          case 'underline':
            tags = ['<u>','</u>'];
            break;
          case 'strikethrough':
            tags = ['<strike>', '</strike>'];
            break;
          case 'append-blockquote':
            tags = ['<blockquote>', '</blockquote>'];
            break;
          default:
            tags = ['',''];
        }

        if (action === 'anchor') {
          var alink = $('<a href="'+ insertedText +'">' + selectedText + '</a>');

          if(settings.anchor.class && $.trim(settings.anchor.class).length) {
            alink.addClass(settings.anchor.class);
          }
          if(settings.anchor.target && $.trim(settings.anchor.target).length) {
            alink.attr('target', settings.anchor.target);
          }
          if(settings.anchor.isClickable) {
            alink.attr('contenteditable', false);
          } else {
            alink.removeAttr('contenteditable');
          }

          finalText = alink[0].outerHTML;
        }
        else {
          finalText = tags[0] + insertedText + selectedText + tags[1];
        }
        return finalText;
      },

      insertTextAreaContent: function(text, action) {
        var el = this.textarea[0],
          val = el.value,
          sel, startPos, endPos, scrollTop;

        // Always have empty text
        text = text ? text : '';

        if (document.selection && el.tagName === 'TEXTAREA') {
          //IE textarea support
          $(el).focus();
          sel = document.selection.createRange();
          sel.text = this.wrapTextInTags(text, sel.text, action);
          $(el).focus();
        } else if (el.selectionStart || el.selectionStart === '0') {
          //MOZILLA/NETSCAPE support
          startPos = el.selectionStart;
          endPos = el.selectionEnd;
          scrollTop = el.scrollTop;
          sel = this.wrapTextInTags(text, val.substring(startPos, endPos), action);
          el.value = val.substring(0, startPos) + sel + val.substring(endPos, val.length);
          $(el).focus();
          el.selectionStart = startPos + sel.length;
          el.selectionEnd = startPos + sel.length;
          el.scrollTop = scrollTop;
        } else {
          // IE input[type=text] and other browsers
          el.value += this.wrapTextInTags(text, el.value, action);
          $(el).focus();
          el.value = el.value;    // forces cursor to end
        }
      },

      buttonTemplate: function (btnType) {
        var buttonLabels = this.getButtonLabels(settings.buttonLabels),
          buttonTemplates = {
            'bold': '<button type="button" class="btn" title="'+ Locale.translate('ToggleBold') + '" data-action="bold" data-element="b">' + buttonLabels.bold + '</button>',
            'italic': '<button type="button" class="btn" title="'+ Locale.translate('ToggleItalic') + '" data-action="italic" data-element="i">' + buttonLabels.italic + '</button>',
            'underline': '<button type="button" class="btn underline" title="'+ Locale.translate('ToggleUnderline') + '" data-action="underline" data-element="u">' + buttonLabels.underline + '</button>',
            'strikethrough': '<button type="button" class="btn" title="'+ Locale.translate('StrikeThrough') + '" data-action="strikethrough" data-element="strike">' + buttonLabels.strikethrough + '</button>',
            'foreColor': '<button type="button" class="btn colorpicker-editor-button" title="'+ Locale.translate('TextColor') + '" data-action="foreColor" data-element="foreColor">' + buttonLabels.foreColor + '</button>',
            'backColor': '<button type="button" class="btn colorpicker-editor-button" title="'+ Locale.translate('BackgroundColor') + '" data-action="backColor" data-element="backColor">' + buttonLabels.backColor + '</button>',
            'superscript': '<button type="button" class="btn" title="'+ Locale.translate('Superscript') + '" data-action="superscript" data-element="sup">' + buttonLabels.superscript + '</button>',
            'subscript': '<button type="button" class="btn" title="'+ Locale.translate('Subscript') + '" data-action="subscript" data-element="sub">' + buttonLabels.subscript + '</button>',
            'separator': '<div class="separator"></div>',
            'anchor': '<button type="button" class="btn" title="'+ Locale.translate('InsertAnchor') + '" data-action="anchor" data-modal="modal-url-'+ this.id +'" data-element="a">' + buttonLabels.anchor + '</button>',
            'image': '<button type="button" class="btn" title="'+ Locale.translate('InsertImage') + '" data-action="image" data-modal="modal-image-'+ this.id +'" data-element="img">' + buttonLabels.image + '</button>',
            'header1': '<button type="button" class="btn" title="'+ Locale.translate('ToggleH3') + '" data-action="append-' + settings.firstHeader + '" data-element="' + settings.firstHeader + '">' + buttonLabels.header1 + '</button>',
            'header2': '<button type="button" class="btn" title="'+ Locale.translate('ToggleH4') + '" data-action="append-' + settings.secondHeader + '" data-element="' + settings.secondHeader + '">' + buttonLabels.header2 + '</button>',
            'quote': '<button type="button" class="btn" title="'+ Locale.translate('Blockquote') + '" data-action="append-blockquote" data-element="blockquote">' + buttonLabels.quote + '</button>',
            'orderedlist': '<button type="button" class="btn" title="'+ Locale.translate('OrderedList') + '" data-action="insertorderedlist" data-element="ol">' + buttonLabels.orderedlist + '</button>',
            'unorderedlist': '<button type="button" class="btn" title="'+ Locale.translate('UnorderedList') + '" data-action="insertunorderedlist" data-element="ul">' + buttonLabels.unorderedlist + '</button>',
            'justifyLeft': '<button type="button" class="btn" title="'+ Locale.translate('JustifyLeft') + '" data-action="justifyLeft" >' + buttonLabels.justifyLeft + '</button>',
            'justifyCenter': '<button type="button" class="btn" title="'+ Locale.translate('JustifyCenter') + '" data-action="justifyCenter">' + buttonLabels.justifyCenter + '</button>',
            'justifyRight': '<button type="button" class="btn" title="'+ Locale.translate('JustifyRight') + '" data-action="justifyRight" >' + buttonLabels.justifyRight + '</button>',
            'source': '<button type="button" class="btn" title="'+ Locale.translate('ViewSource') + '" data-action="source" >' + buttonLabels.source + '</button>',
            'visual': '<button type="button" class="btn" title="'+ Locale.translate('ViewVisual') + '" data-action="visual" >' + buttonLabels.visual + '</button>'
          };
       return buttonTemplates[btnType] || false;
      },

      getIcon: function(textName, iconName, className) {
        return '<span class="audible">'+ Locale.translate(textName) +'</span>' + $.createIcon({ classes: (className || ''), icon: iconName });
      },

      getButtonLabels: function (buttonLabelType) {
        var customButtonLabels,
          attrname,
          buttonLabels = {
            'bold': this.getIcon('Bold', 'bold'),
            'italic': this.getIcon('Italic', 'italic'),
            'underline': this.getIcon('Underline', 'underline'),
            'superscript': '<span aria-hidden="true"><b>x<sup>1</sup></b></span>',
            'subscript': '<span aria-hidden="true"><b>x<sub>1</sub></b></span>',
            'strikethrough': this.getIcon('StrikeThrough', 'strike-through'),
            'foreColor': this.getIcon('TextColor', 'fore-color'),
            'backColor': this.getIcon('BackgroundColor', 'back-color'),
            'anchor': this.getIcon('InsertAnchor', 'link'),
            'image': this.getIcon('InsertImage', 'insert-image'),
            'header1': this.getIcon('ToggleH3', 'h3'),
            'header2': this.getIcon('ToggleH4', 'h4'),
            'quote': this.getIcon('Blockquote', 'quote'),
            'orderedlist': this.getIcon('OrderedList', 'number-list'),
            'unorderedlist': this.getIcon('UnorderedList', 'bullet-list'),
            'pre': '<span aria-hidden="true"><b>0101</b></span>',
            'indent': '<span aria-hidden="true"><b>&rarr;</b></span>',
            'outdent': '<span aria-hidden="true"><b>&larr;</b></span>',
            'justifyLeft': this.getIcon('JustifyLeft', 'left-text-align'),
            'justifyCenter': this.getIcon('JustifyCenter', 'center-text'),
            'justifyRight': this.getIcon('JustifyRight', 'right-text-align'),
            'source': this.getIcon('ViewSource', 'html', 'html-icon'),
            'visual': this.getIcon('ViewSource', 'visual', 'visual-icon')
          };

        if (typeof buttonLabelType === 'object') {
          customButtonLabels = buttonLabelType;
        }
        if (typeof customButtonLabels === 'object') {
          for (attrname in customButtonLabels) {
            if (customButtonLabels.hasOwnProperty(attrname)) {
              buttonLabels[attrname] = customButtonLabels[attrname];
            }
          }
        }
        return buttonLabels;
      },

      //Show the Buttons
      activateButton: function (tag) {
        this.toolbar.find('[data-element="' + tag + '"]').addClass('is-active');
      },

      //Bind Events to Toolbar Buttons
      bindButtons: function () {
        var self = this;

        this.toolbar.on('touchstart.editor click.editor', 'button', function (e) {
          var btn = $(this),
            action = btn.attr('data-action');

          // Don't do anything if it's the More Button
          if (btn.is('.btn-actions')) {
            return;
          }

          e.preventDefault();
          self.getCurrentElement().focus();

          if (self.selection === undefined) {
            self.checkSelection();
          }

          if (!self.sourceViewActive()) {
            btn.toggleClass('is-active');
          }

          if (action) {
            self.execAction(action, e);
          }

          return false;
        });

        return this;
      },

      bindModals: function() {
        var self = this;

        self.modals = {
          url: self.createURLModal(),
          image: self.createImageModal()
        };

        $('[name="em-target"]').dropdown();

        $('#modal-url-'+ self.id +', #modal-image-'+ self.id).modal()
          .on('beforeopen', function () {
            self.savedSelection = self.saveSelection();

            if ($(this).attr('id') === ('modal-url-' + self.id)) {

              if (!self.selectionRange) {
                return undefined;
              }
            }
          })
          .off('open')
          .on('open', function () {
            var isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
              id = $(this).attr('id'),
              input = $('input:first', this),
              button = $('.modal-buttonset .btn-modal-primary', this);

            $('[name="em-url"]').val(settings.anchor.url);
            $('[name="em-class"]').val(settings.anchor.class);
            $('[name="em-target"]').val(settings.anchor.target).trigger('updated');
            $('[name="em-isclickable"]').prop('checked', settings.anchor.isClickable);

            // $('[id="em-target-shdo"]').val($('[name="em-target"] option:selected').text());

            setTimeout(function () {
              if (isTouch && id === 'modal-image-'+ self.id) {
                button.focus();
              } else {
                input.focus().select();
              }
            }, 10);

          })
          .off('close')
          .on('close', function (e, isCancelled) {
            self.restoreSelection(self.savedSelection);

            if (isCancelled) {
              return;
            }

            //insert image or link
            if ($(this).attr('id') === ('modal-url-'+ self.id)) {
              var currentLink = $(self.findElementInSelection('a', self.element[0]));
              if (currentLink.length) {
                self.updateCurrentLink(currentLink);
              } else {
                self.createLink($('[name="em-url"]', this));
              }
            } else {
              self.insertImage($('#image').val());
            }
          });

        return this;
      },

      /**
      * Function that creates the Url Modal Dialog. This can be customized by making a modal with ID `#modal-url-{this.id}`
      */
      createURLModal: function() {
        var targetOptions = '',
          isTargetCustom = true,
          urlModal = $('#modal-url-'+ this.id);

        if (urlModal.length > 0) {
          return urlModal;
        }

        $.each(settings.anchor.targets, function(key, val) {
          targetOptions += '<option value="'+ val +'">'+ key +'</option>';
          if ((settings.anchor.defaultTargetText).toLowerCase() === (key).toLowerCase()) {
            isTargetCustom = false;
          }
        });
        if (isTargetCustom) {
          targetOptions += '<option value="'+ settings.anchor.target +'">'+ settings.anchor.target +'</option>';
        }

        return $('<div class="modal editor-modal-url" id="modal-url-'+ this.id +'"></div>')
          .html('<div class="modal-content">' +
            '<div class="modal-header">' +
              '<h1 class="modal-title">' + Locale.translate('InsertAnchor') + '</h1>' +   //TODO: Rename to link when you get strings
            '</div>' +
            '<div class="modal-body">' +
              '<div class="field">' +
                '<label for="em-url">' + Locale.translate('Url') + '</label>' +
                '<input id="em-url" name="em-url" type="text" value="'+ settings.anchor.url +'">' +
              '</div>' +
              (settings.anchor.showIsClickable ?('<div class="field">' +
                '<input type="checkbox" class="checkbox" id="em-isclickable" name="em-isclickable" checked="'+ settings.anchor.isClickable +'">' +
                '<label for="em-isclickable" class="checkbox-label">' + Locale.translate('Clickable') + '</label>' +
              '</div>') : '') +
              '<div class="field">' +
                '<label for="em-class">' + Locale.translate('CssClass') + '</label>' +
                '<input id="em-class" name="em-class" type="text" value="'+ settings.anchor.class +'">' +
              '</div>' +
              '<div class="field">' +
                '<label for="em-target" class="label">' + Locale.translate('Target') + '</label>' +
                '<select id="em-target" name="em-target" class="dropdown">' +
                  targetOptions +
                '</select>' +
              '</div>' +
              '<div class="modal-buttonset">' +
                '<button type="button" class="btn-modal btn-cancel">' + Locale.translate('Cancel') + '</button>' +
                '<button type="button" class="btn-modal-primary">' + Locale.translate('Insert') + '</button>' +
              '</div>' +
            '</div>' +
          '</div>').appendTo('body');
      },

       /**
       * Function that creates the Image Dialog. This can be customized by making a modal with ID `#modal-image-{this.id}`
       */
      createImageModal: function() {
        var imageModal = $('#modal-image-' + this.id);
        if (imageModal.length > 0) {
          return imageModal;
        }
        return $('<div class="modal editor-modal-image" id="modal-image-'+ this.id +'"></div>')
          .html('<div class="modal-content">' +
            '<div class="modal-header">' +
              '<h1 class="modal-title">' + Locale.translate('InsertImage') + '</h1>' +
            '</div>' +
            '<div class="modal-body">' +
              '<div class="field">' +
                '<label for="image">' + Locale.translate('Url') + '</label>' +
                '<input id="image" name="image" type="text" value="'+ settings.image.url +'">' +
              '</div>' +
              '<div class="modal-buttonset">' +
                '<button type="button" class="btn-modal btn-cancel">' + Locale.translate('Cancel') + '</button>' +
                '<button type="button" class="btn-modal-primary">' + Locale.translate('Insert') + '</button>' +
              '</div>' +
            '</div>' +
          '</div>').appendTo('body');
      },

      bindAnchorPreview: function () {
        this.element.find('a').tooltip({content: function() {
          return $(this).attr('href');
        }});
        return;
      },

      updateCurrentLink: function (alink) {
        var emUrl = $('[name="em-url"]').val(),
          emClass = $('[name="em-class"]').val(),
          emTarget = $('[name="em-target"]').val(),
          emIsClickable = $('[name="em-isclickable"]').is(':checked');

        alink.attr('href', (emUrl && $.trim(emUrl).length ? emUrl : settings.anchor.defaultUrl));
        alink.attr('class', (emClass && $.trim(emClass).length ? emClass : settings.anchor.defaultClass));

        if (emIsClickable) {
          alink.attr('contenteditable', false);
        } else {
          alink.removeAttr('contenteditable');
        }

        if (emTarget && $.trim(emTarget).length) {
          alink.attr('target', emTarget);
        } else {
          alink.removeAttr('target');
        }
      },

      createLink: function (input) {
        var alink;

        //Restore Selection in the Editor and Variables
        this.restoreSelection(this.savedSelection);

        //Fix and Format the Link
        input.val(this.fixLinkFormat(input.val()));

        // Set selection url/class/target for Link
        settings.anchor.url = input.val();
        settings.anchor.class = $('[name="em-class"]').val();
        settings.anchor.target = $('[name="em-target"]').val();
        settings.anchor.isClickable = $('[name="em-isclickable"]').is(':checked');

        alink = $('<a href="'+ input.val() +'">' + input.val() + '</a>');

        if(settings.anchor.class && $.trim(settings.anchor.class).length) {
          alink.addClass(settings.anchor.class);
        }
        if(settings.anchor.target && $.trim(settings.anchor.target).length) {
          alink.attr('target', settings.anchor.target);
        }
        if(settings.anchor.isClickable) {
          alink.attr('contenteditable', false);
        } else {
          alink.removeAttr('contenteditable');
        }

        if (this.sourceViewActive()) {
          this.insertTextAreaContent(input.val(), 'anchor');
        }
        else {
          var sel, range, rangeStr;

          if (!this.selection.isCollapsed || this.isIe11) {
            //document.execCommand('createLink', false, input.val());

            //get example from: http://jsfiddle.net/jwvha/1/
            //and info: http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
            if (window.getSelection) {
              // IE9 and non-IE
              sel = window.getSelection();
              if (sel.getRangeAt && sel.rangeCount) {
                range = sel.getRangeAt(0);
                rangeStr = range + '';
                if (rangeStr.trim() !== '') {
                  alink.html(rangeStr);
                }
                range.deleteContents();

                // Range.createContextualFragment() would be useful here but is
                // only relatively recently standardized and is not supported in
                // some browsers (IE9, for one)
                var el = document.createElement('div');
                el.innerHTML = alink[0].outerHTML;
                var frag = document.createDocumentFragment(), node, lastNode;

                while ((node = el.firstChild)) {
                  lastNode = frag.appendChild(node);
                }
                range.insertNode(frag);

                // Preserve the selection
                if (lastNode) {
                  range = range.cloneRange();
                  range.setStartAfter(lastNode);
                  range.collapse(true);
                  sel.removeAllRanges();
                  sel.addRange(range);
                }
              }
            }
          }
          else {
            var self = this;
            document.execCommand('insertHtml', null, alink[0].outerHTML);
            setTimeout(function () {
              self.getCurrentElement().focus();
            }, 1);
          }
          this.bindAnchorPreview();
        }
      },

      fixLinkFormat: function (value) {
        var re = /^https?:\/\//;
        if (value.match(re)) {
          return value;
        }
        return 'http://' + value;
      },

      //Setup Events For Text Selection
      bindSelect: function () {
        var self = this,
            selectionTimer = '';

        this.selectionHandler = function () {
          clearTimeout(selectionTimer);
          selectionTimer = setTimeout(function () {
            self.checkSelection();
          }, settings.delay);
        };

        var currentElement = self.getCurrentElement();

        currentElement.off('mouseup.editor keyup.editor')
          .on('mouseup.editor keyup.editor', this.selectionHandler);

        return this;
      },

      checkSelection: function () {
        var newSelection,
            selectionElement;

        if (this.selection === undefined) {
          if (this.sourceViewActive()) {
            newSelection = this.textarea.val().substring( this.textarea[0].selectionStart, this.textarea[0].selectionEnd ).toString().trim();
            this.hideToolbarActions();
            return;
          }
        }

        newSelection = window.getSelection();
        selectionElement = this.getSelectionElement();
        if (!selectionElement) {
            this.hideToolbarActions();
        } else {
          this.checkSelectionElement(newSelection, selectionElement);
        }
        return this;
      },

      getSelectionElement: function () {
        var selection = window.getSelection(),
          range, current, parent,
          result,
          getElement = function (e) {
            var localParent = e;
            try {
                while (!localParent.getAttribute('data-editor')) {
                    localParent = localParent.parentNode;
                }
            } catch (errb) {
                return false;
            }
            return localParent;
          };

        // First try on current node
        try {
          range = selection.getRangeAt(0);
          current = range.commonAncestorContainer;
          parent = current.parentNode;

          if (current.getAttribute('data-editor')) {
              result = current;
          } else {
              result = getElement(parent);
          }
          // If not search in the parent nodes.
        } catch (err) {
          result = getElement(parent);
        }
        return result;
      },

      //See if the Editor is Selected and Show Toolbar
      checkSelectionElement: function (newSelection, selectionElement) {
        var currentElement = this.sourceViewActive() ? this.sourceView[0] : this.element[0];

        this.selection = newSelection;
        this.selectionRange = this.selection.getRangeAt(0);
        if (currentElement === selectionElement) {
          this.setToolbarButtonStates();
          return;
        }
        this.hideToolbarActions();
      },

      //Set button states for toolbar buttons
      setToolbarButtonStates: function () {
        var buttons = this.toolbarActions.find('button');

        buttons.removeClass('is-active');
        this.checkActiveButtons();
        return this;
      },

      checkActiveButtons: function () {
        this.checkButtonState('bold');
        this.checkButtonState('italic');
        this.checkButtonState('underline');
        this.colorpickerButtonState('foreColor');
        if (this.toolbar.find('.buttonset [data-action="backColor"]').length) {
          this.colorpickerButtonState('backColor');
        }

        var self = this,
            parentNode = this.getSelectedParentElement();

        while (parentNode.tagName !== undefined && this.parentElements.indexOf(parentNode.tagName.toLowerCase) === -1) {
          this.activateButton(parentNode.tagName.toLowerCase());

          // we can abort the search upwards if we leave the contentEditable element
          if (self.element.is(parentNode)) {
            break;
          }
          parentNode = parentNode.parentNode;
        }
      },

      checkButtonState: function(command) {
        if (!document.queryCommandState) {
          return;
        }

        if (document.queryCommandState(command)) {
          this.toolbar.find('[data-action="' + command + '"]').addClass('is-active');
        } else {
          this.toolbar.find('[data-action="' + command + '"]').removeClass('is-active');
        }
      },

      rangeSelectsSingleNode: function (range) {
        var startNode = range.startContainer;
        return startNode === range.endContainer &&
            startNode.hasChildNodes() &&
            range.endOffset === range.startOffset + 1;
      },

      getSelectedParentElement: function () {
        var selectedParentElement = null,
            range = this.selectionRange;
        if (this.rangeSelectsSingleNode(range)) {
            selectedParentElement = range.startContainer.childNodes[range.startOffset];
        } else if (range.startContainer.nodeType === 3) {
            selectedParentElement = range.startContainer.parentNode;
        } else {
            selectedParentElement = range.startContainer;
        }
        return selectedParentElement;
      },

      //Hide Toolbar
      hideToolbarActions: function () {
        if (this.toolbar !== undefined) {
          this.toolbar.removeClass('is-active');
        }
      },

      //Handle Pasted In Text
      bindPaste: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        if (!self.pasteEvent) {
          self.pasteEvent = self.getPasteEvent();
        }

        this.pasteWrapper = function (e) {

          var paste = e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData ?
            e.originalEvent.clipboardData.getData('text/plain') : // Standard
            window.clipboardData && window.clipboardData.getData ?
            window.clipboardData.getData('Text') : // MS
            false,
            paragraphs,
            html = '',
            p;

          if (self.sourceViewActive() ) {
            return this;
          }

          if (paste && !e.defaultPrevented) {
            e.preventDefault();
            paragraphs = paste.split(/[\r\n]/g);

            for (p = 0; p < paragraphs.length; p += 1) {
              if (paragraphs[p] !== '') {
                if (navigator.userAgent.match(/firefox/i) && p === 0) {
                  html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                } else {
                  if((/\.(gif|jpg|jpeg|tiff|png)$/i).test(paragraphs[p])) {
                    html += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
                  } else {
                    html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                  }
                }
              }
            }

            if (document.queryCommandSupported('insertText')) {
                document.execCommand('insertHTML', false, html);
                return false;
            } else { // IE > 7
              self.pasteHtmlAtCaret(html);
            }
          }
        };

        this.pasteWrapperHtml = function (e) {
          if (self.sourceViewActive()) {
            return this;
          }
          var types, clipboardData, pastedData,
            paste, p, paragraphs,
            getCleanedHtml = function(pastedData) {
              var i, l, attributeStripper,
                s = pastedData || '',
                badAttributes = [
                  'start','xmlns','xmlns:o','xmlns:w','xmlns:x','xmlns:m',
                  'onmouseover','onmouseout','onmouseenter','onmouseleave',
                  'onmousemove','onload','onfocus','onblur','onclick',
                  'style'
                ];

              // Remove extra word formating
              if (self.isWordFormat(s)) {
                s = self.cleanWordHtml(s);
              }

              // Remove bad attributes
              for (i = 0, l = badAttributes.length; i < l; i++) {
                attributeStripper = new RegExp(' ' + badAttributes[i] + '="(.*?)"','gi');
                s = self.stripAttribute(s, badAttributes[i], attributeStripper);

                attributeStripper = new RegExp(' ' + badAttributes[i] + '=\'(.*?)\'','gi');
                s = self.stripAttribute(s, badAttributes[i], attributeStripper);
              }

              // Remove "ng-" directives and "ng-" classes
              s = s.replace(/(ng-\w+-\w+="(.|\n)*?"|ng-\w+="(.|\n)*?"|ng-(\w+-\w+)|ng-(\w+))/g, '');

              // Remove comments
              s = s.replace(/<!--(.*?)-->/gm, '');

              // Remove extra spaces
              s = s.replace(/\s\s+/g, ' ').replace(/\s>+/g, '>');

              // Remove extra attributes from list elements
              s = s.replace(/<(ul|ol)(.*?)>/gi, '<$1>');

              // Remove html and body tags
              s = s.replace(/<\/?(html|body)(.*?)>/gi, '');

              // Remove header tag and content
              s = s.replace(/<head\b[^>]*>(.*?)<\/head>/gi, '');

              return s;
            };

          if (e.clipboardData || e.originalEvent) {
            if (e.clipboardData && e.clipboardData.types) {
              clipboardData = e.clipboardData;
            }
            else if (e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
              clipboardData = e.originalEvent.clipboardData;
            }
          }

          if (clipboardData && clipboardData.types) {
            types = clipboardData.types;
            // jshint undef:false
            if ((types instanceof DOMStringList && types.contains('text/html')) ||
                (types.indexOf && types.indexOf('text/html') !== -1) || self.isIeEdge) {
            // jshint undef:true
              if (self.isIeEdge) {
                pastedData =  e.originalEvent.clipboardData.getData('text/plain');
              } else {
                pastedData = e.originalEvent.clipboardData.getData('text/html');
              }
            }
          } else {
            paste = window.clipboardData ? window.clipboardData.getData('Text') : '';
            paragraphs = paste.split(/[\r\n]/g);
            pastedData = '';
            for (p = 0; p < paragraphs.length; p += 1) {
              if (paragraphs[p] !== '') {
                if (navigator.userAgent.match(/firefox/i) && p === 0) {
                  pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                } else {
                  if((/\.(gif|jpg|jpeg|tiff|png)$/i).test(paragraphs[p])) {
                    pastedData += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
                  } else {
                    pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                  }
                }
              }
            }
          }

          self.pastedData = getCleanedHtml(pastedData);

          $.when(self.element.triggerHandler('beforepaste', [{pastedData: self.pastedData}])).done(function() {
            if (self.pastedData && !e.defaultPrevented) {
              e.preventDefault();

              if (document.queryCommandSupported('insertText')) {
                  document.execCommand('insertHTML', false, self.pastedData);
                  return false;
              } else { // IE > 7
                self.pasteHtmlAtCaret(self.pastedData);
              }
            }
            self.element.triggerHandler('afterpaste', [{pastedData: self.pastedData}]);
            self.pastedData = null;
          });
          return false;
        };

        currentElement.on(self.pasteEvent, (self.settings.pasteAsPlainText ? self.pasteWrapper : self.pasteWrapperHtml));

        return this;
      },

      pasteHtmlAtCaret: function(html) {
        var sel, range;
        if (window.getSelection) {
          // IE9 and non-IE
          sel = window.getSelection();
          if (sel.getRangeAt && sel.rangeCount) {
            range = sel.getRangeAt(0);
            range.deleteContents();

            // Range.createContextualFragment() would be useful here but is
            // only relatively recently standardized and is not supported in
            // some browsers (IE9, for one)
            var el = document.createElement('div');

            el.innerHTML = html;
            var frag = document.createDocumentFragment(), node, lastNode;
            while ( (node = el.firstChild) ) {
              lastNode = frag.appendChild(node);
            }
            range.insertNode(frag);

            // Preserve the selection
            if (lastNode) {
              range = range.cloneRange();
              range.setStartAfter(lastNode);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        } else if (document.selection && document.selection.type !== 'Control') {
          // IE < 9
          document.selection.createRange().pasteHTML(html);
        }
      },

      htmlEntities: function (str) {
        // converts special characters (like <) into their escaped/encoded values (like &lt;).
        // This allows you to show to display the string without the browser reading it as HTML.
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      },

      bindWindowActions: function () {
        var self = this,
          editorContainer = this.element.closest('.editor-container'),
          currentElement = self.getCurrentElement();

        self.element
        // Work around for Firefox with using keys was not focusing on first child in editor
        // Firefox behaves differently than other browsers
        .on('mousedown.editor', function () {
          self.mousedown = true;
        })
        .on('focus.editor', function () {
          if (self.isFirefox && !self.mousedown && self.element === currentElement) {
            self.setFocus();
          }
        })

        // Work around for Chrome's bug wrapping contents in <span>
        // http://www.neotericdesign.com/blog/2013/3/working-around-chrome-s-contenteditable-span-bug
        .on('DOMNodeInserted', function(e) {
          var target = $(e.target),
            helper = $('<b>helper</b>');

          if (e.target.tagName === 'IMG') {
            target.removeAttr('id style srcset');
          }
          else if (e.target.tagName === 'SPAN') {

            target.before(helper);
            helper.after(target.contents());
            helper.add(target).remove();
          }
        });

        editorContainer
          .on('focus.editor', '.editor, .editor-source', function () {
            var elem = $(this);

            editorContainer.addClass('is-active');
            setTimeout(function () {
              if (elem.hasClass('error')) {
                editorContainer.parent().find('.editor-toolbar').addClass('error');
                editorContainer.parent().find('.editor-source').addClass('error');
              }
            }, 100);
          })
          .on('blur.editor', '.editor, .editor-source', function() {
            editorContainer.removeClass('is-active');
            editorContainer.parent().find('.editor-toolbar').removeClass('error');
            editorContainer.parent().find('.editor-source').removeClass('error');
          });

        //Attach Label
        var label = this.element.prevAll('.label');
        for (var i = 0, l = label.length; i < l; i++) {
          label[i].style.cursor = 'default';
        }
        label.on('click.editor', function () {
          currentElement.focus();
        });
        currentElement.attr('aria-label', label.text());
        return this;
      },

      //Restore Text Selection
      restoreSelection: function(savedSel) {
        var i,
          len,
          sel = window.getSelection();

        if (!savedSel) {
          savedSel = this.savedSelection;
        }

        if (savedSel) {
          sel.removeAllRanges();
          for (i = 0, len = savedSel.length; i < len; i += 1) {
              sel.addRange(savedSel[i]);
          }
        }
      },

      //Save Text Selection
      saveSelection: function() {
        var i,
          len,
          ranges,
          sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          ranges = [];
          for (i = 0, len = sel.rangeCount; i < len; i += 1) {
              ranges.push(sel.getRangeAt(i));
          }
          return ranges;
        }
        return null;
      },

      // Get the Element the Caret idea from http://bit.ly/1kRmZIL
      getSelectionStart: function() {
        var node = document.getSelection().anchorNode,
          startNode = (node && node.nodeType === 3 ? node.parentNode : node);
        return startNode;
      },

      getrange: function() {
        return window.getSelection().getRangeAt(0);
      },

      // Find element within the selection
      // http://stackoverflow.com/questions/6052870/how-to-know-if-there-is-a-link-element-within-the-selection
      findElementInSelection: function(tagname, container) {
        var i, len, el, comprng, selparent,
          rng = this.getrange();

        if (rng) {
          selparent = rng.commonAncestorContainer || rng.parentElement();
          // Look for an element *around* the selected range
          for (el = selparent; el !== container; el = el.parentNode) {
            if (el && el.tagName && el.tagName.toLowerCase() === tagname) {
              return el;
            }
          }

          // Look for an element *within* the selected range
          if (!rng.collapsed && (rng.text === undefined || rng.text) && selparent.getElementsByTagName) {
            el = selparent.getElementsByTagName(tagname);
            comprng = document.createRange ? document.createRange() : document.body.createTextRange();

            for (i = 0, len = el.length; i < len; i++) {
              // determine if element el[i] is within the range
              if (document.createRange) { // w3c
                comprng.selectNodeContents(el[i]);
                if (rng.compareBoundaryPoints(Range.END_TO_START, comprng) < 0 && rng.compareBoundaryPoints(Range.START_TO_END, comprng) > 0) {
                  return el[i];
                }
              }
              else { // microsoft
                comprng.moveToElementText(el[i]);
                if (rng.compareEndPoints('StartToEnd', comprng) < 0 && rng.compareEndPoints('EndToStart', comprng) > 0) {
                  return el[i];
                }
              }
            }
          }
        }
      },

      // Restore if Selection is a Link
      restoreLinkSelection: function () {
        var currentLink = $(this.findElementInSelection('a', this.element[0])),
          contenteditable;

        settings.anchor.url = settings.anchor.defaultUrl;
        settings.anchor.class = settings.anchor.defaultClass;
        settings.anchor.target = settings.anchor.defaultTarget;
        settings.anchor.isClickable = settings.anchor.defaultIsClickable;

        if (currentLink.length) {
          settings.anchor.url = currentLink.attr('href');
          settings.anchor.class = currentLink.attr('class');
          settings.anchor.target = currentLink.attr('target');
          contenteditable = currentLink.attr('contenteditable');
          if (contenteditable === false || contenteditable === 'false') {
            settings.anchor.isClickable = true;
          }

          // currentLink.removeAttr('class target');
          // document.execCommand('unlink', false, null);
        }

      },

      //Run the CE action.
      execAction: function (action) {
        var currentElement = this.getCurrentElement();

        // Visual Mode
        if (currentElement === this.element) {
          if (action.indexOf('append-') > -1) {
            this.execFormatBlock(action.replace('append-', ''));
          } else if (action === 'anchor') {
            this.restoreLinkSelection();
            this.modals.url.data('modal').open();
          } else if (action === 'image') {
            this.modals.image.data('modal').open();
          } else if (action === 'foreColor' || action === 'backColor') {
            this.colorpickerActions(action);
          } else if (action === 'source' || action === 'visual') {
            this.toggleSource();
          } else {
            document.execCommand(action, false, null);
          }
        } else {
          // Source Mode
          switch(action) {
            case 'visual':
              this.toggleSource();
              break;
            case 'anchor':
              this.modals.url.data('modal').open();
              break;
            default:
              this.insertTextAreaContent(null, action);
              break;
          }
        }

      },

      insertImage: function (url) {
        document.execCommand('insertImage', false, url);
      },

      toggleSource: function() {
        if (this.sourceViewActive()) {
          this.element.empty().html($.sanitizeHTML(this.textarea.val()));
          this.element.removeClass('source-view-active hidden');
          this.sourceView.addClass('hidden').removeClass('is-focused');
          this.element.trigger('focus.editor');
        } else {
          // Format The Text being pulled from the WYSIWYG editor
          var val = this.element.html().toString().trim()
            .replace(/\s+/g, ' ')
            .replace(/<br( \/)?>/g, '<br>\n')
            .replace(/<\/p> /g, '</p>\n\n')
            .replace(/<\/blockquote>( )?/g, '</blockquote>\n\n');

          this.textarea.val(val).focus();

          // var val = this.element.html().toString();
          // this.textarea.val(this.formatHtml(val)).focus();

          this.element.addClass('source-view-active hidden');
          this.sourceView.removeClass('hidden');
          this.adjustSourceLineNumbers();
          this.textarea.focus();
        }
        this.switchToolbars();
      },

      // Set ['foreColor'|'backColor'] button icon color in toolbar
      colorpickerButtonState: function(action) {
        var self = this,
          cpBtn = $('[data-action="'+ action +'"]', this.toolbar),
          cpApi = cpBtn.data('colorpicker'),
          color = document.queryCommandValue(action);

        // Set selection color checkmark in picker popup
        // by adding/updating ['data-value'] attribute
        if (cpApi) {
          if (self.isFirefox && action === 'backColor') {
            color = $(window.getSelection().focusNode.parentNode).css('background-color');
          }
          // IE-11 queryCommandValue returns the as decimal
          if (typeof color === 'number') {
            color = cpApi.decimal2rgb(color);
          }
          color = cpApi.rgb2hex(color);
          cpBtn.attr('data-value', color).find('.icon').css('fill', color);
        }
        return {cpBtn:cpBtn, cpApi:cpApi, color:color};
      },

      // Colorpicker actions ['foreColor'|'backColor']
      colorpickerActions: function(action) {
        var self = this,
          state = this.colorpickerButtonState(action),
          cpBtn = state.cpBtn,
          cpApi = state.cpApi;

        cpBtn.on('selected.editor', function (e, item) {
          var value = ('#' + item.data('value')).toLowerCase();
          cpBtn.attr('data-value', value).find('.icon').css('fill', value);

          if (self.isIe || action === 'foreColor') {
            document.execCommand(action, false, value);
          }

          // [action: backColor] - for Chrome/Firefox/Safari
          else {
            // Get selection parent element
            var getSelectionParentElement = function() {
              var parentEl = null, sel;
              if (window.getSelection) {
                sel = window.getSelection();
                if (sel.rangeCount) {
                  parentEl = sel.getRangeAt(0).commonAncestorContainer;
                  if (parentEl.nodeType !== 1) {
                    parentEl = parentEl.parentNode;
                  }
                }
              } else if ( (sel = document.selection) && sel.type !== 'Control') {
                  parentEl = sel.createRange().parentElement();
              }
              return parentEl;
            };

            // FIX: "backColor" - Chrome/Firefox/Safari
            // some reason font/span node not get inserted with "backColor"
            // so use "fontSize" command to add node, then remove size attribute
            // this fix will conflict with combination of font size & background color
            document.execCommand('fontSize', false, '2');
            var parent = getSelectionParentElement().parentNode,
              els = parent.getElementsByTagName('font');

            // Using timeout, firefox not executes with current call stack
            setTimeout(function() {
              for (var i = 0, l = els.length; i < l; i++) {
                if (els[i].hasAttribute('size')) {
                  els[i].setAttribute('style', 'background-color: '+ value +';');
                  els[i].removeAttribute('size');
                }
              }
            }, 0);

          }

          setTimeout(function() {
            self.getCurrentElement().focus();
          }, 0);
        });

        // Toggle colorpicker
        cpApi.toggleList();
      },

      execFormatBlock: function (el) {
        var selectionData = this.getSelectionData(this.selection.anchorNode);
        // FF handles blockquote differently on formatBlock
        // allowing nesting, we need to use outdent
        // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla
        if (el === 'blockquote' && selectionData.el &&
            selectionData.el.parentNode.tagName.toLowerCase() === 'blockquote') {
            return document.execCommand('outdent', false, null);
        }
        if (selectionData.tagName === el) {
            el = 'p';
        }
        // When IE we need to add <> to heading elements and
        // blockquote needs to be called as indent
        // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
        // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777
        if (this.isIe) {
          if (el === 'blockquote') {
              return document.execCommand('indent', false, el);
          }
          el = '<' + el + '>';
        }

        return document.execCommand('formatBlock', false, el);
      },

      //Get What is Selected
      getSelectionData: function (el) {
        var tagName;

        if (el && el.tagName) {
        tagName = el.tagName.toLowerCase();
        }

        while (el && this.parentElements.indexOf(tagName) === -1) {
          el = el.parentNode;
          if (el && el.tagName) {
              tagName = el.tagName.toLowerCase();
          }
        }

        return {
          el: el,
          tagName: tagName
        };
      },

      isListItemChild: function (node) {
        var parentNode = node.parentNode,
            tagName = parentNode.tagName.toLowerCase();
        while (this.parentElements.indexOf(tagName) === -1 && tagName !== 'div') {
          if (tagName === 'li') {
              return true;
          }
          parentNode = parentNode.parentNode;
          if (parentNode && parentNode.tagName) {
              tagName = parentNode.tagName.toLowerCase();
          } else {
              return false;
          }
        }
        return false;
      },

      destroyToolbar: function() {
        var element = this.getCurrentElement();
        // Unbind all events attached to the old element that involve triggering the toolbar hide/show

        var toolbarApi = this.toolbar.data('toolbar');
        if (toolbarApi) {
          toolbarApi.destroy();
        }

        var tooltips = this.toolbar.find('button');
        tooltips.each(function() {
          var tooltip = $(this).data('tooltip');
          if (tooltip && typeof tooltip.destroy === 'function') {
            tooltip.destroy();
          }
        });

        this.toolbar.off('click.editor mousedown.editor');
        this.toolbar.remove();
        this.toolbar = undefined;
        this.element.off('mouseup.editor keyup.editor focus.editor blur.editor ' + this.pasteEvent);
        this.textarea.off('mouseup.editor keyup.editor focus.editor blur.editor ' + this.pasteEvent);
        element.off('keydown.editor');
        this.element.prev('.label').off('click.editor');
        $(window).off('resize.editor');
        $.each(this.modals, function(i, modal) {
          modal.off('beforeclose close open');
        });
        this.modals = {};

        this.element.trigger('destroy.toolbar.editor');
      },

      updated: function() {
        // TODO: Updated Method
        return this;
      },

     /**
     * Disable the editable area.
     */
      disable: function () {
        this.element.addClass('is-disabled').attr('contenteditable', 'false');
        this.container.addClass('is-disabled');
      },

      /**
      * Enable the editable area.
      */
      enable: function () {
        this.element.removeClass('is-disabled is-readonly').attr('contenteditable', 'true');
        this.container.removeClass('is-disabled is-readonly');
      },

      /**
      * Make the editable area readonly.
      */
      readonly: function () {
        this.element.removeClass('is-readonly').attr('contenteditable', 'false');
        this.container.addClass('is-readonly');
      },

      // Fix to Firefox get focused by keyboard
      setFocus: function() {
        var self = this,
          el = ($.trim(self.element.html()).slice(0, 1) === '<') ?
            $(':first-child', self.element)[0] : self.element[0];

        window.setTimeout(function() {
          var sel, range;
          if (window.getSelection && document.createRange) {
            range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(true);
            sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          } else if (document.body.createTextRange) {
            range = document.body.createTextRange();
            range.moveToElementText(el);
            range.collapse(true);
            range.select();
          }
        }, 1);

      },

      // Called whenever a paste event has occured
      onPasteTriggered: function () {
        if(!this.isFirefox && document.addEventListener) {
          document.addEventListener('paste', function (e) {
            if(typeof e.clipboardData !== 'undefined') {
              var copiedData = e.clipboardData.items[0]; // Get the clipboard data
              // If the clipboard data is of type image, read the data
              if(copiedData.type.indexOf('image') === 0) {
                var imageFile = copiedData.getAsFile();
                // We will use HTML5 FileReader API to read the image file
                var reader = new FileReader();

                reader.onload = function (evt) {
                  var result = evt.target.result; // base64 encoded image
                  document.execCommand('insertImage', false, result);
                  // Create an image element and append it to the content editable div
                  // var img = document.createElement('img');
                  // img.src = result;
                  // document.getElementById('editablediv').appendChild(img);
                };
                // Read the image file
                reader.readAsDataURL(imageFile);
              }
            }
          }, false);
        }
      },

      isWordFormat: function(content) {
        return (
          (/<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i).test(content) ||
          (/class="OutlineElement/).test(content) ||
          (/id="?docs\-internal\-guid\-/.test(content))
        );
      },

      cleanWordHtml: function(content) {
        var s = content;

        // Word comments like conditional comments etc
        s = s.replace(/<!--[\s\S]+?-->/gi, '');

        // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
        // MS Office namespaced tags, and a few other tags
        s = s.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, '');

        // Convert <s> into <strike> for line-though
        s = s.replace(/<(\/?)s>/gi, '<$1strike>');

        // Replace nsbp entites to char since it's easier to handle
        s = s.replace(/&nbsp;/gi, '\u00a0');

        // Convert <span style="mso-spacerun:yes"></span> to string of alternating
        // breaking/non-breaking spaces of same length
        s = s.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function(str, spaces) {
          return (spaces.length > 0) ?
          spaces.replace(/./, ' ').slice(Math.floor(spaces.length / 2)).split('').join('\u00a0') : '';
        });

        // Remove line breaks / Mso classes
        s = s.replace(/(\n|\r| class=(\'|")?Mso[a-zA-Z]+(\'|")?)/g, ' ');

        var i, l, re,
          badTags = ['style', 'script','applet','embed','noframes','noscript'];

        // Remove everything in between and including "badTags"
        for (i = 0, l = badTags.length; i < l; i++) {
          re = new RegExp('<'+badTags[i]+'.*?'+badTags[i]+'(.*?)>', 'gi');
          s = s.replace(re, '');
        }

        return s;
      },

      // Strip attributes
      stripAttribute: function (s, attribute, attributeStripper) {
        return (attribute === 'style') ?
          this.stripStyles(s, attributeStripper) :
          s.replace(attributeStripper, '');
      },

      // Strip styles
      stripStyles: function (s, styleStripper) {
        var stylesToKeep = ['color','background','font-weight','font-style','text-decoration','text-align'];
        return s.replace(styleStripper, function(m) {
          m = m.replace(/( style=|("|\'))/gi, '');
          var attributes = m.split(';'),
          strStyle = '';
          for (var i = 0; i < attributes.length; i++) {
            var entry = attributes[i].split(':');
            strStyle += (stylesToKeep.indexOf(entry[0]) > -1) ? entry[0] +':'+ entry[1] +';' : '';
          }
          return (strStyle !=='') ? (' style="'+ strStyle +'"') : '';
        });
      },

      getIndent: function(level) {
        var result = '',
          i = level * 2;
        if (level > -1) {
          while (i--) {
            result += ' ';
          }
        }
        return result;
      },

      formatHtml: function(html) {
        html = html.trim();
        var result = '',
          indentLevel = 0,
          tokens = html.split(/</);

        for (var i = 0, l = tokens.length; i < l; i++) {
          var parts = tokens[i].split(/>/);
          if (parts.length === 2) {
            if (tokens[i][0] === '/') {
              indentLevel--;
            }
            result += this.getIndent(indentLevel);
            if (tokens[i][0] !== '/') {
              indentLevel++;
            }
            if (i > 0) {
              result += '<';
            }
            result += parts[0].trim() + '>\n';
            if (parts[1].trim() !== '') {
              result += this.getIndent(indentLevel) + parts[1].trim().replace(/\s+/g, ' ') + '\n';
            }
            if (parts[0].match(/^(area|base|br|col|command|embed|hr|img|input|link|meta|param|source)/)) {
              indentLevel--;
            }
          } else {
            result += this.getIndent(indentLevel) + parts[0] + '\n';
          }
        }
        return result.trim();
      },

      /**
      * Detach Events and tear back additions.
      */
      destroy: function () {
        $('html').off('mouseup.editor');
        this.destroyToolbar();
        this.sourceView.remove();
        if ($('[data-editor="true"]').length === 1) {
          $('#modal-url-'+ this.id +', #modal-image-'+ this.id).remove();
        }
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Editor#events
       * @param {Object} input  &nbsp;-&nbsp; Fires after the value in the input is changed by user interaction.
       * @param {Object} keydown  &nbsp;-&nbsp; Fires after as keys are pressed.
       *
       */
      handleEvents: function () {

      }

    };

    // Make it plugin protecting from double initialization
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Editor(this, settings));
      }
    });

  };


  $.fn.expandablearea = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'expandablearea',
        defaults = {
          trigger: null,
          bottomBorder: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class ExpandableArea
    * @param {String} trigger  &nbsp;-&nbsp; Id of some other button to use as a trigger
    * @param {String} bottomBorder  &nbsp;-&nbsp; Change the border to bottom vs top (for some cases)
    *
    */
    function ExpandableArea(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ExpandableArea.prototype = {
      init: function() {
        this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        var id;
        this.id = id = this.element.attr('id');
        if (!id || id === undefined) {
          this.id = id = 'expandable-area-' + $('body').find('.expandable-area').index(this.element);
        }

        this.header = this.settings.trigger ? this.element : this.element.children('.expandable-header');
        this.footer = this.element.children('.expandable-footer');
        this.content = this.element.children('.expandable-pane');

        this.isCard = this.element.is('.card, .widget');
        return this;
      },

      build: function() {
        var self = this,
          expanded = this.element.hasClass('is-expanded');

        this.header.attr({
          'aria-expanded': '' + expanded,
          'aria-controls': this.id + '-content',
          'id': this.id + '-header'
        });
        this.content.attr({
          'id': this.id + '-content'
        });

        // Add the link and footer if not there.
        // If we're using an expandable card,
        if (!this.isCard && !this.footer.length && !this.settings.trigger) {
          this.footer =  $('<div class="expandable-footer"></div>').appendTo(this.element);
        }

        function getExpander(instance, useHeaderExpander) {
          var expander;

          if (useHeaderExpander === true) {
            // Use icon-based expander in the header
            expander = instance.header.find('expandable-expander');
            if (!expander.length) {
              expander = $('<a href="#" target="_self" class="btn-expander">' +
                '<svg class="chevron icon" focusable="false" aria-hidden="true" role="presenation">' +
                  '<use xlink:href="' + '#icon-caret-down' + '"></use>' +
                '</svg>' +
                '<span class="audible">'+ Locale.translate('ShowMore') +'</span>' +
              '</a>').appendTo(instance.header);
            }

            return expander;
          }

          // Use the text-based expander button in the footer
          expander = instance.footer.find('.expandable-expander');
          if (!expander.length) {
            expander = $('<a href="#" target="_self" class="expandable-expander hyperlink">' +
              '<span data-translated="true">'+ Locale.translate('ShowMore') +'</span>' +
            '</a>').prependTo(instance.footer);
          }
          return expander;
        }

        this.expander = getExpander(self, this.isCard);
        this.expander.attr('href', '#').hideFocus();

        if (this.expander.length === 0) {
          this.expander = $('#' + this.settings.trigger);
        }

        // Change the borer to the bottom vs top
        if (this.settings.bottomBorder) {
          this.element.addClass('has-bottom-border');
        }

        //Initialized in expanded mode.
        if (expanded) {
          this.content.addClass('no-transition');
          this.element.one('afterexpand.expandable-area', function() {
            self.content.removeClass('no-transition');
          });
          this.open();
        }

        if (!expanded) {
          this.content.addClass('no-transition');
          this.element.one('aftercollapse.expandable-area', function() {
            self.content.removeClass('no-transition');
          });
          this.close();
        }

        return this;
      },

      /**
      * Return if the expandable area is current disable or not.
      * @returns {Boolean}
      */
      isDisabled: function() {
        return this.element.hasClass('is-disabled');
      },

      handleKeys: function(e) {
        if (this.isDisabled()) {
          return;
        }

        var key = e.which;

        if (key === 13 || key === 32) { // Enter/Spacebar
          e.preventDefault();
          this.toggleExpanded();
          return false;
        }
      },

      handleFocus: function() {
        if (this.isDisabled()) {
          return;
        }

        this.header.addClass('is-focused');
      },

      handleBlur: function() {
        if (this.isDisabled()) {
          return;
        }

        this.header.removeClass('is-focused');
      },

      /**
       * Indicates whether or not this area is expanded.
       * @returns {boolean}
       */
      isExpanded: function() {
        return this.element.is('.is-expanded');
      },

      /**
       * Toggle Current Expansion State.
       */
      toggleExpanded: function() {
        // if (this.header.attr('aria-expanded') === 'true') {
        if (this.isExpanded()) {
          this.close();
        } else {
          this.open();
        }
      },

      /**
       * Open the pane if closed.
       */
      open: function() {
        var self = this,
        canExpand = this.element.triggerHandler('beforeexpand', [this.element]);

        if (canExpand === false) {
          return;
        }

        this.element.addClass('is-expanded');
        this.header.attr('aria-expanded', 'true');
        this.expander.addClass('active');
        this.element.triggerHandler('expand', [this.element]);

        this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowLess') ? Locale.translate('ShowLess') : 'Show Less');

        if (this.isCard) {
          this.expander.find('.icon').addClass('active');
        }

        if (this.content[0]) {
          this.content[0].style.display = 'block';
        }
        this.content.one('animateopencomplete', function() {
          self.element.triggerHandler('afterexpand', [self.element]);
        }).animateOpen();
      },

      /**
       * Close the pane if open.
       */
      close: function() {
        var self = this,
        canCollapse = this.element.triggerHandler('beforecollapse', [this.element]);

        if (canCollapse === false) {
          return;
        }

        this.expander.removeClass('active');
        this.element.triggerHandler('collapse', [this.element]);
        this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowMore') ? Locale.translate('ShowMore') : 'Show More');

        if (this.isCard) {
          this.expander.find('.icon').removeClass('active');
        }

        this.content.one('animateclosedcomplete', function() {
          self.element.removeClass('is-expanded');
          self.header.attr('aria-expanded', 'false');
          self.element.triggerHandler('aftercollapse', [self.element]);
          self.content[0].style.display = 'none';
        }).animateClosed();
      },

      /**
       * Disable the Expandable Area from being closable.
       */
      disable: function() {
        this.element.addClass('is-disabled');
      },

      /**
       * Enable the Expandable Area to allow close.
       */
      enable: function() {
        this.element.removeClass('is-disabled');
      },

      /**
       * Teardown - Remove added markup and events
       */
      destroy: function() {
        this.header.children('a').offTouchClick('expandablearea').off();
        this.header.off();
        this.header
          .removeAttr('aria-controls')
          .removeAttr('aria-expanded')
          .removeAttr('id');
        this.content.removeAttr('id').removeClass('no-transition');
        $.removeData(this.element[0], pluginName);
      },

      handleEvents: function() {
        var self = this;
        this.expander.onTouchClick('expandablearea').on('click.expandablearea', function(e) {
          if (!self.isDisabled()) {
            e.preventDefault();
            self.toggleExpanded();
          }
        });

        this.header.on('keydown.expandablearea', function(e) {
          self.handleKeys(e);
        }).on('focus.expandablearea', function(e) {
          self.handleFocus(e);
        }).on('blur.expandablearea', function(e) {
          self.handleBlur(e);
        });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new ExpandableArea(this, settings));
      }
    });
  };


  /**
  * Make elements in the jQuery selector disabled if they support the prop disabled. Or has a disable method.
  */
  $.fn.disable = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.disable) {
        value.disable();
      }
    });
    this.prop('disabled', true);
    return this;
  };

  /**
  * Make elements in the jQuery selector enabled if they support the prop disabled. Or has a enable method.
  */
  $.fn.enable = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.enable) {
        value.enable();
      }
    });
    this.prop('disabled', false);
    return this;
  };

  /**
  * Make elements in the jQuery selector readonly if they support the prop readonly. Or has a readonly method.
  */
  $.fn.readonly = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.readonly) {
        value.readonly();
      }
    });
    this.prop('readonly', true);
    return this;
  };

  /**
  * Track changes on the inputs passed in the jQuery selector and show a dirty indicator.
  */
  $.fn.trackdirty = function() {
      this.each(function () {
        var input = $(this);

        function valMethod(elem) {
          switch(elem.attr('type')) {
            case 'checkbox':
            case 'radio':
              return elem.prop('checked');
            default:
              return elem.val();
          }
        }

        // Get absolute position for an element
        function getAbsolutePosition(element) {
          var pos = element.position();
          element.parents().each(function() {
            var el = this;
            if (window.getComputedStyle(el, null).position === 'relative') {
              return false;
            }
            pos.left += el.scrollLeft;
            pos.top += el.scrollTop;
          });
          return {left:pos.left, top:pos.top};
        }

        input.data('original', valMethod(input))
        .on('resetdirty.dirty', function () {
          input.data('original', valMethod(input))
            .triggerHandler('doresetdirty.dirty');
        })
        .on('change.dirty doresetdirty.dirty', function (e) {
          var el = input,
            field = input.closest('.field, .radio-group'),
            label = $('label:visible', field),
            d = {class: '', style: ''};

          if (field.is('.field-fileupload')) {
            el = label.prev('input');
          }

          if (field.is('.editor-container')) {
            el = field.closest('textarea');
          }

          // Used element without .field wrapper
          if (!label[0]) {
            label = input.next('label');
          }
          if (input.attr('data-trackdirty') !== 'true') {
            return;
          }

          // Add class to element
          input.addClass('dirty');

          //Set css class
          if (input.is('[type="checkbox"], [type="radio"]')) {
            d.class += ' dirty-'+ input.attr('type');
            d.class += input.is(':checked') ? ' is-checked' : '';
          }
          if (input.is('select')) {
            d.class += ' is-select';
            el = input.next('.dropdown-wrapper').find('.dropdown');
          }

          //Add class and icon
          d.icon = el.prev();
          if (!d.icon.is('.icon-dirty')) {
            if (input.is('[type="checkbox"]')) {
              d.rect = getAbsolutePosition(label);
              d.style = ' style="left:'+ d.rect.left +'px; top:'+ d.rect.top +'px;"';
            }
            d.icon = '<span class="icon-dirty'+ d.class +'"'+ d.style +'></span>';
            d.msg = Locale.translate('MsgDirty') || '';
            d.msg = '<span class="audible msg-dirty">'+ d.msg +'</span>';

            // Add icon and msg
            var firstInput = $($(el[0].parentElement).find('input')[0]);
            el = input.is('[type="radio"]') ? firstInput : el;

            if ($(el[0].parentElement).find('.icon-dirty').length === 0) {
              el.before(d.icon);
              label.append(d.msg);
            }

            // Cache icon and msg
            d.icon = el.prev();
            d.msg = label.find('.msg-dirty');
          }

          //Handle resetting value back
          var original = input.data('original');
          var current = valMethod(input);
          if(field.is('.editor-container')) {
            // editors values are further down it's tree in a textarea, so get the elements with the value
            var textArea = field.find('textarea');
            original = textArea[0].defaultValue;
            current = valMethod(textArea);
          }
          if (current === original) {
            input.removeClass('dirty');
            $('.icon-dirty, .msg-dirty', field).add(d.icon).add(d.msg).remove();
            input.trigger(e.type === 'doresetdirty' ? 'afterresetdirty' : 'pristine');
            return;
          }

          //Trigger event
          input.trigger('dirty');

        });
      });
    return this;
  };

  // Fix: Labels without the "for" attribute
  $(function () {
    var str, control,
      labelText = $('.label-text'),
      labels = labelText.closest('label, .label');

    labels.each(function () {
      control = $('input, textarea, select', this);
      str = control.attr('class');

      $(this).addClass(function () {
        // Add "inline" and "inline-{control}" class to label
        // assuming control class is first thing in class string
        return 'inline' + (str ? ' inline-'+ (str.indexOf(' ') === -1 ? str : str.substr(0, str.indexOf(' '))) : '');
      });
    });
  });

  // Fix: Radio buttons was not selecting when click and than use arrow keys on Firefox
  $(function () {
    $('input:radio').on('click.radios', function() {
      this.focus();
    });
  });

  // Add css classes to parent for apply special rules
  $(function () {
    var addCssClassToParent = function(elemArray, cssClass) {
      for (var i = 0, l = elemArray.length; i < l; i++) {
        $(elemArray[i]).parent().addClass(cssClass);
      }
    };
    addCssClassToParent($('.field > input:checkbox, .field > .inline-checkbox'), 'field-checkbox');
    addCssClassToParent($('.field > input:radio, .field > .inline-radio'), 'field-radio');
  });


  $.fn.fileupload = function() {

    'use strict';

    // Settings and Options
    var pluginName = 'fileupload';

    /**
    * A trigger field for uploading a single file.
    *
    * @class FileUpload
    * @param {Boolean} none  &nbsp;-&nbsp; No options
    */
    function FileUpload(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // FileUpload Methods
    FileUpload.prototype = {

      init: function() {
        this.build();
      },

      // Example Method
      build: function() {
        var self = this,
          elem = this.element,
          hasInlineLabel = !elem.is('input.fileupload');

        this.fileInput = hasInlineLabel ? elem.find('input') : elem;

        elem.closest('.field').addClass('field-fileupload');

        //append markup
        var id = !hasInlineLabel ? (elem.attr('id') || elem.attr('name')) : elem.find('input').attr('name'),
          elemClass = !hasInlineLabel ? elem.attr('class') : elem.find('input').attr('class'),
          instructions = Locale.translate('FileUpload'),
          label = $('<label for="'+ id +'-filename">'+ elem.text() +' <span class="audible">'+ instructions +'</span></label>'),
          shadowField = $('<input readonly id="'+ id +'-filename" class="fileupload-background-transparent'+ (elemClass ? ' '+ elemClass : '') +'" type="text">'),
          svg = '<span class="trigger" tabindex="-1">' + $.createIcon('folder') + '</span>',
          svgClose = '<span class="trigger-close" tabindex="-1">' + $.createIcon('close') + '</span>';

        if (!hasInlineLabel) {
          var orgLabel = elem.prev('label');

          if (orgLabel.length === 0) {  //Could be wrapped (angular)
            orgLabel = elem.parent().prev('label');
          }

          label = $('<label for="'+ (elem.attr('id') || elem.attr('name')) +'-filename">'+ orgLabel.text() +'</label>');
          elem.before(label, shadowField);
          this.fileInput.after(svgClose);
          this.fileInput.after(svg);
          orgLabel.addClass('audible').append('<span class="audible">'+ instructions +'</span>');
        } else {
          elem.before(label, shadowField);
          this.fileInput.after(svgClose);
          this.fileInput.after(svg);
        }

        this.textInput = elem.parent().find('[type="text"]');
        this.svg = elem.parent().find('.trigger');
        this.svgClose = elem.parent().find('.trigger-close');

        /*
        * Added Keydown for Keyboard Backspace and remove Keypress because it doesn't detect Backspace
        */
        this.textInput.on('keydown.fileupload', function(e) {
          var handle = false;
          if (e.which === 13 || e.which === 32) {
            elem.parent().find('[type="file"]').trigger('click');
            handle = true;
          } else if (e.which === 8) {
            self.clearUploadFile();
            handle = true;
          }
          if (handle) {
            e.stopPropagation();
          }
        });

        this.svg.on('click.fileupload', function () {
          self.fileInput.trigger('click');
          return false;
        });

        this.svgClose.on('click.fileupload', function () {
          self.clearUploadFile();
          return false;
        });

        if (this.fileInput.is(':disabled')) {
          this.textInput.prop('disabled', true);
        }

        if (elem.hasClass('required')) {
          label.addClass('required');
          elem.removeClass('required');
        }

        if (this.fileInput.attr('data-validate')) {
          this.textInput.attr('data-validate', this.fileInput.attr('data-validate'));
          this.textInput.validate();
        }

        if (this.fileInput.attr('readonly')) {
          this.textInput.prop('disabled', false);
          this.textInput[0].classList.remove('fileupload-background-transparent');
          this.fileInput.attr('disabled', 'disabled');
        }

        /*
        * New Event for File Upload Change
        */
        this.fileInput.on('change.fileupload', function() {
          if (this.files.length > 0) {
            self.textInput.val(this.files[0].name);
            self.svgClose.show().addClass('is-visible');
          } else {
            self.clearUploadFile();
          }
        });

        // Fix: not sure why, but some browser(ie. safari) need to rerender,
        // some rules were not applying from css file
        self.fileInput.css({position: 'static', left: 0});
        setTimeout(function() {
          self.fileInput.css({position: 'fixed', left: '-10000px'});
        }, 0);
      },

      /*
      * Clear the Input Upload File
      */
      clearUploadFile: function() {
        var val = this.fileInput.val();
        this.fileInput.add(this.textInput).val('');
        this.svgClose.hide().removeClass('is-visible');
        if (val !== '') {
          this.fileInput.triggerHandler('change');
        }
      },

      /**
      * Teardown - Remove added markup and events
      */
      destroy: function() {
        this.svg.add(this.svgClose).off('click.fileupload');
        this.fileInput.off('change.fileupload');
        this.textInput.off('keydown.fileupload');

        this.element.closest('.field-fileupload')
          .removeClass('field-fileupload')
          .find('>label:first, >[type="text"]:first, .trigger, .trigger-close, .icon-dirty, .msg-dirty').remove();

        $.removeData(this.element[0], pluginName);
      },

      /**
      * Disable the input and button.
      */
      disable: function() {
        this.textInput.prop('disabled', true);
        this.fileInput.prop('disabled', true);
      },

      /**
      * Enable the input and button.
      */
      enable: function() {
        this.textInput.prop('disabled', false).prop('readonly', false);
        this.fileInput.removeAttr('disabled');
      },

      /**
      * Make the input readonly and disable the button.
      */
      readonly: function() {
        this.textInput.prop('readonly', true);
        this.fileInput.prop('disabled', true);

        this.textInput.prop('disabled', false);
        this.textInput.removeClass('fileupload-background-transparent');
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new FileUpload(this));
      }
    });
  };


  $.fn.fieldoptions = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'fieldoptions',
        defaults = {
        },
        settings = $.extend({}, defaults, options);

    /**
    *
    * @class FieldOptions
    */
    function FieldOptions(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // FieldOptions Methods
    FieldOptions.prototype = {

      init: function() {
        this.setElements();
        this.handleEvents();
      },

      // Set elements
      setElements: function() {
        var self = this;
        self.isFirefox = Soho.env.browser.name === 'firefox';
        self.isSafari = Soho.env.browser.name === 'safari';

        self.targetElem = self.element;
        self.hoverElem = self.targetElem;
        self.field = self.element.closest('.field, .radio-group');
        self.fieldParent = self.element.closest('.field').parent();
        self.trigger = self.field.find('.btn-actions');

        // Fix: Some reason firfox "event.relatedTarget" not working
        // with un-focusable elements(ie.. div) on focusout, use "contentEditable"
        // https://stackoverflow.com/a/43010274
        if (self.isFirefox && self.trigger.length) {
          self.trigger[0].contentEditable = true;
          self.trigger.on('keydown.' + pluginName, function(e) {
            var key = e.which || e.keyCode || e.charCode || 0;
            if (key !== 9) {
              e.preventDefault();
              e.stopPropagation();
            }
          });
        }

        // Adjust some setting for popupmenu this trigger(action button)
        setTimeout(function() {
          self.popupmenuApi = self.trigger.data('popupmenu');
          if (self.popupmenuApi) {
            self.popupmenuApi.settings.returnFocus = false;
            self.popupmenuApi.settings.offset.y = 10;
          }
        }, 100);

        return this;
      },

      // Handle Events
      handleEvents: function() {
        var self = this,
          datepicker = self.element.data('datepicker'),
          timepicker = self.element.data('timepicker'),
          dropdown = self.element.data('dropdown'),
          lookup = self.element.data('lookup') || self.element.hasClass('lookup'),
          isFileupload = self.element.is('.fileupload'),
          isSearchfield = self.element.is('.searchfield'),
          isSpinbox = self.element.is('.spinbox'),
          isColorpicker = self.element.is('.colorpicker'),
          isRadio = self.element.closest('.radio-group').length > 0,
          isFieldset = self.element.is('.data') && self.element.closest('.summary-form').length > 0,

          // Helper functions
          isFocus = function(elem) {
            return $(':focus').is(elem);
          },
          doActive = function() {
            self.element.add(self.trigger).add(self.field).add(self.fieldParent).addClass('is-active');
          },
          doUnactive = function() {
            self.element.add(self.trigger).add(self.field).add(self.fieldParent).removeClass('is-active');
          },
          canUnactive = function(e) {
            var r = !isFocus(self.element);
            r = self.trigger.is(e.relatedTarget) ? false : r;
            r = self.trigger.is('.is-open') ? false : r;
            r = datepicker && datepicker.isOpen() ? false : r;
            r = timepicker && timepicker.isOpen() ? false : r;
            r = $(e.relatedTarget).prev().is(self.element) ? false : r;
            r = dropdown && dropdown.isOpen() ? false : r;
            r = lookup && lookup.modal && lookup.modal.isOpen() ? false : r;
            return r;
          },
          getTriggerTopVal = function() {
            var height = self.element.height();

            if (isFieldset) {
              var lineHeight = parseInt(self.element.css('line-height'), 10);
              if (height > lineHeight) {
                self.element.css({'margin-bottom': '', 'padding-bottom': ''});
                return ((height - lineHeight)/2) * -1;
              } else {
                self.element.css({'margin-bottom': '8px', 'padding-bottom': '12px'});
                return 6;
              }
            }
            else if (isRadio) {
              return ((height - self.trigger.height())/2) * -1;
            }
          },
          setTriggerCssTop = function() {
            self.trigger.css({top:  getTriggerTopVal() +'px'});
          };

        // Update target element
        self.targetElem = dropdown ? dropdown.pseudoElem : self.targetElem;
        self.targetElem = isFileupload ? self.field.find('.fileupload[type="text"]') : self.targetElem;

        // Update hover element
        self.hoverElem = isSpinbox ? self.element.add(self.field.find('.down, .up')) : self.targetElem;
        self.hoverElem = isColorpicker ? self.element.add(self.field.find('.colorpicker-container, .swatch, .trigger')) : self.hoverElem;

        // Set is-hover for field
        self.hoverElem
          .on('mouseenter.' + pluginName, function() {
            self.field.addClass('is-hover');
          })
          .on('mouseleave.' + pluginName, function() {
            self.field.removeClass('is-hover');
          });

        // Adjust stack order for dropdown
        if (dropdown) {
          setTimeout(function() {
            self.trigger.data('popupmenu')
              .menu.closest('.popupmenu-wrapper').css({'z-index': '4502'});
          }, 0);
        }
        // Adjust return focus for timepicker
        if (timepicker) {
          timepicker.settings.returnFocus = false;
        }
        // Move trigger(action-button) in to lookup-wrapper
        if (lookup || isColorpicker) {
          self.field.addClass('is-fieldoptions');
          self.field.on('click.' + pluginName, '.lookup-wrapper .trigger, .colorpicker-container .trigger', function() {
            doActive();
          });
        }
        // Bind fileupload events
        if (isFileupload) {
          self.element.on('change.' + pluginName, function() {
            self.targetElem.focus();
          });
          self.field.on('click.' + pluginName, 'label.fileclose .trigger', function() {
            self.targetElem.focus();
          });
          self.field.on('click.' + pluginName, 'label.fileupload .trigger', function() {
            doActive();
          });
        }
        // Spinbox add parent css class
        if (isSpinbox) {
          self.field.addClass('is-fieldoptions');
        }
        // Move trigger(action-button) in to searchfield-wrapper
        if (isSearchfield) {
          self.field.addClass('is-fieldoptions');
          setTimeout(function() {
            self.trigger.add(self.trigger.next('.popupmenu'))
              .appendTo(self.element.closest('.searchfield-wrapper'));
          }, 0);
        }
        // Fieldset - set trigger(action-button) top value and bind events
        if (isFieldset) {
          setTriggerCssTop();
          self.targetElem.add(self.trigger).on('keydown.' + pluginName, function(e) {
            var key = e.which || e.keyCode || e.charCode || 0;
            if (key === 13) {
              setTimeout(function() {
                doActive();
              }, 0);
            }
          });
          self.targetElem.attr('tabindex', 0)
          .on('click.' + pluginName, function() {
            doActive();
          });
          $(document).on('click.' + pluginName, function(e) {
            if (!$(e.target).is(self.element)) {
              doUnactive();
            }
          });
          $('body').on('resize.' + pluginName, function() {
            setTriggerCssTop();
          });
        }
        // Radio group - set trigger(action-button) top value and bind events
        if (isRadio) {
          setTriggerCssTop();
          self.element.find('.radio').on('focusin.' + pluginName, function() {
            var delay = self.isSafari ? 200 : 0;
            setTimeout(function() {
              doActive();
            }, delay);
          });
          $('body').on('resize.' + pluginName, function() {
            setTriggerCssTop();
          });
        }

        // Element events
        self.targetElem
          .on('focusin.' + pluginName, function() {
            doActive();
          })
          .on('focusout.' + pluginName, function(e) {
            var delay = self.isSafari ? 200 : 0;
            setTimeout(function() {
              if (canUnactive(e)) {
                doUnactive();
              }
            }, delay);
          });

        // Trigger(action button) events
        self.trigger
          .on('focusin.' + pluginName +' click.' + pluginName, function() {
            doActive();
          })
          .on('focusout.' + pluginName, function(e) {
            if (canUnactive(e)) {
              doUnactive();
            }
          })
          .on('selected.' + pluginName, function() {
            self.popupmenuApi.settings.returnFocus = true;
          })
          .on('close.' + pluginName, function(e, isCancelled) {
            if (canUnactive(e) && isCancelled) {
              doUnactive();
            }
          });

        // FIX: Safari - by default does not get focus on some elements while using tab key
        // https://stackoverflow.com/a/29106095
        if (self.isSafari || isFileupload) {
          if (isRadio) {
            self.element.attr('tabindex', 0);
          }
          self.targetElem.on('keydown.' + pluginName, function(e) {
            var key = e.which || e.keyCode || e.charCode || 0;
            if (key === 9 && !e.shiftKey) {
              self.trigger.focus();
              doActive();
              e.preventDefault();
              e.stopPropagation();
            }
          });

          self.element
            .on('listopened.' + pluginName, function() {
              doActive();
            })
            .on('listclosed.' + pluginName, function() {
              doUnactive();
            });
        }

        return this;
      }, // END: Handle Events -------------------------------------------------

      // Make enable
      enable: function () {
        this.trigger.prop('disabled', false);
        return this;
      },

      // Make disable
      disable: function () {
        this.trigger.prop('disabled', true);
        return this;
      },

      // Unbind all events
      unbind: function() {
        $(document)
          .add('body')
          .add(this.field)
          .add(this.element)
          .add(this.trigger)
          .add(this.hoverElem)
          .add(this.targetElem)
          .add(this.element.find('.radio'))
          .off('.' + pluginName);
        return this;
      },

      // Update this plugin
      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new FieldOptions(this, settings));
      }
    });
  };


  $.fn.fileuploadadvanced = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'fileuploadadvanced',
        defaults = {
          isStandalone: true, //
          standaloneClass: 'standalone', // css class if on page
          allowedTypes: '*', // restrict file types(ie. 'jpg|png|gif') ['*' all types]
          maxFilesInProcess: 99999, // max files can be upload
          maxFileSize: -1, // max file size in bytes, -1 for unlimited
          fileName: 'myfile', // variable name to read from server
          isDisabled: false, // Disabled
          showBrowseButton: true, // Browse files to upload
          send: null, // Function to send files to server

          // Text strings
          textDropArea: Locale.translate('TextDropArea'),
          textDropAreaWithBrowse: Locale.translate('TextDropAreaWithBrowse'),
          textBtnCancel: Locale.translate('TextBtnCancel'),
          textBtnCloseError: Locale.translate('TextBtnCloseError'),
          textBtnRemove: Locale.translate('TextBtnRemove'),

          // Error strings
          errorAllowedTypes: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorAllowedTypes'),
          errorMaxFileSize: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorMaxFileSize'),
          errorMaxFilesInProcess: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorMaxFilesInProcess')
        },
        settings = $.extend({}, defaults, options);

    /**
    * A trigger field for uploading a single file.
    *
    * @class FileUploadAdvanced
    * @param {Boolean} isStandalone  &nbsp;-&nbsp; On page(true) -or- on modal (false) , this is used for some visual style only.
    * @param {Boolean} allowedTypes  &nbsp;-&nbsp; Restrict file types(ie. 'jpg|png|gif') ['*' all types]
    * @param {Boolean} maxFilesInProcess  &nbsp;-&nbsp; Max number of files can be uploaded
    * @param {Boolean} maxFileSize  &nbsp;-&nbsp; Max file size in bytes, -1 for unlimited
    * @param {Boolean} fileName  &nbsp;-&nbsp; Variable name to read from server
    * @param {Boolean} isDisabled  &nbsp;-&nbsp; Make control disabled
    * @param {Boolean} showBrowseButton  &nbsp;-&nbsp; Add way to browse files to upload
    * @param {Function} send  &nbsp;-&nbsp; Method for send file to upload
    * @param {String} textDropArea  &nbsp;-&nbsp; Text to show in drop area
    * @param {String} textDropAreaWithBrowse  &nbsp;-&nbsp; Text to show in drop area when browse option true
    * @param {String} textBtnCancel  &nbsp;-&nbsp; Hidden text for cancel button
    * @param {String} textBtnCloseError  &nbsp;-&nbsp; Hidden text for error close button
    * @param {String} textBtnRemove  &nbsp;-&nbsp; Hidden text for remove button
    *
    */
    function FileUploadAdvanced(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // FileUploadAdvanced Methods
    FileUploadAdvanced.prototype = {

      init: function() {
        this.build();
        this.handleEvents();
      },

      //Add any markup
      build: function() {
        var s = this.settings,
          cssClassList = s.isStandalone ? s.standaloneClass : '',
          fileExtensions, types, isExtra, id, html;

        // Disabled
        if (this.element.is('.is-disabled')) {
          s.isDisabled = true;
        }
        if (s.isDisabled) {
          cssClassList += ' is-disabled';
        }

        // Browse files option
        if (s.showBrowseButton) {
          types = '';
          id = $.fn.uniqueId('fileupload-adv-');
          fileExtensions = s.allowedTypes.split(/[\s|]+/g);
          isExtra = s.maxFilesInProcess > 1 ? ' multiple' : '';
          isExtra += s.isDisabled ? ' disabled' : '';

          if (fileExtensions.length === 1) {
            if (fileExtensions[0] !== '*') {
              types = '.'+ fileExtensions[0];
            }
          } else {
            for (var i = 0, l = fileExtensions.length; i < l; i++) {
              types += '.'+ fileExtensions[i] + (i !== (l-1) ? ',' : '');
            }
          }

          html = '' +
            '<div class="fileupload-wrapper '+ cssClassList +'">' +
              '<div class="container drop-area">' +
                $.createIcon('upload') +
                '<label class="fileupload-adv-browse-lbl">' +
                  '<span>'+ s.textDropAreaWithBrowse +'</span>' +
                  '<input type="file" name="'+ id +'" accept="'+ types +'"'+ isExtra +' />' +
                '</label>' +
              '</div>' +
            '</div>';
        }

        // Without browse files option
        else {
          html = '' +
            '<div class="fileupload-wrapper '+ cssClassList +'">' +
              '<div class="container drop-area">' +
                $.createIcon('upload') +
                '<p>'+ s.textDropArea +'</p>' +
              '</div>' +
            '</div>';
        }
        this.element.append(html);
        this.dropArea = $('.drop-area', this.element);
      },

      //Attach Events used by the Control
      handleEvents: function () {
        var self = this,
          s = this.settings;


        self.dropArea

        // Drag enter
        .on('dragenter.fileuploadadvanced', function (e) {
          self.element.triggerHandler('filesdragenter');
          e.stopPropagation();
          e.preventDefault();

          if (s.isDisabled) {
            return;
          }
          $(this).addClass('hover');
        })

        // Drag over
        .on('dragover.fileuploadadvanced', function (e) {
          e.stopPropagation();
          e.preventDefault();
        })

        // Drop
        .on('drop.fileuploadadvanced', function (e) {
          var files = e.originalEvent.dataTransfer.files;
          e.preventDefault();
          if (s.isDisabled) {
            return;
          }

          self.element.triggerHandler('filesdroped', [files]);

          $(this).removeClass('hover is-focus');

          // Clear previous errors in general area
          $('span.msg', this.element).closest('.error').remove();

          // Max files can be upload
          if ((files.length + $('.progress', this.element).length) > s.maxFilesInProcess) {
            self.showError(s.errorMaxFilesInProcess);
            return;
          }

          self.handleFileUpload(files);
        });

        if (s.showBrowseButton && !s.isDisabled) {
          var label = self.dropArea.find('.fileupload-adv-browse-lbl'),
            input = label.find('input[type="file"]');

          // Only let open dialog if clicked on link or input
          label.click(function(e) {
            if (!$(e.target).is('.hyperlink, input[type="file"]')) {
              e.preventDefault();
            }
          });

          input.hideFocus();
          input.on('hidefocusremove.fileuploadadvanced', function (e) {
              e.stopPropagation();
              self.dropArea.addClass('is-focus');
            })
            .on('hidefocusadd.fileuploadadvanced', function (e) {
              e.stopPropagation();
              self.dropArea.removeClass('is-focus');
            })
            .on('change.fileuploadadvanced', function (e) {
              e.stopPropagation();
              self.handleFileUpload(this.files);
            });
        }

        // If the files are dropped outside the div, files will open in the browser window.
        // To avoid this prevent 'drop' event on document.
        $(document).on('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced', function (e) {
          e.stopPropagation();
          e.preventDefault();

          if (e.type === 'dragover') {
            self.dropArea.removeClass('hover');
          }
        });

      },

      /**
      * Read the file contents using HTML5 FormData()
      * @param {Object} files &nbsp;-&nbsp; File object containing uploaded files.
      */
      handleFileUpload: function (files) {
        var s = this.settings,
          fileName = s.fileName.replace('[]', '');

        for (var i = 0, l = files.length; i < l; i++) {

          // Check if file type allowed
          if (!this.isFileTypeAllowed(files[i].name)) {
            this.showError(s.errorAllowedTypes, files[i]);
            continue;
          }

          // Check for max file size
          if (s.maxFileSize !== -1 && files[i].size > s.maxFileSize) {
            this.showError(s.errorMaxFileSize, files[i]);
            continue;
          }

          this.element.triggerHandler('beforecreatestatus', [files[i]]);
          var fd = new FormData();
          fd.append(fileName + '[]', files[i]);

          var status = this.createStatus(files[i]);
          status.container.find('.status-icon .action').focus();
          this.element.triggerHandler('aftercreatestatus', [files[i]]);

          if (typeof s.send === 'function') {
            s.send(fd, status);
          } else {
            this.sendFileToServer(fd, status);
          }
        }

        if (s.showBrowseButton) {
          // Clear browse file input
          this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').val('');
        }
      },

      // Create status
      createStatus: function (file) {
        var self = this,
          s = this.settings,
          container = $(
            '<div class="container">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ icon: 'close', classes: ['icon-close'] }) +
                    '<span>'+ s.textBtnCancel +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="description">'+ file.name +'</span>' +
                '<div class="l-pull-right">' +
                  '<span class="size">'+ self.formatFileSize(file.size) +'</span>' +
                '</div>' +
              '</div>' +
              '<div class="progress-row">' +
                '<span class="progress">' +
                  '<span class="progress-bar" data-value="0"></span>' +
                '</span>' +
              '</div>' +
            '</div>'),

          btnCancel = $('.action', container).button(),
          rightSide = $('.l-pull-right', container),
          progressBar = $('.progress-bar', container).progress({ animationLength: 10 });

        // Add this container
        self.dropArea.after(container);

        // Update progress-bar
        var setProgress = function(progress) {
            self.element.triggerHandler('fileprogress', [{file: file, 'progress': progress}]);
            progressBar.attr('data-value', progress).triggerHandler('updated');
          },

          // Set abort action
          setAbort = function(jqxhr) {
            btnCancel.on('click.fileuploadadvanced', function() {
              self.element.triggerHandler('fileaborted', [file]);
              jqxhr.abort();
              btnCancel.off('click.fileuploadadvanced');
              container.remove();
            });
          },

          // Set completed state
          setCompleted = function(data) {
            container.addClass('completed');

            // Add "Completed" icon
            btnCancel.after($.createIcon('check'));

            // Add "Remove from server" button
            rightSide.append(
              '<button type="button" class="btn-icon action">' +
                $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                '<span>'+ s.textBtnRemove +'</span>' +
              '</button>');

            // Set "Remove from server" button action
            $('.action', rightSide).button().on('click.fileuploadadvanced', function() {
              $(this).off('click.fileuploadadvanced');
              container.remove();

              // TODO: server call for removing data
              data.remove();
            });

            // Remove Cancel button and progress-bar area
            btnCancel.off('click.fileuploadadvanced');
            btnCancel.add(progressBar.closest('.progress-row')).remove();
            self.element.triggerHandler('filecompleteuploading', [file]);
          };

        return {
          file: file,
          container: container,
          setProgress: setProgress,
          setAbort: setAbort,
          setCompleted: setCompleted
        };
      },

      /**
      * Function you can implement to send data to the server.
      * @param {Object} formData - Contains the form data / file data.
      * @param {Object} status - Status of the upload operation
      *
      */
      sendFileToServer: function (formData, status) {
        var jqXHR = { abort: function() {} },
          tempData = { remove: function() {} },
          percent = 0,
          total = parseFloat(status.file.size),
          timer = new $.fn.timer(function() {
            status.setCompleted(tempData);
          }, total);

        $(timer.event)
        .on('update', function(e, data) {
          percent = Math.ceil(data.counter / total * 100);
          status.setProgress(percent);
        });

        status.setAbort(jqXHR);
      },

      // Show Errors
      showError: function (error, file) {
        var container,
          s = this.settings;

        if (error === s.errorMaxFilesInProcess) {
          // This error show without file name or size in general area
          container = $(
            '<div class="container error">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                    '<span>'+ s.textBtnCloseError +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="msg">'+ error +'</span>' +
              '</div>' +
            '</div>');
        }
        else {
          container = $(
            '<div class="container error">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                    '<span>'+ s.textBtnCloseError +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="description">'+ file.name +'</span>' +
                '<div class="l-pull-right">' +
                  '<span class="size">'+ this.formatFileSize(file.size) +'</span>' +
                '</div>' +
              '</div>' +
              '<div class="msg">' +
                '<p>' + error +'</p>' +
              '</div>' +
            '</div>');
        }

        $('.action', container).button().on('click.fileuploadadvanced', function() {
          container.remove();
        });

        // Add this container
        this.dropArea.after(container);
      },

      // Check if file type allowed
      isFileTypeAllowed: function (fileName) {
        var fileExtensions = this.settings.allowedTypes.toLowerCase().split(/[\s|]+/g),
          ext = fileName.split('.').pop().toLowerCase();
        if(this.settings.allowedTypes !== '*' && $.inArray(ext, fileExtensions) < 0) {
          return false;
        }
        return true;
      },

      // Helper function that formats the file sizes
      formatFileSize: function (bytes) {
        var scale = {
          GB: 1000000000,
          MB: 1000000,
          KB: 1000
        };
        if (typeof bytes !== 'number') {
          return '';
        }
        if (bytes >= scale.GB) {
          return (bytes / scale.GB).toFixed(2) +' GB';
        }
        if (bytes >= scale.MB) {
          return (bytes / scale.MB).toFixed(2) +' MB';
        }
        return (bytes / scale.KB).toFixed(2) +' KB';
      },

      /**
      * Set input to enabled.
      */
      enable: function() {
        this.settings.isDisabled = false;
        this.teardown();
        this.element
          .find('.fileupload-wrapper').removeClass('is-disabled')
          .find('.fileupload-adv-browse-lbl input[type="file"]').removeAttr('disabled');
        this.handleEvents();
      },

      /**
      * Set input to disabled.
      */
      disable: function() {
        this.settings.isDisabled = true;
        this.teardown();
        this.element
          .find('.fileupload-wrapper').addClass('is-disabled')
          .find('.fileupload-adv-browse-lbl input[type="file"]').attr('disabled', 'disabled');
        this.handleEvents();
      },

      /**
      * Teardown - Remove added events
      */
      teardown: function() {
        this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').off('hidefocusremove.fileuploadadvanced hidefocusadd.fileuploadadvanced change.fileuploadadvanced');

        this.dropArea.off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
        $(document).off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
        $('.action', this.element).off('click.fileuploadadvanced');
      },

      /**
      * Destroy - Remove added markup and events
      */
      destroy: function() {
        this.teardown();
        $('.fileupload-wrapper', this.element).remove();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new FileUploadAdvanced(this, settings));
      }
    });
  };


/*
ERROR
--------
https://social.technet.microsoft.com/Forums/ie/en-US/ec3c0be0-0834-4873-8e94-700e9df9c822/edge-browser-drag-and-drop-files-not-working?forum=ieitprocurrentver

*/

  $.fn.header = function(options) {

    'use strict';

    // Tab Settings and Options
    var pluginName = 'header',
        defaults = {
          demoOptions: true,
          useBackButton: true,
          useBreadcrumb: false,
          usePopupmenu: false,
          tabs: null,
          wizardTicks: null,
          useAlternate: false,
          addScrollClass: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * Special Toolbar at the top of the page used to faciliate SoHo Xi Nav Patterns
    *
    * @class Header
    * @param {Boolean} demoOptions  &nbsp;-&nbsp; Used to enable/disable default SoHo Xi options for demo purposes
    * @param {Boolean} useBackButton  &nbsp;-&nbsp; If true, displays a back button next to the title in the header toolbar
    * @param {Boolean} useBreadcrumb  &nbsp;-&nbsp; If true, displays a breadcrumb on drilldown
    * @param {Boolean} usePopupmenu  &nbsp;-&nbsp; f true, changes the Header Title into a popupmenu that can change the current page
    * @param {Array} tabs  &nbsp;-&nbsp; If defined as an array of Tab objects, displays a series of tabs that represent application sections
    * @param {Array} wizardTicks  &nbsp;-&nbsp; If defined as an array of Wizard Ticks, displays a Wizard Control that represents steps in a process
    * @param {Boolean} useAlternate  &nbsp;-&nbsp; If true, use alternate background/text color for sub-navigation areas
    * @param {Boolean} addScrollClass  &nbsp;-&nbsp; If true a class will be added as the page scrolls up and down to the header for manipulation. Eg: Docs Page.
    *
    */
    function Header(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Header.prototype = {

      init: function() {
        this
          .setup()
          .build()
          .handleEvents();

        // Theme, Personalization, Language Changer, Scrolling
        if (this.settings.demoOptions) {
          this.initPageChanger();
        }
      },

      setup: function() {
        // TODO: Settings all work independently, but give better descriptions
        this.settings.demoOptions = this.element.attr('data-demo-options') ? this.element.attr('data-demo-options') === 'true' : this.settings.demoOptions;
        this.settings.useBackButton = this.element.attr('data-use-backbutton') ? this.element.attr('data-use-backbutton') === 'true' : this.settings.useBackButton;
        this.settings.useBreadcrumb = this.element.attr('data-use-breadcrumb') ? this.element.attr('data-use-breadcrumb') === 'true' : this.settings.useBreadcrumb;
        this.settings.useAlternate = this.element.attr('data-use-alternate') ? this.element.attr('data-use-alternate') === 'true' : this.settings.useAlternate;

        this.settings.tabs = !$.isArray(this.settings.tabs) ? null : this.settings.tabs;
        this.settings.wizardTicks = !$.isArray(this.settings.wizardTicks) ? null : this.settings.wizardTicks;

        this.titleText = this.element.find('.title > h1');

        // Used to track levels deep
        this.levelsDeep = [];
        this.levelsDeep.push('' + this.titleText.text());

        return this;
      },

      build: function() {
        this.toolbarElem = this.element.find('.toolbar');

        // Build toolbar if it doesn't exist
        if (!this.toolbarElem.data('toolbar')) {
          var opts = $.fn.parseOptions(this.toolbarElem);
          this.toolbarElem.toolbar(opts);
        }
        this.toolbar = this.toolbarElem.data('toolbar');

        // Hamburger Icon is optional, but tracking it is necessary.
        this.titleButton = this.element.find('.title > .application-menu-trigger');
        this.hasTitleButton = this.titleButton.length > 0;

        if (this.hasTitleButton) {
          this.toolbarElem.addClass('has-title-button');
          var appMenu = $('#application-menu').data('applicationmenu');
          if (appMenu) {
            appMenu.modifyTriggers([this.titleButton], null, true);
          } else {
            $('#application-menu').applicationmenu({
              triggers: [this.titleButton]
            });
          }
        }

        // Application Tabs would be available from the Application Start, so activate them during build if they exist
        if (this.settings.tabs && this.settings.tabs.length) {
          this.buildTabs();
        }

        if (this.settings.wizardTicks && this.settings.wizardTicks.length) {
          this.buildWizard();
        }

        if (this.settings.usePopupmenu) {
          this.buildPopupmenu();
        }

        //Add a Scrolling Class to manipulate the header
        if (this.settings.addScrollClass) {
          var self =$(this.element),
            scrollDiv = $(this.element).next('.scrollable'),
            container = (scrollDiv.length === 1 ? scrollDiv : $(window)),
            scrollThreshold = this.settings.scrollThreshold ? this.settings.scrollThreshold : 15;

          container.on('scroll.header', function () {
            if (this.scrollTop > scrollThreshold) {
              self.addClass('is-scrolled-down');
            } else {
              self.removeClass('is-scrolled-down');
            }

          });

          if (container.scrollTop() > scrollThreshold ) {
            self.addClass('is-scrolled-down');
          }
        }

        return this;
      },

      buildTitleButton: function() {
        if (this.levelsDeep.length > 1 && !this.hasTitleButton && !this.titleButton.length) {
          this.titleButton = $('<button class="btn-icon back-button" type="button"></button>');
          this.titleButton.html('<span class="audible">'+ Locale.translate('Drillup') +'</span>' +
            '<span class="icon app-header go-back">' +
              '<span class="one"></span>' +
              '<span class="two"></span>' +
              '<span class="three"></span>' +
            '</span>');
          this.titleButton.prependTo(this.element.find('.title'));

          // Need to trigger an update on the toolbar control to make sure tabindexes and events are all firing on the button
          this.toolbar.element.triggerHandler('updated');
        }

        this.titleButton.find('.icon.app-header').addClass('go-back');
      },

      // Used for adding a Breadcrumb Element to the Header
      buildBreadcrumb: function() {
        var self = this,
          breadcrumbClass = 'has-breadcrumb';

        if (this.settings.useAlternate) {
          breadcrumbClass = 'has-alternate-breadcrumb';
        }
        this.element.addClass(breadcrumbClass);

        this.breadcrumb = this.element.find('.breadcrumb');
        if (!this.breadcrumb.length) {
          this.breadcrumb = $('<nav class="breadcrumb" role="navigation" style="display: none;"></nav>').appendTo(this.element);
          this.breadcrumb.on('click', 'a', function(e) {
            self.handleBreadcrumbClick(e);
          });
        }

        this.breadcrumb[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');
        this.adjustBreadcrumb();
      },

      // Builds Breadcrumb markup that reflects the current state of the application
      adjustBreadcrumb: function() {
        var last = this.levelsDeep[this.levelsDeep.length - 1];
        this.breadcrumb.empty();

        var bcMarkup = $('<ol aria-label="breadcrumb"></ol>').appendTo(this.breadcrumb);
        $.each(this.levelsDeep, function(i, txt) {
          var current = '';
          if (last === txt) {
            current = ' current';
          }

          bcMarkup.append($('<li><a href="#" class="hyperlink'+ current +'">'+ txt +'</a></li>'));
        });
      },

      buildTabs: function() {
        this.tabsContainer = this.element.find('.tab-container');
        if (!this.tabsContainer.length) {
          this.tabsContainer = $('<div class="tab-container"></div>').appendTo(this.element);

          // TODO: Flesh this out so that the header control can build tabs based on options
          var tablist = $('<ul class="tab-list" role="tablist"></ul>').appendTo(this.tabsContainer);
          $('<li class="tab"><a href="#header-tabs-home" role="tab">SoHo Xi Controls | Patterns</a></li>').appendTo(tablist);
          $('<li class="tab"><a href="#header-tabs-level-1" role="tab">Level 1 Detail</a></li>').appendTo(tablist);
          $('<li class="tab"><a href="#header-tabs-level-2" role="tab">Level 2 Detail</a></li>').appendTo(tablist);
        }

        this.element.addClass(this.settings.useAlternate ? 'has-alternate-tabs' : 'has-tabs');
        this.tabsContainer[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

        // NOTE: For demo purposes the markup for tab panels is already inside the Nav Patterns Test page.
        $('#header-tabs-level-1').removeAttr('style');
        $('#header-tabs-level-2').removeAttr('style');

        // Invoke Tabs Control
        this.tabsContainer.tabs({
          containerElement: '#maincontent'
        });
      },

      buildWizard: function() {
        this.element.addClass('has-wizard');

        this.wizard = this.element.find('.wizard');
        if (!this.wizard.length) {
          this.wizard = $('<div class="wizard"></div>').appendTo(this.element);
          var header = $('<div class="wizard-header"></div>').appendTo(this.wizard),
            bar = $('<div class="bar"></div>').appendTo(header);
          $('<div class="completed-range"></div>').appendTo(bar);

          // TODO: Flesh this out so the header control can build the Wizard Ticks based on options
          $('<a href="#" class="tick current"><span class="label">Context Apps</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">Utility Apps</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">Inbound Configuration</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">OID Mapping</span></a>').appendTo(bar);
        }

        this.wizard[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

        // NOTE: For Demo Purposes, the shifting forms associated with the Wizard are coded
        // inside the Nav Patterns Test page.
        // TODO: Build shifting forms

        // Invoke the Wizard Control
        this.wizard.wizard();
      },

      buildPopupmenu: function() {
        var title = this.toolbarElem.children('.title');
        this.titlePopup = title.find('.btn-menu');
        if (!this.titlePopup.length) {
          var heading = title.find('h1'); // If H1 doesn't exist here, you're doing it wrong.
          heading.wrap('<button id="header-menu" type="button" class="btn-menu"></button>');
          this.titlePopup = heading.parent('.btn-menu');
        }
        this.titlePopupMenu = this.titlePopup.next('.popupmenu');
        if (!this.titlePopupMenu.length) {
          this.titlePopupMenu = $('<ul class="popupmenu is-selectable"></ul>').insertAfter(this.titlePopup);
          $('<li class="is-checked"><a href="#">Page One Title</a></li>' +
            '<li><a href="#">Page Two Title</a></li>' +
            '<li><a href="#">Page Three Title</a></li>' +
            '<li class="is-disabled"><a href="#">Page Four Title</a></li>' +
            '<li><a href="#">Page Five Title</a></li>').appendTo(this.titlePopupMenu);
        }
        this.titlePopupMenu.addClass('is-selectable');

        // Set the text on the Title
        this.titlePopup.children('h1').text(this.titlePopupMenu.children().first().text());

        // Invoke the Popupmenu on the Title
        this.titlePopup.button().popupmenu();

        // Update the Header toolbar to account for the new button
        this.toolbarElem.triggerHandler('updated');
      },

      handleEvents: function() {
        var self = this;

        this.element
          .on('updated.header', function() {
            self.updated();
          })
          .on('reset.header', function() {
            self.reset();
          })
          .on('drilldown.header', function(e, viewTitle) {
            self.drilldown(viewTitle);
          })
          .on('drillup.header', function(e, viewTitle) {
            self.drillup(viewTitle);
          });

        // Events for the title button.  e.preventDefault(); stops Application Menu functionality while drilled
        this.titleButton.bindFirst('click.header', function(e) {
          if (self.levelsDeep.length > 1) {
            e.stopImmediatePropagation();
            self.drillup();
            e.returnValue = false;
          }
        });

        // Popupmenu Events
        if (this.settings.usePopupmenu) {
          this.titlePopup.on('selected.header', function(e, anchor) {
            $(this).children('h1').text(anchor.text());
          });
        }

        return this;
      },

      handleBreadcrumbClick: function(e) {
        var selected = $(e.target).parent(),
          breadcrumbs = this.breadcrumb.find('li'),
          selectedIndex = breadcrumbs.index(selected),
          delta;

        if (selected.hasClass('current')) {
          return;
        }

        if (selectedIndex === 0) {
          return this.reset();
        }

        if (selectedIndex < breadcrumbs.length - 1) {
          delta = (breadcrumbs.length - 1) - selectedIndex;
          while (delta > 0) {
            this.drillup();
            delta = delta - 1;
          }
        }
      },

      initPageChanger: function () {
        this.element.find('.page-changer').on('selected.header', function (e, link) {
          // Change Theme
          if (link.attr('data-theme')) {
            var theme = link.attr('data-theme');
            $('body').trigger('changetheme', theme.replace('-theme',''));
            return;
          }

          // TODO: Change Lang
          if (link.attr('data-lang')) {
            Locale.set(link.attr('data-lang'));
            return;
          }

          // Change Color
          var color = link.attr('data-rgbcolor');
          $('body').trigger('changecolors', [color]);
        });
      },

      // Activates the Drilldown Header View
      drilldown: function(viewTitle) {
        this.element.addClass('is-drilldown');
        this.levelsDeep.push(viewTitle.toString());
        this.titleText.text(this.levelsDeep[this.levelsDeep.length - 1]);

        if (this.settings.useBackButton) {
          this.buildTitleButton();
        }

        if (this.settings.useBreadcrumb) {
          if (!this.breadcrumb || !this.breadcrumb.length) {
            this.buildBreadcrumb();
            this.breadcrumb.css({'display': 'block', 'height': 'auto'});
          } else {
            this.adjustBreadcrumb();
          }
        }
      },

      drillup: function(viewTitle) {
        var title;
        this.element.removeClass('is-drilldown');

        if (this.levelsDeep.length > 1) {
          this.levelsDeep.pop();
          title = this.levelsDeep[this.levelsDeep.length - 1];
        }

        if (viewTitle !== undefined) {
          title = viewTitle;
        }

        if (this.levelsDeep.length > 1) {
          if (this.settings.useBreadcrumb) {
            this.adjustBreadcrumb();
          }
          this.titleText.text(title);
          return;
        }

        // Completely reset all the way back to normal
        title = this.levelsDeep[0];

        if (this.settings.useBackButton) {
          this.removeButton();
        }
        if (this.settings.useBreadcrumb) {
          this.removeBreadcrumb();
        }
        if (this.settings.usePopupmenu) {
          this.removePopupmenu();
        }

        this.titleText.text(title);
        this.element.trigger('drillTop');
      },

      /**
      * Reset the toolbar to its default removing the drilled in patterns.
      */
      reset: function() {
        while (this.levelsDeep.length > 1) {
          this.levelsDeep.pop();
        }
        this.titleText.text(this.levelsDeep[0]);

        this.removeBreadcrumb();
        this.removeTabs();
        this.removeWizard();
        this.removePopupmenu();
        this.removeButton();

        this.element.trigger('afterreset');
        return this;
      },

      removeButton: function() {
        if (this.hasTitleButton) {
          this.titleButton.find('.icon.app-header').removeClass('go-back');
          return;
        }

        if (this.titleButton && this.titleButton.length) {
          this.titleButton.remove();
          this.titleButton = $();

          // Need to trigger an update on the toolbar control to make sure tabindexes and events are all firing on the button
          this.toolbar.element.triggerHandler('updated');
        }
      },

      removeBreadcrumb: function() {
        if (!this.breadcrumb || !this.breadcrumb.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyBreadcrumb() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.breadcrumb-header');
          self.breadcrumb.off().remove();
          self.breadcrumb = $();
        }

        self.element.removeClass('has-breadcrumb').removeClass('has-alternate-breadcrumb');
        if (this.breadcrumb.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.breadcrumb-header', destroyBreadcrumb);
          timeout = setTimeout(destroyBreadcrumb, 300);
        } else {
          destroyBreadcrumb();
        }
      },

      removeTabs: function() {
        if (!this.tabsContainer || !this.tabsContainer.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyTabs() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.tabs-header');
          self.tabsContainer.data('tabs').destroy();
          self.tabsContainer.remove();
          self.tabsContainer = null;

          // NOTE: For demo purposes the markup for tab panels is already inside the Nav Patterns Test page.
          $('#header-tabs-level-1').css('display', 'none');
          $('#header-tabs-level-2').css('display', 'none');
        }

        this.element.removeClass('has-tabs').removeClass('has-alternate-tabs');
        if (this.tabsContainer.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.tabs-header', destroyTabs);
          timeout = setTimeout(destroyTabs, 300);
        } else {
          destroyTabs();
        }
      },

      removeWizard: function() {
        if (!this.wizard || !this.wizard.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyWizard() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.wizard-header');
          self.wizard.data('wizard').destroy();
          self.wizard.remove();
          self.wizard = null;

        }

        this.element.removeClass('has-wizard');
        if (this.wizard.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.wizard-header', destroyWizard);
          timeout = setTimeout(destroyWizard, 300);
        } else {
          destroyWizard();
        }
      },

      removePopupmenu: function() {
        var self = this;

        if (!this.titlePopup || !this.titlePopup.length) {
          return;
        }

        this.titlePopup.data('popupmenu').destroy();
        this.titlePopup.data('button').destroy();
        this.titlePopupMenu.remove();
        this.titlePopup.children('h1').detach().insertBefore(self.titlePopup);
        this.titlePopup.remove();

        this.titlePopup = undefined;
        this.titlePopupMenu = undefined;

        this.toolbarElem.triggerHandler('updated');
      },

      // teardown events
      unbind: function() {
        this.titleButton.off('click.header');
        this.element.off('drilldown.header drillup.header');
        return this;
      },

      /**
      * Sync up the ui with settings.
      */
      updated: function() {
        this
          .reset()
          .unbind()
          .init();
      },

      /**
      * Tear down and destroy the menu and events.
      */
      destroy: function() {
        this.unbind();
        if (this.hasTitleButton) {
          this.toolbarElem.removeClass('has-title-button');
        }

        $.removeData(this.element[0], pluginName);
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Header(this, settings));
      }
    });
  };


 $.fn.hierarchy = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'hierarchy',
        defaults = {
          legend: [],
          legendKey: '',
          dataset: [],
          newData: [],
          templateId: '',  //Id to the Html Template
          mobileView: false,
          leafHeight: null,
          leafWidth: null,
          beforeExpand: null,
          paging: false
        },
        settings = $.extend({}, defaults, options);

    var colorClass = [
      'azure08', 'turquoise02', 'amethyst06', 'slate06', 'amber06', 'emerald07', 'ruby06'
    ];

    /**
    * The displays custimizable hierarchical data such as an org chart.
    *
    * @class Hierarchy
    * @param {String} legend  &nbsp;-&nbsp; Pass in custom markdown for the legend structure.
    * @param {String} legendKey  &nbsp;-&nbsp; Key to use for the legend matching
    * @param {String} dataset  &nbsp;-&nbsp; Hierarchical Data to display
    * @param {Boolean} newData  &nbsp;-&nbsp; New data to be appended into dataset
    * @param {String} templateId  &nbsp;-&nbsp; Additional product name information to display
    * @param {Boolean} mobileView  &nbsp;-&nbsp; If true will only show mobile view, by default using device info to determine.
    * @param {String} beforeExpand  &nbsp;-&nbsp; A callback that fires before node expansion of a node.
    *
    */
    function Hierarchy(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Hierarchy Methods
    Hierarchy.prototype = {
      init: function() {

        var isMobile = $(this.element).parent().width() < 610; //Phablet down

        if (isMobile) {
          this.mobileView = true;
        } else {
          this.mobileView = false;
        }

        this.handleEvents();

        // Safety check, check for data
        if (settings.dataset) {
          if (settings.dataset[0] && settings.dataset[0].children.length > 0) {
            this.render(settings.dataset[0]);
          } else if (settings.dataset && settings.dataset.children.length > 0) {
            this.render(settings.dataset);
          } else {
            $(this.element).append('<p style=\'padding:10px;\'>No data available</p>');
          }
        }

        if (settings.leafHeight !== null && settings.leafWidth !== null) {

          var style = 'body .hierarchy .leaf,' +
                'body .hierarchy .sublevel .leaf,' +
                'body .hierarchy .container .root.leaf { width: ' + settings.leafWidth + 'px; ' + ' height: ' + settings.leafHeight + 'px; ' + ' }';

          $('<style type=\'text/css\' id=\'hierarchyLeafStyles\'>' + style + '</style>').appendTo('body');
        }
      },

      /**
       * Private function
       * Attach all event handlers
       */
      handleEvents: function() {
        var self = this;

        // Expand or Collapse
        self.element.onTouchClick('hierarchy', '.btn').on('click.hierarchy', '.btn', function(event) {

          if (settings.newData.length > 0) {
            settings.newData = [];
          }

          var nodeId = $(this).closest('.leaf').attr('id');
          var nodeData = $('#' + nodeId).data();
          var domObject = {
            branch: $(this).closest('li'),
            leaf: $(this).closest('.leaf'),
            button: $(this)
          };

          if (nodeData.isExpanded) {
            self.collapse(event, nodeData, domObject);
          } else {
            self.expand(event, nodeData, domObject);
          }

        });

        self.element.on('keypress', '.leaf', function(event) {
          var nodeId     = $(this).attr('id');
          var nodeData   = $('#' + nodeId);

          if (event.which === 13) {
            if (nodeData.isExpanded) {
              self.collapse(event, nodeData);
            } else {
              self.expand(event, nodeData);
            }
          }
        });

        /**
         *  Public,
         *  Usage: $('#hierarchy').on('selected', function(event, eventInfo) {}
         */
        self.element.on('mousedown', '.leaf, .back button', function(event) {
          var hierarchy = $(this).closest('.hierarchy').data('hierarchy');
          var nodeData = $(this).data();
          var targetInfo = {target: event.target, pageX: event.pageX, pageY: event.pageY};
          var eventType = 'selected';
          var isButton = $(event.target).is('button');
          var isNotBack = !$(event.target).hasClass('btn-back');
          var isBack = $(event.target).is('.btn-back');
          var svgHref = $(event.target).find('use').prop('href');
          var isCollapseButton = svgHref ? svgHref.baseVal === '#icon-caret-up' : false;
          var isExpandButton = svgHref ? svgHref.baseVal === '#icon-caret-down' : false;

          $('.is-selected').removeClass('is-selected');
          $('#' + nodeData.id).addClass('is-selected');

          // Is collapse event
          if (isButton && isCollapseButton && isNotBack) {
            eventType = 'collapse';
          }

          // Is expand event
          if ( isButton && isExpandButton && isNotBack) {
            eventType = 'expand';
          }

          if (isBack) {
            eventType = 'back';
          }

          // Is right click event
          if (event.which === 3) {
            eventType = 'rightClick';
          }

          var eventInfo = {
            data: nodeData,
            targetInfo: targetInfo,
            eventType: eventType,
            isAddEvent: hierarchy.isAddEvent(eventType),
            isExpandEvent: hierarchy.isExpandEvent(),
            isCollapseEvent: hierarchy.isCollapseEvent(),
            isSelectedEvent: hierarchy.isSelectedEvent(),
            allowLazyLoad: hierarchy.allowLazyLoad(nodeData, eventType)
          };

          $(this).trigger('selected', eventInfo);
        });
      },

      /**
       * Private function
       * check if event is add
       */
      isAddEvent: function(eventType) {

        if (eventType === undefined) {
          return false;
        }

        return eventType === 'add';
      },

      /**
       * Private function
       * check if event is expand
       */
      isExpandEvent: function(eventType) {

        if (eventType === undefined) {
          return false;
        }

        return eventType === 'expand';
      },

      /**
       * Private function
       * check if event is collapse
       */
      isCollapseEvent: function(eventType) {

        if (eventType === undefined) {
          return false;
        }

        return eventType === 'collapse';
      },

      /**
       * Private function
       * check if event is select
       */
      isSelectedEvent: function(eventType) {

        if (eventType === undefined) {
          return false;
        }

        return eventType === 'select';
      },

      /**
       * Private function
       * Check to see if lazy load is allowed
       */
      allowLazyLoad: function (data, eventType) {

        if(data === undefined || eventType === undefined) {
          return false;
        }

        return !data.isLoaded && !data.isLeaf && eventType === 'expand';
      },

      /**
       * Public function
       * Process data attached through jquery data
       * @param nodeId
       * @param currentDataObject
       * @param newDataObject
       * @param params
       * @returns {*}
       */
      data: function(nodeId, currentDataObject, newDataObject, params) {

        if (params === undefined) {
          params = {};
        }

        var obj = currentDataObject.isRootNode ? currentDataObject : currentDataObject[0];
        var nodeData = [];

        if (settings.newData.length > 0) {
          settings.newData = [];
        }

        function processData(self, obj, newDataObject) {
          if (obj.length === undefined) {
            checkForChildren(self, obj, newDataObject);
          } else {
            for (var i = 0, l = obj.length; i < l; i++) {
              var o = obj[i];
              checkForChildren(self, o, newDataObject);
            }
          }
        }

        if (newDataObject !== undefined) {
          processData(this, obj, newDataObject);
        }

        function checkForChildren(self, obj, newDataObject) { //jshint ignore:line
          for (var prop in obj) {
            if (prop === 'id' && nodeId === obj.id) {
              if (!obj.isLoaded && !obj.isRootNode) {
                addChildrenToObject(obj, params);
              }
              nodeData.push(obj);
            }
          }
          if (obj.children) {
            processData(self, obj.children, newDataObject);
          }
        }

        function addChildrenToObject(obj, params) { //jshint ignore:line
          if (params.insert) {
            delete obj.isLeaf;
            obj.isExpanded = true;
          }
          if (newDataObject.length !== 0 && params.insert) {
            obj.children = [newDataObject];
          } else {
            obj.children = newDataObject;
          }
        }

        if (nodeData.length !== 0) {
          $('#' + nodeData[0].id).data(nodeData[0]);
        }

        return nodeData[0];
      },

      /**
       * Public function
       * Reloads hierarchy control with new dataset
       * @param options -- hierarchy options
       */
      reload: function (options) {
        this.destroy();
        this.element.hierarchy(options);
      },

      /**
       *  Public function
       *  Removes the component from existence
       */
      destroy: function () {
        this.element.empty();
        this.element.removeData(pluginName);
      },

      /**
       * Public function
       * Add data as children for the given nodeId.
       * @param nodeId
       * @param currentDataObject
       * @param newDataObject
       */
      add: function (nodeId, currentDataObject, newDataObject) {

        var self            = this;
        var id              = currentDataObject.id !== undefined ? currentDataObject.id : nodeId;
        var node            = $('#' + id);
        var parentContainer = node.parent().hasClass('leaf-container') ? node.parent().parent() : node.parent();
        var selectorObject  = {};
        var isSubLevelChild = parentContainer.parent().attr('class') !== 'sub-level';
        var subListExists   = parentContainer.children('.sublist').length === 1;

        if (isSubLevelChild) {
          if (subListExists) {
            selectorObject.element = parentContainer.children('.sublist');
          } else {
            selectorObject.el = parentContainer.append('<ul class=\'sublist\'></ul>');
            selectorObject.element = $(selectorObject.el).find('.sublist');
          }
        } else {
          selectorObject.el = parentContainer.children('ul');
          selectorObject.element = $(selectorObject.el);
        }

        if (!currentDataObject.isRootNode) {
          for(var i = 0, l = newDataObject.length; i < l; i++) {
            settings.newData.push(newDataObject[i]);
          }
          self.createLeaf(newDataObject, selectorObject.element);
        }

        self.updateState(node, false, null, 'add');
      },

      /**
       * Private function
       * Expand the nodes until nodeId is displayed on the page.
       * @param event
       * @param nodeData
       * @param domObject
       */
      expand: function(event, nodeData, domObject) {
        var self = this,
            node = domObject.leaf,
            nodeTopLevel  = node.next();

        nodeTopLevel.animateOpen();
        self.element.trigger('expanded', [nodeData, settings.dataset]);

        if (node.hasClass('root')) {
          nodeTopLevel  = nodeTopLevel.next('ul');
          nodeTopLevel.animateOpen();
        }

        node.parent().removeClass('branch-collapsed').addClass('branch-expanded');
        self.updateState(node, false, null, 'expand');
      },

      /**
       * Private function
       * Collapse the passed in nodeId.
       * @param event
       * @param nodeData
       * @param domObject
       */
      collapse: function(event, nodeData, domObject) {
        var self = this,
            node = domObject.leaf,
            nodeTopLevel  = node.next();

        nodeTopLevel.animateClosed().on('animateclosedcomplete', function () {
          self.element.trigger('collapsed', [nodeData, settings.dataset]);
        });

        if (node.hasClass('root')) {
          nodeTopLevel  = nodeTopLevel.next('ul');
          nodeTopLevel.animateClosed();
        }

        node.parent().removeClass('branch-expanded').addClass('branch-collapsed');
        self.updateState(node, false, null, 'collapse');
      },

      /**
       * Private Function
       * Main render method
       * @param data
       */
      render: function (data) {
        var legend       = settings.legend;
        var children     = data.children;
        var rootNodeHTML = [];
        var structure    = {
          legend    : '<legend><ul></ul></legend>',
          chart     : settings.paging ? '<ul class=\'container\'><li class=\'chart display-for-paging\'></li></ul>' : '<ul class=\'container\'><li class=\'chart\'></li></ul>',
          toplevel  : settings.paging ? '<ul class=\'child-nodes\'></ul>' : '<ul class=\'top-level\'></ul>',
          sublevel  : settings.paging ? '' : '<ul class=\'sub-level\'></ul>'
        };

        var chartContainer  = this.element.append(structure.chart);
        var chart = $('.chart', chartContainer);

        if (legend.length !== 0) {
          this.element.prepend(structure.legend);
          var element = $('legend', chartContainer);
          this.createLegend(element);
        }

        // check to see how many children are not leafs and have children
        if (this.isSingleChildWithChildren()) {
          $(chart).addClass('has-single-child');
        }

        // Create root node
        this.setColor(data);

        if (settings.paging && data.parentDataSet) {
          var backMarkup = '' +
            '<div class=\'back\'>' +
              '<button type="button" class="btn-icon hide-focus btn-back">' +
                '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">' +
                  '<use xlink:href="#icon-caret-up"></use>' +
                '</svg>' +
                '<span>Back</span>' +
              '</button>' +
            '</div>';

          // Append back button to chart to go back to view previous level
          var backButton = $(backMarkup).appendTo(chart);

          // Attach data reference to back button
          backButton.children('button').data(data);

          // Class used to adjust heights and account for back button
          $(chart).addClass('has-back');
        }

        if (data.isMultiRoot) {
          var multiRootHTML = '<div class=\'leaf multiRoot\'><div><h2>' + data.multiRootText +'</h2></div></div>';

          rootNodeHTML.push(multiRootHTML);
          $(rootNodeHTML[0]).addClass('root').appendTo(chart);

        } else {

          var leafTemplate = Tmpl.compile('{{#dataset}}' + $('#' + settings.templateId).html() + '{{/dataset}}');
          var leaf = leafTemplate.render({dataset: data});
          rootNodeHTML.push(leaf);

          $(rootNodeHTML[0]).addClass('root').appendTo(chart);
          this.updateState($('.leaf.root'), true);
        }

        function renderSubChildren(self, subArray, data) {
          if (subArray !== null && subArray !== undefined) {
            for (var i = 0, l = subArray.length; i < l; i++) {
              var obj = subArray[i];
              subArrayChildren(self, obj, data);
            }
          }
        }

        // Create children nodes
        if (children.length > 0) {
          for (var i = 0, l = children.length; i < l; i++) {

            var childObject = data.children[i].children;

            // If child has no children then render the element in the top level
            // If paging then render all children in the top level
            // If not paging and child has children then render in the sub level
            if (this.isLeaf(children[i]) && !settings.paging) {
              this.createLeaf(data.children[i], $(structure.toplevel));
            } else if (settings.paging) {
              this.createLeaf(data.children[i], $(structure.toplevel));
            }
            else {
              this.createLeaf(data.children[i], $(structure.sublevel));
            }

            if (childObject !== undefined && childObject !== null) {
              var subArray = data.children[i].children;
              var self = this;
              renderSubChildren(self, subArray, data);
            }
          }
        }

        function subArrayChildren(self, obj, data) { //jshint ignore:line
          for(var prop in obj) {
            if (prop === 'children') {
              var nodeId = obj.id;
              var currentDataObject = obj;
              var newDataObject = obj.children;

              if (newDataObject !== null && newDataObject !== undefined) {
                if (newDataObject.length > 0) {
                  self.add(nodeId, currentDataObject, newDataObject);
                }
              }

              return renderSubChildren(self, newDataObject, data);
            }
          }
        }

        var containerWidth = this.element.find('.container').outerWidth();
        var windowWidth = $(window).width();
        var center = (containerWidth - windowWidth) / 2;
        this.element.scrollLeft(center);

      },

      /**
       *  Private function:
       *  Checks to see if children have children
       *  used to set a class if there is only a single child with children
       */
      isSingleChildWithChildren: function() {
        if (settings.dataset && settings.dataset[0].children) {
          var i = settings.dataset[0].children.length;
          var count = 0;

          while (i--) {
            if (!settings.dataset[0].children[i].isLeaf) {
              count++;
            }
          }

          return count === 1;
        } else {
          return false;
        }
      },

      /**
       * Private function
       * Add the legend from the Settings
       * @param element
       */
      createLegend: function(element) {
        var mod      = 4;
        var index    = 0;

        for (var i = 0, l = settings.legend.length; i < l; i++) {
          var label  = settings.legend[i].label;
          var color  = colorClass[i];

          if (i - 1 % mod + 1 === mod) {
            element.append('<ul></ul>');
            index++;
          }

          element.children('ul').eq(index).append(
            '<li>' +
            '<span>' + label + '</span>' +
            '<span class=\'key ' + color + '\'></span>' +
            '</li>'
          );
        }
      },

      /**
       * Private function
       *  Creates a leaf node under element for nodeData
       * @param nodeData
       * @param container
       */
      createLeaf: function(nodeData, container) {
        var self           = this;
        var chartClassName = self.element.attr('class');
        var chart          = $('.' + chartClassName + ' .chart', self.container);
        var elClassName    = container.attr('class');
        var el             = elClassName !== undefined ? $('.' + elClassName) : container;

        if (el.length < 1) {
          if (elClassName === 'top-level') {
            container.insertAfter('.root');
          } else {
            container.appendTo(chart);
          }
        }

        function processDataForLeaf(nodeData) {
          self.setColor(nodeData);

          var leafTemplate = Tmpl.compile('{{#dataset}}' + $('#' + settings.templateId).html() + '{{/dataset}}');
          var leaf = leafTemplate.render({dataset: nodeData});
          var parent       = el.length === 1 ? el : container;
          var branchState = nodeData.isExpanded || nodeData.isExpanded === undefined ? 'branch-expanded' : 'branch-collapsed';

          if (nodeData.isLeaf) {
            branchState = '';
          }

          parent.append('<li class=' + branchState + '>' + $(leaf)[0].outerHTML + '</li>');

          if (nodeData.children) {
            var childrenNodes = '';

            for (var j = 0, l = nodeData.children.length; j < l; j++) {
              self.setColor(nodeData.children[j]);

              var childLeaf = leafTemplate.render({dataset: nodeData.children[j]});

              if (j === nodeData.children.length - 1) {
                childrenNodes += '<li>' + $(childLeaf)[0].outerHTML + '</li>';
              }
              else {
                childrenNodes += '<li>' + $(childLeaf)[0].outerHTML + '</li>';
              }
            }

            parent = $('#' + nodeData.id).parent();
            parent.append('<ul>' + childrenNodes + '</ul>');

            var childLength = nodeData.children.length;
            while (childLength--) {
              self.updateState($('#' + nodeData.children[childLength].id), false, nodeData.children[childLength]);
            }
          }
        }

        if (nodeData.length) {
          for (var i = 0, l = nodeData.length; i < l; i++) {
            var isLast = i === nodeData.length -1;
            processDataForLeaf(nodeData[i], isLast);
            self.updateState($('#' + nodeData[i].id), false, nodeData[i]);
          }
        } else {
          processDataForLeaf(nodeData, true);
          self.updateState($('#' + nodeData.id), false, nodeData);
        }
      },

      /**
       * Private function
       * Determine the color from settings
       * @param data
       */
      setColor: function(data) {
        for (var i = 0, l = settings.legend.length; i < l; i++) {
          if (data[settings.legendKey] === settings.legend[i].value) {
            data.colorClass = colorClass[i];
            break;
          }
          else if (data[settings.legendKey] === '') {
            data.colorClass =  'default-color';
          }
        }

        if (data.children && !data.isRootNode) {
          for (var k = 0, ln = data.children.length; k < ln; k++) {
            for (var j = 0, x = settings.legend.length; j < x; j++) {
              if (data.children[k][settings.legendKey] === settings.legend[j].value) {
                data.children[k].colorClass = colorClass[j];
              }
            }
          }
        }
      },

      /**
      * Return whether or not a particular node is a leaf
      * private function
      */
      isLeaf: function(dataNode) {

        if (dataNode.children === undefined) {
          dataNode.isLeaf = true;
          return dataNode.isLeaf;
        }

        if (settings.beforeExpand) {
          return dataNode.isLeaf;
        }

        if (dataNode.children && dataNode.children.length > 0) {
          return false;
        }

        return true;
      },

      /**
       * Handle all leaf state here,
       * get the current state via .data() and re-attach the new state
       * private function
       * @param leaf
       * @param isRoot
       */
      updateState: function (leaf, isRoot, nodeData, eventType) {

        // set data if it has not been set already
        if ($.isEmptyObject($(leaf).data()) && nodeData) {
          var d = nodeData === undefined ? {} : nodeData;
          $(leaf).data(d);
        }

        var btn = $(leaf).find('.btn');
        var data = $(leaf).data();
        var expandCaret = settings.paging ? 'caret-right' : 'caret-up';

        // data has been loaded if it has children
        if ((data.children && data.children.length !== 0) || eventType === 'add') {
          data.isLoaded = true;
        }

        if (isRoot) {
          data.isRootNode = true;
          data.isLoaded = true;
        }

        if ((data.isExpanded === undefined && data.children) || eventType === 'expand') {
          data.isExpanded = true;
        }

        // defaults to collapsed state
        if (data.isExpanded === undefined || eventType === 'collapse') {
          data.isExpanded = false;
        }

        if (data.isExpanded) {
          btn.find('svg.icon').changeIcon(expandCaret);
          btn.addClass('btn-expand').removeClass('btn-collapse');
        } else {
          btn.find('svg.icon').changeIcon('caret-down');
          btn.addClass('btn-collapse').removeClass('btn-expand');
        }

        if (data.isLeaf || data.isRootNode) {
          btn.addClass('btn-hidden');
        }

        if (data.isLeaf) {
          data.isLoaded = false;
          data.isExpanded = false;
        }

        // Keep reference of the parent dataset for paging
        data.parentDataSet = settings.dataset;

        // Reset data
        $(leaf).data(data);
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);

      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Hierarchy(this, settings));
      }

    });
  };

/*
 * Text Highlight/Unhighlight Control
 * Originally called "highlight v5" by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Modified for SoHo Xi (TODO: bit.ly link to docs)
**/


  $.fn.highlight = function(pat) {

    function innerHighlight(node, pat) {
      var skip = 0,
        pos, spannode, middlebit, middleclone, endbit;

      if (node.nodeType === 3) {
        pos = node.data.toUpperCase().indexOf(pat);
        pos -= (node.data.substr(0, pos).toUpperCase().length - node.data.substr(0, pos).length);

        if (pos >= 0) {
          spannode = document.createElement('mark');
          spannode.className = 'highlight';
          middlebit = node.splitText(pos);
          endbit = middlebit.splitText(pat.length);
          middleclone = middlebit.cloneNode(true);
          spannode.appendChild(middleclone);
          middlebit.parentNode.replaceChild(spannode, middlebit);
          skip = 1;
        }

      } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
        for (var i = 0; i < node.childNodes.length; ++i) {
          i += innerHighlight(node.childNodes[i], pat);
        }
      }

      return skip;
    }

    return this.length && pat && pat.length ? this.each(function() {
      innerHighlight(this, pat.toUpperCase());
    }) : this;
  };

  $.fn.unhighlight = function() {
    return this.find('mark.highlight').each(function() {
      var node = this.parentNode;
      node.replaceChild(this.firstChild, this);
      node.normalize();
    }).end();
  };


  $.fn.homepage = function(options) {

    // Settings and Options
    var pluginName = 'homepage',

        defaults = {
          gutterSize: 20, //Private
          widgetWidth: 360, //Private
          widgetHeight: 370, //Private
          animate: true,
          timeout: 100, //Private
          columns: 3,
          easing: 'blockslide' //Private
        },
        settings = $.extend({}, defaults, options);


    /**
    * The Homepage handles card layout at multiple breakpoints.
    *
    * @class Homepage
    * @param {Boolean} animate  &nbsp;-&nbsp; Disable animation during resize
    * @param {Number} columns  &nbsp;-&nbsp; Display in 3 (default) or 4 column layout
    *
    */
    function Homepage(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Homepage.prototype = {

      init: function() {
        this.settings = settings;
        this.isTransitionsSupports = this.supportsTransitions();
        this.initHeroWidget();
        this.handleEvents();

        //Initial Sizing
        this.resize(this, false);
      },

      initColumns: function(row) {
        row = row || 0;
        this.rowsAndCols[row] = [];

        for (var i = 0, l = this.settings.columns; i < l; i++) {
          this.rowsAndCols[row][i] = true;// Make all columns available in first row[true]
        }
      },

      initHeroWidget: function() {
        var heroWidget = $('.hero-widget');
        if (heroWidget.length > 1) {
          heroWidget = heroWidget.not(':first').remove();
        }
        this.heroWidget = heroWidget;
      },

      initRowsAndCols: function() {
        this.rowsAndCols = [];// Keeping all blocks as rows and columns
        this.initColumns();
      },

      // Return [x and y] where we can fit this block
      getAvailability: function(block) {
        var i, j, n, l, cols, innerCheck,
          self = this,
          rows = self.rowsAndCols.length,
          smallest = {},
          abort = false;

        // Loop thru each row and column soon it found first available spot
        // Then check for if block's width can fit in(yes), asign to [smallest] and break both loops
        for (i = 0, l = rows; i < l && !abort; i++) {
          for (j = 0, innerCheck = true, cols = self.rowsAndCols[i].length; j < cols && !abort; j++) {
            if ((self.rowsAndCols[i][j]) && ((block.w + j) <= cols)) {
              if ((block.w > 1) && (cols > (j+1))) {
                for (n = 0; n < block.w; n++) {
                  if (!self.rowsAndCols[i][j + n]) {
                    innerCheck = false;
                    break;
                  }
                }
              }
              if ((block.h > 1) && (rows > (i+1))) {
                for (n = 0; n < block.h; n++) {
                  if (!self.rowsAndCols[i + n][j]) {
                    innerCheck = false;
                    break;
                  }
                }
              }
              if (innerCheck) {
                smallest.row = i;
                smallest.col = j;
                abort = true;
              }
            }
          }
        }

        // If did not found any available spot from previous loops
        // Add new row and asign to [smallest] first column in this new row
        if (!Object.getOwnPropertyNames(smallest).length) {
          self.initColumns(rows);
          smallest.row = rows;
          smallest.col = 0;
        }

        return smallest; //{x:0, y:0}
      },

      // Make all spots as unavailable, depends on block's width and height
      // Soon we used this block
      fitBlock: function(r, c, block) {
        var i, j, l, l2,
          self = this,
          addRow = true;

        block.x = c;
        block.y = r;

        if ((block.w === 1) && (block.h === 1)) { // Single block can fit anywhere
          self.rowsAndCols[r][c] = false;
        } else {
          // If more then one row or column then loop thru to block's width and height
          // If height is more then current rows then add new row
          // Mark those spots as unavailable[false]
          if(block.w !== 1) {
            // Left to right
            for (i = r, l = block.h + r; i < l; i++) {
              for (j = c, l2 = block.w + c; j < l2; j++) {
                if (!self.rowsAndCols[i]) {
                  self.initColumns(i);
                }
                self.rowsAndCols[i][j] = false;
              }
            }
          } else {
            // Top to bottom
            for (i = r, l = block.h + r; i < l; i++) {
              for (j = c, l2 = block.h + c; j < l2; j++) {
                if (!self.rowsAndCols[i]) {
                  self.initColumns(i);
                }
                self.rowsAndCols[i][c] = false;
              }
            }
          }
        }

        // Check if reach to end of columns then assign flag[addRow]
        for (i = 0, l = self.rowsAndCols[r].length; i < l; i++) {
          if(self.rowsAndCols[r][i]) {
            addRow = false;
          }
        }

        // If reach to end of columns and next row is not avaiable then add new row
        // Make all columns available, if not assigned earlier as unavailable
        if (addRow) {
          if (!self.rowsAndCols[r +1]) {
            self.initColumns(r +1);
          }
        }
      },

      // Setup each block sizes, based on classes provided from markup
      setBlocks: function() {
        var self = this;
        self.blocks = [];

        self.element.find('.card, .widget').each(function () {
          var card = $(this),
            h = card.hasClass('double-height') ? 2 : 1,
            w = card.hasClass('quad-width') ? 4 : card.hasClass('triple-width') ? 3 : card.hasClass('double-width') ? 2 : 1;

          self.blocks.push({w: w, h: h, elem: card, text: card.text()});
        });

        // Max sized columns brings to top
        if (self.settings.columns > 1) {
          for (var i=0, j=0, w=0, l=self.blocks.length; i<l; i++) {
            if (self.blocks[i].w >= self.settings.columns && i && w) {
              self.arrayIndexMove(self.blocks, i, j);
            }
            w += self.blocks[i].w;
            if(w >= self.settings.columns) {
              w = 0; //reset
              j = (self.blocks[j].w >= self.settings.columns) ? j+1 : i; //record to move
            }
          }
        }
      },

      //Move an array element position
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      // Resize Method
      resize: function(self, animate) {
        //Sizes of "breakpoints" is  320, 660, 1000 , 1340 (for 320)
        //or 360, 740, 1120, 1500 or (for 360)
        var bpXL    = (self.settings.widgetWidth * 4) + (self.settings.gutterSize * 3),
          bpDesktop = (self.settings.widgetWidth * 3) + (self.settings.gutterSize * 2),
          bpTablet  = (self.settings.widgetWidth * 2) + self.settings.gutterSize,
          bpPhone   = self.settings.widgetWidth;

        var bp = bpXL, //1340,
          elemWidth = self.element.outerWidth(); //Math min against window.screen.width for single line mobile support

        // elemWidth -= 30; //extra break space

        // Find the Breakpoints
        var xl    = (elemWidth >= bpXL),
          desktop = (elemWidth >= bpDesktop && elemWidth <= bpXL),
          tablet  = (elemWidth >= bpTablet && elemWidth <= bpDesktop),
          phone   = (elemWidth <= bpTablet);

        var maxAttr = this.element.attr('data-columns'),
          content = self.element.find('> .content');
        this.settings.columns = parseInt((maxAttr || this.settings.columns));

        // Assign columns as breakpoint sizes
        if (xl && self.settings.columns === 4) {
          self.settings.columns = 4;
          bp = bpXL;
        }
        if ((desktop) || (xl && self.settings.columns === 3)) {
          self.settings.columns = 3;
          bp = bpDesktop;
        }
        if (tablet) {
          self.settings.columns = 2;
          bp = bpTablet;
        }
        if (phone) {
          self.settings.columns = 1;
          bp = bpPhone;
        }

        if (content.length) {
          content[0].style.marginLeft = '-' + (bp/2) + 'px';
        }

        this.setBlocks(); //setup blocks
        this.initRowsAndCols(); //setup colums

        // Loop thru each block, make fit where available and
        // If block more wider than available size, make as  available size
        // Assign new left and top css positions
        for (var i = 0, l = self.blocks.length; i < l; i++) {
          var left, top, pos, available,
            block = self.blocks[i];

          // Remove extra classes if assigned earlier
          block.elem.removeClass('to-single to-double to-triple');

          // If block more wider than available size, make as available size
          if (block.w > self.settings.columns) {
            block.w = self.settings.columns;

            if (self.settings.columns === 1) {
              block.elem.addClass('to-single');
            }
            else if (self.settings.columns === 2) {
              block.elem.addClass('to-double');
            }
            else if (self.settings.columns === 3) {
              block.elem.addClass('to-triple');
            }
          }

          // Get Availability
          available = self.getAvailability(block);

          // Set positions
          var box = self.settings.widgetWidth + self.settings.gutterSize,
            totalWidth = box * self.settings.columns;

          left = Locale.isRTL() ? totalWidth - ((box * block.w) + (box * available.col)) : box * available.col;
          top = (self.settings.widgetHeight + self.settings.gutterSize) * available.row;
          pos = {left: left, top: top};

          if (animate) {
            var easing = self.settings.easing,
              blockslide = [0.09, 0.11, 0.24, 0.91];

            if (easing === 'blockslide') {
              if (self.isTransitionsSupports) {
                self.applyCubicBezier(block.elem, blockslide);
                block.elem[0].style.left = pos.left + 'px';
                block.elem[0].style.top = pos.top + 'px';
              }
              // IE-9
              else {
                block.elem.animate(pos, self.settings.timeout);
              }
            }

            // Other easing effects ie (linear, swing)
            else {
              block.elem.animate(pos, self.settings.timeout, easing);
            }
          }
          else {
            block.elem[0].style.left = pos.left + 'px';
            block.elem[0].style.top = pos.top + 'px';
          }

          // Mark all spots as unavailable for this block, as we just used this one
          self.fitBlock(available.row, available.col, block);
        }
        self.element.triggerHandler('resize', self.settings.columns);
      },

      applyCubicBezier: function (el, cubicBezier) {
        el[0].style['-webkit-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-moz-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-ms-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-o-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style.transition = 'all .3s cubic-bezier('+ cubicBezier +')';
      },

      supportsTransitions: function () {
        var s = document.createElement('p').style,
          p = 'transition';

        if (typeof s[p] === 'string') {
          return true;
        }

        // Tests for vendor specific prop
        var v = ['Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];
        p = p.charAt(0).toUpperCase() + p.substr(1);

        for (var i = 0, l = v.length; i < l; i++) {
          if (typeof s[v[i] + p] === 'string') {
            return true;
          }
        }
        return false;
      },

      detachEvents: function () {
        $('body').off('resize.homepage');
        $('.application-menu').off('applicationmenuopen.homepage applicationmenuclose.homepage');
      },

      /**
      * Teardown - Remove added markup and events
      */
      destroy: function() {
        this.detachEvents();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Homepage#events
       * @param {Object} resize  &nbsp;-&nbsp; Fires after the page is resized and layout is set. Can be used for any special adjustments.
       *
       */
      handleEvents: function () {
        var self = this;

        $('body').on('resize.homepage', function() {
          self.resize(self, self.settings.animate);
        });

        $('.application-menu').on('applicationmenuopen.homepage applicationmenuclose.homepage', function () {
          self.resize(self, self.settings.animate);
        });
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Homepage(this, settings));
      }
    });
  };


  window.Soho = window.Soho || {};
  window.Soho.components = window.Soho.components || {};

  var DEFAULT_HYPERLINK_OPTIONS = {};

  /**
   * Soho component wrapper for Hyperlinks.
   * @class Hyperlink
   *
   * @param {HTMLElement} element
   * @param {Object} options
   * @returns {Hyperlink}
   */
  function Hyperlink(element, options) {
    return this.init(element, options);
  }

  Hyperlink.prototype = {
    init: function(element, options) {
      if (!this.element && element instanceof HTMLElement) {
        this.element = element;
      }

      if (typeof options === 'object') {
        var previousOptions = this.options || DEFAULT_HYPERLINK_OPTIONS;
        this.options = $.extend({}, previousOptions, options);
      }

      if (!this.focusBehavior) {
        this.focusBehavior = new Soho.behaviors.hideFocus(this.element);
      }

      return this;
    },

    handleEvents: function() {
      return this;
    },

    updated: function(options) {
      $.extend({}, this.options, options);

      return this
        .teardown()
        .init();
    },

    teardown: function() {
      return this;
    }
  };

  // Add to the Soho object
  window.Soho.components.hyperlink = Hyperlink;

  // Legacy jQuery wrappers
  $.fn.hyperlink = function(options) {
    'use strict';

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, 'hyperlink');
      if (instance) {
        instance.updated(options);
      } else {
        instance = $.data(this, 'hyperlink', new Hyperlink(this, options));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, 'hyperlink');
        };
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.icon = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'icon',
        defaults = {
          use: 'user-profile', // Match this to one of the SoHo Xi icons, prefixed with an ID of '#icon-'
          focusable: false
        },
        settings = $.extend({}, defaults, options);

    /**
     * Icon Control
     * Wraps SVG Icons with a Javascript control that can change the icon type, reference
     * relative or absolute URLs, and clean up after itself.  Works with the Base tag.
     * @constructor
     * @param {Object} element
     */
    function Icon(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Icon.prototype = {
      init: function() {
        this.getExistingUseTag();

        //Do other init (change/normalize settings, load externals, etc)
        return this
          .render()
          .handleEvents();
      },

      // Add markup to the control
      render: function() {
        var self = this;
        this.element.addClass('icon');

        if (!this.element.is('svg')) {
          // TODO: Possibly work with span-based icons here?
          return this;
        }

        // Get a "base-tag-proof" version of the Use tag's definition.
        // jQuery can't work with SVG elements, so we just modify it with regular DOM APIs
        var use = this.element[0].getElementsByTagName('use')[0];
        if (!use) {
          return this;
        }

        if (use.getAttribute('xlink:href') !== self.getBasedUseTag()) {
          setTimeout(function () {
            use.setAttribute('xlink:href', self.getBasedUseTag());
          }, 0);
        }

        return this;
      },

      getBasedUseTag: function() {
        return $.getBaseURL('#icon-' + this.settings.use);
      },

      // In the event that a <use> tag exists on an icon, we want to retain it
      // and replace the settings.
      getExistingUseTag: function() {
        if (!this.element.is('svg')) {
          return;
        }

        var useTag = this.element.children('use');
        if (!useTag.length) {
          return this;
        }

        var xlinkHref = useTag.attr('xlink:href');
        this.settings.use = xlinkHref.replace('#icon-', '');

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        });

        return this;
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
        var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Icon(this, settings));
      }
    });
  };

  // Factory Function for instantly building icons.
  // Use this for building icons that don't exist yet.
  // Scoped Privately on purpose...
  (function (){
    'use strict';

    function normalizeIconOptions(options) {
      var defaults = {
        icon: 'user-profile', // omit the "icon-" if you want; this code strips it out.
        classes: ['icon']
      };
      options = options || $.extend({}, defaults);

      if (typeof options === 'string') {
        options = $.extend({}, defaults, {
          icon: options.replace('icon-', '')
        });
      }

      // reroute "options.class" if that exists
      if (!options.classes && options.class) {
        options.classes = options.class;
        delete options.class;
      }

      if (!options.classes) {
        options.classes = [].concat(defaults.classes);
      }

      if (typeof options.classes === 'string') {
        options.classes = options.classes.split(' ');
      }

      if (options.classes.indexOf('icon') === -1) {
        options.classes.push('icon');
      }

      return options;
    }

    // Returns the RAW HTML for creating a new icon in string form
    $.createIcon = function createIcon(options) {
      options = normalizeIconOptions(options);

      return [
        '<svg class="' + options.classes.join(' ') + '" focusable="false" aria-hidden="true" role="presentation">' +
          '<use xlink:href="#icon-' + options.icon + '"></use>' +
        '</svg>'
      ].join('');
    };

    // Returns a jQuery-wrapped element containing a new icon
    $.createIconElement = function createIconElement(options) {
      return $($.createIcon(options));
    };

    // Returns just the path part
    $.createIconPath = function createIconElement(options) {
      options = normalizeIconOptions(options);
      return $.getBaseURL('#icon-' + options.icon.replace('icon-',''));
    };

    //Toggle the use or entire svg icon in the case of the polyfill
    $.fn.changeIcon = function(icon) {
      $(this).find('use').attr('xlink:href', $.createIconPath({icon: icon}));
    };

    $.fn.getIconName = function() {
      var svg = $(this),
          use = svg.find('use');

      if (use.length === 1) {
        return use.attr('xlink:href').substr(use.attr('xlink:href').indexOf('#icon-')+6);
      } else {
        return svg.attr('data-icon');
      }

    };

  })();


  $.fn.lookup = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'lookup',
        defaults = {
          click: null,
          field: 'id',
          title: null,
          buttons: [],
          options: null,
          beforeShow: null,
          modalContent: null,
          editable: true,
          typeahead: false, // Future TODO
          autoApply: true,
          validator: null,
          autoWidth: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * Input element that opens a dialog with a list for selection.
    *
    * @class Lookup
    * @param {Function} click  &nbsp;-&nbsp; Provide a special function to run when the dialog opens to customize the interaction entirely.
    * @param {String} field  &nbsp;-&nbsp; Field name to return from the dataset or can be a function which returns a string on logic
    * @param {String} title  &nbsp;-&nbsp;  Dialog title to show, or befault shows  field label + "Lookup"
    * @param {Array} buttons  &nbsp;-&nbsp; Pass dialog buttons or Cancel / Apply
    * @param {Object} options  &nbsp;-&nbsp; Options to pass to the datagrid
    * @param {Function} beforeShow  &nbsp;-&nbsp; Call back that executes async before the lookup is opened.
    * @param {String} modalContent  &nbsp;-&nbsp; Custom modal markup can be sent in here
    * @param {Boolean} editable  &nbsp;-&nbsp; Can the user type text in the field
    * @param {String} autoApply  &nbsp;-&nbsp; If set to false the dialog wont apply the value on clicking a value.
    * @param {Function} validator  &nbsp;-&nbsp; A function that fires to let you validate form items on open and select
    * @param {Boolean} autoWidth  &nbsp;-&nbsp; If true the field will grow/change in size based on the content selected.
    *
    */
    function Lookup(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    var lookupGridId = 'lookup-datagrid';

    // Plugin Methods
    Lookup.prototype = {

      init: function() {
        this.settings = settings;
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = !!this.inlineLabelText.length;
        this.build();
        this.handleEvents();
        this.grid = null;
        this.selectedRows = null;
      },

      // Build the Ui lookup
      build: function() {
         var lookup = this.element;

        var cssClass = this.element.is('.input-xs') ? 'lookup-wrapper xs' :
            this.element.is('.input-sm') ? 'lookup-wrapper sm' :
            this.element.is('.input-lg') ? 'lookup-wrapper lg' : 'lookup-wrapper';

        if (this.element.is('.has-actions')) {
         cssClass += ' has-actions-wrapper';
        }

        //Add Button
        this.icon = $('<span class="trigger" tabindex="-1"></span>').append($.createIcon('search-list'));
        if (this.isInlineLabel) {
          this.inlineLabel.addClass(cssClass);
        } else {
          this.container = $('<span class="'+ cssClass +'"></span>');

          if (this.element.is('.field-options')) {
            var field = this.element.closest('.field'),
              fieldOptionsTrigger = field.find('.btn-actions');

            lookup
              .add(fieldOptionsTrigger)
              .add(fieldOptionsTrigger.next('.popupmenu'))
              .wrapAll(this.container);
          } else {
            lookup.wrap(this.container);
          }
        }

        // this.container = $('<span class="lookup-wrapper"></span>');
        // lookup.wrap(this.container);
        lookup.after(this.icon);

        if (this.settings.autoWidth) {
          this.applyAutoWidth();
        }

        //Add Masking to show the #
        if (lookup.attr('data-mask')) {
          lookup.mask();
        }

        if (this.element.is(':disabled')) {
          this.disable();
        }

        if (!this.settings.editable) {
          this.element.attr('readonly', 'true').addClass('is-not-editable');
        }

        // Fix field options in case lookup is initialized after
        var wrapper = this.element.parent('.lookup-wrapper');
        if (wrapper.next().is('.btn-actions')) {
          if (this.element.data('fieldoptions')) {
            this.element.data('fieldoptions').destroy();
          }
          this.element.fieldoptions();
        }

        this.addAria();
      },

      // Add/Update Aria
      addAria: function () {
        var self = this;

        setTimeout(function () {
          self.label = self.isInlineLabel ? self.inlineLabelText : $('label[for="'+ self.element.attr('id') + '"]');

          if (self.label) {
            self.label.append('<span class="audible">' + Locale.translate('UseEnter') + '</span>');
          }
        }, 500);
      },

      //Handle events on the field
      handleEvents: function () {
        var self = this;

        this.icon.on('click.lookup', function (e) {
          self.openDialog(e);
        });

        //Down Arrow opens the dialog in this field
        this.element.on('keyup.lookup', function (e) {
          //If autocomplete open dont open list
          if ($('#autocomplete-list').length > 0) {
            return;
          }

          if (e.which === 40) {
            self.openDialog(e);
          }
        });

      },

      //Create and Open the Dialog
      openDialog: function (e) {
        var self = this,
          canOpen = self.element.triggerHandler('beforeopen');

        if (canOpen === false) {
          return;
        }

        if (self.isDisabled() || (self.isReadonly() && !self.element.hasClass('is-not-editable'))) {
          return;
        }

        if (self.settings.click) {
          self.settings.click(e, this);
          return;
        }

        if (this.settings.beforeShow) {
         var response = function (grid) {
            if (grid) {
              self.createGrid(grid);
            }
            self.createModal();
            self.element.triggerHandler('complete'); // for Busy Indicator
            self.element.trigger('open', [self.modal, self.grid]);

            if (self.settings.validator) {
              self.settings.validator(self.element, self.modal, self.grid);
            }
            return;
          };

          this.element.triggerHandler('start'); // for Busy Indicator
          this.settings.beforeShow(this, response);
          return;
        }

        if (!this.settings.options) {
          return;
        }

        self.createModal();
        self.element.trigger('open', [self.modal, self.grid]);

        self.modal.element.find('.btn-actions').removeClass('is-selected');

        // Fix: IE-11 more button was not showing
        var thisMoreBtn = self.modal.element.find('.toolbar .more > .btn-actions');
        if (thisMoreBtn.length) {
          setTimeout(function() {
            window.Soho.utils.fixSVGIcons(thisMoreBtn);
          }, 600);
        }

        self.element.trigger('afteropen', [self.modal, self.grid]);

        if (self.settings.validator) {
          self.settings.validator(self.element, self.modal, self.grid);
        }

      },

      //Overidable function to create the modal dialog
      createModal: function () {
        var self = this,
          content = '<div id="'+lookupGridId+'"></div>',
          thisLabel = $('label[for="'+self.element.attr('id')+'"]'),
          labelText = self.isInlineLabel ? self.inlineLabelText : (thisLabel.length ? thisLabel.clone().find('span').remove().end().text() : '');

        if (this.settings.title) {
          labelText = this.settings.title;
        }

        var settingContent = this.settings.modalContent;
        if (settingContent && settingContent instanceof jQuery) {
          content = settingContent;
          settingContent.show();
        }

        if (settingContent && !(settingContent instanceof jQuery)) {
          content = settingContent;
        }

        var buttons = this.settings.buttons;
        if (this.settings.options && this.settings.options.selectable === 'multiple' && buttons.length === 0 || (!self.settings.autoApply && buttons.length === 0)) {
          buttons = [{
            text: Locale.translate('Cancel'),
            click: function(e, modal) {
              self.element.focus();
              modal.close();
            }
          }, {
            text: Locale.translate('Apply'),
            click: function(e, modal) {
              var selectedRows = self.grid.selectedRows();
              modal.close();
              self.insertRows(selectedRows);
            },
            isDefault: true
          }];
        }

        if (this.settings.options && this.settings.options.selectable === 'single' && buttons.length === 0 && self.settings.autoApply) {
          buttons = [{
            text: Locale.translate('Cancel'),
            click: function(e, modal) {
              self.element.focus();
              modal.close();
            }
          }];
        }

        var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;

        $('body').modal({
          title: labelText,
          content: content,
          buttons: buttons,
          cssClass: 'lookup-modal' + (!hasKeywordSearch ? ' lookup-no-search' : '')
        }).off('open.lookup').on('open.lookup', function () {
          self.createGrid();
        }).off('close.lookup').on('close.lookup', function () {
          self.element.focus();
          self.element.triggerHandler('close', [self.modal, self.grid]);
        });

        self.modal = $('body').data('modal');
        if (!this.settings.title) {
          self.modal.element.find('.modal-title').append(' <span class="datagrid-result-count"></span>');
        }

        self.modal.element.off('beforeclose.lookup').on('beforeclose.lookup', function () {
          self.closeTearDown();
        });

        // Wait until search field available
        setTimeout(function () {
          $('.modal.is-visible .searchfield').on('keypress.lookup', function (e) {
            if (e.keyCode === 13) {
              return false; // Prevent for closing modal
            }
          });
        }, 300);
      },

      closeTearDown: function () {
        var search = $('.modal.is-visible .searchfield').off('keypress.lookup');
        if (search.data() && search.data('searchfield')) {
          search.data('searchfield').destroy();
        }

        if (search.data() && search.data('toolbarsearchfield')) {
          search.data('toolbarsearchfield').destroy();
          search.removeData();
        }
        search = null;

        if (!this.grid) {
          this.grid.destroy();
        }
      },

      //Overridable Function in which we create the grid on the current ui dialog.
      createGrid: function (grid) {
        var self = this, lookupGrid;

        if (grid) {
          lookupGrid = grid;
          lookupGridId = grid.attr('id');
          self.settings.options = grid.data('datagrid').settings;
        } else {
          lookupGrid = self.modal.element.find('#' + lookupGridId);
        }

        if (self.settings.options) {

          if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
            self.settings.options.cellNavigation = false;
            lookupGrid.find('tr').addClass('is-clickable');
          }

          self.settings.options.isList = true;

          // Create grid (unless already exists from passed in grid)
          if (!lookupGrid.data('datagrid')) {
            lookupGrid.datagrid(self.settings.options);
          }
        }

        self.grid = lookupGrid.data('datagrid');
        if (!this.settings.title && self.modal) {
          self.modal.element.find('.title').remove();
        }

        var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;
        if (!hasKeywordSearch && self.modal) {
          self.modal.element.find('.toolbar').appendTo(self.modal.element.find('.modal-header'));
        }

        // Reset keyword search from previous loads
        if (hasKeywordSearch && self.grid) {
          self.grid.keywordSearch('');
        }

        //Mark selected rows
        lookupGrid.off('selected.lookup');
        var val = self.element.val();
        if (val) {
          self.selectGridRows(val);
        }

        if (this.settings.options) {
          lookupGrid.on('selected.lookup', function (e, selectedRows) {

            // Only proceed if a row is selected
            if (!selectedRows || selectedRows.length === 0) {
              return;
            }

            if (self.settings.validator) {
              self.settings.validator(self.element, self.modal, self.grid);
            }

            if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
              setTimeout(function () {
                self.modal.close();
                self.insertRows();
              }, 100);
            }
          });
        }

      },

      //Given a field value, select the row
      selectGridRows: function (val) {
        var self = this,
          selectedId = val;

        if (!val) {
          return;
        }

        //Multi Select
        if (selectedId.indexOf(',') > 1) {
          var selectedIds = selectedId.split(',');

          for (var i = 0; i < selectedIds.length; i++) {
            self.selectRowByValue(self.settings.field, selectedIds[i]);
          }
          return;
        }

        self.selectRowByValue(self.settings.field, selectedId);
      },

      //Find the row and select it based on select value / function / field value
      selectRowByValue: function(field, value) {
        if (!this.settings.options) {
          return;
        }

        var self = this,
          data = this.settings.options.dataset,
          selectedRows = [];

        for (var i = 0; i < data.length; i++) {
          if (typeof self.settings.match === 'function') {
            if (self.settings.match(value, data[i], self.element, self.grid)) {
              selectedRows.push(i);
            }

            continue;
          }

          if (data[i][field] == value) {  // jshint ignore:line
            selectedRows.push(i);
          }
        }

        if (this.grid) {
          this.grid.selectedRows(selectedRows);
        }
      },

      //Get the selected rows and return them to the UI
      insertRows: function () {
        var self = this,
          value = '';

        self.selectedRows = self.grid.selectedRows();

        for (var i = 0; i < self.selectedRows.length; i++) {
          var currValue = '';

          if (typeof self.settings.field === 'function') {
            currValue = self.settings.field(self.selectedRows[i].data, self.element, self.grid);
          } else {
            currValue = self.selectedRows[i].data[self.settings.field];
          }

          value += (i !== 0 ? ',' : '') + currValue;
        }

        self.element.val(value).trigger('change', [self.selectedRows]);
        self.applyAutoWidth();
        self.element.focus();
      },

      /**
      * Enable the input.
      */
      enable: function() {
        this.element.prop('disabled', false).prop('readonly', false);
        this.element.parent().removeClass('is-disabled');
      },

      /**
      * Disable the input.
      */
      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent().addClass('is-disabled');
      },

      /**
      * Make the input readonly.
      */
      readonly: function() {
        this.element.prop('readonly', true);
      },

      /**
      * Make the input the size of the text.
      * @private
      */
      applyAutoWidth: function() {
        var value = this.element.val(),
          length = value.length,
          isUpperCase = (value === value.toUpperCase()),
          isNumber = !isNaN(value);

        this.element.attr('size', length + (isUpperCase && !isNumber ? 2 :1));
      },

      /**
      * Returns whether or not the Input is disabled
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
      * Returns whether or not the Input is readonly
      */
      isReadonly: function() {
        return this.element.prop('readonly');
      },

      /**
      * Teardown events and objects.
      */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('click.dropdown keypress.dropdown');

        this.icon.remove();
        this.element.unwrap();

        if (this.label && this.label != null) {
          this.label.find('.audible').remove();
        }
      }
    };

    // Initialize the plugin once
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Lookup(this, settings));
      }
    });
  };

 // Lifecycle Methods for jQuery Controls
 // Recursive methods that "globally" call certain methods on large groups of controls


  var EXCLUDED_FROM_CLOSE_CHILDREN = ['.expandable-area', '.accordion'],
      EXCLUDED_FROM_HANDLE_RESIZE = [];

  // Used by several of these plugins to detect whether or not the "data" property in question
  // is a valid SoHo Xi Control.
  function canAccessAPI(prop) {
    return prop && !(prop instanceof jQuery);
  }

  // Used by several of these plugins to detect whether or not there is a method on a "data" api
  // that can be called.
  function canCall(prop, method) {
    var api = canAccessAPI(prop);
    if (!api) {
      return false;
    }

    return (prop[method] && typeof prop[method] === 'function');
  }

  // Actually triggers the method on the control if it's possible
  function triggerAPIMethod(prop, method) {
    if (canCall(prop, method)) {
      prop[method]();
      return true;
    }
    return false;
  }

  // Tracks each element that attempts to trigger an API method.
  // If a trigger is successful, it stores it in an array that's used later.
  function findControlsOnElements(elems, method) {
    var foundControls = [];

    $.each(elems, function elementIterator(index, elem) {
      $.each($(elem).data(), function dataEntryIterator(index, dataEntry) {
        if (triggerAPIMethod(dataEntry, method)) {
          foundControls.push({ elem: $(elem), control: dataEntry });
        }
      });
    });

    return foundControls;
  }

  // Kicks it all off
  function siftFor(rootElem, method, filteredOutElements) {
    if (!rootElem || !method) {
      return;
    }

    rootElem = $(rootElem);
    var DOMelements = rootElem.find('*').add(rootElem);

    if (filteredOutElements) {
      DOMelements = DOMelements.not(filteredOutElements.join(', '));
    }
    var siftedControls = findControlsOnElements(DOMelements, method);

    rootElem.trigger('sift-' + method + '-complete', [siftedControls]);
    return rootElem;
  }

  //==========================================================
  // Actual Control Plugins
  //==========================================================

  $.fn.destroy = function() {
    return siftFor($(this), 'destroy');
  };

  $.fn.closeChildren = function() {
    return siftFor($(this), 'close', EXCLUDED_FROM_CLOSE_CHILDREN);
  };

  $.fn.handleResize = function() {
    return siftFor($(this), 'handleResize', EXCLUDED_FROM_HANDLE_RESIZE);
  };


  $.fn.listview = function(options) {

    // Settings and Options
    var pluginName = 'listview',
      defaults = {
        dataset: [],
        template: null,
        description: null,
        paging: false,
        pagesize: 10,
        searchable: false,
        selectable: 'single',
        selectOnFocus: true,
        showCheckboxes: true,
        hoverable: true,
        source: null,
        disableItemDeactivation: false
      },
      settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class ListView
    * @param {Array} dataset  &nbsp;-&nbsp; Array of data to feed the template
    * @param {String} content  &nbsp;-&nbsp; Html Template String
    * @param {String} description  &nbsp;-&nbsp; Audible Label (or use parent title)
    * @param {Boolean} paging  &nbsp;-&nbsp; If true, activates paging
    * @param {Number} pagesize  &nbsp;-&nbsp; If paging is activated, sets the number of listview items available per page
    * @param {Boolean} searchable  &nbsp;-&nbsp; If true, associates itself with a Searchfield/Autocomplete and allows itself to be filtered
    * @param {String|Boolean} selectable  &nbsp;-&nbsp;  selection mode, can be false, 'single' or 'multiple' or 'mixed'
    * @param {Boolean} selectOnFocus  &nbsp;-&nbsp;  If true the first item in the list will be selected as it is focused.
    * @param {Boolean} showCheckboxes  &nbsp;-&nbsp;  If false will not show checkboxes used with multiple selection mode only
    * @param {Boolean} hoverable  &nbsp;-&nbsp;  If true the list element will show a hover action to indicate its actionable.
    * @param {Function|String} source  &nbsp;-&nbsp; If source is a string then it serves as the url for an ajax call that returns the dataset. If its a function it is a call back for getting the data asyncronously.
    * @param {Boolean} disableItemDeactivation  &nbsp;-&nbsp; If true when an item is activated the user should not be able to deactivate it by clicking on the activated item. They can only select another row.
    *
    */
    function ListView(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Object
    ListView.prototype = {

      /**
      * Initialize this component.
      * @private
      */
      init: function() {
        this.setup();
        this.refresh();
        this.selectedItems = [];
        this.lastSelectedItem = 0; // Rember index to use shift key
        this.isSelectedAll = false; // Rember if all selected or not
        this.sortInit('listview', 'click.listview', 'data-sortlist');
        this.handleEvents();
        this.handleResize();
      },

      /**
      * Do initial dom and settings setup.
      * @private
      */
      setup: function() {
        var self = this,
          card = this.element.closest('.card, .widget'),
          selectable = this.element.attr('data-selectable'),
          selectOnFocus = this.element.attr('data-select-onfocus');

        if (selectable && selectable.length) {
          this.settings.selectable = selectable;
        }

        if (selectOnFocus && selectOnFocus.length) {
          this.settings.selectOnFocus = JSON.parse(selectOnFocus);
        }

        self.actionButton = card.find('.btn-actions');

        if (self.actionButton.length > 0) {
          // Action Buttons may already be invoked via initialize.js.
          if (!(self.actionButton.data('popupmenu'))) {
            self.actionButton.popupmenu();
          }
        }

        this.element.attr({'tabindex': '-1', 'x-ms-format-detection': 'none'});

        // Configure Paging
        if (this.element.is('.paginated') || this.settings.paging === true) {
          this.element.pager({
            componentAPI: this,
            pagesize: this.settings.pagesize,
            source: this.settings.source
          });

          this.pager = this.element.data('pager');
        }

        var cardWidgetContent =  this.element.parent('.card-content, .widget-content');
        if (cardWidgetContent[0]) {
          cardWidgetContent[0].style.overflow = 'hidden';
        }

         // Add Aria Roles
        this.element.attr({ 'role' : 'listbox',
          'aria-label' : this.settings.description || card.find('.card-title, .widget-title').text()
        });

        // Associate with an existing searchfield, if applicable
        if (this.settings.searchable) {
          this.searchfield = this.element.parent().find('.searchfield, .autocomplete');

          if (!this.searchfield.length) {
            // TODO: Create Searchfield somehow
          }

          this.listfilter = new ListFilter({
            filterMode: 'contains'
          });
        }

        if (this.settings.dataset) {
          // Search the global variable space for a dataset variable name, if provided.
          if (typeof this.settings.dataset === 'string') {
            var dataset = window[this.settings.dataset];
            if (dataset && dataset.length) {
              this.settings.dataset = dataset;
            }
          }
        }
      },

      /**
      * Calculate the totals for totalling examples. This is done by template {{totals}}.
      *
      * @private
      */
      getTotals: function(dataset) {
        var totals = { count: dataset.length },
          property;

        if (!dataset[0]) {
          return;
        }

        for (property in dataset[0]) {
          totals[property] = 0;
        }

        for (var i = 0; i < dataset.length; i++) {
          for (property in dataset[i]) {
            totals[property] += parseFloat(dataset[i][property]);
          }
        }
        return totals;
      },

      /**
      * Render the template against the dataset.
      *
      * @param {Array} dataset  &nbsp;-&nbsp; The dataset to use
      * @param {Object} pagerInfo  &nbsp;-&nbsp; Pager instructions
      */
      render: function(dataset, pagerInfo) {
        var self = this,
          totals = {};

        // Render "mustache" Template
        if (typeof Tmpl === 'object' && dataset && this.settings.template) {

          // create a copy of an inlined template
          if (this.settings.template instanceof $) {
            this.settings.template = '' + this.settings.template.html();
          }

          if (this.settings.template.indexOf('{{#totals}}') > -1) {
            totals = this.getTotals(dataset);
          }

          var compiledTmpl = Tmpl.compile(this.settings.template),
            renderedTmpl = compiledTmpl.render({dataset: dataset, totals: totals});

          this.element.html(renderedTmpl);
        }

        // Render Pager
        if (this.settings.paging) {
          this.renderPager(pagerInfo);
        }

        // Add Aria
        $('ul', this.element).attr({'role': 'presentation'});

        // Add Checkboxes
        var first = this.element.find('li, tbody > tr').first(),
          items = this.element.find('li, tr'),
          isMultiselect = (this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed');

        //Set Initial Tab Index
        first.attr('tabindex', 0);

        //Let the link be focus'd
        if (!this.settings.selectable && first.find('a').length === 1) {
          first.removeAttr('tabindex');
        }

        items.each(function (i) {
          var item = $(this);

          item.attr('role', 'option');

          if (isMultiselect) {
            // Add Selection Checkboxes
            self.element.addClass('is-muliselect');

            // Create a Toolbar for the "Selected Items" area
            var selectedToolbar = self.element.prevAll('.toolbar');
            if (selectedToolbar.length && selectedToolbar.data('toolbar')) {
              selectedToolbar.data('toolbar').toggleMoreMenu();
            }

            if (self.settings.showCheckboxes) {
              //For mixed selection mode primarily append a checkbox object
              item.prepend('<label class="listview-selection-checkbox l-vertical-center inline inline-checkbox"><input tabindex="-1" type="checkbox" class="checkbox"><span class="label-text">&nbsp;</span></label>');
              //TODO: item.find('.checkbox').attr('tabindex', '-1');
            }
          }

          // Add Aria
          item.attr({'aria-posinset': i+1, 'aria-setsize': items.length});

          // Add Aria disabled
          if (item.hasClass('is-disabled')) {
            item.attr('aria-disabled','true');
          }
        });

        // TODO: Invoke the "element" here after we write an updated method.
        this.element.children().initialize();
        this.element.trigger('rendered', [dataset]);

        //Handle refresh
        this.element.off('updated').on('updated', function () {
          self.refresh();
        });
      },

      /**
      * Add and update the pager (if used)
      * @private
      */
      renderPager: function(updatedPagerInfo) {
        if (!this.pager) {
          return;
        }

        this.pager.updatePagingInfo(updatedPagerInfo);
        this.pager.setActivePage(1, true);
      },

      /**
      * Get the Data Source. Can be an array, Object or Url and render the list.
      */
      refresh: function () {
        this.loadData();

        if (this.list) {
          this.render(this.list.data);
        }
      },

      /**
      * Load Data from an external API
      * @param {Object} ds  &nbsp;-&nbsp; The dataset to use or will use settings.dataset.
      * @param {Object} pagerInfo  &nbsp;-&nbsp; The pager settings to use (see pager api)
      */
      loadData: function (ds, pagerInfo) {
        var ajaxDs = false, self = this;

        ds = ds || this.settings.dataset;
        pagerInfo = pagerInfo || {};

        if (!ds) {
          return;
        }

        function done(response, pagingInfo) {
          ds = response;
          self.render(ds, pagingInfo);
        }

        var s = this.settings.source;

        if (typeof ds === 'string' && (ds.indexOf('http') === 0 || ds.indexOf('/') === 0)) {
          s = ds;
          ajaxDs = true;
        }

        // If paging is not active, and a source is present, attempt to retrieve information from the datasource
        // TODO: Potentially abstract this datasource concept out for use elsewhere
        if ((s) || ajaxDs) {
          switch (typeof s) {
            case 'function':
              return s(pagerInfo, done);
            case 'string':
              if (s.indexOf('http') === 0 || s.indexOf('/') === 0) {
                $.ajax({
                  url: s,
                  async: false,
                  dataType: 'json',
                  success: function(response) {
                    ds = self.settings.dataset = response;
                    return self.render(ds, pagerInfo);
                  }
                });
              }
              return;
            default:
              ds = this.settings.dataset = s;
              return this.render(s, pagerInfo);
          }
        }

        // Otherwise, simply render with the existing dataset
        this.render(ds, pagerInfo);
      },

      /**
      * Toggle all items from selected to deselected, useful for multi/mixed selection
      */
      toggleAll: function() {
        this[this.isSelectedAll ?
          'deselectItemsBetweenIndexes' :
          'selectItemsBetweenIndexes']([0, $('li, tbody tr', this.element).length-1]);
        this.isSelectedAll = !this.isSelectedAll;
      },

      /**
      * Select Items between a set of indexes. Used for shift selection.
      * @private
      */
      selectItemsBetweenIndexes: function(indexes) {
        this.clearSelection();
        indexes.sort(function(a, b) { return a-b; });
        for (var i = indexes[0]; i <= indexes[1]; i++) {
          var item = $('li, tbody tr', this.element).eq(i);

          if (!item.is('.is-disabled, .is-selected')) {
            this.select(item);
          }
        }
      },

      /**
      * De-Select Items between a set of indexes. Used for shift selection.
      * @private
      */
      deselectItemsBetweenIndexes: function(indexes) {
        indexes.sort(function(a, b) { return a-b; });
        for (var i = indexes[0]; i <= indexes[1]; i++) {
          var item = $('li, tbody tr', this.element).eq(i);
          if(!item.is('.is-disabled') && item.is('.is-selected')) {
            this.select(item);
          }
        }
      },

      /**
      * Clear all currently selected list items.
      * @private
      */
      clearSelection: function() {
        if (window.getSelection) {
          window.getSelection().removeAllRanges();
        } else if (document.selection) {
          document.selection.empty();
        }
      },

      /**
      * Handle page/form resize
      * @private
      */
      handleResize: function () {
        var items = $('li .listview-heading, tr .listview-heading', this.element),
          item1 = items.eq(1),
          item1W = item1.width();

        if (item1.length && item1W) {
          items[0].style.width = item1W + 'px';
        }

        if (this.element.data('pager')) {
          this.element.data('pager').renderBar();
        }
      },

      /**
      * For instances of Listview that are paired with a Searchfield
      * NOTE: Search functionality is called from "js/listfilter.js"
      *
      * @private
      */
      handleSearch: function(e, searchfield) {
        var list = this.element.find('li, tbody > tr'),
            term = searchfield.val(),
            results;

        this.resetSearch();

        if (term && term.length) {
          results = this.listfilter.filter(list, term);
        }

        if (!results || !results.length && !term) {
          return;
        }

        list.not(results).addClass('hidden');
        list.filter(results).each(function(i) {
          var li = $(this);
          li.attr('tabindex', i === 0 ? '0' : '-1');
          li.highlight(term);
        });

        this.renderPager();
      },

      /**
      * Reset the current search parameters and highlight.
      */
      resetSearch: function() {
        var list = this.element.find('li, tbody > tr');

        list.removeClass('hidden').each(function() {
          $(this).unhighlight();
        });
      },

      /**
      * Focus the provided list item with the keyboard
      * @param {jQuery} item  &nbsp;-&nbsp; The list item (as jQuery) to focus
      */
      focus: function (item) {
        if (item.is(':hidden') || item.is('.is-disabled')) {
          return;
        }

        item.siblings().removeAttr('tabindex');
        item.attr('tabindex', 0).focus();

        if (!this.settings.selectable && item.find('a').length === 1) {
          item.find('a').focus();
          item.removeAttr('tabindex');
        }

        if (this.settings.selectOnFocus &&
          this.settings.selectable !== 'multiple' &&
          this.settings.selectable !== 'mixed') {
          this.select(item);
        }
      },

      /**
      * Remove the given list item.
      * @param {jQuery|Number} li  &nbsp;-&nbsp; Either the actually jQuery list element or a zero based index
      */
      remove: function (li) {
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }
        // Un-select selected item
        // and donot trigger selected event, sinnce we removeing
        if (li.is('.is-selected')) {
          this.select(li, true);
        }
        li.remove();
      },

      /**
      * Remove all list items.
      */
      clear: function () {
        var root = $(this.element.children()[0]);
        root.empty();
      },

      /**
      * Remove all selected items entirely from the list..
      */
      removeAllSelected: function () {
        var self = this;
        $.each(this.selectedItems, function(index, selected) {
          self.remove(selected);
        });
      },

      /**
      * Deselect all selected items.
      */
      clearAllSelected: function () {
        var self = this;
        $.each(this.selectedItems, function(index, selected) {
          // Un-select selected item
          self.select(selected);
        });
      },

      /**
      * Initialize the sorted list
      * @private
      */
      sortInit: function(control, onEvent, attr){
        if(!attr || $.trim(attr) === '') {
          return;
        }
        $('['+ attr +']').each(function() {
          var elment = $(this),
            options = $.fn.parseOptions(elment, attr);

          elment.on(onEvent, function(e) {
            $(options.list).data(control).setSortColumn(options);
            e.preventDefault();
          });
        });
      },

      /**
      * Sort the list with the given options.
      * @private
      */
      setSortColumn: function(options) {
        var sort,
        field = options.orderBy || this.list.sort.field,
        reverse = options.order;

        if (!this.list.data && !field) {
          return;
        }

        reverse = reverse ?
          (reverse === 'desc') :
          (this.list.sort && this.list.sort[field] && this.list.sort[field].reverse) ? false : true;

        //reload data
        if (options.reloadApi || options.reloadApiNoSort) {
          this.loadData();
        }

        //reload data but no sort change
        if (options.reloadApiNoSort) {
          field = this.list.sort.field;
          reverse = this.list.sort[field].reverse;
        }

        sort = this.sortFunction(field, reverse);
        this.list.data.sort(sort);
        this.render(this.list.data);

        this.list.sort = {field: field};
        this.list.sort[field] = {reverse: reverse};

        this.element.trigger('sorted', [this.element, this.list.sort]);
      },

      /**
      * Overridable function to conduct sorting
      * @param {String} field  &nbsp;-&nbsp; The field in the dataset to sort on.
      * @param {String} reverse  &nbsp;-&nbsp; If true sort descending.
      * @param {Function} primer  &nbsp;-&nbsp; A sorting primer function.
      *
      */
      sortFunction: function(field, reverse, primer) {
        var key;
        if (!primer) {
          primer = function(a) {
            a = (a === undefined || a === null ? '' : a);
            if (typeof a === 'string') {
              a = a.toUpperCase();

              if (!isNaN(parseFloat(a))) {
                a = parseFloat(a);
              }
            }
            return a;
          };
        }
        key = primer ? function(x) { return primer(x[field]); } : function(x) { return x[field]; };
        reverse = !reverse ? 1 : -1;
        return function (a, b) {
           return a = key(a), b = key(b), reverse * ((a > b) - (b > a));
        };
      },

      /**
      * Deselect the given list item.
      * @param {jQuery|Number} li  &nbsp;-&nbsp; Either the actually jQuery list element or a zero based index
      */
      deselect: function (li) {
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }
        if (li.is('.is-selected')) {
          this.select(li);
        }
      },

      /**
      * Deprivated - use deselect
      * @deprecated
      */
      unselect: function (li) {
        this.deselect(li);
      },

      /**
      * Select the given list item.
      * @param {jQuery|Number} li &nbsp;-&nbsp; Either the actually jQuery list element or a zero based index
      * @param {Boolean} noTrigger &nbsp;-&nbsp; Do not trigger the selected event.
      */
      select: function (li, noTrigger) {
        var self = this,
          isChecked = false,
          isMixed = self.settings.selectable === 'mixed';

        self.selectedItems = [];
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }

        isChecked = li.hasClass('is-selected');

        //focus
        if (!li.is('[tabindex="0"]')) {
          li.siblings().removeAttr('tabindex');
          li.attr('tabindex', 0);
        }

        if (this.settings.selectable === false || this.settings.selectable === 'false') {
          return;
        }

        //Select
        if (this.settings.selectable !== 'multiple' && this.settings.selectable !== 'mixed') {
          li.parent().children().removeAttr('aria-selected');
          li.parent().find('.is-selected').removeClass('is-selected');
          self.selectedItems[0] = $(this);
        }

        if (isChecked) {
          self.selectedItems = [];
          li.removeClass('is-selected hide-selected-color');
        } else {
          if (this.settings.selectable) {
            li.addClass('is-selected' + (isMixed ? ' hide-selected-color' : ''));
            self.lastSelectedItem = li.index();// Rember index to use shift key
          }
        }

        li.parent().find('.is-selected').each(function (i) {
          self.selectedItems[i] = $(this);
        });

        li.attr('aria-selected', !isChecked);
        li.find('.listview-selection-checkbox input').prop('checked', !isChecked);

        if (!noTrigger) {
          var triggerStr = isChecked ? 'unselected' : 'selected';
          this.element.triggerHandler(triggerStr, {selectedItems: this.selectedItems, elem: li});

          if (triggerStr === 'unselected') {
            this.element.triggerHandler('deselected', {selectedItems: this.selectedItems, elem: li});
          }
        }

        var toolbar, toolbarControl,
          parent = this.element.closest('.card, .widget');

        if (!parent.length) {
          parent = this.element.parent();
        }
        toolbar = parent.find('.listview-toolbar, .contextual-toolbar');

        toolbarControl = toolbar.data('toolbar');

        if (self.selectedItems.length > 0) {
          if (toolbarControl) {
            toolbarControl.toggleMoreMenu();
          }
          // Order of operations: set up event, change display prop, animate, toggle menu.
          // Menu toggle takes place after the animation starts
          toolbar.one('animateopencomplete', function() {
            self.element.addClass('is-toolbar-open');
            toolbar.trigger('recalculate-buttons').removeClass('is-hidden');
          });
          if (toolbar[0]) {
            toolbar[0].style.display = 'block';
          }
          // toolbar.animateOpen({distance: 52});
          toolbar.animateOpen({distance: 40});

          var title = toolbar.find('.title, .selection-count');
          if (!title || !title.length) {
            title = $('<div class="title selection-count"></div>');
            toolbar.prepend(title);
          }
          title.text(self.selectedItems.length + ' ' + Locale.translate('Selected'));

        } else {
          toolbar.addClass('is-hidden').one('animateclosedcomplete', function(e) {
            e.stopPropagation();
            this.style.display = 'none';
          }).animateClosed();

        }
      },

      /**
      * Toggle acivation state on the list item
      * @param {jQuery} li &nbsp;-&nbsp; The jQuery list element.
      */
      toggleItemActivation: function(li) {
        var isActivated = li.hasClass('is-activated');

        if (isActivated) {
          if (!this.settings.disableItemDeactivation) {
            this.deactivateItem(li);
          }
          return;
        }

        this.activateItem(li);
      },

      /**
      * Set item to activated, unactivate others and fire an event.
      * @param {jQuery|Number} li &nbsp;-&nbsp; The jQuery list element or the index.
      */
      activateItem: function(li) {
        var active = this.element.find('li.is-activated');
        this.deactivateItem(active);

        if (typeof li === 'number') {
          li = this.element.find('ul').children().eq(li);
        }
        li.addClass('is-activated');

        var idx = li.index();
        this.element.triggerHandler('itemactivated', [{index: idx, elem: li, data: this.settings.dataset[idx]}]);
      },

      /**
      * Return an object containing info about the currently activated item.
      * @returns {Object} An object containing the active row's index, dom element and data.
      */
      activatedItem: function() {
        var active = this.element.find('li.is-activated'),
          idx = active.index();

        return {index: idx, elem: active, data: this.settings.dataset[idx]};
      },

      /**
      * Set item to deactivated, uand fire an event.
      * @param {jQuery|Number} li &nbsp;-&nbsp; The jQuery list element. The li element or the index. If null the currently activated one will be deactivated.
      */
      deactivateItem: function(li) {

        if (typeof li === 'number') {
          li = this.element.find('ul').children().eq(li);
        }

        if (li === undefined) {
          li = this.element.find('li.is-activated');
        }

        li.removeClass('is-activated');
        var idx = li.index();

        if (idx < 0) {
          return;
        }

        this.element.triggerHandler('itemdeactivated', [{index: idx, elem: li, data: this.settings.dataset[idx]}]);
      },

      /**
      * Refresh the list with any optioned options that might have been set.
      */
      updated: function() {
        this.refresh();
        return this;
      },

      /**
      * Detatch all bound events.
      */
      teardown: function() {
        $('body').off('resize.listview');
        this.element.off('focus.listview click.listview touchend.listview keydown.listview change.selectable-listview afterpaging.listview').empty();
        return this;
      },

      /**
      * Detatch all events and tear down data object
      */
      destroy: function() {
        this.teardown();
        this.element.removeData(pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires ListBox#events
       * @param {Object} selected  &nbsp;-&nbsp; Fires when a item is selected
       * @param {Object} unselected  &nbsp;-&nbsp; Fires when a item is deselected (deprecated)
       * @param {Object} deselected  &nbsp;-&nbsp; Fires when a item is deselected
       * @param {Object} rendered  &nbsp;-&nbsp; Fires after the listbox is fully rendered
       *
       */
      handleEvents: function () {
        var self = this,
          isSelect = false,
          isFocused = false,
          isMultiple = self.settings.selectable === 'multiple' || self.settings.selectable === 'mixed';

        this.element.on('focus.listview', 'li, tbody tr', function () {
          var item = $(this);

          // First element if disabled
          if (item.is(':first-child') && item.hasClass('is-disabled')) {
            var e = $.Event('keydown.listview');

            e.keyCode= 40; // move down
            isSelect = true;
            item.trigger(e);
          }

          if ((!isSelect) &&
              (!item.hasClass('is-disabled')) &&
              (self.settings.selectOnFocus) &&
              (self.settings.selectable !== 'multiple')&&
              (self.settings.selectable !== 'mixed')) {

            self.select(item);
            isSelect = true;
            isFocused = true;
          }
        });

        // Key Board
        this.element.on('keydown.listview', 'li, tr, a', function (e) {
          var elem = $(this),
            item = elem.is('a') ? elem.closest('li') : $(this),
            list = item.is('a') ? item.closest('ul') : item.parent(),
            key = e.keyCode || e.charCode || 0,
            metaKey = e.metaKey;

          if (item.index() === 0 && e.keyCode === 38) {
            return;
          }

          if ((key === 40 || key === 38) && !metaKey) {// move down or up
            var newItem = e.keyCode === 40 ? item.nextAll(':not(.is-disabled):visible:first') : item.prevAll(':not(.is-disabled):visible:first');

            if (newItem.length && ($(e.target).is(item) || e.shiftKey || elem.is('a'))) {
              self.focus(newItem);
            }
            e.preventDefault();
            e.stopPropagation();  //prevent container from scrolling
          }

          if (key === 35 || (key === 40 && metaKey)) { //end
            var last = list.children().last();
            self.focus(last);
            e.stopPropagation();
            return false;
          }

          if (key === 36 || (key === 38 && metaKey)) {  //home
            var first = list.children().first();
            self.focus(first);
            e.stopPropagation();
            return false;
          }

          if (key === 32) { // Space to toggle selection
            if ($(e.target).is(item)) {
              if (isMultiple && e.shiftKey) {
                self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
              } else {
                self.select(item);
              }
              e.preventDefault();
            }
          }

          // If multiSelect is enabled, press Control+A to toggle select all items
          if (isMultiple && ((e.ctrlKey || e.metaKey) && key === 65)) {
            self.toggleAll();
            self.focus(item);
            e.preventDefault();
          }

        });

        // Selection View Click/Touch
        if (this.settings.selectable) {

          this.element.addClass('is-selectable');

          var trigger = $('.list-detail-back-button, .list-detail-button').find('.app-header'),
            pattern = $(this.element).closest('.list-detail, .builder');

          trigger.parent().onTouchClick('listview').on('click.listview', function (e) {
            if (trigger.hasClass('go-back')) {
              trigger.removeClass('go-back');
              pattern.removeClass('show-detail');
            }
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
            return false;
          });

          this.element
          .off('click.listview', 'li, tr, input[checkbox]')
          .on('click.listview', 'li, tr, input[checkbox]', function (e) {
            var item = $(this),
              isCheckbox = $(e.target).closest('.listview-selection-checkbox').length > 0,
              isMixed = self.settings.selectable === 'mixed';

            if (!isFocused && !item.hasClass('is-disabled') && (!isMixed || isCheckbox)) {
              isSelect = true;

              if (isMultiple && e.shiftKey) {
                self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
                e.preventDefault();
              } else {
                self.select(item);
              }
              item.focus();
            }

            if (!item.hasClass('is-disabled') && isMixed && !isCheckbox) {
              item.focus();
              self.toggleItemActivation(item);
            }

            if (pattern.length > 0 && $(window).outerWidth() < 767 && !item.hasClass('is-disabled')) {
              pattern.toggleClass('show-detail');
              trigger.toggleClass('go-back');
            }

            isFocused = false;

            e.preventDefault();
            e.stopPropagation();

            self.element.trigger('click', [{elem: item, data: self.settings.dataset[item.attr('aria-posinset')], index: item.index(), originalEvent: e}]);
            return false;
          });

          this.element
          .off('dblclick.listview', 'li, tr')
          .on('dblclick.listview', 'li, tr', function (e) {
            var item = $(this);

            e.preventDefault();
            e.stopPropagation();
            self.element.trigger('dblclick', [{elem: $(this), data: self.settings.dataset[item.attr('aria-posinset')], index: item.index(), originalEvent: e}]);
            return false;
          });

          this.element
          .off('contextmenu.listview', 'li, tr')
          .on('contextmenu.listview', 'li, tr', function (e) {
            var item = $(this);

            e.preventDefault();
            e.stopPropagation();
            self.element.trigger('contextmenu', [{elem: $(this), data: self.settings.dataset[item.attr('aria-posinset')], index: item.index(), originalEvent: e}]);
            return false;
          });
        }

        if (!this.settings.hoverable || this.settings.hoverable === 'false') {
          this.element.removeClass('is-selectable');
          this.element.addClass('disable-hover');
        }

        if (!this.settings.selectable || this.settings.selectable === 'false') {
          this.element.removeClass('is-selectable');
          this.element.addClass('disable-hover');
        }

        if (this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed') {
          this.element.on('change.selectable-listview', '.listview-checkbox input', function (e) {
           $(this).parent().trigger('click');
           e.stopPropagation();
          });
        }

        // For use with Searchfield
        if (this.settings.searchable) {
          this.searchfield.on('contents-checked.searchable-listview', function(e) {
            self.handleSearch(e, $(this));
          });
        }

        //If used with a Pager Control, listen for the end of the page and scroll the Listview to the top
        if (this.element.data('pager')) {
          this.element.on('afterpaging.listview', function() {
            self.element.scrollTop(0);
          });
        }

        $('body').on('resize.listview', function() {
          self.handleResize();
        });

        //Animate open and Closed from the header
        self.element.prev('.listview-header').onTouchClick().on('click', function () {
          var icon = $(this).find('.plus-minus');
          if (icon.hasClass('active')) {
            icon.removeClass('active');
            self.element.animateClosed();
          } else {
            icon.addClass('active');
            self.element.animateOpen();
          }
        });

      }

    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ListView(this, settings));
      }
    });
  };


  $.fn.listbuilder = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'listbuilder',
        defaults = {
          'dataset': [], // Array of data,
          'handle': '.handle', // The Class of the handle element

          // Action buttons
          // use "data-action" attributes, ie. data-action="add"
          // or jQuery elements
          'btnAdd': 'add',
          'btnEdit': 'edit',
          'btnDelete': 'delete',
          'btnGoUp': 'goup',
          'btnGoDown': 'godown',

          // Template HTML
          'template': ''+
            '<ul data-handle=".handle">'+
              '{{#dataset}}'+
                '{{#text}}'+
                  '<li'+
                    '{{#value}} data-value="{{value}}"{{/value}}'+
                    '{{#selected}} selected="selected"{{/selected}}'+
                    '{{#disabled}} class="is-disabled"{{/disabled}}'+
                  '>'+
                    '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
                    '<div class="item-content"><p>{{text}}</p></div>'+
                  '</li>'+
                '{{/text}}'+
              '{{/dataset}}'+
            '</ul>',

          'templateNewItem': ''+
            '<li data-value="{{text}}" role="option">'+
              '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
              '<div class="item-content"><p>{{text}}</p></div>'+
            '</li>',

          'templateItemContent': '<p>{{text}}</p>'
        },
        settings = $.extend({}, defaults, options);

    /**
    * A list of items with add/remove/delete and sort functionality.
    *
    * @class ListBuilder
    * @param {Object} dataset  &nbsp;-&nbsp; The array of data
    * @param {String} btnAdd  &nbsp;-&nbsp; The attribute to match the add button in the toolbar (ie. data-action="add")
    * @param {String} btnEdit  &nbsp;-&nbsp; The attribute to match the edit button in the toolbar (ie. data-action="edit")
    * @param {Boolean} btnDelete  &nbsp;-&nbsp; The attribute to match the delete button in the toolbar (ie. data-action="delete")
    * @param {String} btnGoUp  &nbsp;-&nbsp; The attribute to match the move up button in the toolbar (ie. data-action="goup")
    * @param {Boolean} btnGoDown  &nbsp;-&nbsp; The attribute to match the move up button in the toolbar (ie. data-action="dodown")
    * @param {String} template  &nbsp;-&nbsp; The list view markdown / template.
    * @param {String} templateItemContent  &nbsp;-&nbsp; The markdown for editing an item
    */
    function ListBuilder(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // ListBuilder Methods
    ListBuilder.prototype = {

      init: function() {
        var self = this;
        this
          .loadListview()
          .initDataset()
          .setElements()
          .handleEvents();

        setTimeout(function() {
          self.setSelected();
        }, 0);
      },

      // Load listview
      loadListview: function() {
        var s = this.settings,
          lv = $('.listview', this.element);

        if (!s.dataset.length && lv.length && $('li', lv).length) {
          this.listApi = lv.listview({selectable: 'single'}).data('listview');
        } else if (lv.length) {
          this.listApi = lv.listview({dataset: s.dataset, template: s.template, selectable: 'single'}).data('listview');
        }
        return this;
      },

      // Init dataset
      initDataset: function() {
        var s = this.settings,
          nodes = $('.listview li', this.element);

        this.dataset = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
          var data,
            li = $(nodes[i]);
          if (s.dataset) {
            // Make sure it's not reference pointer to data object, make copy of data
            data = JSON.parse(JSON.stringify(s.dataset[i]));
            data.node = li;
          }
          else {
            data = this.extractNodeData(li);
          }
          this.dataset.push(data);
        }
        return this;
      },

      // Extract node data
      extractNodeData: function(node) {
        var data = {node: node, text: $.trim($('.item-content', node).text())},
          value = node.attr('data-value');
        if (typeof value !== 'undefined') {
          data.value = value;
        }
        return data;
      },

      // Set elements
      setElements: function() {
        var self = this,
          s = this.settings;

        // Action buttons
        var setAction = function(selector) {
          return self.isjQuery(selector) ?
            selector : (typeof selector === 'string' ?
              $('[data-action="'+ selector +'"]', self.element) : null);
        };
        s.btnAdd = setAction(s.btnAdd);
        s.btnGoUp = setAction(s.btnGoUp);
        s.btnGoDown = setAction(s.btnGoDown);
        s.btnEdit = setAction(s.btnEdit);
        s.btnDelete = setAction(s.btnDelete);

        // Init tooltips
        this.topButtons = s.btnAdd.add(s.btnGoUp).add(s.btnGoDown).add(s.btnEdit).add(s.btnDelete);
        this.topButtons.tooltip();

        // Make Draggable
        this.ul = $('.listview ul', this.element);
        this.arrangeApi = this.ul.arrange({
          handle: s.handle,
          placeholder: s.templateNewItem
        }).data('arrange');

        return this;
      },

      // Handle Events
      handleEvents: function() {
        var data,
          self = this,
          s = self.settings;

        // TOP BUTTONS =============================================================================
        var topButtonsClick = function(btn, method) {
          btn.offTouchClick('listbuilder').off('click.listbuilder')
            .onTouchClick('listbuilder').on('click.listbuilder', function() {
            self[method]();
          });
        };
        topButtonsClick(s.btnAdd, 'addItem');
        topButtonsClick(s.btnGoUp, 'moveItemUp');
        topButtonsClick(s.btnGoDown, 'moveItemDown');
        topButtonsClick(s.btnEdit, 'editItem');
        topButtonsClick(s.btnDelete, 'deleteItem');

        // DRAGGABLE ===============================================================================
        self.arrangeApi.element
        .on('beforearrange.listbuilder', function(e, status) {
          var d = self.getDataByNode(status.start),
            str = s.templateItemContent.replace(/{{text}}/g, d.data.text);

          self.arrangeApi.placeholders.attr('data-value', d.data.text)
            .find('.item-content').html(str);
        })
        .on('arrangeupdate.listbuilder', function(e, status) {
          self.updateAttributes();
          self.arrayIndexMove(self.dataset, status.startIndex, status.endIndex);
          data = self.getDataByNode(status.end);
          data.indexBeforeMove = status.startIndex;
          self.element.triggerHandler('arrangeupdate', [data]);
        });

        $('li:not(.is-disabled) '+ self.arrangeApi.handle, self.ul)
          .on('mousedown.listbuilder touchstart.listbuilder', function() {
            var li = $(this);
            if (!li.is('.is-selected')) {
              li.trigger('click');
            }
          });

        $('.listview', self.element)
          .off('selected.listbuilder')
          .on('selected.listbuilder', function(e, args) {
            var data = self.getDataByNode(args.elem[0]);
            self.element.triggerHandler('selected', [data]);
          });

        self.updatedEventsStr = 'arrangeupdate.listbuilder aftergoup.listbuilder aftergodown.listbuilder exiteditmode.listbuilder';
        self.element
          .off(self.updatedEventsStr)
          .on(self.updatedEventsStr, function(e, data) {
            self.element.triggerHandler('updated', [data]);
          });

        return this;
      }, // END: Handle Events ---------------------------------------------------------------------

      /**
      * Add an item into edit node.
      */
      addItem: function() {
        var self = this,
          s = self.settings;

        $.when(self.element.triggerHandler('beforeadd')).done(function() {
          var li, data,
            index = 0,
            node = self.listApi.selectedItems[0],
            str = s.templateNewItem.replace(/{{text}}/g, Locale.translate('NewItem'));

          if (node && node.length > 0) {
            data = self.getDataByNode(node);
            index = data.index + 1;
            $(str).insertAfter(node);
            li = $('li', self.ul).eq(index);
          }
          else {
            self.ul.prepend(str);
            li = $('li:first-child', self.ul);
          }

          self.dataset.push(self.extractNodeData(li));
          self.arrayIndexMove(self.dataset, self.dataset.length - 1, index);
          self.updateAttributes();
          li.trigger('click');
          self.arrangeApi.updated();
          self.editItem(true);

          data = {index: index, data: self.dataset[index]};
          self.element.triggerHandler('afteradd', [data]);
        });
      },

      /**
      * Move the currently selected item up.
      */
      moveItemUp: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined' && data.index > 0) {
            $.when(self.element.triggerHandler('beforegoup', [data])).done(function() {
              var prev = node.prev();
              node.insertBefore(prev);
              self.updateAttributes();
              self.arrayIndexMove(self.dataset, data.index, data.index - 1);
              data.indexBeforeMove = data.index;
              data.index = data.index - 1;
              self.element.triggerHandler('aftergoup', [data]);
            });
          }
        }
      },

      /**
      * Move the currently selected item down.
      */
      moveItemDown: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined' && data.index < self.dataset.length - 1) {
            $.when(self.element.triggerHandler('beforegodown', [data])).done(function() {
              var next = node.next();
              node.insertAfter(next);
              self.updateAttributes();
              self.arrayIndexMove(self.dataset, data.index, data.index + 1);
              data.indexBeforeMove = data.index;
              data.index = data.index + 1;
              self.element.triggerHandler('aftergodown', [data]);
            });
          }
        }
      },

      /**
      * Edit the selected item
      * @param {Boolean} isNewItem  &nbsp;-&nbsp; Is it a new item?
      */
      editItem: function(isNewItem) {
        var node = this.listApi.selectedItems[0];
        if (node && node.length > 0) {
          if (node.is('.is-editing')) {
            this.commitEdit(node, isNewItem);
          } else {
            this.makeEditable(node, isNewItem);
          }
        }
      },

      /**
      * Make the node editable
      * @param {jQuery} node  &nbsp;-&nbsp; The node to edit
      * @param {Boolean} isNewItem  &nbsp;-&nbsp; Is it a new item?
      */
      makeEditable: function(node, isNewItem) {
        var self = this,
          data = self.getDataByNode(node),
          container = $('.item-content', node);

        if (typeof data.index !== 'undefined' && data.index < self.dataset.length) {
          $.when(self.element.triggerHandler('beforeedit', [data])).done(function() {
            var origValue = container.text().trim(),
              editInput = $('<input name="edit-input" class="edit-input" type="text" value="'+ origValue +'" />');

            node.addClass('is-editing');
            container.html(editInput);
            editInput.focus().select();

            editInput
            .on('click.listbuilder', function() {
              return false;
            })
            .on('blur.listbuilder', function() {
              self.commitEdit(node, isNewItem);
            })
            .on('keypress.listbuilder', function (e) {
              var key = e.keyCode || e.charCode || 0;
              if (key === 13) {
                self.commitEdit(node, isNewItem);
                node.focus();
              }
            });

            self.element.triggerHandler('entereditmode', [data]);
          });
        }
      },

      /**
      * Delete the selected item.
      * @param {jQuery} node  &nbsp;-&nbsp; The node to delete
      * @param {Boolean} isNewItem  &nbsp;-&nbsp; Is it a new item?
      */
      commitEdit: function(node, isNewItem) {
        var self = this,
          s = this.settings,
          data = self.getDataByNode(node),
          container = $('.item-content', node),
          editInput = $('.edit-input', container);

        if (isNewItem) {
          data.data.value = editInput.val();
        }
        data.data.text = editInput.val();
        editInput.off('click.listbuilder blur.listbuilder keypress.listbuilder');
        container.html(s.templateItemContent.replace(/{{text}}/g, editInput.val()));
        node.removeClass('is-editing');
        self.element.triggerHandler('exiteditmode', [data]);
      },

      /**
      * Delete the selected item.
      */
      deleteItem: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined') {
            $.when(self.element.triggerHandler('beforedelete', [data])).done(function() {
              self.listApi.removeAllSelected();
              self.updateAttributes();
              self.dataset.splice(data.index, 1);
              self.element.triggerHandler('afterdelete', [data]);
            });
          }
        }
      },

      /**
      * Get data from dataset by node
      * @returns {Object}
      */
      getDataByNode: function(node) {
        var data = {};
        for (var i = 0,l = this.dataset.length; i < l; i++) {
          var d = this.dataset[i];
          if ($(d.node).is(node)) {
            data = {index: i, data: d};
            break;
          }
        }
        return data;
      },

      // Move an array element position
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      // Check if given object is a jQuery object
      isjQuery: function (obj) {
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      // Move cursor to end
      // http://stackoverflow.com/a/26900921
      moveCursorToEnd: function (el) {
        setTimeout(function() {
          if (typeof el.selectionStart === 'number') {
            el.selectionStart = el.selectionEnd = el.value.length;
          } else if (typeof el.createTextRange !== 'undefined') {
            var range = el.createTextRange();
            range.collapse(false);
            range.select();
          }
        }, 100);
      },

      // Update attributes
      updateAttributes: function() {
        var nodes = $('li', this.ul),
          size = nodes.length;

        nodes.each(function(i) {
          $(this).attr({'aria-posinset': i + 1, 'aria-setsize': size});
        });
      },

      // Update dataset
      updateDataset: function(ds) {
        var self = this,
          nodes = $('li', this.ul),
          lv = $('.listview', this.element).data('listview');

        lv.deselectItemsBetweenIndexes([0, nodes.length-1]);
        this.settings.dataset = ds;
        lv.loadData(this.settings.dataset);

        this
          .initDataset()
          .setElements()
          .handleEvents();

        setTimeout(function() {
          self.setSelected();
        }, 0);
      },

      // Set pre selected items
      setSelected: function() {
        $('li[selected]', this.ul).each(function() {
          var li = $(this);
          li.removeAttr('selected');
          if (!li.is('.is-selected')) {
            li.trigger('click');
          }
        });
        return this;
      },

      // Make selected
      select: function(selector) {
        var li = this.getListItem(selector);

        if (li) {
          if (!li.is('.is-selected')) {
            li.trigger('click');
          }
        }
      },

      // Make unselected
      unselect: function(selector) {
        var li = this.getListItem(selector);

        if (li) {
          if (li.is('.is-selected')) {
            li.trigger('click');
          }
        }
      },

      // Get an item from list, selector: can be
      // jQuery, DOM element, zero based index or 'first'|'last' as string
      getListItem: function(selector) {
        var li = $();
        if (this.isElement(selector) && $.contains(this.ul, selector)) {
          li = this.isjQuery(selector) ? selector : $(selector);
        } else {
          var idx = parseInt(selector),
            items = $('li', this.ul);
          if (!isNaN(idx) && (idx > -1 && idx < items.length)) {
            li = items.eq(idx); // zero based index
          } else if ((selector + '').toLowerCase() === 'first') {
            li = items.first(); // first
          } else if ((selector + '').toLowerCase() === 'last') {
            li = items.last(); // last
          }
        }
        // Make sure to return only one item -or- null
        return (li.length < 1) ? null : ((li.length > 1) ? li.eq(0) : li);
      },

      // Check if given object is a DOM object
      isElement: function(obj) {
        return (this.isjQuery(obj) && obj.get(0) instanceof Element) || obj instanceof Element;
      },

      // Make enable
      enable: function () {
        this.element.removeClass('is-disabled')
          .find('.toolbar .buttonset button').removeAttr('disabled').end()
          .find('.toolbar .buttonset button[data-original-disabled]')
            .attr('disabled', 'disabled').removeAttr('data-original-disabled');

        this.ul
          .find('li').removeClass('is-disabled').end()
          .find('li[data-original-disabled]').addClass('is-disabled').removeAttr('data-original-disabled');
      },

      // Make disable
      disable: function () {
        this.element.addClass('is-disabled')
          .find('.toolbar .buttonset button[disabled]').attr('data-original-disabled', 'disabled').end()
          .find('.toolbar .buttonset button').attr('disabled', 'disabled');

        this.ul
          .find('li.is-disabled').attr('data-original-disabled', 'is-disabled').end()
          .find('li').addClass('is-disabled');
      },

      // Unbind all events
      unbind: function() {
        this.element.off(this.updatedEventsStr);
        $('.listview', this.element).off('selected.listbuilder');

        $('li '+ this.arrangeApi.handle, this.ul)
          .off('mousedown.listbuilder touchstart.listbuilder');

        this.arrangeApi.element
          .off('beforearrange.listbuilder arrangeupdate.listbuilder').destroy();

        this.topButtons.off('click.listbuilder').each(function() {
          $(this).data('tooltip').destroy();
        });

        this.listApi.destroy();
        return this;
      },

      // Update this plugin
      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ListBuilder(this, settings));
      }
    });
  };


  $.fn.circlepager = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'circlepager',
        defaults = {
          slidesToShow: 1,
          startingSlide: null,
          loop: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Circle Pager Displays content in a sliding carousel and has paging buttons.
    *
    * @class CirclePager
    * @param {String} slidesToShow  &nbsp;-&nbsp; The number of slides to show in one view / pane
    * @param {String} startingSlide  &nbsp;-&nbsp; First showing slide/group, an 0-based integer
    * @param {String} loop  &nbsp;-&nbsp;  Setting loop: true will loop back after next/previous reached to end
    *
    */
    function CirclePager(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // CirclePager Methods
    CirclePager.prototype = {

      init: function() {
        this.setElements();

        if (this.slides.length) {
          this.createControls();
          this.handleEvents();
          this.showCollapsedView();
          this.initActiveSlide();
        }
      },

      // Set elements
      setElements: function() {
        var self = this,
          s = this.settings;

        this.container = $('.slides', this.element);
        this.slidesJQ = $('.slide', this.element);
        this.slidesToShow = s.slidesToShow;
        this.slides = [];
        this.slidesJQ.each(function() {
          self.slides.push({ node: $(this) });
        });

        this.activeIndex = s.startingSlide !== null &&
          s.startingSlide > -1 && s.startingSlide < this.slides.length ?
            s.startingSlide : 0;
      },

      // Create controls
      createControls: function() {
        var len = this.slides.length,
          html = '<div class="controls">',
          htmlContent = '',
          numOfButtons = 0,
          i, l, slide, temp, href, text, buttonText,
          last, lastIndex, isSingle, isDisabled,
          previousButton, nextButton;

        for (i = 0, l = len; i < l; i += this.slidesToShow) {
          temp = '';
          numOfButtons++;
          isSingle = (this.slidesToShow === 1) || (len - i === 1);
          text = Locale.translate(isSingle ? 'SlideOf' : 'SlidesOf') + '';
          // Keep href in english language only
          href = isSingle ? '#slide {0} of {1}' : '#slides {0} and {1} of {2}';

          // Collect as much bullets need to present
          for (var g = 0; g < this.slidesToShow && (i + g) < len; g++) {
            temp += (i + g + 1) + ', ';
          }
          text = text.replace(isSingle ? '{1}' : '{2}', len);
          href = href.replace(isSingle ? '{1}' : '{2}', len);
          temp = temp.slice(0, -2);
          lastIndex = temp.lastIndexOf(',');
          last = temp.substr(lastIndex + 2);

          // Controls for single slide in view
          if (isSingle) {
            isDisabled = '';
            slide = this.slides[i].node;

            // Set disabled
            if (slide.is('.is-disabled, [disabled]') && !slide.is('[disabled="false"]')) {
              isDisabled = ' disabled tabindex="-1"';
              this.slides[i].isDisabled = true;
            }

            // Set default starting slide
            if (slide.is('.active') && this.settings.startingSlide === null && isDisabled === '') {
              this.activeIndex = i;
            }

            // Use custom text if supplied
            buttonText = slide.attr('data-button-text');
            text = (buttonText && buttonText.length) ?
              buttonText : text.replace('{0}', temp);

            // href = (buttonText && buttonText.length) ?
            //   '#'+ $.trim(text) : href.replace('{0}', temp);
            href = href.replace('{0}', temp);

          }

          // Controls for multiple slides in view
          else {
            temp = temp.substr(0, lastIndex);
            text = text.replace('{1}', last).replace('{0}', temp);
            href = href.replace('{1}', last).replace('{0}', temp);
          }

          href = href.toLowerCase().replace(/[\s,--]+/g, '-');

          htmlContent += '<a href="'+ href +'" class="control-button hyperlink hide-focus"'+ isDisabled +'><span class="audible">'+ text +'</span></a>';
        }

        html += htmlContent + '</div>';

        // Previous/Next buttons
        this.isBulletsNav = this.element.width() > numOfButtons * 29;
        previousButton = $('.btn-previous', this.element);
        nextButton = $('.btn-next', this.element);
        if (!this.isBulletsNav) {
          if (!previousButton.length) {
            html += '<button class="btn-previous" type="button">' + $.createIcon('left-arrow') + '<span class="audible">'+
                Locale.translate('Previous') +'</span></button>';
          }
          if (!nextButton.length) {
            html += '<button class="btn-next" type="button">' + $.createIcon('right-arrow') + '<span class="audible">'+
                Locale.translate('Next') +'</span></button>';
          }
        } else {
          previousButton.add(nextButton).remove();
        }

        if (this.activeIndex > 0 && this.activeIndex > (numOfButtons - 1)) {
          this.activeIndex = numOfButtons - 1;
        }

        if (numOfButtons > 1) {
          this.element.append(html);
        }
      },

      // Check if given element is visible in container
      isVisibleInContainer: function(element) {
        if (element && element[0]) {
          var eRect = element[0].getBoundingClientRect();
          var cRect = this.element[0].getBoundingClientRect();
          return (eRect.left > cRect.left && eRect.left < (cRect.left + cRect.width) &&
            eRect.top > cRect.top && eRect.top < (cRect.top + cRect.height));
        }
        return -1;
      },

      // Update number of slides to show in view
      updateSlidesToShow: function(numOfSlides) {
        if (!this.isActive) {
          return;
        }
        this.settings.slidesToShow = numOfSlides || 1;
        this.updated();
        return this;
      },

      // Make sure max number of slides to show in view
      responsiveSlidesToShow: function(numOfSlides) {
        if (!this.isActive) {
          return;
        }
        var self = this;
        this.slidesToShow = numOfSlides || this.settings.slidesToShow;
        this.unbind().slidesJQ.css('width', '');
        if (this.slides.length) {
          setTimeout(function() {
            self.createControls();
            self.handleEvents();
            self.showCollapsedView();
            self.initActiveSlide();
          }, 0);
        }
      },

      /**
      * Show a slide to First Slide
      * @param {String} index  &nbsp;-&nbsp; The index of the slide to show (0 based)
      */
      show: function(index) {
        if (!this.isActive) {
          return;
        }
        index = typeof index !== 'undefined' ? index : this.activeIndex;
        this.activeIndex = index;

        // var isBulletsNav = this.element.width() > this.controlButtons.length * 30;
        var left = index > 0 ? ((Locale.isRTL() ? '' : '-') + (index * 100) +'%') : 0;
        this.controlButtons.removeClass('is-active').eq(index).addClass('is-active');
        this.container[0].style.left = left;

        // Make sure bullets navigation do not overflow
        if (!this.isBulletsNav) {
          this.element.addClass('is-bullets-nav-hidden');
          this.controlButtons.find('span').addClass('audible').end()
            .eq(index).find('span').removeClass('audible');
        } else {
          this.element.removeClass('is-bullets-nav-hidden');
          this.controlButtons.find('span').addClass('audible');
        }

        // Set focus
        if (this.isFocus && this.isBulletsNav) {
          this.isFocus = false;
          this.controlButtons.eq(index).focus();
        }
      },

      /**
      * Move to First Slide
      */
      first: function() {
        this.show(0);
      },

      /**
      * Move to Last Slide
      */
      last: function() {
        this.show(Math.round(this.slides.length/this.slidesToShow)-1);
      },

      /**
      * Move to Previous Slide
      */
      prev: function() {
        var self = this,
          prev = this.activeIndex > 0 ?
            this.activeIndex - 1 : (this.settings.loop ? Math.round(this.slides.length/this.slidesToShow)-1 : 0);

        if (this.slides[prev].isDisabled) {
          setTimeout(function() {
            self.prev();
          }, 0);
          this.activeIndex = prev;
          return false;
        }
        this.show(prev);
      },

      /**
      * Move to Next Slide
      */
      next: function() {
        var self = this,
          next = this.activeIndex >= Math.round(this.slides.length/this.slidesToShow)-1 ?
            (this.settings.loop ? 0 : this.activeIndex) : this.activeIndex + 1;

        if (this.slides[next].isDisabled) {
          setTimeout(function() {
            self.next();
          }, 0);
          this.activeIndex = next;
          return false;
        }
        this.show(next);
      },

      // Make active
      showCollapsedView: function() {
        this.isActive = true;
        this.element.addClass('is-active');
        this.container[0].style.width = (100 * this.slides.length) +'%';
        if (this.settings.slidesToShow > 1 &&
           (this.slidesJQ.eq(0).width() * this.slidesToShow > this.element.width())) {
          this.responsiveSlidesToShow(this.slidesToShow - 1);
          return;
        }
        for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
          this.slidesJQ[i].style.width = ((100/this.slidesToShow) / this.slides.length) +'%';
        }
        this.show();
      },

      // Make un-active
      showExpandedView: function() {
        this.isActive = false;
        this.element.removeClass('is-active');
        this.element[0].style.width = '';
        this.container[0].style.width = '';
        this.container[0].style.left = '';
      },

      // Initialize active slide
      initActiveSlide: function() {
        if (this.slides[this.activeIndex].isDisabled) {
          this.next();
          return false;
        }
        this.show();
      },

      unbind: function() {
        $('body').off('resize.circlepager');
        this.element.off('focus.circlepager keydown.circlepager', '*');
        this.controlButtons.off('click.circlepager keydown.circlepager');
        $('.btn-previous, .btn-next', this.element).off('click.circlepager');
        $('.controls', this.element).remove();
        this.showExpandedView();
        return this;
      },

      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      },

      // Handle events
      handleEvents: function() {
        var self = this;

        // Previous button
        $('.btn-previous', this.element)
          .onTouchClick('circlepager')
          .on('click.circlepager', function (e) {
            self.prev();
            e.stopImmediatePropagation();
          });

        // Next button
        $('.btn-next', this.element)
          .onTouchClick('circlepager')
          .on('click.circlepager', function (e) {
            self.next();
            e.stopImmediatePropagation();
          });

        this.controlButtons = $('.control-button', this.element);
        this.controlButtons.each(function(index) {
          var btn = $(this);
          btn.hideFocus();

          // Handle clicks for bottom bullet links
          btn.on('click.circlepager', function(e) {
            e.preventDefault();
            if (self.slides[index].isDisabled) {
              return;
            }
            self.show(index);
          });

        });

        // Handle keyboard events

        // Prevent hidden slide's content to be get focused
        // on focusable elements in slides content
        this.element.on('focus.circlepager', '*', function(e) {
          var handled = false;
          if (!self.isVisibleInContainer($(this))) {
            var canfocus = self.element.find(':focusable');
            for (var i = 0, l = canfocus.length; i < l; i++) {
              if (self.isVisibleInContainer(canfocus.eq(i))) {
                canfocus.eq(i).focus();
                handled = true;
                break;
              }
            }
          }
          e.stopPropagation();
          if (handled) {
            return false;
          }
        });
        // Keydown on focusable elements in slides content to
        // prevent hidden slide's content to be get focused
        this.element.on('keydown.circlepager', '*', function(e) {
          var key = e.which || e.keyCode || e.charCode || 0,
            handled = false,
            canfocus = $(':focusable'),
            index = canfocus.index(this);

          if (key === 9) {//tab
            // Using shift key with tab (going backwards)
            if (e.shiftKey) {
              for (var i = index-1; i >= 0; i--) {
                if ((self.element.has(canfocus.eq(i)).length < 1) ||
                    (self.isVisibleInContainer(canfocus.eq(i)))) {
                  canfocus.eq(i).focus();
                  handled = true;
                  break;
                }
              }
            }
            // Using only tab key (going forward)
            else {
              if (!self.isVisibleInContainer(canfocus.eq(index + 1))) {
                self.controlButtons.first().focus();
                handled = true;
              }
            }
          }
          e.stopPropagation();
          if (handled) {
            return false;
          }
        });

        // Control buttons
        this.controlButtons.on('keydown.circlepager', function(e) {
          var key = e.which || e.keyCode || e.charCode || 0,
            handled = false,
            isRTL = Locale.isRTL();

          // Left and Right arrow keys
          if ([37, 39].indexOf(key) !== -1) {
            self.isFocus = true; // Move focus
            if (e.altKey) {
              // [Alt + Left/Right arrow] to move to the first or last
              if ((key === 37 && !isRTL) || (key === 39 && isRTL)) {
                self.first();
              } else {
                self.last();
              }
            }
            // Left and Right arrow keys to navigate
            else {
              if ((!isRTL && key === 37) || (isRTL && key === 39)) {
                self.prev();
              } else {
                self.next();
              }
              handled = true;
            }
          }

          if (handled) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        });

        // Set max number of slides can view on resize
        $('body').on('resize.circlepager', function() {
          self.responsiveSlidesToShow();
        });

      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new CirclePager(this, settings));
      }
    });
  };


  $.fn.pager = function(options) {

    // Settings and Options
    var pluginName = 'pager',
        defaults = {
          componentAPI: undefined,
          type: 'list',
          position: 'bottom',
          activePage: 1,
          hideOnOnePage: false,
          source: null,
          pagesize: 15,
          pagesizes: [15, 25, 50, 75],
          showPageSizeSelector: true,
          indeterminate: false
        },
        settings = $.extend({}, defaults, options);

    var PAGER_NON_NUMBER_BUTTON_SELECTOR = 'li:not(.pager-prev):not(.pager-next):not(.pager-first):not(.pager-last)';

    /**
    * The Pager Component supports paging on lists.
    *
    * @class Pager
    * @param {String} componentAPI  &nbsp;-&nbsp; If defined, becomes the definitive way to call methods on parent component.
    * @param {String} type  &nbsp;-&nbsp; Different types of pagers: list, table and more
    * @param {String} position  &nbsp;-&nbsp; Can be on 'bottom' or 'top'.
    * @param {Number} activePage  &nbsp;-&nbsp; Start on this page
    * @param {Boolean} hideOnOnePage  &nbsp;-&nbsp; If true, hides the pager if there is only one page worth of results.
    * @param {Function} source  &nbsp;-&nbsp; Call Back Function for Pager Data Source
    * @param {Number} pagesize  &nbsp;-&nbsp; Can be calculated or a specific number
    * @param {Array} pagesizes  &nbsp;-&nbsp; Array of numbers of the page size selector
    * @param {Boolean} showPageSizeSelector  &nbsp;-&nbsp; If false will not show page size selector
    * @param {Boolean} indeterminate  &nbsp;-&nbsp; If true will not show anything that lets you go to a specific page
    *
    */
    function Pager(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Pager.prototype = {

      pagerInfo: {},

      init: function() {
        this.setup();
        this.createPagerBar();
        this.setActivePage(this.settings.activePage, true); //Get First Page
        this.renderBar();
        this.renderPages('initial');
        this.handleEvents();
      },

      setup: function() {

        // Add [pagesize] if not found in [pagesizes]
        if($.inArray(this.settings.pagesize, this.settings.pagesizes) === -1) {
          var sortNumber = function (a, b) {
            return a - b;
          };
          this.settings.pagesizes.push(this.settings.pagesize);
          this.settings.pagesizes = this.settings.pagesizes.sort(sortNumber);
        }

        var widgetContainer = this.element.parents('.card, .widget');

        // Adjust for the possibility of the pager being attached to a Table instead of normal grid markup
        if (this.element.is('tbody')) {
          this.isTable = true;
          this.settings.type = 'table';
          this.mainContainer = this.element.closest('.datagrid-container');

          if (!this.settings.componentAPI) {
            this.settings.componentAPI = this.mainContainer.data('datagrid');
          }

          if (widgetContainer.length) {
            widgetContainer[0].classList.add('has-datagrid');
          }
        }

        // If contained by a widget/card container, build some settings for that
        var listviewContainer = this.element.is('.listview');
        if (listviewContainer.length) {
          this.isTable = false;
          this.settings.type = 'list';
          this.mainContainer = listviewContainer;

          if (!this.settings.componentAPI) {
            this.settings.componentAPI = this.element.data('listview');
          }
        }

        this.isRTL = Locale.isRTL();

        return this;
      },

      createPagerBar: function () {
        this.pagerBar = this.element.prev('.pager-toolbar');

        if (this.pagerBar.length === 0) {
          this.pagerBar = $('<ul class="pager-toolbar"></ul>');
          var buttons = '<li class="pager-prev">' +
              '<a href="#" rel="prev" title="PreviousPage">' + $.createIcon({ icon: 'previous-page' }) +
                '<span class="audible">' + Locale.translate('PreviousPage') + '</span>' +
              '</a>' +
            '</li>' +
            '<li class="pager-next">' +
              '<a href="#" rel="next" title="NextPage">' + $.createIcon({ icon: 'next-page' }) +
                '<span class="audible">' + Locale.translate('NextPage') + '</span>' +
              '</a>' +
            '</li>';

          if (this.settings.type === 'table') {
            buttons = '<li class="pager-first">' +
              '<a href="#" title="FirstPage">' + $.createIcon({ icon: 'first-page' }) +
                '<span class="audible">' + Locale.translate('FirstPage') + '</span>' +
              '</a>' +
            '</li>' +
            buttons +
            '<li class="pager-last">' +
              '<a href="#" title="LastPage">' + $.createIcon({ icon: 'last-page' }) +
                '<span class="audible">' + Locale.translate('LastPage') + '</span>' +
              '</a>' +
            '</li>';
          }

          this.pagerBar.html(buttons);

          this.pagerBar.children('li').children('a').button();
        }

        if (this.isTable) {
          this.mainContainer.after(this.pagerBar);
        } else {
          if (this.settings.position ==='bottom') {
            this.element.after(this.pagerBar);
          } else {
            this.element.before(this.pagerBar);
          }
        }

        // Inside of Listviews, place the pager bar inside of the card/widget footer
        var widgetContainer = this.element.closest('.card, .widget');
        if (widgetContainer.length) {
          var self = this,
            widgetTypes = ['widget', 'card'];

          widgetTypes.forEach(function(type) {
            var widgetContent = self.element.closest('.' + type + '-content');
            if (!widgetContent.length) {
              return;
            }

            var widgetFooter = widgetContent.next('.' + type + '-footer');
            if (!widgetFooter.length) {
              widgetFooter = $('<div class="'+ type +'-footer"></div>').insertAfter(widgetContent);
            }

            self.pagerBar.appendTo(widgetFooter);
          });
        }

        this.pagerBar.find('a').tooltip();
      },

      // Attach All relevant events
      handleEvents: function () {
        var self = this;

        // Set element to be focused after paging
        self.element.on('afterpaging.pager', function () {
          var isVisible = $('li[tabindex]:visible, td[tabindex]:visible', self.element);
          if (!isVisible.length) {
            $('li:visible:first, td:visible:first', self.element).attr('tabindex', '0');
          }

          // Fix: Firefox by default to not allow keyboard focus on links
          $('li a', self.pagerBar).each(function() {
            var a = $(this),
              li = a.closest('li');

            if (!a.is('[disabled]')) {
              li.attr('tabindex', '0').on('focus.pager', function() {
                $('a', this).focus();
              });
            }
          });
        });

        //Attach button click and touch
        this.pagerBar.on('click.pager', 'a', function (e) {
          var li = $(this).parent();
          e.preventDefault();

          if ($(this).attr('disabled')) {
            return;
          }

          if (li.is('.pager-prev')) {
            self.setActivePage(self.activePage - 1, false, 'prev');
            return false;
          }

          if (li.is('.pager-next')) {
            self.setActivePage((self.activePage === -1 ? 0 : self.activePage)  + 1, false, 'next');
            return false;
          }

          if (li.is('.pager-first')) {
            self.setActivePage(1, false, 'first');
            return false;
          }

          if (li.is('.pager-last')) {
            self.setActivePage(self.pageCount(), false, 'last');  //TODO Calculate Last Page?
            return false;
          }

          //Go to the page via the index of the button
          self.setActivePage($(this).parent().index() + (self.settings.type === 'table' ? -1 : 0), false, 'page');

          return false;
        })
        .on('focus.pager', 'a', function() {
          var li = $(this).parent('li');
          li.addClass('is-focused');
        })
        .on('blur.pager', 'a', function() {
          var li = $(this).parent('li');
          li.removeClass('is-focused');
        });

        //Toolbar functionality
        this.pagerBar.on('keydown.pager', 'a', function (e) {
          e = e || window.event;
          var key = e.which || e.keyCode || e.charCode || false,
            parent = $(this).parent(),
            btn = ((key === 37 || key === 9 && e.shiftKey) ? parent.prev() : (key === 39 ? parent.next() : $()));

          if (key === 9 && e.shiftKey && parent.prev().is('.pager-prev, .pager-first, .pager-count') ||
              key === 9 && e.shiftKey && parent.is('.pager-prev, .pager-first')) {
            parent.removeAttr('tabindex');
            setTimeout(function () {
              parent.attr('tabindex', '0');
            }, 0);
          // Handle pressing Enter on arrow icons and prevent pagerBar.onTouchClick from being triggered
          } else if (key === 13) {
            var li = $(this).parent();
            e.preventDefault();

            if ($(this).attr('disabled')) {
              return;
            }

            if (li.is('.pager-prev')) {
              self.setActivePage(self.activePage - 1, false, 'prev');
              return false;
            }

            if (li.is('.pager-next')) {
              self.setActivePage((self.activePage === -1 ? 0 : self.activePage)  + 1, false, 'next');
              return false;
            }

            if (li.is('.pager-first')) {
              self.setActivePage(1, false, 'first');
              return false;
            }

            if (li.is('.pager-last')) {
              self.setActivePage(self.pageCount(), false, 'last');  //TODO Calculate Last Page?
              return false;
            }
          }

          btn = $('a', btn).length ? btn : $(':text', btn);
          if (btn.length && !btn.is('[disabled]')) {
            btn.focus();
          }
        });
      },

      //Show page size selector
      showPageSizeSelector: function(toggleOption) {
        toggleOption = (toggleOption + '').toLowerCase() === 'true';
        this.settings.showPageSizeSelector = toggleOption;
        if (toggleOption) {
          this.isShowPageSizeSelectorCall = toggleOption;
          this.pageCount();
        } else {
          this.pagerBar.find('.pager-pagesize').remove();
        }
      },

      //Set or Get Current Page
      setActivePage: function(pagingInfo, force, op) {
        var lis = this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR),
          pageNum;

        // Backwards compatibility with having "pageNum" as the first argument
        // instead of "pagingInfo"
        if (!isNaN(pagingInfo)) {
          pageNum = pagingInfo;
          pagingInfo = {
            activePage: pageNum
          };
        }

        // Check to make sure our internal active page is set
        if (!this.activePage || isNaN(this.activePage)) {
          this.activePage = this.settings.activePage;
        }

        // If any of the following conditions are met, don't rerender the pages.
        // Only rerender the pager bar.
        if (pageNum === undefined ||
            pageNum === 0 ||
            isNaN(pageNum) ||
            pageNum > this.pageCount() ||
            (pageNum === this.activePage && !force)) {

          this.renderBar(pagingInfo);
          return this.activePage;
        }

        this.activePage = pageNum;

        //Remove selected
        if (!this.settings.source) {
          lis.filter('.selected').removeClass('selected').removeAttr('aria-selected')
            .find('a').removeAttr('aria-disabled')
              .find('.audible').html(Locale.translate('Page'));

          //Set selected Page
          lis.eq(pageNum-1).addClass('selected').attr('aria-selected', true)
            .find('a').attr('aria-disabled', true)
              .find('.audible').html(Locale.translate('PageOn'));
        }

        this.renderBar(pagingInfo);
        this.renderPages(op);
        if (this.settings.componentAPI && this.settings.componentAPI.saveUserSettings) {
          this.settings.componentAPI.saveUserSettings();
        }
        return pageNum;
      },

      _pageCount: 0,

      //Get/Set Total Number of pages
      pageCount: function(pages) {
        var self = this,
          isShowPageSizeSelectorCall = this.isShowPageSizeSelectorCall;

        // Remove call, after cached
        delete this.isShowPageSizeSelectorCall;

        if (pages === undefined && this.settings.indeterminate) {
          this._pageCount = this.settings.pagesize;
        }

        if (pages === undefined && !this.settings.source && !isShowPageSizeSelectorCall) {
          return this._pageCount;
        }

        if (pages !== undefined) {
          this._pageCount = pages;
        }

        //Add in fake pages
        if (!this.isTable) {
          var i, thisClass, thisText, isAriaSelected, isAriaDisabled;
          this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR).remove();

          for (i = pages; i > 0; i--) {
            if (i === (this.activePage || 1)) {
              thisClass = 'class="selected"';
              thisText = Locale.translate('PageOn');
              isAriaSelected = 'aria-selected="true"';
              isAriaDisabled = 'aria-disabled="true"';
            } else {
              thisClass = '';
              thisText = Locale.translate('Page');
              isAriaSelected = '';
              isAriaDisabled = '';
            }

            $('<li '+ thisClass + isAriaSelected +'><a href="#" '+ isAriaDisabled +'><span class="audible">'+ thisText +' </span>'+ i +'</a></li>').insertAfter(this.pagerBar.find('.pager-prev'));
          }
        }

        if (this.isTable && !this.settings.indeterminate && this.pagerBar.find('.pager-count').length === 0) {
          var text = Locale.translate('PageOf');
          text = text.replace('{0}', '<input name="pager-pageno" value="' + this.activePage + '">');
          text = text.replace('{1}', '<span class="pager-total-pages">' + (pages || 1) + '</span>');
          $('<li class="pager-count"><label>'+ text +' </label>').insertAfter(this.pagerBar.find('.pager-prev'));

          //Setup interactivty with the numeric page input
          var lastValue = null;

          this.pagerBar.find('.pager-count input')
          .on('focus', function () {
            lastValue = $(this).val();
          }).on('blur', function () {
            if (lastValue !== $(this).val()) {
              $(this).val(self.setActivePage(parseInt($(this).val()), false, 'page'));
            }
          }).on('keydown', function (e) {
            if (e.which === 13) {
              self.setActivePage(parseInt($(this).val()), false, 'page');

              e.stopPropagation();
              e.preventDefault();
            }
          });
        }

        //Add functionality to change page size.
        if (this.isTable && this.pagerBar.find('.btn-menu').length === 0 && self.settings.showPageSizeSelector) {
          var pageSize = $('<li class="pager-pagesize"></li>'),
            pageSizeButton = $('<button type="button" class="btn-menu">' +
              '<span>' + Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize) + '</span> ' +
              $.createIcon({ icon: 'dropdown' }) +
              ' </button>').appendTo(pageSize);

          pageSize.insertAfter(this.pagerBar.find('.pager-last'));

          var menu = $('<ul class="popupmenu has-icons"></ul>');

          for (var k = 0; k < self.settings.pagesizes.length; k++) {
            var size = self.settings.pagesizes[k];
            menu.append('<li '+ (size === self.settings.pagesize ? ' class="is-checked"' : '') +'><a href="#">' + size + '</a></li>');
          }

          pageSizeButton.after(menu);

          var popupOpts = {
            placementOpts: {
              parent: pageSizeButton,
              parentXAlignment: (this.isRTL ? 'left' : 'right'),
              strategies: ['flip']
            }
          };

          pageSizeButton.popupmenu(popupOpts).on('selected.pager', function (e, args) {
            var tag = args;
            tag.closest('.popupmenu').find('.is-checked').removeClass('is-checked');
            tag.parent('li').addClass('is-checked');
            self.settings.pagesize = parseInt(tag.text());

            if (self.settings.componentAPI) {
              self.settings.componentAPI.settings.pagesize = self.settings.pagesize;
            }
            self.setActivePage(1, true, 'first');
          });
        }

        var pattern = (''+ this._pageCount).replace(/\d/g, '#');
        this.pagerBar.find('.pager-count input').attr('data-mask', '').mask({pattern: pattern, mode: 'number', processOnInitialize: false});

        this._pageCount = this._pageCount || 1;

        return this._pageCount;
      },

      // Reliably gets all the pre-rendered elements in the container and returns them for use.
      getPageableElements: function() {
        var elements = this.element.children().not('.datagrid-expandable-row');

        // Adjust for cases where the root is a <ul>
        if (elements.is('ul')) {
          elements = elements.children();
        }

        return elements;
      },

      /**
       * Renders the pager bar based on derived or forced settings.
       * @private
       * @param {SohoPagingInfo} pagingInfo - an object containing information on how to render the pager.
       * @returns {undefined}
       */
      renderBar: function(pagingInfo) {
        //How many can fit?
        var pb = this.pagerBar,
          elems, pc,
          width = (this.element.parent().width() / pb.find('li:first').width()),
          VISIBLE_BUTTONS = 3, // Take out the ones that should be visible (buttons and selected)
          howMany = Math.floor(width - VISIBLE_BUTTONS);

        if (!pagingInfo) {
          pagingInfo = {};
        }

        //Check Data Attr
        if (this.element.attr('data-pagesize')) {
          this.settings.pagesize = this.element.attr('data-pagesize');
        }

        //Adjust Page count numbers
        if (!this.settings.source) {
          var pageableLength = this.getPageableElements().not('.is-filtered').length;
          pc = Math.ceil(pageableLength/this.settings.pagesize);

          if (this.isTable) {
            var isFiltered = function(value) {
              return !value.isFiltered;
            },
            dataLength = this.settings.dataset.filter(isFiltered).length;

            pc = Math.ceil(dataLength/this.settings.pagesize);
          }
          this.pageCount(pc);
        }

        // Update the input field's number
        this.pagerBar
          .find('.pager-count input').val(this.activePage);

        // Update the total number of pages
        if (this._pageCount !== '0' && !isNaN(this._pageCount)) {
          this.pagerBar.find('.pager-total-pages').text(this._pageCount);
        }

        // Update the number of records per page
        this.pagerBar.find('.btn-menu span')
          .text(Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize));

        // Refresh Disabled
        var prev = pb.find('.pager-prev a'),
          next = pb.find('.pager-next a'),
          first = pb.find('.pager-first a'),
          last = pb.find('.pager-last a'),
          prevGroup = prev.add(first).add('.pager-prev').add('.pager-first'),
          nextGroup = next.add(last).add('.pager-next').add('.pager-last'),
          disabledAttrs = {'disabled': 'disabled', 'tabindex': -1};

        // Reset all pager buttons' disabled/focusable states
        this.pagerBar[0].classList.remove('hidden');
        prevGroup.add(nextGroup).removeAttr('disabled tabindex');

        // Explicit false turns buttons back on.
        if (pagingInfo.firstPage === false) {
          prevGroup.removeAttr('disabled').removeAttr('tabindex');
        }
        if (pagingInfo.lastPage === false) {
          nextGroup.removeAttr('disabled').removeAttr('tabindex');
        }

        // First page
        if (pagingInfo.firstPage === true || (pagingInfo.firstPage === undefined && this.activePage === 1)) {
          prevGroup.attr(disabledAttrs);

          if (pagingInfo.lastPage !== true) {
            nextGroup.attr({'tabIndex': 0});
          }
        }

        // Last page
        if (pagingInfo.lastPage === true || (pagingInfo.lastPage === undefined && this.activePage === this.pageCount())) {
          nextGroup.attr(disabledAttrs);

          if (pagingInfo.firstPage !== true) {
            prevGroup.attr({'tabindex': 0});
          }
        }

        if (this.hidePagerBar(pagingInfo)) {
          this.pagerBar[0].classList.add('hidden');
        }

        // Remove from the front until selected is visible and we have at least howMany showing
        // rowTemplate
        if (!this.settings.source) {
          elems = pb.find(PAGER_NON_NUMBER_BUTTON_SELECTOR);
          elems.show();
          if (elems.length < howMany) {
            return;
          }

          elems.each(function () {
            var li = $(this);
            if (pb.find('.pager-next').offset().top - pb.offset().top > 1 && !li.is('.selected')) {
              $(this).hide();
            }
          });

        }
      },

      // Render Paged Items
      renderPages: function(op, callback) {
        var expr,
          self = this,
          request = {
            activePage: self.activePage,
            pagesize: self.settings.pagesize,
            type: op,
            total: self.settings.componentAPI ? self.settings.componentAPI.settings.dataset.length : -1
          };

        //Make an ajax call and wait
        setTimeout(function () {
          var doPaging = self.element.triggerHandler('beforepaging', request);
          if (doPaging === false) {
            return;
          }

          if (self.settings.source && op) {
            var response;

            response = function(data, pagingInfo) {
              if (pagingInfo && pagingInfo.activePage) {
                if (pagingInfo.activePage > -1) {
                  self.activePage = pagingInfo.activePage;
                }
              }

              //Render Data
              pagingInfo.preserveSelected = true;

              // Call out to the component's API to pull in dataset information.
              // This method should also tell the Pager how to re-render itself.
              self.settings.componentAPI.loadData(data, pagingInfo, true);

              if (callback && typeof callback === 'function') {
                callback(true);
              }

              setTimeout(function () {
                self.element.trigger('afterpaging', pagingInfo);
              },1);
              return;
            };

            if (self.settings.componentAPI.sortColumn && self.settings.componentAPI.sortColumn.sortId) {
              request.sortAsc = self.settings.componentAPI.sortColumn.sortAsc;
              request.sortField = self.settings.componentAPI.sortColumn.sortField;
              request.sortId = self.settings.componentAPI.sortColumn.sortId;
            }

            if (self.settings.componentAPI.filterExpr) {
               request.filterExpr = self.settings.componentAPI.filterExpr;
            }
            self.settings.source(request, response);
          }

          //Make an ajax call and wait
          self.element.trigger('paging', request);
          var elements = self.getPageableElements();

          //Render page objects
          if (!self.settings.source) {
            var rows = self.settings.pagesize;

            self.updatePagingInfo(request);

            if (self.settings.componentAPI && typeof self.settings.componentAPI.renderRows === 'function' && request.type && request.type !=='initial') {
              self.settings.componentAPI.renderRows();
            }

            elements.hide();

            //collapse expanded rows
            self.element.children()
              .filter('.datagrid-expandable-row.is-expanded')
                .removeClass('is-expanded').hide()
                .prev().removeClass('.is-expanded')
                  .find('.plus-minus').removeClass('active');

            expr = (self.activePage === 1 ? ':not(".is-filtered"):lt('+ rows +')' : ':not(".is-filtered"):lt('+ ((self.activePage) * rows) +'):gt('+ (((self.activePage-1) * rows) -1) +')');

            elements.filter(expr).show();
          } else {
            elements.show();
          }

          if (!self.settings.source) {
            self.element.trigger('afterpaging', request);
          }

        }, 0);
      },

      /**
       * Updates this instance of pager with externally-provided settings.
       * @param {Object} pagingInfo - contains settings that will change buttons on the pager.
       * @param {number} pagingInfo.pagesize - the number of items visible per page
       * @param {number} pagingInfo.total - the total number of pages
       * @param {number} pagingInfo.activePage - the currently visible page
       * @param {boolean} [pagingInfo.firstPage=false] - passed if the currently visible page is the first one
       * @param {boolean} [pagingInfo.lastPage=false] - passed if the currently visible page is the last one
       * @param {boolean} [pagingInfo.hideDisabledPagers=false] - causes the pager to become completely hidden if all buttons are disabled
       */
      updatePagingInfo: function(pagingInfo) {
        if (!pagingInfo) {
          return;
        }

        // Grab and retain the pagesize
        if (pagingInfo.pagesize) {
          this.settings.pagesize = pagingInfo.pagesize;
          if (this.isTable && this.settings.componentAPI) {
            this.settings.componentAPI.settings.pagesize = pagingInfo.pagesize;
          }
        }

        // Set a default total if none are defined.
        if (!pagingInfo.total) {
          pagingInfo.total = 0;
        }

        if (this.settings.source) {
          this._pageCount = Math.ceil(pagingInfo.total/this.settings.pagesize);
          //Set first and last page if passed
          // If we get a page number as a result, rendering has already happened and
          // we should not attempt to re-render.
          return this.setActivePage(pagingInfo, false, 'pageinfo');
        }

        this.renderBar(pagingInfo);
      },

      // to reclaim the pager height so that datagrid can use it's full container
      hidePagerBar: function(pagingInfo) {
        if (this.settings.hideOnOnePage && pagingInfo.total <= pagingInfo.pagesize) {
          return true;
        }

        if ((pagingInfo.firstPage === true && pagingInfo.lastPage === true) && pagingInfo.hideDisabledPagers) {
          return true;
        }

        return false;
      },

      /**
       * Tear down and detatch all events
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Pager(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.place = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'place',
        defaults = {
          bleedFromContainer: false, // If true, allows positioned content to bleed outside of a defined container.
          callback: null, // If defined, provides extra placement adjustments after the main calculation is performed.
          container: null, // If defined, contains the placement of the element to the boundaries of a specific container element.
          parent: null, // If defined, will be used as the reference element for placement this element.
          parentXAlignment: 'center',
          parentYAlignment: 'center', // Only used for parent-based placement. Determines the alignment of the placed element against its parent. value 0 === X, value 1 === Y
          placement: 'bottom', // If defined, changes the direction in which placement of the element happens
          strategies: ['nudge'] // Determines the "strategy" for alternatively placing the element if it doesn't fit in the defined boundaries.  Only matters when "parent" is a defined setting.  It's possible to define multiple strategies and execute them in order.
        },
        strategies = ['nudge', 'clockwise', 'flip', 'shrink', 'shrink-x', 'shrink-y'],
        placements = ['top', 'left', 'right', 'bottom', 'center'],
        xAlignments = ['left', 'center', 'right'],
        yAlignments = ['top', 'center', 'bottom'],
        settings = $.extend({}, defaults, options);

    /**
     * Object that contains coordinates along with temporary, changeable properties.
     * This object gets passed around the Place Behavior and modified during each phase of positioning.
     * This object is also passed to all callbacks and event listeners for further modification.
     * @constructor
     * @param {object} placementOptions
     */
    function PlacementObject(placementOptions) {
      var self = this,
        possibleSettings = [
          'x', 'y',
          'container', 'containerOffsetX', 'containerOffsetY',
          'callback',
          'parent', 'parentXAlignment', 'parentYAlignment',
          'useParentWidth', 'useParentHeight',
          'placement',
          'strategies'
        ];

      possibleSettings.forEach(function settingIterator(val) {
        if (placementOptions[val] === null) {
          return;
        }

        if (val === 'x' || val === 'y') {
          self.setCoordinate(val, placementOptions[val]);
          self['original' + val] = placementOptions[val];
          return;
        }

        self[val] = placementOptions[val];
      });

      this.modified = false;

      return this.sanitize();
    }

    PlacementObject.prototype = {
      isReasonableDefault: function(setting, limits) {
        return $.inArray(setting, limits) > -1;
      },

      sanitize: function() {
        var self = this;

        this.bleedFromContainer = this.bleedFromContainer === true;
        this.callback = (typeof this.callback === 'function') ? this.callback : settings.callback;
        this.container = (this.container instanceof $ && this.container.length) ? this.container : settings.container;
        this.containerOffsetX = !isNaN(parseInt(this.containerOffsetX)) ? this.containerOffsetX : 0;
        this.containerOffsetY = !isNaN(parseInt(this.containerOffsetY)) ? this.containerOffsetY : 0;
        this.parent = (this.parent instanceof $ && this.parent.length) ? this.parent : settings.parent;
        this.parentXAlignment = this.isReasonableDefault(this.parentXAlignment, xAlignments) ? this.parentXAlignment : settings.parentXAlignment;
        this.parentYAlignment = this.isReasonableDefault(this.parentYAlignment, yAlignments) ? this.parentYAlignment : settings.parentYAlignment;
        this.placement = this.isReasonableDefault(this.placement, placements) ? this.placement : settings.placement;
        this.useParentHeight = this.useParentHeight === true;
        this.useParentWidth = this.useParentWidth === true;

        if (!$.isArray(this.strategies) || !this.strategies.length) {
          this.strategies = ['nudge'];
        }
        this.strategies.forEach(function(strat, i) {
          self.strategies[i] = self.isReasonableDefault(strat, strategies) ? strat : self.strategies[i];
        });

      },

      setCoordinate: function(coordinate, value) {
        var coordinates = ['x', 'y'];
        if (!this.isReasonableDefault(coordinate, coordinates)) {
          return;
        }

        if (isNaN(value)) {
          value = 0;
        }

        this[coordinate] = parseInt(value, 10);
      }
    };

    // Place Behavior Constructor
    // This is the actual "thing" that is tied to a Placeable Element.
    function Place(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      this.init();
    }

    Place.prototype = {
      init: function() {
        //Do other init (change/normalize settings, load externals, etc)
        return this
          .build()
          .handleEvents();
      },

      // Add markup to the control
      build: function() {
        if (!this.element.hasClass('placeable')) {
          this.element.addClass('placeable');
        }

        // Setup a hash of original styles that will retain width/height whenever
        // the placement for this element is recalculated.
        this.originalStyles = {};
        var h = this.element[0].style.height,
          w = this.element[0].style.width;

        if (h) {
          this.originalStyles.height = h;
        }
        if (w) {
          this.originalStyles.width = w;
        }

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('place.' + pluginName, function placementEventHandler(e, x, y) {
          self.place(new PlacementObject({ x: x, y: y }));
        }).on('updated.' + pluginName, function updatedEventHandler() {
          self.updated();
        });

        return this;
      },

      // Actually renders an element with coordinates inside the DOM
      render: function(placementObj) {
        var unitRegex = /(px|%)/i;

        this.element.offset({
          'left': placementObj.x,
          'top': placementObj.y
        });

        if (placementObj.height) {
          this.element[0].style.height = placementObj.height + (unitRegex.test(placementObj.height + '') ? '' : 'px');
        }
        if (placementObj.width) {
          this.element[0].style.width = placementObj.width + (unitRegex.test(placementObj.width + '') ? '' : 'px');
        }
      },

      // Main placement API Method (external)
      // Can either take a PlacementObject as a single argument, or can take 2 coordinates (x, y) and
      // will use the pre-defined settings.
      place: function(placementObj) {
        var curr = [
          this.element[0].style.left,
          this.element[0].style.top,
        ];

        // Cancel placement with return:false; from a "beforeplace" event
        var canBePlaced = this.element.trigger('beforeplace', [curr]);
        if (!canBePlaced) {
          return curr;
        }

        if (!(placementObj instanceof PlacementObject)) {
          placementObj = new PlacementObject(placementObj);
        }

        // If no values are defined, simply return the current coordinates with a warning.
        if (placementObj.x == null && placementObj.y == null) {
          // TODO: Log a warning about not positioning stuff?
          return curr;
        }

        // Remove any previous placement styles
        this.clearOldStyles();

        // Use different methods if placement against a parent, versus straight-up coordinate placement
        if (placementObj.parent) {
          return this._placeWithParent(placementObj);
        }

        return this._placeWithCoords(placementObj);
      },

      // Placement Routine that expects a parent to be used as a base placement marking.
      // In this case, "x" and "y" integers are "relative" adjustments to the original numbers generated by the parent.
      // Can be modified by using a callback in the settings.
      _placeWithParent: function(placementObj) {
        if (!placementObj.parent || !placementObj.parent.length) {
          return [undefined, undefined]; // can't simply return x and y here because they are not coordinates, they are offsets
        }

        var self = this,
          parentRect = Soho.DOM.getDimensions(placementObj.parent[0]),
          elRect = Soho.DOM.getDimensions(this.element[0]),
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();

        if (placementObj.useParentWidth) {
          placementObj.width = parentRect.width;
        }
        if (placementObj.useParentHeight) {
          placementObj.height = parentRect.height;
        }

        function getCoordsFromPlacement(placementObj) {
          var cX, cY,
            p = placementObj.placement,
            aX = placementObj.parentXAlignment,
            aY = placementObj.parentYAlignment;

          // Set initial placements
          switch(p) {
            case 'top':
              cY = parentRect.top - elRect.height - placementObj.y + (containerIsBody ? scrollY : 0);
              break;
            case 'left':
              cX = parentRect.left - elRect.width - placementObj.x + (containerIsBody ? scrollX : 0);
              break;
            case 'right':
              cX = parentRect.right + placementObj.x + (containerIsBody ? scrollX : 0);
              break;
            default: // Bottom
              cY = parentRect.bottom + placementObj.y + (containerIsBody ? scrollY : 0);
              break;
          }

          // Set X alignments on bottom/top placements
          if (p === 'top' || p === 'bottom') {
            switch(aX) {
              case 'left':
                cX = parentRect.left - placementObj.x + (containerIsBody ? scrollX : 0);
                break;
              case 'right':
                cX = (parentRect.right - elRect.width) + placementObj.x + (containerIsBody ? scrollX : 0);
                break;
              default: // center
                cX = (parentRect.left + ((parentRect.width - elRect.width) / 2)) + placementObj.x + (containerIsBody ? scrollX : 0);
                break;
            }
          }

          // Set Y alignments on left/right placements
          if (p === 'right' || p === 'left') {
            switch(aY) {
              case 'top':
                cY = parentRect.top - placementObj.y + (containerIsBody ? scrollY : 0);
                break;
              case 'bottom':
                cY = (parentRect.bottom - elRect.height) + placementObj.y + (containerIsBody ? scrollY : 0);
                break;
              default: // center
                cY = (parentRect.top + ((parentRect.height - elRect.height) / 2)) + placementObj.y + (containerIsBody ? scrollY : 0);
                break;
            }
          }

          return [cX, cY];
        }

        function doPlacementAgainstParent(placementObj) {
          var coords = getCoordsFromPlacement(placementObj);
          placementObj.setCoordinate('x', coords[0]);
          placementObj.setCoordinate('y', coords[1]);
          self.render(placementObj);
          placementObj = self._handlePlacementCallback(placementObj);
          return placementObj;
        }

        // Simple placement logic
        placementObj = doPlacementAgainstParent(placementObj);

        // Adjusts the placement coordinates based on a defined strategy
        // Will only adjust the current strategy if bleeding outside the viewport/container are detected.
        placementObj.strategies.forEach(function(strat) {
          placementObj = self.checkBleeds(placementObj);

          if (placementObj.bleeds) {
            placementObj = (function(self) {
              switch(strat) {
                case 'nudge':
                  return self.nudge(placementObj);
                case 'clockwise':
                  return self.clockwise(placementObj);
                case 'flip':
                  placementObj = self.flip(placementObj);
                  placementObj.setCoordinate('x', placementObj.originalx);
                  placementObj.setCoordinate('y', placementObj.originaly);
                  placementObj = doPlacementAgainstParent(placementObj);
                  return placementObj;
                case 'shrink':
                  return self.shrink(placementObj);
                case 'shrink-x':
                  return self.shrink(placementObj, 'x');
                case 'shrink-y':
                  return self.shrink(placementObj, 'y');
                default:
                  return placementObj;
              }
            })(self);

            self.render(placementObj);
          }
        });

        // Trigger an event to notify placement has ended
        this.element.trigger('afterplace', [placementObj]);

        return placementObj;
      },

      // Basic Placement Routine that simply accepts X and Y coordinates.
      // In this case, "x" and "y" integers are "absolute" and will be the base point for placement.
      // Can be modified by using a callback in the settings.
      _placeWithCoords: function(placementObj) {
        this.render(placementObj);

        placementObj = this._handlePlacementCallback(placementObj);

        this.render(placementObj);

        // Coordinate placement can only be "nudged" (strategy is not used in this style of placement).
        placementObj = this.checkBleeds(placementObj);
        if (placementObj.bleeds) {
          placementObj = this.nudge(placementObj);
        }

        // Place again
        this.render(placementObj);

        placementObj = this.checkBleeds(placementObj);
        if (placementObj.bleeds) {
          placementObj = this.shrink(placementObj);
        }

        this.render(placementObj);

        this.element.trigger('afterplace', [
          placementObj
        ]);

        return placementObj;
      },

      // Perform callback, if it exists
      // Callback should return an array containing the modified coordinate values: [x, y];
      // NOTE: These are actual coordinates in all cases.  They are not relative values - they are absolute
      _handlePlacementCallback: function(placementObj) {
        var cb = placementObj.callback || this.settings.callback;

        if (cb && typeof cb === 'function') {
          placementObj = cb(placementObj);
        }

        this.render(placementObj);
        return placementObj;
      },

      /**
       * Detects for elements with fixed positioning, or an absolutely-positioned containment.
       * If either condition is true, this placement should not account for container scrolling.
       * @private
       */
      _accountForScrolling: function(placementObj) {
        var container = placementObj.container,
          containerStyle,
          pos = window.getComputedStyle(this.element[0]).position;

        // fixed-positoned, placed elements don't account for scrolling
        if (pos === 'fixed') {
          return false;
        }

        // Check the container element. If we can't find a valid container element, do account for scrolling.
        if (!container || !container.length) {
          container = this.element.parents().filter(function() {
            var pos = window.getComputedStyle(this).position;
            return pos === 'absolute' || pos === 'fixed';
          });
        }
        if (!container || !container.length) {
          return true;
        }

        if (container[0] === document.body) {
          return false;
        }

        containerStyle = window.getComputedStyle(container[0]);
        pos = containerStyle.position;
        if (pos === 'fixed') {
          return false;
        }
        if (pos === 'absolute' && containerStyle.overflow === 'hidden') {
          return false;
        }
        return true;
      },

      // Gets a parent container element.
      getContainer: function(placementObj) {
        if (placementObj.container instanceof $ && placementObj.container.length) {
          return placementObj.container;
        }

        var modalParent = this.element.parents('.modal');
        if (modalParent.length) {
          return modalParent;
        }

        return $(document.body);
      },

      // Re-adjust a previously-placed element to account for bleeding off the edges.
      // Element must fit within the boundaries of the page or it's current scrollable pane.
      checkBleeds: function(placementObj) {
        var containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          BoundingRect = this.element[0].getBoundingClientRect(),
          rect = {},
          containerRect = container ? container[0].getBoundingClientRect() : {},
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
          d;

          rect.width = BoundingRect.width;
          rect.height = BoundingRect.height;
          rect.top = BoundingRect.top;
          rect.right = BoundingRect.right;
          rect.bottom = BoundingRect.bottom;
          rect.left = BoundingRect.left;

        function getBoundary(edge) {
          switch(edge) {
            case 'top':
              return (containerBleed ? 0 : containerRect.top) - (!containerIsBody ? 0 : scrollY * -1); // 0 === top edge of viewport
            case 'left':
              return (containerBleed ? 0 : containerRect.left) - (!containerIsBody ? 0 : scrollX * -1); // 0 === left edge of viewport
            case 'right':
              return (containerBleed ? windowW : containerRect.right) - (!containerIsBody ? 0 : scrollX * -1);
            default: // bottom
              return (containerBleed ? windowH : containerRect.bottom) - (!containerIsBody ? 0 : scrollY * -1);
          }
        }

        // If element width is greater than window width, shrink to fit
        var rightViewportEdge = getBoundary('right');
        if (rect.width >= rightViewportEdge) {
          d = rect.width - rightViewportEdge;
          var newWidth = rect.width - d;
          placementObj.width = newWidth;

          this.element[0].style.width = newWidth + 'px';
          rect.width = newWidth; // reset the rect because the size changed
        }

        // If element height is greater than window height, shrink to fit
        var bottomViewportEdge = getBoundary('bottom');
        if (rect.height >= bottomViewportEdge) {
          d = rect.height - bottomViewportEdge;
          var newHeight = rect.height - d;
          placementObj.height = newHeight;

          this.element[0].style.height = newHeight + 'px';
          rect.height = newHeight; // reset the rect because the size changed
        }

        // build conditions
        var offRightEdge = rect.right > getBoundary('right'),
            offLeftEdge = rect.left < getBoundary('left'),
            offTopEdge = rect.top < getBoundary('top'),
            offBottomEdge = rect.bottom > getBoundary('bottom');

        // Return if no bleeding is detected (no need to fix anything!)
        if (!offRightEdge && !offLeftEdge && !offTopEdge && !offBottomEdge) {
          placementObj.bleeds = undefined;
          return placementObj;
        }

        // Keep a record of bleeds that need to be adjusted, and by what values
        placementObj.bleeds = {};
        placementObj.bleeds.right = offRightEdge ? (rect.right - getBoundary('right')) : null;
        placementObj.bleeds.left = offLeftEdge ? -(rect.left - getBoundary('left')) : null;
        placementObj.bleeds.top = offTopEdge ? -(rect.top - getBoundary('top')) : null;
        placementObj.bleeds.bottom = offBottomEdge ? (rect.bottom - getBoundary('bottom')) : null;

        return placementObj;
      },

      // Bumps the element around in each direction
      nudge: function(placementObj) {
        if (!placementObj.nudges) {
          placementObj.nudges = {x: 0, y: 0};
        }

        var d = 0;
        if (placementObj.bleeds.right) {
          d = Math.abs(placementObj.bleeds.right) + Math.abs(placementObj.containerOffsetX);
          placementObj.setCoordinate('x', placementObj.x - d);
          placementObj.nudges.x = placementObj.nudges.x - d;
        }
        if (placementObj.bleeds.left) {
          d = Math.abs(placementObj.bleeds.left) + Math.abs(placementObj.containerOffsetX);
          placementObj.setCoordinate('x', placementObj.x + d);
          placementObj.nudges.x = placementObj.nudges.x + d;
        }
        if (placementObj.bleeds.top) {
          d = Math.abs(placementObj.bleeds.top) + Math.abs(placementObj.containerOffsetY);
          placementObj.setCoordinate('y', placementObj.y + d);
          placementObj.nudges.y = placementObj.nudges.y + d;
        }
        if (placementObj.bleeds.bottom) {
          d = Math.abs(placementObj.bleeds.bottom) + Math.abs(placementObj.containerOffsetY);
          placementObj.setCoordinate('y', placementObj.y - d);
          placementObj.nudges.y = placementObj.nudges.y - d;
        }

        placementObj.wasNudged = true;
        placementObj.bleeds = undefined;

        return placementObj;
      },

      flip: function(placementObj) {
        // Don't attempt to flip if there was no bleeding on the edge we're attempting to leave from.
        if (!placementObj.bleeds[placementObj.placement]) {
          return placementObj;
        }

        if (!placementObj.attemptedFlips) {
          placementObj.attemptedFlips = [];
        }
        placementObj.attemptedFlips.push(placementObj.placement);

        // If we've tried flipping in all directions, give up and use the default placement.
        if (placementObj.attemptedFlips.length > 3) {
          placementObj = this.giveup(placementObj);
          return placementObj;
        }

        var accountForScrolling = this._accountForScrolling(placementObj),
          isXCoord = ['left', 'right'].indexOf(placementObj.placement) > -1,
          containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          containerRect = container ? container[0].getBoundingClientRect() : {},
          parentRect = placementObj.parent[0].getBoundingClientRect(),
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

        function getOppositeDir(dir) {
          switch(dir) {
            case 'left':
              return 'right';
            case 'right':
              return 'left';
            case 'top':
              return 'bottom';
            default: // bottom
              return 'top';
          }
        }

        // Gets the distance between an edge on the target element, and its opposing viewport border
        function getDistance(dir) {
          var d = 0;

          switch (dir) {
            case 'left':
              d = (containerBleed ? 0 : containerRect.left) - (accountForScrolling ? scrollX : 0) - parentRect.left + placementObj.containerOffsetX;
              break;
            case 'right':
              d = ((containerBleed ? windowW : containerRect.right) - (accountForScrolling ? scrollX : 0)) - parentRect.right - placementObj.containerOffsetX;
              break;
            case 'top':
              d = (containerBleed ? 0 : containerRect.top) - (accountForScrolling ? scrollY : 0) - parentRect.top + placementObj.containerOffsetY;
              break;
            default: // bottom
              d = ((containerBleed ? windowH : containerRect.bottom) - (accountForScrolling ? scrollY : 0)) - parentRect.bottom - placementObj.containerOffsetY;
              break;
          }

          return Math.abs(d);
        }

        function tried(placement) {
          return $.inArray(placement, placementObj.attemptedFlips) > -1;
        }

        function performFlip(originalDir) {
          var newDir = getOppositeDir(originalDir),
            perpendicularDir = isXCoord ? 'top' : 'left',
            oppPerpendicularDir = getOppositeDir(perpendicularDir),
            originalDistance = getDistance(originalDir),
            targetDistance = getDistance(newDir);

          if (!tried(newDir)) {
            if (originalDistance >= targetDistance) {
              return originalDir;
            }

            placementObj.wasFlipped = true;
            return newDir;
          }

          // switch the coordinate definitions
          // since the axis for placement is flipped, our coordinate offsets should also flip
          var tmp = placementObj.originalx;
          placementObj.originalx = placementObj.originaly;
          placementObj.originaly = tmp;

          var perpendicularDistance = getDistance(perpendicularDir),
            oppPerpendicularDistance = getDistance(oppPerpendicularDir);

          if (!tried(perpendicularDir)) {
            if (perpendicularDistance >= oppPerpendicularDistance) {
              return perpendicularDir;
            }

            if (!tried(oppPerpendicularDir)) {
              return oppPerpendicularDir;
            }
          }

          return originalDir;
        }

        placementObj.placement = performFlip(placementObj.placement);

        return placementObj;
      },

      // TODO: Move Clockwise
      clockwise: function(placementObj) {
        return placementObj;
      },

      // If element height/width is greater than window height/width, shrink to fit
      shrink: function(placementObj, dimension) {
        var accountForScrolling = this._accountForScrolling(placementObj),
          containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerRect = container ? container[0].getBoundingClientRect() : {},
          containerIsBody = container.length && container[0] === document.body,
          rect = this.element[0].getBoundingClientRect(),
          useX = dimension === undefined || dimension === null || dimension === 'x',
          useY = dimension === undefined || dimension === null || dimension === 'y',
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
          leftViewportEdge = (accountForScrolling ? scrollX: 0) + (containerBleed ? 0 : containerRect.left) + placementObj.containerOffsetX,
          topViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? 0 : containerRect.top) + placementObj.containerOffsetY,
          rightViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? windowW : containerRect.right) - placementObj.containerOffsetX,
          bottomViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? windowH : containerRect.bottom) - placementObj.containerOffsetY,
          d;

        // Shrink in each direction.
        // The value of the "containerOffsets" is "factored out" of each calculation, if for some reason the
        // element is larger than the viewport/container space allowed.
        placementObj.nudges = placementObj.nudges || {};

        if (useX) {
          // Left
          if (rect.left < leftViewportEdge) {
            d = Math.abs(leftViewportEdge - rect.left);
            if (rect.right >= rightViewportEdge) {
              d = d - placementObj.containerOffsetX;
            }
            placementObj.width = rect.width - d;
            placementObj.setCoordinate('x', placementObj.x + d);
            placementObj.nudges.x = placementObj.nudges.x + d;
          }

          // Right
          if (rect.right > rightViewportEdge) {
            d = Math.abs(rect.right - rightViewportEdge);
            if (rect.left <= leftViewportEdge) {
              d = d - placementObj.containerOffsetX;
            }
            placementObj.width = rect.width - d;
          }
        }

        if (useY) {
          // Top
          if (rect.top < topViewportEdge) {
            d = Math.abs(topViewportEdge - rect.top);
            if (rect.bottom >= bottomViewportEdge) {
              d = d - placementObj.containerOffsetY;
            }
            placementObj.height = rect.height - d;
            placementObj.setCoordinate('y', placementObj.y + d);
            placementObj.nudges.y = placementObj.nudges.y + d;
          }

          // Bottom
          if (rect.bottom > bottomViewportEdge) {
            d = Math.abs(rect.bottom - bottomViewportEdge);
            if (rect.top <= topViewportEdge) {
              d = d - placementObj.containerOffsetY;
            }
            placementObj.height = rect.height - d;
          }
        }

        return placementObj;
      },

      // Giving up causes all the placementObj settings to revert
      giveup: function(placementObj) {
        placementObj.giveup = true;
        placementObj.strategy = this.settings.strategy;
        placementObj.placement = this.settings.placement;
        return placementObj;
      },

      // Clears the old styles that may be present
      clearOldStyles: function() {
        this.element[0].style.left = '';
        this.element[0].style.top = '';
        this.element[0].style.width = '';
        this.element[0].style.height = '';

        var os = this.originalStyles;
        if (os) {
          if (os.width) {
            this.element[0].style.width = os.width;
          }

          if (os.height) {
            this.element[0].style.height = os.height;
          }
        }

        return this;
      },

      // Built-in method for handling positon of optional arrow elements.
      // Used for tooltip/popovers/popupmenus
      setArrowPosition: function(e, placementObj, element) {
        var target = placementObj.parent,
          arrow = element.find('div.arrow'),
          dir = placementObj.placement,
          isXCoord = ['left', 'right'].indexOf(dir) > -1,
          targetRect = {},
          elementRect = element[0].getBoundingClientRect(),
          arrowRect = {},
          newArrowRect = {},
          hideArrow = false;

        if (!target || !target.length || !arrow.length) {
          return;
        }

        arrow[0].removeAttribute('style');

        //if (placementObj.attemptedFlips) { TJM Removed for pager bug. Seems to work.
          element.removeClass('top right bottom left').addClass(dir);
        //}

        // Flip the arrow if we're in RTL mode
        if (this.isRTL && isXCoord) {
          var opposite = dir === 'right' ? 'left' : 'right';
          element.removeClass('right left').addClass(opposite);
        }

        // Custom target for some scenarios
        if (target.is('.colorpicker')) {
          target = target.next('.trigger');
        }
        if (target.is('.datepicker, .timepicker')) {
          target = target.next('.icon');
        }
        if (target.is('.btn-split-menu, .btn-menu, .btn-actions, .btn-filter, .tab, .tab-more')) {
          target = target.find('.icon').last();
        }
        if (target.is('.searchfield-category-button')) {
          target = target.find('.icon.icon-dropdown');
        }
        if (target.is('.colorpicker-editor-button')) {
          target = target.find('.trigger .icon');
        }

        // reset if we borked the target
        if (!target.length) {
          target = placementObj.parent;
        }

        targetRect = target.length ? target[0].getBoundingClientRect() : targetRect;
        arrowRect = arrow.length ? arrow[0].getBoundingClientRect() : arrowRect;
        newArrowRect = {};

        function getMargin(placement) {
          return (placement === 'right' || placement === 'left') ? 'margin-top' : 'margin-left';
        }

        function getDistance() {
          var targetCenter = 0,
            currentArrowCenter = 0,
            d = 0;

          if (dir === 'left' || dir === 'right') {
            targetCenter = targetRect.top + (targetRect.height/2);
            currentArrowCenter = arrowRect.top + (arrowRect.height/2);
            d = targetCenter - currentArrowCenter;
            newArrowRect.top = arrowRect.top + d;
            newArrowRect.bottom = arrowRect.bottom + d;

            if (newArrowRect.top <= elementRect.top || newArrowRect.bottom >= elementRect.bottom) {
              hideArrow = true;
            }
          }
          if (dir === 'top' || dir === 'bottom') {
            targetCenter = targetRect.left + (targetRect.width/2);
            currentArrowCenter = arrowRect.left + (arrowRect.width/2);
            d = targetCenter - currentArrowCenter;
            newArrowRect.left = arrowRect.left + d;
            newArrowRect.right = arrowRect.right + d;

            if (newArrowRect.left <= elementRect.left || newArrowRect.right >= elementRect.right) {
              hideArrow = true;
            }
          }

          return d;
        }

        // line the arrow up with the target element's "dropdown icon", if applicable
        var positionOpts = {};
        positionOpts[getMargin(dir)] = getDistance();
        if (hideArrow) {
          positionOpts.display = 'none';
        }
        arrow.css(positionOpts);
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.clearOldStyles();
        this.element.removeClass('placeable');

        this.element.off('updated.' + pluginName + ' place.' + pluginName);

        this.element.trigger('afterteardown');
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Place(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.popdown = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'popdown',
        defaults = {
          trigger: undefined // If defined, provides a way to place the popdown against an alternate element.
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Popdown(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Popdown.prototype = {

      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        var self = this;
        this.popdown = $();

        // Setup the proper trigger element to use
        this.trigger = this.element;
        if (this.settings.trigger instanceof $ || Soho.DOM.isElement(this.settings.trigger)) {
          this.trigger = $(this.settings.trigger);
        }
        // Force-change the trigger element in some specific scenarios
        if (this.trigger.is('.dropdown, .multiselect')) {
          this.trigger = $('#' + this.element.attr('id') + '-shdo');
        }

        // Find the correct element to use as the popdown's view.
        function tryPopdownElement(elem) {
          if (!elem) { return false; }

          if (typeof elem === 'string') {
            if (!elem.match('#') || elem.indexOf('#') !== 0) {
              elem = '#' + elem;
            }
            elem = $(elem);
          }

          if (elem.length) {
            self.popdown = elem;
            return true;
          }

          return false;
        }

        var popdownElem = tryPopdownElement(this.trigger.attr('data-popdown'));
        if (!popdownElem) {
          tryPopdownElement(this.trigger.next('.popdown'));
        }

        // Setup an ID for this popdown if it doesn't already have one
        this.id = this.popdown.attr('id');
        if (!this.id) {
          this.id = 'popdown-' + $('body').find('.popdown').index(this.popdown);
          this.popdown.attr('id', this.id);
        }

        return this;
      },

      build: function() {
        // Ensure the popdown window is a popdown, and remove any hidden classes from it.
        this.popdown.addClass('popdown').removeClass('hidden');

        // Wrap the contents inside for spacing purposes
        var contents = this.popdown.children('.popdown-contents');
        if (!contents.length) {
          this.popdown.children().wrap('<div class="popdown-contents"></div>');
        }

        // Add the arrow markup if it doesn't already exist
        this.arrow = $('<div class="arrow"></div>').prependTo(this.popdown);

        this.place();

        // Expand if necessary
        var ariaExpanded = this.trigger.attr('aria-expanded');
        if (!ariaExpanded || ariaExpanded === undefined) {
          this.trigger.attr('aria-expanded', '');
        }
        if (ariaExpanded === 'true') {
          this.open();
        }

        // aria-controls for the trigger element
        this.trigger.attr('aria-controls', this.id);

        return this;
      },

      handleEvents: function() {
        var self = this;

        this.trigger
          .onTouchClick('popdown')
          .on('click.popdown', function() {
            self.toggle();
          })
          .on('updated.popdown', function() {
            self.updated();
          });

        return this;
      },

      hasValidTriggerSetting: function() {
        return (this.settings.trigger instanceof $ || Soho.DOM.isElement(this.settings.trigger));
      },

      isOpen: function() {
        return this.trigger.attr('aria-expanded') === 'true';
      },

      open: function() {
        if (this.isAnimating) {
          return;
        }

        var self = this,
          setFocusinEvent = false;

        this.isAnimating = true;
        this.trigger.attr('aria-expanded', 'true');
        this.position();
        this.popdown.addClass('visible');

        // Setup events that happen on open
        // Needs to be on a timer to prevent automatic closing of popdown.
        setTimeout(function() {
          self.popdown.one('focusin.popdown', function() {
            if (!setFocusinEvent) {
              setFocusinEvent = true;
              $(document).on('focusin.popdown', function(e) {
                var target = e.target;
                if (!$.contains(self.popdown[0], target)) {
                  self.close();
                }
              });
            }
          });

          $('body').on('resize.popdown', function() {
            if (!$(document.activeElement).closest('.popdown').length) {
              self.close();
            }
          });

          $(document).on('click.popdown', function(e) {
            var target = $(e.target);

            if (!target.is('.popdown') && !target.closest('.popdown').length) {
              self.close();
            }
          });

          self.isAnimating = false;
        }, 400);
      },

      close: function() {
        if (this.isAnimating) {
          return;
        }

        var self = this;
        this.isAnimating = true;
        this.trigger.attr('aria-expanded', 'false');
        this.popdown.removeClass('visible');

        // Turn off events
        this.popdown.off('focusin.popdown');
        $('body').off('resize.popdown');
        $(document).off('click.popdown focusin.popdown');

        // Sets the element to "display: none" to prevent interactions while hidden.
        setTimeout(function() {
          self.popdown[0].style.display = 'none';
          self.isAnimating = false;
        }, 400);
      },

      toggle: function() {
        if (this.isOpen()) {
          this.close();
          return;
        }
        this.open();
      },

      // Detaches Popdown Element and places at the body tag root, or at the root of the nearest
      // scrollable parent.
      place: function() {
        this.scrollparent = $('body');
        this.popdown.detach().appendTo(this.scrollparent);
      },

      position: function() {
        var parent = {
          offset: {
            left: 0,
            top: 0
          },
          scrollDistance: {
            left: 0,
            top: 0
          }
        },
        winH = window.innerHeight + $(document).scrollTop(),
        // subtract 2 from the window width to account for the tooltips
        // resizing themselves to fit within the CSS overflow boundary.
        winW = (window.innerWidth - 2) + $(document).scrollLeft();

        // Reset adjustments to panel and arrow
        this.popdown.removeAttr('style');
        this.arrow.removeAttr('style');

        // Add/subtract offsets if a scrollable parent element is involved
        if (this.scrollparent.length) {
          parent.offset = this.scrollparent.offset();
          parent.scrollDistance.top = this.scrollparent.scrollTop();
          parent.scrollDistance.left = this.scrollparent.scrollLeft();
          winH = winH - (parent.offset.top + parent.scrollDistance.top);
          winW = winW - (parent.offset.left + parent.scrollDistance.left);
        }

        var adjustX = false,
          adjustY = false,
          t = this.trigger,
          to = t.offset(), // Trigger offset
          arrowHeight = 11,
          XoffsetFromTrigger = 0,
          YoffsetFromTrigger = 0,
          po; // Popover offset

        // Place the popdown below to start
        this.popdown.addClass('bottom');

        this.popdown[0].style.left = to.left + 'px';
        this.popdown[0].style.top = (to.top + t.outerHeight(true) + arrowHeight) + 'px';

        this.arrow[0].style.left = (t.outerWidth(true)/2) + 'px';
        this.arrow[0].style.top = (0 - arrowHeight) + 'px';

        // Get the newly-set values for the popdown's offset
        po = this.popdown.offset();

        // Get deltas for popdown position if the button is off either X edge
        if (po.left < 0) { // Checking the left edge
          adjustX = true;
          XoffsetFromTrigger = 0 - po.left;
        }
        var rightEdgePos = po.left + this.popdown.outerWidth(true);
        if (rightEdgePos > winW) { // Checking the right edge
          adjustX = true;
          XoffsetFromTrigger = rightEdgePos - winW + (Locale.isRTL() ? 20 : 0);
        }

        if (adjustX) {
          // Adjust the X position based on the deltas
          this.popdown[0].style.left = (po.left + (XoffsetFromTrigger * -1)) + 'px';

          var popdownRect = this.popdown[0].getBoundingClientRect(),
            triggerRect = t[0].getBoundingClientRect(),
            deltaRightEdge = popdownRect.right - triggerRect.right + 10;

          this.arrow[0].style.left = 'auto';
          this.arrow[0].style.right = deltaRightEdge+ 'px';


          // Get the newly set values
          po = this.popdown.offset();
        }

        // Get the deltas for popdown position if the button is off either Y edge
        if (po.top < 0) { // Checking top edge
          adjustY = true;
          YoffsetFromTrigger = 0 - po.top;
        }
        var bottomEdgePos = po.top + this.popdown.outerHeight(true);
        if (bottomEdgePos > winH) { // Checking the bottom edge
          adjustY = true;
          YoffsetFromTrigger = bottomEdgePos - winH;
        }

        // Remove the arrow if we need to adjust this, since it won't line up anymore
        if (adjustY) {
          this.arrow[0].style.display = 'none';

          // Adjust the Y position based on the deltas
          this.popdown[0].style.top = (po.top + (YoffsetFromTrigger * -1)) + 'px';
          this.arrow[0].style.top = (parseInt(this.arrow[0].style.top) - (YoffsetFromTrigger * -1)) + 'px';

          // Get the values again
          po = this.popdown.offset();
        }

        // One last check of the Y edges.  At this point, if either edge is out of bounds, we need to
        // shrink the height of the popdown, as it's too tall for the viewport.
        if (po.top < 0 || po.top + this.popdown.outerHeight(true) > winH) {
          this.popdown[0].style.top = 0;
          po = this.popdown.offset();

          bottomEdgePos = po.top + this.popdown.outerHeight(true);
          this.popdown[0].style.height = (parseInt(this.popdown[0].style.height) - (bottomEdgePos - winH)) + 'px';
        }
      },

      updated: function() {
        if (this.hasValidTriggerSetting()) {
          this.trigger = $(this.settings.trigger);
        }

        return this;
      },

      teardown: function() {
        if (this.isOpen()) {
          this.close();
        }

        this.trigger
          .offTouchClick('popdown')
          .off('updated.popdown click.popdown')
          .removeAttr('aria-controls')
          .removeAttr('aria-expanded');

        if (this.originalParent && this.originalParent.length) {
          this.popdown.detach().appendTo(this.originalParent);
        }

        this.arrow.remove();

        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Popdown(this, settings));
      }
    });
  };


  $.fn.popupmenu = function(options) {

    // Settings and Options
    var pluginName = 'popupmenu',
      defaults = {
        menu: null,
        trigger: 'click',
        autoFocus: true,
        mouseFocus: true,
        attachToBody: false,
        beforeOpen: null,
        ariaListbox: false,
        eventObj: undefined,
        returnFocus: true,
        placementOpts: {
          containerOffsetX: 10,
          containerOffsetY: 10,
          strategies: ['flip', 'shrink']
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      settings = $.extend({}, defaults, options);


    /**
    * Responsive Popup Menu Control aka Context Menu when doing a right click action.
    *
    * @class PopupMenu
    * @param {String} menu  &nbsp;-&nbsp; Menu's ID Selector, or a jQuery object representing a menu
    * @param {String} trigger  &nbsp;-&nbsp; Action on which to trigger a menu can be: click, rightClick, immediate ect
    * @param {Boolean} autoFocus  &nbsp;-&nbsp; If false the focus will not focus the first list element. (At the cost of accessibility)
    * @param {Boolean} attachToBody  &nbsp;-&nbsp; If true the menu will be moved out to the body. To be used in certin overflow situations.
    * @param {function} beforeOpen  &nbsp;-&nbsp; Callback that can be used for populating the contents of the menu.
    * @param {String} ariaListbox  &nbsp;-&nbsp;  Switches aria to use listbox construct instead of menu construct (internal)
    * @param {String} eventObj  &nbsp;-&nbsp; Can pass in the event object so you can do a right click with immediate
    * @param {String} returnFocus  &nbsp;-&nbsp; If set to false, focus will not be returned to the calling element. It usually should be for accessibility purposes.
    * @param {Object} placementOpts  &nbsp;-&nbsp; Gets passed to this control's Place behavior
    * @param {Object} offset  &nbsp;-&nbsp; Can tweak the menu position in the x and y direction. Takes an object of form: `{x: 0, y: 0}`
    *
    */
    function PopupMenu(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      this.isOldIe  = $('html').is('.ie11, .ie10, .ie9');
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Object
    PopupMenu.prototype = {
      init: function() {
        this.setup();
        this.addMarkup();
        this.handleEvents();
        this.iconFilteringSetup();

        // Allow for an external click event to be passed in from outside this code.
        // This event can be used to pass clientX/clientY coordinates for mouse cursor positioning.
        if (this.settings.trigger === 'immediate') {
          this.open(this.settings.eventObj);
        }

        // Use some css rules on submenu parents
        if (this.menu.find('.submenu').length) {
          this.menu.addClass('has-submenu');
        }
      },

      isRTL: function() {
        return $('html').attr('dir') === 'rtl';
      },

      setup: function() {
        if (this.element.attr('data-popupmenu') && !this.settings.menu) {
          this.settings.menu = this.element.attr('data-popupmenu').replace(/#/g, '');
        }
        // Backwards compatibility for "menuId" menu options coming from other controls
        // that utilize the Popupmenu.
        if (this.settings.menuId) {
          this.settings.menu = this.settings.menuId;
          this.settings.menuId = undefined;
        }

        // keep track of how many popupmenus there are with an ID.
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = (parseInt($('.popupmenu-wrapper').length, 10)+1).toString();
        }
      },

      //Add markip including Aria
      addMarkup: function () {
        var id,
          leftClick = this.settings.trigger !== 'rightClick',
          immediate = this.settings.trigger === 'immediate';

        switch(typeof this.settings.menu) {
          case 'string': // ID Selector
            id = this.settings.menu;
            this.menu = $('#' + this.settings.menu);
            break;
          case 'object': // jQuery Object
            if (this.settings.menu === null) {
              this.menu = this.element.next('.popupmenu, .popupmenu-wrapper');
            } else {
              this.menu = $(this.settings.menu);
            }

            id = this.menu.attr('id');
            if (!id || id === '') {
              this.menu.attr('id', 'popupmenu-' + this.id);
              id = this.menu.attr('id');
            }
            break;
        }

        // If markup already exists for the wrapper, use that instead of rebuilding.
        if (this.menu.is('.popupmenu-wrapper')) {
          this.preExistingWrapper = true;
          this.wrapper = this.menu;
          this.menu = this.wrapper.children('.popupmenu').first();
        }

        // Similar check as above, assuming the menu wasn't a popupmenu wrapper.
        if (this.menu.parent().is('.popupmenu-wrapper')) {
          this.preExistingWrapper = true;
          this.wrapper = this.menu.parent();
        }

        // If we still don't have a menu reference at this point, fail gracefully by returning out
        // and simply acting like a button.
        if (this.menu.length === 0) {
          return false;
        }

        // if the menu is deeply rooted inside the markup, detach it and append it to the <body> tag
        // to prevent containment issues. (Now a Preference)
        if (this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
          this.originalParent = this.menu.parent();
          this.menu.detach().appendTo('body');
        }

        if (!this.menu.is('.popupmenu')) {
          this.menu.addClass('popupmenu')
            .attr('role', (this.settings.ariaListbox ? 'listbox' : 'menu'));
        }

        // Always store a reference to the trigger element under jQuery data.
        this.menu.data('trigger', this.element);

        this.wrapper = this.menu.parent('.popupmenu-wrapper');
        if (!this.wrapper.length) {
          this.wrapper = this.menu.wrap('<div class="popupmenu-wrapper"></div>');
        }

        // Invoke all icons as icons
        this.wrapper.find('svg').each(function() {
          if (!$(this).data('icon')) {
            $(this).icon();
          }
        });

        //Enforce Correct Modality
        this.menu.parent('.popupmenu-wrapper').attr('role', 'application').attr('aria-hidden', 'true');

        // Use "absolute" positioning on the menu insead of "fixed", only when the
        // menu lives <body> tag and we have a <body> element that is tall enough to
        // scroll and is allowed to scroll.
        function scrollableFilter() {
          var c = this ? this.style.overflow : null;
          return c !== 'auto' && c !== 'visible' && c !== 'scroll';
        }
        if (this.wrapper.parents().filter(scrollableFilter).length === 0) {
          this.wrapper[0].style.position = 'absolute';
        }

        // Wrap submenu ULs in a 'wrapper' to help break it out of overflow.
        this.menu.find('.popupmenu').each(function(i, elem) {
          var popup = $(elem);

          if (!(popup.parent().hasClass('wrapper'))) {
            popup.wrap('<div class="wrapper"></div>');
          }
        });

        // If the trigger element is a button with no border append arrow markup
        var containerClass = this.element.parent().attr('class');
        if ((this.element.hasClass('btn-menu') ||
            this.element.hasClass('btn-actions') ||
            this.element.hasClass('btn-icon') && this.element.find('use').attr('xlink:href') === '#icon-more' ||
            this.settings.menu === 'colorpicker-menu' ||
            this.element.closest('.toolbar').length > 0 ||
            this.element.closest('.masthead').length > 0 ||
            this.element.is('.searchfield-category-button') ||
            (containerClass && containerClass.indexOf('more') >= 0) ||
            containerClass && containerClass.indexOf('btn-group') >= 0)) {

          var arrow = $('<div class="arrow"></div>'),
            wrapper = this.menu.parent('.popupmenu-wrapper');

          wrapper.addClass('bottom').append(arrow);
        }

        // If inside of a ".field-short" container, make smaller
        var addFieldShort = this.element.closest('.field-short').length;
        this.menu[addFieldShort ? 'addClass' : 'removeClass']('popupmenu-short');

        // If button is part of a header/masthead or a container using the "alternate" UI color, add the "alternate" class.
        if (containerClass !== undefined &&
          (this.element.closest('.masthead').not('.search-results .masthead').length > 0)) {
          this.menu.parent('.popupmenu-wrapper').addClass('inverse');
        }

        this.element.attr('aria-haspopup', true);
        this.element.attr('aria-controls', id);

        this.markupItems();

        //Add an Audible Label
        if (!leftClick && !immediate) {
          var audibleSpanId = 'popupmenu-f10-label';
          if ($('#'+audibleSpanId).length === 0) {
            this.element.after('<span style="display:none;" id="' + audibleSpanId + '">' + Locale.translate('PressShiftF10') + '</span>');
          }
          //PressShiftF10
          this.element.attr('aria-describedby', audibleSpanId);
        }

        // Unhide the menu markup, if hidden
        if (this.menu.is('.hidden')) {
          this.menu.removeClass('hidden');
        }
      },

      /**
       * @param {jQuery[]|HTMLElement}
       */
      markupItems: function (contextElement) {
        var self = this;

        if (!contextElement) {
          contextElement = this.menu;
        } else if (contextElement instanceof HTMLElement) {
          contextElement = $(contextElement);
        }

        var lis = contextElement.find('li:not(.heading):not(.separator)'),
          menuClassName = contextElement[0].className,
          isTranslatable = Soho.DOM.classNameHas(menuClassName, 'isTranslatable');

        lis.each(function(i, li) {
          var a = $(li).children('a')[0], // TODO: do this better when we have the infrastructure
            span = $(a).children('span')[0],
            submenu = $(li).children('ul')[0],
            submenuWrapper = $(li).children('.wrapper')[0];

          li.setAttribute('role', 'presentation');

          if (a) {
            a.setAttribute('tabindex', '-1');
            a.setAttribute('role', (self.settings.ariaListbox ? 'option' : 'menuitem'));

            // Should be translated
            if (isTranslatable) {
              span.innerText = Locale.translate(span.innerText) || span.innerText;
            }

            // disabled menu items, by prop and by className
            var $a = $(a),
              $li = $(li);

            if ($li.hasClass('is-disabled') || (a.getAttribute('disabled') === 'true' || a.getAttribute('disabled') === 'disabled')) {
              $li.addClass('is-disabled');
              a.setAttribute('aria-disabled', 'true');
              a.setAttribute('disabled', true);
            } else {
              $li.removeClass('is-disabled');
              $a.removeAttr('aria-disabled');
              a.removeAttribute('disabled');
            }

            // menu items that contain submenus
            if (submenu instanceof HTMLElement) {
              submenu.classList.add('popupmenu');
            }
            if (submenuWrapper instanceof HTMLElement) {
              li.className += (Soho.DOM.classNameExists(li) ? ' ' : '') + 'submenu';
              submenu = $(submenuWrapper).children('ul')[0];
              submenu.classList.add('popupmenu');
            }
            if (Soho.DOM.classNameHas(li.className, 'submenu')) {

              // Add a span
              if (!span) {
                a.innerHTML = '<span>' + a.innerHTML + '</span>';
                span = $a.children('span')[0];
              }

              if ($a.find('svg.arrow').length === 0) {
                $a.append($.createIconElement({ classes: ['arrow', 'icon-dropdown'], icon: 'dropdown' }));
              }
              a.setAttribute('aria-haspopup', 'true');

              // Check for existing menus, and if present, apply a `.popupmenu` class automatically.

            }

            // is-checked
            if (Soho.DOM.classNameHas(li.className, 'is-checked')) {
              a.setAttribute('role', 'menuitemcheckbox');
              a.setAttribute('aria-checked', true);
            }

            // is-not-checked
            if (Soho.DOM.classNameHas(li.className, 'is-not-checked')) {
              li.className = li.className.replace('is-not-checked', '');
              a.setAttribute('role', 'menuitemcheckbox');
              a.removeAttribute('aria-checked');
            }
          }
        });
      },

      handleEvents: function() {
        var self = this,
          leftClick = this.settings.trigger !== 'rightClick',
          immediate = this.settings.trigger === 'immediate';

        function disableBrowserContextMenu(e) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        function doOpen(e) {
          var rightClick = self.settings.trigger === 'rightClick';

          e.stopPropagation();
          e.preventDefault();

          if (rightClick && self.menu.hasClass('is-open')) {
            self.close();
            self.open(e);
            return;
          }

          if (self.menu.hasClass('is-open')){
            self.close();
          } else {
            self.open(e);
          }
        }

        function contextMenuHandler(e, isLeftClick) {
          e.preventDefault();

          if (self.keydownThenClick) {
            self.keydownThenClick = undefined;
            return;
          }

          var btn = isLeftClick === true ? 0 : 2;
          if (e.button > btn || self.element.is(':disabled')) {
            return;
          }

          doOpen(e);
        }

        if (!immediate) {
          // Left-Click activation
          if (leftClick) {
            this.element
              .on('click.popupmenu', function (e) {
                contextMenuHandler(e, true);
              });
          }

          // Right-Click activation
          if (!leftClick) {
            this.menu.parent().on('contextmenu.popupmenu', disableBrowserContextMenu);
            this.element
              .on('contextmenu.popupmenu', function(e) {
                disableBrowserContextMenu(e);
                contextMenuHandler(e);
              });
          }
        }

        // Disable dragging text to a new browser tab
        this.menu.off('dragstart.popupmenu').on('dragstart.popupmenu', 'a', function () {
          return false;
        });

        // Setup these next events no matter what trigger type is
        this.element.not('.autocomplete')
          .on('keydown.popupmenu', function (e) {
            switch(e.which) {
              case 13:
              case 32:
                if (self.settings.trigger === 'click') {
                  self.keydownThenClick = true;
                  self.open(e);
                }
                break;
              case 121:
                if (e.shiftKey) { //Shift F10
                  self.open(e);
                }
                break;
            }
          })
          .on('updated.popupmenu', function(e) {
            e.stopPropagation();
            self.updated();
          });

          // Media Query Listener to detect a menu closing on mobile devices that change orientation.
          if (window.matchMedia) {
            this.matchMedia = window.matchMedia('(orientation: landscape)');
            this.mediaQueryListener = function() {
              // Match every time.
              if (!self.menu.hasClass('is-open')) {
                return;
              }
              self.close();
            };
            this.matchMedia.addListener(this.mediaQueryListener);
          }
      },

      handleKeys: function () {
        var self = this;
        //http://access.aol.com/dhtml-style-guide-working-group/#popupmenu

        //Handle Events in Anchors
        this.menu.onTouchClick('popupmenu', 'a')
          .on('click.popupmenu', 'a', function(e) {
            self.handleItemClick(e, $(this));
          });

        var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';

        //Select on Focus
        if (this.settings.mouseFocus) {
          this.menu.on('mouseenter.popupmenu', 'li', function () {
            self.highlight($(this).children('a'));
          });
        }

        setTimeout(function() {
          $(document).off('keydown.popupmenu.' + this.id).on('keydown.popupmenu.' + this.id, function (e) {
            var key = e.which,
              focus;

            //Close on escape
            if (key === 27) {
              e.stopPropagation();
              e.stopImmediatePropagation();
              self.close(true);
              return false;
            }

            //Close on tab
            if (key === 9) {
              e.stopPropagation();
              self.close(true);
            }

            //Select Checkboxes
            if (key === 32) {
              e.stopPropagation();

              var target = $(e.target),
                checkbox = target.find('input:checkbox');
              if (checkbox.length) {
                checkbox.trigger('click');
                return;
              }

              var a = $();

              // Return here and let Tabs control handle the spacebar
              if (target.is('.tab') || target.parent().is('.tab') || target.is('.tab-more')) {
                // Spacebar acts like Enter if there aren't any checkboxes (trigger links, etc)
                e.preventDefault();
                return;
              }

              if (target.is('li')) {
                a = target.children('a');
              }

              if (target.is('a')) {
                a = target;
              }

              if (a.length) {
                a.trigger('click');
                return;
              }
            }

            focus = self.menu.find(':focus');

            var isPicker = (self.settings.menu === 'colorpicker-menu'),
              isAutocomplete = self.element.is('.autocomplete');

            // Close Submenu
            if (key === 37 && !isAutocomplete) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.closest('.popupmenu')[0] !== self.menu[0] && focus.closest('.popupmenu').length > 0) {
                focus.closest('.popupmenu').removeClass('is-open').parent().parent().removeClass('is-submenu-open');
                self.highlight(focus.closest('.popupmenu').parent().prev('a'));
              }
            }

            var getPrev, getNext, getLast, getFirst;

            getPrev = function(a) {
              var prevs = a.parent().prevAll(excludes),
                prev;

              prevs.each(function() {
                if (prev) {
                  return;
                }

                var li = $(this),
                  targetA = li.children('a');
                if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                  return;
                }
                prev = targetA;
              });

              if (!prev) {
                return getFirst(a);
              }

              return prev;
            };

            getFirst = function(a) {
              var first = a.parent().prevAll(excludes).last(),
                targetA = first.children('a');

              if (first.is('.is-disabled') || targetA.prop('disabled') === true) {
                return getNext(targetA);
              }

              return targetA;
            };

            getNext = function(a) {
              var nexts = a.parent().nextAll(excludes),
                next;

              nexts.each(function() {
                if (next) {
                  return;
                }

                var li = $(this),
                  targetA = li.children('a');
                if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                  return;
                }
                next = targetA;
              });

              if (!next) {
                return getFirst(a);
              }

              return next;
            };

            getLast = function(a) {
              var last = a.parent().nextAll(excludes).last(),
                targetA = last.children('a');

              if (last.is('.is-disabled') || targetA.prop('disabled') === true) {
                return getPrev(targetA);
              }

              return targetA;
            };

            // Count number of rows in picker
            var rowCount = 0,
                colors = self.menu.children(excludes),
                colorsLength = colors.length,
                currentOffsetTop = 0;

            for (var i = 0; i < colorsLength; i++) {
              var colorItem = colors[i];

              if (currentOffsetTop === 0) {
                currentOffsetTop = colorItem.offsetTop;
              }

              if(colorItem.offsetTop === currentOffsetTop) {
                rowCount++;
              } else {
                break;
              }
            }

            //Up on Up
            if ((!isPicker && key === 38) || (isPicker && key === 37)) {
               e.stopPropagation();
               e.preventDefault();

              //Go back to Top on the last one
              if (focus.parent().prevAll(excludes).length === 0) {
                if (focus.length === 0) {
                  self.highlight(self.menu.children(excludes).last().find('a'));
                } else {
                  self.highlight(getLast(focus));
                }
                return;
              }
              self.highlight(getPrev(focus));
            }

            //Up a square
            if (isPicker && key === 38) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.parent().prevAll(excludes).length > 0) {
                self.highlight($(focus.parent().prevAll(excludes)[rowCount - 1]).find('a'));
              }
            }

            //Right Open Submenu
            if (key === 39  && !isAutocomplete) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.parent().hasClass('submenu')) {
                self.openSubmenu(focus.parent());
                self.highlight(focus.parent().find('.popupmenu a:first'));
              }
            }

            //Down
            if ((!isPicker && key === 40) || (isPicker && key === 39 && !isAutocomplete)) {
              e.stopPropagation();
              e.preventDefault();

              //Go back to Top on the last one
              if (focus.parent().nextAll(excludes).length === 0) {
                if (focus.length === 0) {
                  self.highlight(self.menu.children(excludes).first().find('a'));
                } else {
                  self.highlight(getFirst(focus));
                }
                return;
              }
              self.highlight(getNext(focus));
            }

            //Down a square
            if ((isPicker && key === 40)) {
              e.stopPropagation();
              e.preventDefault();

              if (focus.parent().nextAll(excludes).length > 0) {
                self.highlight($(focus.parent().nextAll(excludes)[rowCount - 1]).find('a'));
              }
            }

          });
        }, 1);
      },

      /**
       * Handles the action of clicking items in the popupmenu.
       * @private
       */
      handleItemClick: function(e, anchor) {
        var href = anchor.attr('href'),
          selectionResult = [anchor];

        if (!e && !anchor) {
          return;
        }

        if (anchor.parent().is('.submenu, .hidden, .is-disabled') || anchor[0].disabled) {
          //Do not close parent items of submenus on click
          e.preventDefault();
          return;
        }

        if (anchor.find('input[checkbox]').length > 0) {
          return;
        }

        if (this.element.hasClass('btn-filter')) {
          this.iconFilteringUpdate(anchor);
          e.preventDefault();
        }

        if (this.isInSelectableSection(anchor) || this.menu.hasClass('is-selectable') || this.menu.hasClass('is-multiselectable')) {
          selectionResult = this.select(anchor);
        }

        // Single toggle on off of checkbox class
        if (anchor.parent().hasClass('is-toggleable')) {
          anchor.parent().toggleClass('is-checked');
        }

        // Trigger a selected event containing the anchor that was selected
        // If an event object is not passed to `handleItemClick()`, assume it was due to this
        // event being triggered already, making it not necessary to re-trigger it.
        if (e) {
          if (selectionResult.length === 1) {
            selectionResult.push(undefined);
          }

          selectionResult.push(true);
          this.element.triggerHandler('selected', selectionResult);
        }

        // MultiSelect Lists should act like other "multiselect" items and not close the menu when options are chosen.
        if (this.menu.hasClass('is-multiselectable') || this.isInMultiselectSection(anchor)) {
          return;
        }

        this.close();

        if (this.element.is('.autocomplete')) {
          return;
        }

        if (href && href.charAt(0) !== '#') {
          if (anchor.attr('target') === '_blank') {
            window.open(href, '_blank');
          } else {
            window.location.href = href;
          }
          return true;
        }

        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
      },

      // Filtering icon initial setup
      iconFilteringSetup: function(alink) {
        if (this.element.hasClass('btn-filter')) {
          var svg = this.element.find('svg.icon-dropdown'),
            link = alink || $('li:first a', this.menu),
            audibleText = link.find('span').text();

          if (svg.length === 1) {
            this.element.append($.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }));
          }

          svg.first().changeIcon(link.find('svg').getIconName());
          this.element.find('.audible').text(audibleText);
        }
      },

      // Filtering icon update
      iconFilteringUpdate: function(alink) {
        if (this.element.hasClass('btn-filter')) {
          var link = alink || $('li:first a', this.menu),
            audibleText = link.find('span').text();

          this.element.find('.audible').text(audibleText);
          this.element.find('svg:not(.ripple-effect):first').changeIcon(link.find('svg').getIconName());
        }
      },

      // Get the event position, handling browser cases (IE,FF) as well as SVG
      getPositionFromEvent: function (e) {
        var x = 0, y = 0;

        if (!e) {
          e = window.event;
        }

        if (!e) {
          return {};
        }

        if (e.pageX || e.pageY) {
          x = e.pageX;
          y = e.pageY;
        } else if (e.clientX || e.clientY) {
          x = e.clientX + document.body.scrollLeft +
                             document.documentElement.scrollLeft;
          y = e.clientY + document.body.scrollTop +
                             document.documentElement.scrollTop;
        }

        return {
          x: x,
          y: y
        };
      },

      position: function(e) {
        var self = this,
          target = this.element,
          isRTL = this.isRTL(),
          wrapper = this.menu.parent('.popupmenu-wrapper'),
          mouse =  this.getPositionFromEvent(e),
          menuDimensions = {
            width: this.menu.outerWidth(),
            height: this.menu.outerHeight()
          };

        if (!wrapper.length) {
          return;
        }

        // Make the field the same size
        var elemWidth = this.element.outerWidth();
        if (this.settings.trigger === 'click' && elemWidth > menuDimensions.width) {
          this.menu.width(elemWidth);
        }

        if (target.is('svg, .icon') && target.closest('.tab').length) {
          target = target.closest('.tab');
        }

        function getCoordinates(e, axis) {
          axis = ((axis === 'x' || axis === 'y') ? axis : 'x');
          return mouse[axis]; // use mouseX/mouseY if this doesn't work
        }

        // Reset the arrow
        wrapper.find('.arrow').removeAttr('style');

        var opts = $.extend({}, this.settings.placementOpts),
          strategies = ['flip'];

        /*
        if (!target.is('.autocomplete, .searchfield')) {
          strategies.push('nudge');
        }
        */
        strategies.push('shrink-y');
        opts.strategies = strategies;

        // If right-click or immediate (with an incoming event object), use coordinates from the event
        if ((this.settings.trigger === 'immediate' && this.settings.eventObj) || this.settings.trigger === 'rightClick') {
          opts.x = getCoordinates(e, 'x') - (isRTL ? menuDimensions.width : 0) + ((isRTL ? -1 : 1) * this.settings.offset.x);
          opts.y = getCoordinates(e, 'y') + this.settings.offset.y;

          if (opts.x === 0 && opts.y === 0) {
            opts.x = this.settings.offset.x || 0;
            opts.y = this.settings.offset.y || 0;
            opts.parent = this.element;
            opts.placement = 'bottom';
            opts.parentXAlignment = isRTL ? 'right' : 'left';
          }

        } else {
          opts.x = this.settings.offset.x || 0;
          opts.y = this.settings.offset.y || 0;
          opts.parent = this.element;
          opts.placement = 'bottom';
          opts.strategies.push('nudge');
        }

        //=======================================================
        // BEGIN Temporary stuff until we sort out passing these settings from the controls that utilize them
        //=======================================================

        var toolbarParent = target.parents('.toolbar'),
          insideToolbar = toolbarParent.length > 0,
          insideToolbarTitle = target.parents('.title').length > 0,
          isNotFullToolbar = insideToolbar && toolbarParent.children('.buttonset, .title').length > 1,
          isPagerMenu = target.parents('.pager-pagesize').length > 0;

        function alignLeft() {
          opts.parentXAlignment = (isRTL ? 'right': 'left');
        }

        function alignRight() {
          opts.parentXAlignment = (isRTL ? 'left' : 'right');
        }

        function shiftDown() {
          opts.y = opts.y + 15;
        }

        // Change the alignment of the popupmenu based on certain conditions
        (function doAlignment() {
          if (target.is('.btn-menu')) {
            if (isPagerMenu) {
              return alignRight();
            }

            if (insideToolbar) {
              if (!isNotFullToolbar) {
                return alignLeft();
              }
              if (insideToolbarTitle) {
                return alignLeft();
              }
              return alignRight();
            }

            return alignLeft();
          }

          if (target.is('.btn-actions')) {
            return alignRight();
          }

          if (target.is('.tab-more')) {
            return alignRight();
          }

          if ((target.is('.btn-split-menu, .tab, .searchfield-category-button') &&
            !target.parent('.pager-pagesize').length)) {
              return alignLeft();
            }
        })();

        if (target.parents('.masthead').length > 0) {
          shiftDown();
        }

        // If inside a "page-container" element, constrain the popupmenu to that element
        // (fixes SOHO-6223)
        var container = this.element.parents('.page-container:not(.tab-container)');
        if (container.length) {
          opts.container = container.first();
        }

        //=======================================================
        // END Temporary stuff until we sort out passing these settings from the controls that utilize them
        //=======================================================

        wrapper.one('afterplace.popupmenu', function(e, positionObj) {
          self.handleAfterPlace(e, positionObj);
        });

        wrapper.place(opts);
        wrapper.data('place').place(opts);
      },

      handleAfterPlace: function(e, placementObj) {
        var wrapper = this.menu.parent('.popupmenu-wrapper');
        wrapper.data('place').setArrowPosition(e, placementObj, wrapper);

        if (placementObj.height) {
          wrapper[0].style.height = '';
          this.menu[0].style.height = (placementObj.height) + (/(px|%)/i.test(placementObj.height + '') ? '' : 'px');
        }
        if (placementObj.width) {
          wrapper[0].style.width = '';
          this.menu[0].style.width = (placementObj.width) + (/(px|%)/i.test(placementObj.width + '') ? '' : 'px');
        }

        wrapper.triggerHandler('popupmenuafterplace', [placementObj]);
        return placementObj;
      },

      /**
       * Calls an external source.
       * @private
       * @param {jQuery.Event} e
       * @param {boolean} doOpen
       * @param {jQuery[]|HTMLElement} [contextElement] - if passed, represents a submenu as the actionable, replaceable menu element instead of the main menu.
       */
      callSource: function (e, doOpen, contextElement) {
        if (typeof this.settings.beforeOpen !== 'function') {
          return;
        }

        var self = this,
          targetMenu = this.menu;

        // Use a different menu, if applicable
        if (Soho.DOM.isElement(contextElement) && $(contextElement).is('.popupmenu, .submenu')) {
          targetMenu = $(contextElement);
        }

        var response = function(content) {
          var existingMenuItems = targetMenu.children();
          existingMenuItems.off().remove();

          if (content === false) {
            return false;
          }

          var newContent = $(content);
          targetMenu.append(newContent);

          var wrapper = targetMenu.parent('.wrapper, .popupmenu-wrapper');
          if (!wrapper.length) {
            wrapper = targetMenu.wrap('<div class="wrapper">').parent();
          }
          wrapper.removeAttr('style');
          self.markupItems(targetMenu);

          if (doOpen) {
            if (!targetMenu.is(self.menu)) {
              self.openSubmenu(wrapper.parent('li'), true);
            } else {
              self.open(e, true);
            }
          }
          return true;

          /*
          if (self.ajaxContent instanceof $) {
            self.ajaxContent.off().remove();
          }

          if (content === false) {
            return false;
          }

          self.ajaxContent = $(content);
          targetMenu.append(self.ajaxContent);

          self.wrapper.removeAttr('style');
          self.markupItems();

          if (doOpen) {
            self.open(e, true);
          }
          return true;
          */
        };

        var callbackOpts = {};
        if (!targetMenu.is(this.menu)) {
          callbackOpts.contextElement = targetMenu;
        }

        if (typeof this.settings.beforeOpen === 'string') {
          window[this.settings.beforeOpen](response, callbackOpts);
          return;
        }

        this.settings.beforeOpen(response, callbackOpts);
        return;
      },

      open: function(e, ajaxReturn) {
        var self = this;

        var canOpen = this.element.triggerHandler('beforeopen', [this.menu]);
        if (canOpen === false) {
          return;
        }

        // Check external AJAX source, if applicable
        if (!ajaxReturn) {
          canOpen = this.callSource(e, true);

          if (this.settings.beforeOpen) {
            return;
          }
        }

        var otherMenus = $('.popupmenu.is-open').filter(function() {
          return $(this).parents('.popupmenu').length === 0;
        }).not(this.menu);  //close others.

        otherMenus.each(function() {
          var trigger = $(this).data('trigger');
          if (!trigger || !trigger.length) {
            return;
          }

          var api = $(this).data('trigger').data('popupmenu');
          if (api && typeof api.close === 'function') {
            api.close();
          }
        });

        this.element.addClass('is-open');
        this.menu.addClass('is-open').attr('aria-hidden', 'false');

        if (this.element.hasClass('inverse')) {
          this.menu.parent('.popupmenu-wrapper').addClass('inverse');
        }

        this.position(e);

        if (this.element.closest('.header').length > 0) {
          this.menu.parent()[0].style.zIndex =  '9001';
        }

        // Check every anchor tag to see if it should be disabled.
        // Use the CSS class on its parent to determine whether or not to disable.
        this.menu.find('a').each(function() {
          var a = $(this),
            li = a.parent();

          if (li.hasClass('is-disabled')) {
            li.addClass('is-disabled');
            a.attr('aria-disabled', 'true');
            a.attr('disabled', 'disabled');
          } else {
            li.removeClass('is-disabled');
            a.removeAttr('aria-disabled');
            a.removeAttr('disabled');
          }
        });

        //Close on Document Click ect..
        setTimeout(function () {
          $(document).on('touchend.popupmenu.' + self.id +' click.popupmenu.' + self.id, function (e) {
            if (e.button === 2) {
              return;
            }

            //Click functionality will toggle the menu - otherwise it closes and opens
            if ($(e.target).is(self.element)) {
              return;
            }

            if ($(e.target).closest('.popupmenu').length === 0) {
              self.close(true, self.settings.trigger ==='rightClick');
            }
          });

          // in desktop environments, close the list on viewport resize
          if (window.orientation === undefined) {
            $('body').on('resize.popupmenu', function() {
              self.close();
            });
          }

          $(window).on('scroll.popupmenu', function () {
            self.close();
          });

          $('.scrollable, .modal.is-visible .modal-body-wrapper').on('scroll.popupmenu', function () {
            self.close();
          });

          self.element.triggerHandler('open', [self.menu]);

          if (self.settings.trigger === 'rightClick') {
            self.element.on('click.popupmenu touchend.popupmenu', function () {
              self.close();
            });
          }
        }, 300);

        //Hide on iFrame Clicks - only works if on same domain
        $('iframe').each(function () {
          var frame = $(this);
          frame.ready(function () {

            try {
              frame.contents().find('body').on('click.popupmenu', function () {
                self.close();
              });
            } catch (e)  {
              //Ignore security errors on out of iframe
            }

          });
        });

        this.handleKeys();

        //hide and decorate submenus - we use a variation on
        var tracker = 0, startY, menuToClose, timeout;

        self.menu.find('.popupmenu').removeClass('is-open');
        self.menu.on('mouseenter.popupmenu touchstart.popupmenu', '.submenu', function (e) {
          var menuitem = $(this);
          startY = e.pageX;

          clearTimeout(timeout);
          timeout = setTimeout(function () {
            self.openSubmenu(menuitem);
          }, 300);

          $(document).on('mousemove.popupmenu.' + this.id, function (e) {
            tracker = e.pageX;
          });
        }).on('mouseleave.popupmenu', '.submenu', function () {
          $(document).off('mousemove.popupmenu.' + this.id);

          menuToClose = $(this).find('ul');

          var hasWrapper = menuToClose.parent('.wrapper').length > 0,
            isLeft = (hasWrapper ? parseInt(menuToClose.parent('.wrapper')[0].style.left) : 0) < 0,
            canClose = (tracker - startY) < 3.5;

          if (isLeft) {
            canClose = (tracker - startY) >= 0;
          }

          if (canClose) { //We are moving slopie to the menu
            menuToClose.removeClass('is-open').removeAttr('style');
            menuToClose.parent('.wrapper').removeAttr('style');
            menuToClose.parent().parent().removeClass('is-submenu-open');
            menuToClose = null;
          }
          clearTimeout(timeout);
        });

        if (self.settings.autoFocus) {
          setTimeout(function () {
            var excludes = ':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)',
              selection = self.menu.children(excludes).find('.is-selected').children('a');

            if (!selection.length) {
              selection = self.menu.children(excludes).first().children('a');
            }

            self.highlight(selection);
            self.element.triggerHandler('afteropen', [self.menu]);
          }, 1);
        }
      },

      openSubmenu: function(li, ajaxReturn) {
        if (Soho.DOM.classNameHas(li[0].className, 'is-disabled') || li[0].disabled) {
          return;
        }

        var submenu = li.children('.wrapper, .popupmenu');
        if (submenu.length && submenu.is('.wrapper')) {
          submenu = submenu.children('.popupmenu');
        }

        var canOpen = this.element.triggerHandler('beforeopen', [submenu]);
        if (canOpen === false) {
          return;
        }

        // Check external AJAX source, if applicable
        if (!ajaxReturn) {
          canOpen = this.callSource(null, true, submenu);
          if (this.settings.beforeOpen) {
            return;
          }
        }

        return this.showSubmenu(li);
      },

      showSubmenu: function (li) {
        // Trigger an event so other components can listen to this element as a popupmenu trigger.
        this.element.triggerHandler('show-submenu', [li]);

        var wrapper = li.children('.wrapper').filter(':first'),
          isRTL = this.isRTL(),
          rtlPadding = 30;

        // Wrap if not wrapped (dynamic menu situation)
        if (wrapper.length === 0) {
          var ul = li.children('ul').filter(':first');
          ul.wrap('<div class="wrapper"></div>');
          wrapper = ul.parent();
        }

        var menu = wrapper.children('.popupmenu'),
          mainWrapperOffset = li.parents('.popupmenu-wrapper:first').offset().top,
          wrapperLeft = li.position().left + li.outerWidth(),
          wrapperWidth = 0;

        li.parent().find('.popupmenu').removeClass('is-open').removeAttr('style');

        wrapper.children('.popupmenu').addClass('is-open');
        wrapperWidth = wrapper.outerWidth();

        if (isRTL) {
          wrapperLeft = li.position().left - wrapperWidth;
        }
        wrapper[0].style.left = wrapperLeft + 'px';
        wrapper[0].style.top = (parseInt(li.position().top) - 5) + 'px';

        //Handle Case where the menu is off to the right
        var menuWidth = menu.outerWidth();
        if ((wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft()) || (isRTL && wrapper.offset().left < 0)) {
          wrapper[0].style.left = '-9999px';
          menuWidth = menu.outerWidth();
          wrapperLeft = li.position().left - menuWidth;

          if (isRTL) {
            var parentMenuWidth = wrapper.closest('.popupmenu').outerWidth();
            wrapperLeft = parentMenuWidth - 4; // Move back across the parent menu
          }
          wrapper[0].style.left = wrapperLeft + 'px';

          // Did it fit?
          if (wrapper.offset().left < 0 || (isRTL && (wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft()))) {
            // No. Push the menu's left offset onto the screen.
            wrapperLeft = li.position().left - menuWidth + Math.abs(wrapper.offset().left) + 40;
            if (isRTL) {
              wrapperLeft = li.position().left - menuWidth - rtlPadding;
            }
            wrapper[0].style.left = wrapperLeft + 'px';
            menuWidth = menu.outerWidth();
          }

          // Do one more check to see if the right edge bleeds off the screen.
          // If it does, shrink the menu's X size.
          if ((wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft()) || (isRTL && wrapper.offset().left < 0)) {
            var differenceY = (wrapper.offset().left + menuWidth) - ($(window).width() + $(document).scrollLeft());
            menuWidth = menuWidth - differenceY;
            menu[0].style.width = menuWidth + 'px';
          }
        }

        //Handle Case where menu is off bottom
        var menuHeight = menu.outerHeight();
        if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
          // First try bumping up the menu to sit just above the bottom edge of the window.
          var bottomEdgeCoord = wrapper.offset().top + menuHeight,
            differenceFromBottomY = bottomEdgeCoord - ($(window).height() + $(document).scrollTop());

          wrapper[0].style.top = (wrapper.position().top - differenceFromBottomY) + 'px';

          // Does it fit?
          if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
            // No. Bump the menu up higher based on the menu's height and the extra space from the main wrapper.
            wrapper[0].style.top = (($(window).height() + $(document).scrollTop()) - menuHeight - mainWrapperOffset) + 'px';
          }

          // Does it fit now?
          if ((wrapper.offset().top - $(document).scrollTop()) < 0) {
            // No. Push the menu down onto the screen from the top of the window edge.
            wrapper[0].style.top = 0;
            wrapper[0].style.top = (wrapper.offset().top * -1) + 'px';
            menuHeight = menu.outerHeight();
          }

          // Do one more check to see if the bottom edge bleeds off the screen.
          // If it does, shrink the menu's Y size and make it scrollable.
          if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
            var differenceX = (wrapper.offset().top + menuHeight) - ($(window).height() + $(document).scrollTop());
            menuHeight = menuHeight - differenceX - 32;
            menu[0].style.height = menuHeight + 'px';
          }
        }

        li.parent().find('.is-submenu-open').removeClass('is-submenu-open');
        li.addClass('is-submenu-open');
      },

      highlight: function(anchor) {
        if (!anchor || !anchor.length) {
          return false;
        }

        var li = anchor.parent();

        li.parent().children('li').removeClass('is-focused');
        li.addClass('is-focused');

        //Prevent chrome from scrolling - toolbar
        anchor.focus();
        li.closest('.header').scrollTop(0);

      },

      // adds/removes checkmarks that are in selectable groups inside the popupmenu
      select: function(anchor) {
        var singleMenu = this.menu.is('.is-selectable'),
          multipleMenu = this.menu.is('.is-multiselectable'),
          singleSection = this.isInSingleSelectSection(anchor),
          multipleSection = this.isInMultiselectSection(anchor),
          parent = anchor.parent(),
          returnObj = [anchor, 'selected'];

        if (!singleMenu && !multipleMenu && !singleSection && !multipleSection) {
          return;
        }

        // If the entire menu is "selectable", place the checkmark where it's supposed to go.
        if (singleMenu || singleSection) {
          parent.prevUntil('.heading, .separator').add(parent.nextUntil('.heading, .separator')).removeClass('is-checked');
          parent.addClass('is-checked');
          return returnObj;
        }

        if (multipleMenu || multipleSection) {
          if (parent.hasClass('is-checked')) {
            returnObj[1] = 'deselected';
            parent.removeClass('is-checked');
            return returnObj;
          }
          parent.addClass('is-checked');
          return returnObj;
        }
      },

      getSelected: function() {
        if (!this.menu.is('.is-selectable, .is-multiselectable')) {
          return $();
        }

        return this.menu.children('.is-checked').children('a');
      },

      isInSelectableSection: function(anchor) {
        var separator = anchor.parent().prevAll().filter('.separator').first();
        return (separator.hasClass('multi-selectable-section') || separator.hasClass('single-selectable-section'));
      },

      isInSingleSelectSection: function(anchor) {
        return anchor.parent().prevAll().filter('.separator').first().hasClass('single-selectable-section');
      },

      isInMultiselectSection: function(anchor) {
        return anchor.parent().prevAll().filter('.separator').first().hasClass('multi-selectable-section');
      },

      detach: function () {
        $(document).off('touchend.popupmenu.' + this.id +' click.popupmenu.' + this.id +' keydown.popupmenu');
        $(window).off('scroll.popupmenu orientationchange.popupmenu');
        $('body').off('resize.popupmenu');
        $('.scrollable').off('scroll.popupmenu');

        this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');

        if (this.settings.trigger === 'rightClick') {
          this.element.off('click.popupmenu touchend.popupmenu');
        }

        $('iframe').each(function () {
          var frame = $(this);
          try {
            frame.contents().find('body').off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');
          } catch (e) {
            //Ignore security errors on out of iframe
          }
        });
      },

      /**
       * Close the open menu
       * @param {Boolean} isCancelled  &nbsp;-&nbsp; Internally set option used if the operation is a cancel. Wont matter for manual api call.
       * @param {Boolean} noFocus  &nbsp;-&nbsp; Do not return focus to the calling element (fx a button)
       */
      close: function (isCancelled, noFocus) {
        if (!isCancelled || isCancelled === undefined) {
          isCancelled = false;
        }

        if (!this.menu.hasClass('is-open')) {
          return;
        }

        var self = this,
          wrapper = this.menu.parent('.popupmenu-wrapper'),
          menu = this.menu.find('.popupmenu');

        this.menu.removeClass('is-open').attr('aria-hidden', 'true');
        if (this.menu[0]) {
          this.menu[0].style.height = '';
          this.menu[0].style.width = '';
        }

        if (wrapper[0]) {
          wrapper[0].style.left = '-999px';
          wrapper[0].style.height = '';
          wrapper[0].style.width = '';
        }

        this.menu.find('.submenu').off('mouseenter mouseleave').removeClass('is-submenu-open');
        if (menu[0]) {
          menu[0].style.left = '';
          menu[0].style.top = '';
          menu[0].style.height = '';
          menu[0].style.width = '';
        }

        this.menu.find('.is-focused').removeClass('is-focused');

        // Close all events
        $(document).off('keydown.popupmenu.' + this.id + ' click.popupmenu.' + this.id + ' mousemove.popupmenu.' + this.id);
        this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu mouseenter.popupmenu mouseleave.popupmenu');

        this.element.removeClass('is-open').triggerHandler('close', [isCancelled]);
        this.detach();

        if (this.settings.trigger === 'immediate') {
          this.destroy();
        }

        if (noFocus) {
          return;
        }

        if (this.settings.returnFocus) {
          self.element.removeClass('hide-focus').focus();
        }
      },

      teardown: function() {
        var wrapper = this.menu.parent('.popupmenu-wrapper');

        if (this.ajaxContent) {
          this.ajaxContent.off().remove();
        }

        this.menu.parent().off('contextmenu.popupmenu');
        if (this.element.hasClass('btn-actions')) {
          this.menu.parent().removeClass('bottom').find('.arrow').remove();
        }

        this.menu.off('dragstart.popupmenu');

        if (this.originalParent) {
          this.menu.appendTo(this.originalParent);
        } else {
          // TODO: Fix when we have time - shouldn't be referencing other controls here
          var insertTarget = this.element,
            searchfield = this.element.parent().children('.searchfield');
          if (searchfield.length) {
            insertTarget = searchfield.first();
          }

          this.menu.insertAfter(insertTarget);
        }

        this.menu.find('.submenu').children('a').each(function(i, item) {
          var text = $(item).find('span').text();
          $(item).find('span, svg').remove();
          $(item).text(text);
        });

        function unwrapPopup(menu) {
          var wrapper = menu.parent();
          if (wrapper.is('.popupmenu-wrapper, .wrapper')) {
            if (wrapper.data('place')) {
              wrapper.data('place').destroy();
            }
            menu.unwrap();
          }
        }

        // Unwrap submenus
        this.menu.find('.popupmenu').each(function() {
          unwrapPopup($(this));
        });

        if (wrapper.data('place')) {
          wrapper.data('place').destroy();
        }
        wrapper.off().remove();

        if (this.matchMedia) {
          this.matchMedia.removeListener(this.mediaQueryListener);
        }

        if (this.menu[0]) {
          $.removeData(this.menu[0], 'trigger');
        }

        this.detach();
        this.element
          .removeAttr('aria-controls')
          .removeAttr('aria-haspopup')
          .off('touchend.popupmenu touchcancel.popupmenu click.popupmenu keydown.popupmenu keypress.popupmenu contextmenu.popupmenu updated.popupmenu');

        return this;
      },

      updated: function() {
        this.teardown().init();
      },

      /**
       * Teardown markup and detach all events.
       */
      destroy: function() {
        this.close();
        this.teardown();
        this.menu.trigger('destroy');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        }
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new PopupMenu(this, settings));
      }
    });
  };


  $.fn.progress = function(options) {

    // Settings and Options
    var pluginName = 'progress',
        defaults = {
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Progress Component displays loading information.
    *
    * @class Progress
    * @param None
    */
    function Progress(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Progress Code
    Progress.prototype = {

      init: function() {
        var self = this;
        self.update();

        this.element.off('updated.progress').on('updated.progress', function (e) {
          e.stopPropagation();
          self.update();
        });
      },

      updateAria: function (value) {
        this.element.attr({'role': 'progressbar', 'aria-valuenow': value, 'aria-maxvalue':'100'});

        var container = this.element.parent();
        if (container.data('tooltip')) {
          container.data('tooltip').content = value + '%';
        } else {
          container.attr('title', value + '%').tooltip();
        }
      },

      /**
      * Update the progress bar.
      *
      * @param {String} value  &nbsp;-&nbsp; The percent value to use to fill. 0-100
      */
      update: function (value) {

        var perc = this.element.attr('data-value');

        if (value) {
          perc = value;
          this.element.attr('data-value', value);
        }

        this.element[0].style.width = perc + '%';
        this.updateAria(perc);
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('updated.progress');
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Progress(this, settings));
      }
    });
  };


  $.fn.multiselect = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'multiselect',
        defaults = {
          filterMode: 'contains',
          maxSelected: undefined,
          moveSelected: 'all',
          showEmptyGroupHeaders: false,
          showSelectAll: false,
          source: undefined
        },
        settings = $.extend({}, defaults, options);

    /**
    * The MultiSelect Component allows selecting multiple items from a list
    *
    * @class MultiSelect
    * @param {String} filterMode  &nbsp;-&nbsp; The search mode to use, can be 'contains' or 'startsWith'
    * @param {Number} maxSelected  &nbsp;-&nbsp; The max number of items which can be selected
    * @param {String} moveSelected  &nbsp;-&nbsp;  Move selected options in each group to just underneath their corresponding group headers.
    * @param {Boolean} showEmptyGroupHeaders  &nbsp;-&nbsp; If true groups with no items will still show the empty group header.
    * @param {Boolean} showSelectAll  &nbsp;-&nbsp; Show the select all text/option.
    * @param {Function} source  &nbsp;-&nbsp; The calback for ajax.
    *
    */
    function MultiSelect(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    MultiSelect.prototype = {

      init: function() {
        this.build();
      },

      build: function() {
        var ddOpts = {
            closeOnSelect: false,
            empty: true,
            moveSelected: 'all',
            multiple: true
          };

        if (this.settings.filterMode) {
          ddOpts.filterMode = this.settings.filterMode;
        }

        if (this.settings.source) {
          ddOpts.source = this.settings.source;
        }

        if (this.settings.maxSelected) {
          ddOpts.maxSelected = this.settings.maxSelected;
        }

        if (this.settings.moveSelected) {
          ddOpts.moveSelected = this.settings.moveSelected;
        }

        if (this.settings.showEmptyGroupHeaders) {
          ddOpts.showEmptyGroupHeaders = this.settings.showEmptyGroupHeaders;
        }

        if (this.settings.showSelectAll) {
          ddOpts.showSelectAll = this.settings.showSelectAll;
        }

        this.element.dropdown(ddOpts);
        this.dropdown = this.element.data('dropdown');

        return this;
      },

      /**
      * Enable the multiselect input
      */
      enable: function() {
        this.dropdown.enable();
      },

      /**
      * Disable the multiselect input
      */
      disable: function() {
        this.dropdown.disable();
      },

      /**
      * Trigger a rebuild due to settings change
      */
      updated: function() {
        this.build();
      },

      /**
      * Remove added markup and events
      */
      destroy: function() {
        this.dropdown.destroy();
        this.element.off();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new MultiSelect(this, settings));
      }
    });
  };


  $.fn.message = function(options) {

    // Settings and Options
    var pluginName = 'message',
      defaults = {
          title: 'Message Title',
          isError: false,
          message: 'Message Summary',
          width: 'auto',
          buttons: null,
          cssClass: null,
          returnFocus: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Message Component is used to show warning / error messages.
    *
    * @class Message
    * @param {String} title  &nbsp;-&nbsp; Title text or content shown in the message
    * @param {Boolean} isError  &nbsp;-&nbsp; If true, will show title styled as an error with an error icon
    * @param {String} message  &nbsp;-&nbsp; The message content or text
    * @param {Number} width  &nbsp;-&nbsp; Pass a specific with or defaults to auto
    * @param {Object} buttons  &nbsp;-&nbsp; Array of buttons to add to the message (see modal examples as well)
    * @param {String} cssClass  &nbsp;-&nbsp; Extra Class to add to the dialog for customization.
    * @param {String} returnFocus  &nbsp;-&nbsp; JQuery Element selector to focus on return
    *
    */
    function Message(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Message.prototype = {

      init: function() {
        var self = this,
          content;

        //Create the Markup
        this.message = $('<div class="modal message"></div>');
        this.messageContent = $('<div class="modal-content"></div>');
        this.title = $('<h1 class="modal-title" id="message-title">' + settings.title + '</h1>').appendTo(this.messageContent).wrap('<div class="modal-header"></div>');
        this.content = $('<div class="modal-body"><p class="message" id="message-text">'+ settings.message +'</p></div>').appendTo(this.messageContent);

        //Append The Content if Passed in
        if (!this.element.is('body')) {
          content = this.element;
          this.content.empty().append(content.show());
        }

        this.message.append(this.messageContent).appendTo('body');
        this.message.modal({trigger: 'immediate', buttons: settings.buttons,
          resizable: settings.resizable, close: settings.close, isAlert: true});

        //Adjust Width if Set as a Setting
        if (settings.width !== 'auto') {
          this.content.closest('.modal')[0].style.maxWidth = 'none';
          this.content.closest('.modal')[0].style.width = settings.width + (/(px|%)/i.test(settings.width + '') ? '' : 'px');
        }

        if (settings.cssClass) {
          this.message.addClass(settings.cssClass);
        }

        //Setup the destroy event to fire on close.  Needs to fire after the "close" event on the modal.
        this.message.on('beforeclose.message', function () {
          var ok = self.element.triggerHandler('beforeclose');
          return ok;
        }).on('beforeopen.message', function () {
          var ok = self.element.triggerHandler('beforeopen');
          return ok;
        }).on('open.message', function () {
          self.element.trigger('open');
        }).on('afterclose.message', function() {
          self.destroy();
          if (settings.returnFocus) {
            settings.returnFocus.focus();
          }

          $(document).off('keypress.message keydown.message');
        });

        $(document).on('keypress.message keydown.message', function (e) {
          var keyCode = e.which || e.keyCode;

          if (keyCode === 27) {
            setTimeout(function () {
              var modalData = self.message.data('modal');
              if (modalData !== undefined) {
                modalData.close();
              }
            }, 0);
          }
        });

        if (settings.isError) {
          this.title.addClass('is-error').prepend($.createIconElement('error'));
        } else {
          this.title.removeClass('is-error').find('svg').remove();
        }
      },

      /**
       * Tear Down and destroy events. However the message will destroy itself on close.
       **/
      destroy: function() {
        var modalData = this.message.data('modal');
        if (modalData !== undefined) {
          modalData.destroy();
        }

        this.message
          .off('beforeclose.message beforeopen.message open.message afterclose.message')
          .remove();
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      new Message(this, settings);
    });
  };


  $.fn.modal = function(options) {

    // Settings and Options
    var pluginName = 'modal',
      defaults = {
        trigger: 'click', //Supports click, immediate
        buttons: null,  //Pass in the Buttons
        isAlert: false, //Adds alertdialog role
        content: null, //Ability to pass in dialog html content
        cssClass: null,  //Append a css class to top level
        autoFocus: true,
        id: null,  //Optionally tag a dialog with an id
        frameHeight: 180, //Extra Height
        frameWidth: 46 //Extra Width
      },
      settings = $.extend({}, defaults, options);

    /**
     * Responsive and Accessible Modal Control
     * @constructor
     * @param {Object} element
     */
    function Modal(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
      this.reStructure();
    }

    // Actual Plugin Code
    Modal.prototype = {
      init: function() {
        var self = this;

        // Used for tracking events tied to the Window object
        this.id = (parseInt($('.modal').length, 10)+1);
        this.trigger = $('button[data-modal="' + this.element.attr('id') + '"]');  //Find the button with same dialog ID
        this.overlay = $('<div class="overlay"></div>');
        this.oldActive = this.trigger;

        if (this.settings.trigger === 'click') {
          this.trigger.on('click.modal', function() {
            self.open();
          });
        }

        if (this.settings.trigger === 'immediate') {
          setTimeout(function() {
            self.open();
          }, 1);
        }

        self.isCancelled = false;

        if (window.history && window.history.pushState) {
          $(window).off('popstate.modal');

          $(window).on('popstate.modal', function() {
            self.destroy();
          });
        }

        //ensure is appended to body for new dom tree
        if (this.settings.content) {

          this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
          this.appendContent();
          setTimeout(function () {
            self.open();
          }, 1);
          return;
        }

        self.addButtons(this.settings.buttons);
        this.element.appendTo('body');
        this.element[0].style.display = 'none';
      },

      appendContent: function () {
        var isAppended = false;

        this.element = $(
          '<div class="modal">' +
            '<div class="modal-content">'+
              '<div class="modal-header"><h1 class="modal-title">'+ this.settings.title +'</h1></div>' +
              '<div class="modal-body-wrapper">'+
                '<div class="modal-body"></div>'+
              '</div>'+
            '</div>'+
          '</div>');

        if (this.settings.id) {
          this.element.attr('id', this.settings.id);
        }

        if ($(this.settings.content).is('.modal')) {
          this.element = $(this.settings.content);
        } else if (this.settings.content && this.settings.content.length > 0) {

          if (this.settings.content instanceof jQuery && this.settings.content.parent().is('.modal-body')) {
            isAppended = true;
            this.element = this.settings.content.closest('.modal');
          } else {
            this.element.find('.modal-body').append(this.settings.content);
          }

          if (this.settings.content instanceof jQuery){
            this.settings.content.show();
          }
        }

        if (!isAppended) {
          this.element.appendTo('body');
        }

        if (this.settings.cssClass) {
          this.element.addClass(this.settings.cssClass);
        }

        if (this.settings.title) {
          this.element.find('.modal-title').text(this.settings.title);
        }

        if (!isAppended) {
          this.addButtons(this.settings.buttons);
        }

        Soho.utils.fixSVGIcons(this.element);
      },

      reStructure: function() {
        var body = $('.modal-body', this.element),
          hr = $('hr:first-child', body),
          buttonset = $('.modal-buttonset', this.element);

        if (body && body.length && !body.parent().hasClass('modal-body-wrapper')) {
          body.wrap('<div class="modal-body-wrapper"></div>');
        }
        if (hr && hr.length && !hr.parent().hasClass('modal-content')) {
          hr.insertAfter(this.element.find('.modal-header'));
        }
        if (buttonset && buttonset.length && !buttonset.parent().hasClass('modal-content')) {
          buttonset.insertAfter(this.element.find('.modal-body-wrapper'));
        }

      },

      disableSubmit: function () {
        var body = this.element,
          fields = body.find('[data-validate]:visible'),
          inlineBtns = body.find('.modal-buttonset button'),
          primaryButton = inlineBtns.filter('.btn-modal-primary').not('.no-validation');

        if (fields.length > 0) {
          primaryButton.removeAttr('disabled');

          var allValid = true;
          fields.each(function () {

            var field = $(this);
            if (field.closest('.datagrid-filter-wrapper').length > 0) {
              return;
            }

            var isVisible = field[0].offsetParent !== null;

            if (field.is('.required')) {
              if (isVisible && !field.val()) {
                allValid = false;
              }
            } else {
              field.checkValidation();
              if (isVisible && !field.isValid()) {
                allValid = false;
              }

            }

            if (allValid) {
              primaryButton.removeAttr('disabled');
            }
          });

          if (!allValid && !primaryButton.is(':disabled')) {
             primaryButton.attr('disabled', 'true');
          }
        }

      },

      addButtons: function(buttons) {
        var self = this,
          body = this.element.find('.modal-body'),
          bodywrapper = body.parent(),
          btnWidth = 100,
          isPanel = false,
          buttonset;

        this.modalButtons = buttons;

        if (!buttons) {
          var inlineBtns = this.element.find('.modal-buttonset button');
          // Buttons in markup
          btnWidth = 100/inlineBtns.length;
          for (var i = 0, l = inlineBtns.length; i < l; i++) {
            inlineBtns[i].style.width = btnWidth + '%';
          }
          inlineBtns.button();
          inlineBtns.not('[data-ng-click], [ng-click], [onclick], :submit').on('click.modal', function (e) {
            if ($(e.target).is('.btn-cancel')) {
              self.isCancelled = true;
            }
            self.close();
          });
          return;
        }

        if (this.element.is('.contextual-action-panel')) {
          isPanel = true;
          // construct the toolbar markup if a toolbar isn't found
          buttonset = this.element.find('.buttonset');
          if (!buttonset.length) {
            var toolbar = this.element.find('.toolbar');
            if (!toolbar.length) {
              $('<div class="toolbar"></div>').appendTo(this.element.find('.modal-header'));
            }
            buttonset = $('<div class="buttonset"></div>').appendTo(this.element.find('.toolbar'));
          }
        } else {
          buttonset = this.element.find('.modal-buttonset');
          if (!buttonset.length) {
            buttonset = $('<div class="modal-buttonset"></div>').insertAfter(bodywrapper);
          }
        }

        btnWidth = 100/buttons.length;

        if (buttons) {
          buttonset.empty();
        }

        var decorateButtons = function(props, cnt) {

          var btn = $('<button type="button"></button>');
          btn.text(props.text);
          btn.attr('type', props.type || 'button');

          if (props.cssClass === 'separator') {
            btn = $('<div class="separator"></div>');
          }

          if (props.cssClass) {
            btn.attr('class', props.cssClass);
          } else {
            if (props.isDefault) {
              btn.addClass('btn-modal-primary');
            } else {
              btn.addClass('btn-modal');
            }
          }

          if (props.validate !== undefined && !props.validate) {
            btn.addClass('no-validation');
          }

          var attrs = {},
            attrTypes = ['id', 'name', 'text'];

          for (var k = 0; k < attrTypes.length; k++) {
            if (props[attrTypes[k]]) {
              attrs[attrTypes[k]] = props[attrTypes[k]];
            }
          }

          if (props.type === 'input') {
            var label = $('<label class="audible" for="filter">' + props.text + '</label>'),
              input = $('<input class="searchfield">').attr(attrs);

            buttonset.append(label, input);
            return;
          }

          if (props.icon && props.icon.charAt(0) === '#') {
            btn.html('<span>' + btn.text() + '</span>');
            $.createIconElement({
              classes: [props.icon === '#icon-close' ? 'icon-close' : ''],
              icon: props.icon.substr('#icon-'.length)
            }).prependTo(btn);
          }

          btn.attr('id', props.id || $.fn.uniqueId('button', 'modal'));

          var func = buttons[cnt].click;

          btn.on('click.modal', function(e) {
            if (func) {
              func.apply(self.element[0], [e, self]);
              return;
            }
            self.close();
          });

          if (!isPanel) {
            btn[0].style.width = btnWidth + '%';
          }

          btn.button();
          buttonset.append(btn);

        };

        for (var cnt = 0; cnt < buttons.length; cnt++) {
          decorateButtons(buttons[cnt], cnt);
        }

      },

      sizeInner: function () {
        var messageArea;
        messageArea = this.element.find('.detailed-message');
        //Set a max width
        var h = $(window).height() - messageArea.offset().top - 150;
        messageArea[0].style.maxHeight = h + 'px';
        messageArea[0].style.overflow = 'auto';
        messageArea[0].style.width = messageArea.width() + 'px';
      },

      open: function () {
        var self = this, messageArea,
          elemCanOpen = true;

        if (!this.trigger || this.trigger.length ===0) {
          this.oldActive = $(':focus');  //Save and restore focus for A11Y
        }

        this.element.after(this.overlay);
        if (this.element && !this.element.parent().hasClass('modal-wrapper')) {
          this.element.wrap('<div class="modal-page-container"><div class="modal-wrapper"></div>');
        }
        this.root = this.element.closest('.modal-page-container');

        messageArea = self.element.find('.detailed-message');
        if (messageArea.length === 1) {
          $('body').on('resize.modal-' + this.id, function () {
            self.sizeInner();
          });
          self.sizeInner();
        }

        elemCanOpen = this.element.triggerHandler('beforeopen');
        self.isCancelled = false;

        if (elemCanOpen === false) {
          self.overlay.remove();
          self.root[0].style.display = 'none';
          return false;
        }

        //Look for other nested dialogs and adjust the zindex.
        $('.modal').each(function (i) {
          var modal = $(this);
          this.style.zIndex = (1020 + (i + 1)).toString();

          if (modal.data('modal') && modal.data('modal').overlay) {
            modal.data('modal').overlay[0].style.zIndex = (1020 + i).toString();
          }

          if (!modal.data('modal')) {
            var overlay = modal.closest('.modal-page-container').next('.overlay');
            if (overlay && overlay[0]) {
              overlay[0].style.zIndex = (1020 + i).toString();
            }
          }
        });

        $('body > *').not(this.element).not('.modal, .overlay, .modal-page-container').attr('aria-hidden', 'true');

        // Ensure aria-labelled by points to the id
        if (this.settings.isAlert) {
          this.element.attr('aria-labeledby', 'message-title');
          this.element.attr('aria-describedby', 'message-text');
        } else {
          var h1 = this.element.find('h1:first'),
            id = h1.attr('id');

          if (!id) {
            id = (this.element.attr('id') ? this.element.attr('id') : 'h1')  + '-title';
            h1.attr('id', id);
          }

          var body = this.element.find('.modal-body'),
            descById = (this.element.attr('id') ? this.element.attr('id') : 'message') + '-text';

          this.element.attr('aria-labeledby', id);

          //Contextual Action Panel Case - Has a toolbar
          if (this.element.find('.toolbar .title').length) {
            this.element.find('.toolbar .title').attr('id', descById);
            this.element.attr('aria-describedby', descById);
          } else {
            body.attr('id', descById);
            this.element.attr('aria-describedby', descById);
          }

        }

        this.mainContent = $('body').children('.scrollable-container');
        if (!this.mainContent.length) {
          this.mainContent = $('body');
        }

        this.removeNoScroll = !this.mainContent.hasClass('no-scroll');
        this.mainContent.addClass('no-scroll');

        $('body').on('resize.modal-' + this.id, function() {
          self.resize();
        });

        //Center
        this.root[0].style.display = '';
        this.element[0].style.display = '';

        setTimeout(function() {
          self.resize();
          self.element.addClass('is-visible').attr('role', (self.settings.isAlert ? 'alertdialog' : 'dialog'));
          self.root.attr('aria-hidden', 'false');
          self.overlay.attr('aria-hidden', 'true');
          self.element.attr('aria-modal', 'true'); //This is a forward thinking approach, since aria-modal isn't actually supported by browsers or ATs yet
        }, 1);

        // Add the 'modal-engaged' class after all the HTML markup and CSS classes have a chance to be established
        // (Fixes an issue in non-V8 browsers (FF, IE) where animation doesn't work correctly).
        // http://stackoverflow.com/questions/12088819/css-transitions-on-new-elements
        $('body').addClass('modal-engaged');

        //Handle Default button.
        $(this.element).on('keypress.modal', function (e) {
          var target = $(e.target);

          if (target.is('.searchfield') || target.is('textarea') || target.is(':button') || target.is('.dropdown') || target.closest('.tab-list').length) {
            return;
          }

          if (e.which === 13 && self.isOnTop() &&
              !target.closest('form').find(':submit').length &&
              self.element.find('.btn-modal-primary:enabled').length) {

            e.stopPropagation();
            e.preventDefault();
            self.element.find('.btn-modal-primary:enabled').trigger('click');
          }
        });

        // Override this page's skip-link default functionality to instead focus the top
        // of this element if it's clicked.
        $('.skip-link').on('focus.modal', function(e) {
          e.preventDefault();
          self.getTabbableElements().first.focus();
        });

        function focusElement() {
          var focusElem = self.element.find(':focusable').not('.modal-header .searchfield').first();
          self.keepFocus();
          self.element.trigger('open', [self]);

          if (focusElem.length === 0) {
            focusElem = self.element.find('.btn-modal-primary');
          }

          if (focusElem.length === 1 && focusElem.is('.btn-modal')) {
            focusElem = self.element.find('.btn-modal-primary');
          }

          if (focusElem.length === 1 && focusElem.is('button') && !focusElem.is(':disabled')) {
            focusElem.addClass('hide-focus');
          }

          if (!self.settings.autoFocus) {
            return;
          }

          // If the selected element is a tab, actually make sure it's the "selected" tab.
          var selected, tabParent;
          if (focusElem.is('.tab:not(.is-selected) a')) {
            tabParent = focusElem.closest('.tab-container');
            selected = tabParent.find('.is-selected');
            if (selected.length) {
              focusElem = selected;
              tabParent.data('tabs').select(selected.children('a').attr('href'));
              return;
            }
          }

          // Otherwise, just focus
          focusElem.focus();

        }

        var pagerElem = self.element.find('.paginated');
        pagerElem.on('afterpaging', function () {
          self.resize();
        });

        setTimeout(function () {
          self.disableSubmit();
        }, 10);

        var fields = this.element.find('[data-validate]');
        fields.removeClass('disable-validation');

        setTimeout(function () {
          focusElement();
        }, 200);

        setTimeout(function () {
          self.element.trigger('afteropen');
        }, 300);

      },

      resize: function() {
        var calcHeight = ($(window).height()* 0.9)-this.settings.frameHeight, //90% -(180 :extra elements-height)
          calcWidth = ($(window).width()* 1)-this.settings.frameWidth;

        var wrapper = this.element.find('.modal-body-wrapper');

        //Remove width for backwards compat
        this.element.find('.modal-contents').css('width', '');

        if (wrapper.length) {
          wrapper[0].style.maxHeight = calcHeight + 'px';
          wrapper[0].style.maxWidth = calcWidth + 'px';
        }

        if (this.element.hasClass('lookup-modal')) {
          var table = this.element.find('.datagrid-body'),
            hasPager = this.element.find('.pager-toolbar'),
            container = table.closest('.datagrid-container');

          calcHeight = calcHeight - (container.prev().is('.toolbar') ? 130 : 60) - (container.next().is('.pager-toolbar') ? 35 : 0);
          table[0].style.maxHeight = calcHeight + (hasPager.length ? -15 : 0) + 'px';
          table[0].style.maxWidth = calcWidth + 'px';
        }

      },

      isOpen: function() {
        return this.element.is('.is-visible');
      },

      isOnTop: function () {
        var max = 0,
          dialog = this.element;

        $('.modal.is-visible').each(function () {
          var zIndex = this.style.zIndex;
          if (max < zIndex) {
            max = zIndex;
          }
        });

        return max === dialog[0].style.zIndex;
      },

      getTabbableElements: function() {
        var allTabbableElements = $(this.element).find('a[href], area[href], input:not([disabled]),' +
          'select:not([disabled]), textarea:not([disabled]),' +
          'button:not([disabled]), iframe, object, embed, *[tabindex],' +
          '*[contenteditable]').filter(':visible');
        return {
          first: allTabbableElements[0],
          last: allTabbableElements[allTabbableElements.length - 1]
        };
      },

      keepFocus: function() {
        var self = this, tabbableElements;

        // Escape key
        $(document).on('keyup.modal', function (e) {
          var keyCode = e.which || e.keyCode;
          if (keyCode === 27) {
            var modals = $('.modal.is-visible'),
              doAction = function(api) {
                if (!api.element.data('listclosed')) {
                  api.close();
                }
                setTimeout(function() {
                  api.element.removeData('listclosed');
                }, 0);
              };
            if (modals.length > 1) {
              modals.not(':last').on('beforeclose.modal', function () {
                return false;
              });
              modals.on('afterclose.modal', function () {
                modals.off('beforeclose.modal');
              });
              var apiModal = modals.last().data('modal');
              if (apiModal && apiModal.close) {
                doAction(apiModal);
              }
            } else {
              doAction(self);
            }
          }
        });

        $(self.element).on('keypress.modal keydown.modal', function (e) {
          var keyCode = e.which || e.keyCode;

          if (keyCode === 9) {
            tabbableElements = self.getTabbableElements();

            // Move focus to first element that can be tabbed if Shift isn't used
            if (e.target === tabbableElements.last && !e.shiftKey) {
              e.preventDefault();
              tabbableElements.first.focus();
            } else if (e.target === tabbableElements.first && e.shiftKey) {
              e.preventDefault();
              tabbableElements.last.focus();
            }

            self.element.find('#message-title').removeAttr('tabindex');
          }

        });
      },

      close: function (destroy) {
        if (!this.isOpen()) {
          return true;
        }

        var elemCanClose = this.element.triggerHandler('beforeclose'),
          self = this,
          fields = this.element.find('[data-validate]');

        this.root = this.element.closest('.modal-page-container');
        fields.addClass('disable-validation');

        if (elemCanClose === false) {
          return false;
        }

        if (this.mainContent && this.removeNoScroll) {
          this.mainContent.removeClass('no-scroll');
        }
        $('body').off('resize.modal-' + this.id);

        this.element.off('keypress.modal keydown.modal');
        this.element.removeClass('is-visible');

        this.overlay.attr('aria-hidden', 'true');
        if (this.root) {
          this.root.attr('aria-hidden', 'true');
        }

        if ($('.modal-page-container[aria-hidden="false"]').length < 1) {
          $('body').removeClass('modal-engaged');
          $('body > *').not(this.element.closest('.modal-page-container')).removeAttr('aria-hidden');
          $('.overlay').remove();
        }

        //Fire Events
        self.element.trigger('close', self.isCancelled);

        // Restore focus
        if (this.oldActive && $(this.oldActive).is('a:visible, button:visible, input:visible, textarea:visible')) {
          this.oldActive.focus();
          this.oldActive = null;
        } else if (this.trigger.parents('.toolbar, .formatter-toolbar').length < 1) {
          this.trigger.focus();
        }

        //close tooltips
        $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');

        // remove the event that changed this page's skip-link functionality in the open event.
        $('.skip-link').off('focus.modal');

        setTimeout( function() {
          self.overlay.remove();
          self.root[0].style.display = 'none';
          self.element.trigger('afterclose');

          if (self.settings.trigger === 'immediate' || destroy) {
            self.destroy();
          }
        }, 300); // should match the length of time needed for the overlay to fade out
      },

      // NOTE: Destroy method needs to function as a callback to be cancellable
      destroy: function() {
        var self = this,
          canDestroy = this.element.trigger('beforedestroy');

        if (!canDestroy) {
          return;
        }

        function destroyCallback() {
          if (self.modalButtons) {
            self.element.find('button').off('click.modal');
          }

          if (self.element.find('.detailed-message').length === 1) {
            $('body').off('resize.modal-' + this.id);
          }

          if (self.settings.trigger === 'click') {
            self.trigger.off('click.modal');
          }

          self.element.closest('.modal-page-container').remove();
          $.removeData(self.element[0], 'modal');

          $(window).off('popstate.modal');
        }

        if (!this.isOpen()) {
          destroyCallback();
          return;
        }

        this.element.one('afterclose.modal', function() {
          destroyCallback();
        });

        this.close(true);
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      var instance = $.data(this, pluginName),
        elem = $(this);

      if (!elem.is('.modal')) {
        instance = elem.closest('.modal').data(pluginName);
      }

      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        }
        instance.settings = $.extend({}, instance.settings, options);

        if (settings.trigger === 'immediate') {
          instance.open();
        }
        return;
      }

      instance = $.data(this, pluginName, new Modal(this, settings));
    });
  };


  $.fn.rating = function(options) {

     // Tab Settings and Options
    var pluginName = 'rating',
        defaults = {},
        settings = $.extend({}, defaults, options);

    function Rating(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Rating Code
    Rating.prototype = {
      init: function() {
        this.handleEvents();
        this.allInputs = this.element.find('input');
        this.readonly();
      },
      handleEvents: function () {
        var self = this;

        $('input', self.element).each(function(index) {
          $(this).on('change', function () {
            if (!self.element.hasClass('is-readonly')) {
              self.val(index + 1);
            }
          });
        });
      },
      val: function(value) {
        var i, chkIdx, self = this;
        if (!value) {
          return this.currentValue;
        }

        this.currentValue = parseFloat(value, 10);
        chkIdx = Math.round(this.currentValue);

        for (i = 0; i < this.allInputs.length; i++) {
          var input = $(this.allInputs[i]),
            svgSelector = input.parent().is('.inline') ? 'svg' : 'label';

          if (i < value) {
            input.addClass('is-filled').removeClass('is-half');
          } else {
            input.removeClass('is-filled').removeClass('is-half');
          }

          //Handle Half Star
          input.next(svgSelector).find('svg').changeIcon('star-filled');

          if (i+1 === chkIdx) {
            input.prop('checked', true);
          }

          if (chkIdx !== self.currentValue && i+1 === chkIdx) {
           input.addClass('is-half').next(svgSelector).find('svg').changeIcon('star-half');
          }
        }
        if (chkIdx <= 0) {
          $(this.allInputs[0]).prop('checked', true);
        }

        return this.currentValue;
      },
      readonly: function() {
        var elem = $(this.element);
        if (elem.hasClass('is-readonly')) {
          elem.find('input').attr('disabled','');
        }
      },
      enable: function() {
        var elem = $(this.element);
        elem.removeClass('is-readonly').find('input').removeAttr('disabled');
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Rating(this, settings));
      }
    });
  };


  $.fn.searchfield = function(options) {
    'use strict';

    if (!options) {
      options = {};
    }

    // Settings and Options
    var pluginName  = 'searchfield',
        defaults = {
          resultsCallback: undefined,
          allResultsCallback: undefined,
          showAllResults: true,
          showGoButton: false,
          goButtonCopy: Locale.translate('Go') || 'Go',
          goButtonAction: undefined, // if defined as a function, will fire this callback on the Go Button "click"
          categories: undefined, // If defined as an array, displays a dropdown containing categories that can be used to filter results.
          categoryMultiselect: false, // If true, creates a multiselectable Categories list
          showCategoryText: false, // If true, will show any available categories that are selected to the left of the Dropdown field.
          source: undefined,
          template: undefined, // Template that can be passed
          clearable: false //Has an X to clear
        },
        settings = $.extend({}, defaults, options);

    /**
     * Searchfield Control
     * @constructor
     * @param {Object} element
     */
    function SearchField(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    SearchField.prototype = {
      /**
       * Initialization Kickoff
       * @returns {this}
       */
      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.build().setupEvents();
      },

      /**
       * Builds the markup for this component.
       * @private
       * @returns {this}
       */
      build: function() {
        this.optionsParseBoolean();
        this.label = this.element.prev('label, .label');

        // Invoke Autocomplete and store references to that and the popupmenu created by autocomplete.
        // Autocomplete settings are fed the same settings as Searchfield
        if (this.settings.source || this.element.attr('data-autocomplete')) {
          this.element.autocomplete(this.settings);
        }
        this.autocomplete = this.element.data('autocomplete');

        //Prevent browser typahead
        this.element.attr('autocomplete','off');

        this.wrapper = this.element.parent('.searchfield-wrapper');
        if (!this.wrapper || !this.wrapper.length) {
          if (this.isInlineLabel) {
            this.wrapper = this.inlineLabel.addClass('searchfield-wrapper');
          }
          else {
            this.wrapper = this.element.wrap('<span class="searchfield-wrapper"></span>').parent();
          }

          // Label for toolbar-inlined searchfields needs to be inside the wrapper to help with positioning.
          if (this.element.closest('.toolbar').length) {
            this.label.prependTo(this.wrapper);
          }

          var customClasses = ['context', 'alternate'],
            c;
          for (var i = 0; i < customClasses.length; i++) {
            if (this.element.hasClass(customClasses[i])) {
              c = customClasses[i];
              this.wrapper.addClass(c);
              this.element.removeClass(c);
            }
          }
        }

        // Add Icon
        var icon = this.wrapper.find('.icon:not(.icon-dropdown)'),
          insertIconInFront = this.wrapper.hasClass('context') || this.wrapper.hasClass('has-categories');

        if (!icon || !icon.length) {
          icon = $.createIconElement('search');
        }

        // Swap icon position to in-front if we have "context/has-categories" CSS class.
        icon[insertIconInFront ? 'insertBefore' : 'insertAfter'](this.element).icon();

        // Change icon to a trigger button if we're dealing with categories
        if (this.hasCategories()) {
          this.wrapper.addClass('has-categories');

          this.categoryButton = this.wrapper.find('.btn, .searchfield-category-button');
          if (!this.categoryButton.length) {
            this.categoryButton = $('<button type="button" class="btn searchfield-category-button"></button>');
          }
          icon.appendTo(this.categoryButton);
          icon = this.categoryButton;

          this.categoryButton.insertBefore(this.element);

          if (this.settings.showCategoryText) {
            this.wrapper.addClass('show-category');
          }

          var ddIcon = icon.find('.icon-dropdown');
          if (!ddIcon.length) {
            ddIcon = $.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }).icon();
          }
          ddIcon.appendTo(icon);

          var popupAPI = this.categoryButton.data('popupmenu');
          if (!popupAPI) {
            this.list = this.wrapper.find('ul.popupmenu');
            if (!this.list || !this.list.length) {
              this.list = $('<ul class="popupmenu"></ul>');
            }

            // Handle Single vs Multi-Selectable Lists
            var categoryListType = this.settings.categoryMultiselect ? 'is-multiselectable' : 'is-selectable';
            this.list.addClass(categoryListType);
            var removeListType = 'is-selectable';
            if (!this.settings.categoryMultiselect) {
              removeListType = 'is-multiselectable';
            }
            this.list.removeClass(removeListType);

            this.setCategories(this.settings.categories);

            this.list.insertAfter(this.element);
            this.categoryButton.popupmenu({
              menu: this.list,
              offset: {
                y: 10
              }
            });

          } else {
            this.setCategories(this.settings.categories);
          }

          this.setCategoryButtonText();
        }

        // Pull a Go Button from markup, if applicable.
        var goButton = this.wrapper.next('.go-button');
        if (!goButton.length) {
          goButton = this.wrapper.find('.go-button');
        }

        if (goButton.length) {
          this.settings.showGoButton = true;
          this.goButton = goButton;
          this.element.after(this.goButton);
        }

        // Add a "Go" Button from scratch if we enable the setting
        if (this.settings.showGoButton && (!this.goButton || !this.goButton.length)) {
          this.goButton = $('<button class="btn-secondary go-button"><span>'+ this.settings.goButtonCopy +'</span></button>');
          this.goButton.attr('id', this.goButton.uniqueId('searchfield-go-button-'));
          this.wrapper.addClass('has-go-button');
          this.element.after(this.goButton);
        } else {
          this.wrapper.removeClass('has-go-button');
        }

        // Hoist the 'alternate' CSS class to the wrapper, if applicable
        var isAlternate = this.element.hasClass('alternate');
        this.wrapper[isAlternate ? 'addClass' : 'removeClass']('alternate');

        if (this.settings.clearable) {
          this.element.clearable();
        }

        this.calculateSearchfieldWidth();

        return this;
      },

      /**
       * Set boolean value if strings
       * @private
       * @returns {undefined}
       */
      optionsParseBoolean: function() {
        var i, l,
          arr = [
            'showAllResults',
            'categoryMultiselect',
            'showCategoryText',
            'clearable'
          ];
        for (i=0,l=arr.length; i<l; i++) {
          this.settings[arr[i]] = this.parseBoolean(this.settings[arr[i]]);
        }
      },

      /**
       * Reveals whether or not categories are active on this searchfield
       * @returns {boolean}
       */
      hasCategories: function() {
        return this.settings.categories && $.isArray(this.settings.categories) && this.settings.categories.length > 0;
      },

      /**
       * Detects the existence of a "Go" button added to the main searchfield API
       * @returns {boolean}
       */
      hasGoButton: function() {
        return this.settings.showGoButton && this.goButton && this.goButton.length;
      },

      /**
       * Sets up the event-listening structure for this component instance.
       * @private
       * @returns {this}
       */
      setupEvents: function() {
        var self = this;

        this.element.on('updated.searchfield', function() {
          self.updated();
        }).on('focus.searchfield', function(e) {
          self.handleFocus(e);
        }).on('blur.searchfield', function(e) {
          self.handleBlur(e);
        }).onTouchClick('searchfield', '.searchfield')
        .on('click.searchfield', function(e) {
          self.handleClick(e);
        }).on('keydown.searchfield', function(e) {
          self.handleKeydown(e);
        }).on('beforeopen.searchfield', function(e, menu) { // propagates from Autocomplete's Popupmenu
          self.handlePopupBeforeOpen(e, menu);
        }).on('safe-blur.searchfield listclose.searchfield', function() {
          self.wrapper.removeClass('popup-is-open');
        });

        this.wrapper.on('mouseenter.searchfield', function() {
          $(this).addClass('is-hovered');
        }).on('mouseleave.searchfield', function() {
          $(this).removeClass('is-hovered');
        });

        if (this.hasCategories()) {
          this.categoryButton.on('selected.searchfield', function(e, anchor) {
            self.handleCategorySelected(e, anchor);
          }).on('focus.searchfield', function(e) {
            self.handleCategoryFocus(e);
          }).on('blur.searchfield', function(e) {
            self.handleCategoryBlur(e);
          }).on('close.searchfield', function(e) { // Popupmenu Close
            self.handlePopupClose(e);
          });
        }

        if (this.hasGoButton()) {
          this.goButton.on('click.searchfield', function(e) {
            return self.handleGoButtonClick(e);
          });
        }

        // Insert the "view more results" link on the Autocomplete control's "populated" event
        this.element.off('populated.searchfield').on('populated.searchfield', function(e, items) {
          if (items.length > 0) {
            if (self.settings.showAllResults) {
              self.addMoreLink();
            }
          } else {
            self.addNoneLink();
          }
        });

        // Override the 'click' listener created by Autocomplete (which overrides the default Popupmenu method)
        // to act differntly when the More Results link is activated.
        this.element.on('listopen.searchfield', function(e, items) {
          var list = $('#autocomplete-list');

          // Visual indicator class
          self.wrapper.addClass('popup-is-open');

          list.off('click').on('click.autocomplete', 'a', function (e) {
            var a = $(e.currentTarget),
              ret = a.text().trim(),
              isMoreLink = a.hasClass('more-results'),
              isNoneLink = a.hasClass('no-results');

            if (!isMoreLink && !isNoneLink) {
              // Only write text into the field on a regular result pick.
              self.element.attr('aria-activedescendant', a.parent().attr('id'));
            }

            if (isMoreLink) {
              // Trigger callback if one is defined
              var callback = self.settings.allResultsCallback;
              if (callback && typeof callback === 'function') {
                callback(ret);
              }
            }

            if (a.parent().attr('data-value')) {
              for (var i = 0; i < items.length; i++) {
                if (items[i].value.toString() === a.parent().attr('data-value')) {
                  ret = items[i];
                }
              }
            }

            self.element.trigger('selected', [a, ret]);
            self.element.data('popupmenu').close();
            //e.preventDefault();
            return false;
          });

          // Override the focus event created by the Autocomplete control to make the more link
          // and no-results link blank out the text inside the input.
          list.find('.more-results, .no-results').off('focus').on('focus.searchfield', function () {
            var anchor = $(this);
            list.find('li').removeClass('is-selected');
            anchor.parent('li').addClass('is-selected');
            self.element.val('');
          });

        });

        return this;
      },

      /**
       * If located inside a toolbar element, setup a timed event that will send a signal to the parent toolbar,
       * telling it to recalculate which buttons are visible. Needs to be done after a CSS animation on the searchfield finishes.
       * @private
       * @returns {undefined}
       */
      recalculateParent: function() {
        var toolbar = this.element.closest('.toolbar');
        if (toolbar.length) {
          // TODO: Bolster this to work with CSS TransitonEnd
          setTimeout(function() {
            toolbar.triggerHandler('recalculate-buttons');
          }, 300);
        }
      },

      /**
       * Activates a toolbar-based searchfield and keeps it "open".  Instead of closing it on blur, sets up
       * an explicit, out-of-bounds click/tap that will serve to close it when the user acts.
       * @private
       * @param {boolean} force - ignore any attempt to return out first
       * @param {boolean} doFocus - focus the searchfield element.
       * @returns {undefined}
       */
      setAsActive: function(force, doFocus) {
        if (!force && this.wrapper.hasClass('active')) {
          return;
        }

        // Activate
        this.wrapper.addClass('active');
        var toolbar = this.element.closest('.toolbar, [class$="-toolbar"]');
        if (toolbar.length) {
          toolbar.addClass('searchfield-active');
        }

        // if Toolbar Searchfield, allow that control to handle adding this class
        if (!this.isToolbarSearchfield()) {
          this.wrapper.addClass('has-focus');
        }

        if (doFocus === true) {
          this.element.focus();
        }
      },

      /**
       * Detects whether or not the Searchfield has focus.
       * @returns {boolean}
       */
      hasFocus: function() {
        var active = document.activeElement;

        if ($.contains(this.wrapper[0], active)) {
          return true;
        }

        // Don't close if a category is being selected from a category menu
        if (this.categoryButton && this.categoryButton.length) {
          var menu = this.categoryButton.data('popupmenu').menu;
          if (menu.has(active).length) {
            return true;
          }
        }

        return false;
      },

      /**
       * Focus event handler
       * @private
       * @returns {undefined}
       */
      handleFocus: function() {
        this.setAsActive();
      },

      /**
       * Blur event handler
       * @private
       * @returns {undefined}
       */
      handleBlur: function() {
        if (!this.hasFocus()) {
          this.wrapper.removeClass('has-focus active');
        }
      },

      /**
       * Click event handler
       * @private
       * @returns {undefined}
       */
      handleClick: function() {
        this.setAsActive();
      },

      /**
       * Keydown event handler
       * @private
       * @returns {undefined}
       */
      handleKeydown: function(e) {
        var key = e.which;

        if (key === 27) {
          this.clear();
        }
      },

      /**
       * Modifies the menu at $('#autocomplete-list') to propagate/remove style classes on the Searchfield element.
       * @private
       * @returns {boolean}
       */
      handlePopupBeforeOpen: function(e, menu) {
        if (!menu) {
          return;
        }

        var contextClassMethod = this.wrapper.hasClass('context') ? 'addClass' : 'removeClass',
          altClassMethod = this.wrapper.hasClass('alternate') ? 'addClass' : 'removeClass';

        menu[contextClassMethod]('context');
        menu[altClassMethod]('alternate');

        return true;
      },


      /**
       * @param {jQuery.Event} e
       */
      handleGoButtonClick: function(e) {
        var action = this.settings.goButtonAction;
        if (typeof action !== 'function') {
          return;
        }

        var searchfieldValue = this.element.val(),
          categorySelection;

        if (this.hasCategories()) {
          categorySelection =this.getCategoryData();
        }

        // gives access to the current searchfield value, and category data if applicable.
        return action(e, searchfieldValue, categorySelection);
      },


      /**
       * Sets the text content on the category button.  Will either display a single category name, or a translated "[x] Selected." string.
       * @param {string} [textContent] - Optional incoming text that will be subtituted for the selected element count.
       * @returns {undefined}
       */
      setCategoryButtonText: function(textContent) {
        if (!this.settings.showCategoryText || !this.hasCategoryButton()) {
          return;
        }

        var text = '',
          button = this.wrapper.find('.btn'),
          span = button.find('span');

        if (!span || !span.length) {
          span = $('<span class="category"></span>').insertAfter(button.find('.icon').first());
        }

        span.empty();

        // incoming text takes precedent
        if (typeof textContent === 'string' && textContent.length) {
          span.text(textContent.trim());
          return;
        }

        // Otherwise, grab currently selected categories and set text
        // (or clear, if no options are selected).
        var item = this.getSelectedCategories();
        if (!item.length) {
          return;
        }

        if (item.length > 1) {
          text = item.length + ' ' + Locale.translate('Selected');
        } else {
          text = item.text().trim();
        }

        span.text(text);
      },

      /**
       * Ensures that the size of the Searchfield Wrapper does not change whenever a category
       * is chosen from a category searchfield.
       * NOTE: this method must be run AFTER changes to DOM elements (text/size changes) have been made.
       */
      calculateSearchfieldWidth: function() {
        if (this.isToolbarSearchfield()) {
          // If this is a toolbar searchfield, run its internal size check that fixes the
          // trigger button and input field size.
          var tsAPI = this.element.data('toolbarsearchfield');
          if (tsAPI && typeof tsAPI.setOpenWidth === 'function') {
            tsAPI.calculateOpenWidth();
            tsAPI.setOpenWidth();
          }
          return;
        }

        var subtractWidth = 0,
          targetWidthProp = '100%';

        if (this.hasCategories()) {
          subtractWidth = subtractWidth + this.categoryButton.outerWidth(true);
        }
        if (this.hasGoButton()) {
          subtractWidth = subtractWidth + this.goButton.outerWidth(true);
        }

        // NOTE: final width can only be 100% if no value is subtracted for other elements
        if (subtractWidth > 0) {
          targetWidthProp = 'calc(100% - '+ subtractWidth +'px)';
        }

        this.element[0].style.width = targetWidthProp;
      },

      /**
       * Detects whether or not this component is a Toolbar Searchfield
       * @returns {boolean}
       */
      isToolbarSearchfield: function() {
        return this.wrapper.is('.toolbar-searchfield-wrapper');
      },

      /**
       * Category Selection event handler
       * @private
       * @returns {undefined}
       */
      handleCategorySelected: function(e, anchor) {
        // Only change the text and searchfield size if we can
        if (!this.settings.showCategoryText) {
          return;
        }

        this.setCategoryButtonText(e, anchor.text().trim());
        this.calculateSearchfieldWidth();
      },

      /**
       * Category Button Focus event handler
       * @private
       * @returns {undefined}
       */
      handleCategoryFocus: function() {
        // if Toolbar Searchfield, allow that control to handle adding this class
        if (this.isToolbarSearchfield()) {
          return;
        }

        this.wrapper
          .addClass('active')
          .addClass('has-focus');
      },

      /**
       * Category Button Blur event handler
       * @private
       * @returns {undefined}
       */
      handleCategoryBlur: function() {
        var self = this;

        // if Toolbar Searchfield, allow that control to handle adding this class
        if (this.isToolbarSearchfield()) {
          return;
        }

        setTimeout(function () {
          if (!self.hasFocus()) {
            self.wrapper.removeClass('has-focus');
          }
        }, 1);
      },

      /**
       * Gets a complete list of categories in jQuery-collection form.
       * @return {jQuery} categories
       */
      getCategories: function() {
        return this.list.children('li:not(.separator)');
      },

      /**
       * Gets the currently selected list of categories in jQuery-collection form.
       * @return {jQuery} selectedCategories
       */
      getSelectedCategories: function() {
        return this.getCategories().filter('.is-checked');
      },

      /**
       * Gets the currently selected categories as data.
       * @param {boolean} [onlyReturnSelected=false] - If set to true, will only return checked list items.
       * @returns {Object[]} data -
       * @returns {string} name - Category name
       * @returns {string|number} id - Category element's ID (if applicable)
       * @returns {string|number} value - Category element's value (if applicable)
       * @returns {boolean} [checked=true] - Category's selection status
       */
      getCategoryData: function(onlyReturnSelected) {
        var categories = this.getCategories(),
          data = [];

        categories.each(function() {
          var classList = this.classList,
            checked = classList.contains('is-checked');

          if (onlyReturnSelected === true && checked === false) {
            return;
          }

          var category = {
            name: this.innerText,
            checked: checked
          };

          if (this.id) {
            category.id = this.id;
          }

          var value = this.getAttribute('data-value');
          if (value !== undefined) {
            category.value = value;
          }

          data.push(category);
        });

        return data;
      },

      /**
       * Updates just the categories setting and rerenders the category list.
       * @param {Object[]} categories - Array of category object definitions.
       * @param {string} categories[].name - Category name.
       * @param {string|number} [id] - Category element's ID (if applicable).
       * @param {string|number} [value] - Category element's value (if applicable).
       * @param {boolean} [checked=true] - Category's selection status
       * @return {undefined}
       */
      updateCategories: function(categories) {
        this.settings.categories = categories;
        this.setCategories(this.settings.categories);
      },

      /**
       * Creates a new set of categories on the Searchfield and rerenders it.
       * @param {Object[]} categories - Array of category object definitions.
       * @param {string} categories[].name - Category name.
       * @param {string|number} [id] - Category element's ID (if applicable).
       * @param {string|number} [value] - Category element's value (if applicable).
       * @param {boolean} [checked=true] - Category's selection status
       * @return {undefined}
       */
      setCategories: function(categories) {
        this.list.empty();

        var self = this,
          previouslySelected = false;

        categories.forEach(function(val) {
          // if passed a string, typecast to an object.
          if (typeof val === 'string') {
            val = {
              name: val
            };
          }

          // Object types get a bit more customization.
          // Don't continue if there's no name present.
          if (!val.name) {
            return;
          }

          var id = '';
          if (typeof val.id === 'string' && val.id.length) {
            id = ' id="'+ val.id +'"';
          }

          var value = '',
            valueTypes = ['string', 'number'];
          if (valueTypes.indexOf(typeof val.value) > -1) {
            value = ' data-value="'+ val.value +'"';
          }

          var selected = '';
          if (val.checked === true && previouslySelected !== true) {
            selected = ' class="is-checked"';

            if (!self.settings.categoryMultiselect) {
              previouslySelected = true;
            }
          }

          self.list.append('<li'+ selected + id + value + '><a href="#">' + val.name + '</a></li>');
        });

        var api = this.categoryButton.data('popupmenu');
        if (api && typeof api.updated === 'function') {
          api.updated();
        }
      },

      /**
       * Determines whether or not a Category Trigger exists.
       * @returns {boolean}
       */
      hasCategoryButton: function() {
        return this.wrapper.find('.btn').length > 0;
      },

      /**
       * Category Button Close event handler
       * @private
       * @returns {function}
       */
      handlePopupClose: function() {
        return this.setAsActive(true, true);
      },

      /**
       * Clears the contents of the searchfield
       * @returns {undefined}
       */
      clear: function() {
        this.element.val('').trigger('change').focus();
      },

      /**
       * Adds a link at the bottom of a searchfield with more than (0) results that can be used to link out to a larger display of search results.
       * @private
       * @returns {undefined}
       */
      addMoreLink: function() {
        var list = $('#autocomplete-list'),
          val = this.element.val();

        if ($('.more-results', list).length > 0) {
          return;
        }

        $('<li class="separator" role="presentation"></li>').appendTo(list);
        var more = $('<li role="presentation"></li>').appendTo(list);
        this.moreLink = $('<a href="#" class="more-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('AllResults') + ' "' + val + '"</span>').appendTo(more);
      },

      /**
       * Adds a link at the bottom of a searchfield with no results that announces no search results.
       * @private
       * @returns {undefined}
       */
      addNoneLink: function() {
        var list = $('#autocomplete-list');
        if ($('.no-results', list).length > 0) {
          return;
        }

        var none = $('<li role="presentation"></li>').appendTo(list);

        this.noneLink = $('<a href="#" class="no-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('NoResults') + '</span>').appendTo(none);
      },

      /**
       * Tears down and rebuilds the Searchfield.
       * Can be called directly, but is also triggered by calling the "updated.searchfield" event on the searchfield element.
       * @returns {undefined}
       */
      updated: function() {
        this.teardown().init();
      },

      /**
       * Enables the Searchfield
       * @returns {undefined}
       */
      enable: function() {
        this.element.prop('disabled', false);
      },

      /**
       * Disables the Searchfield
       * @returns {undefined}
       */
      disable: function() {
        this.element.prop('disabled', true);
      },

      /**
       * Performs the usual Boolean coercion with the exception of the strings "false" (case insensitive) and "0"
       * @private
       * @returns {boolean}
       */
      parseBoolean: function(b) {
        return !(/^(false|0)$/i).test(b) && !!b;
      },

      /**
       * Unbinds events and removes unnecessary markup.
       * @private
       * @returns {this}
       */
      teardown: function() {
        this.element.off('updated.searchfield focus.searchfield blur.searchfield click.searchfield keydown.searchfield beforeopen.searchfield listopen.searchfield listclose.searchfield safe-blur.searchfield');

        if (this.autocomplete) {
          this.autocomplete.destroy();
        }

        if (this.wrapper.hasClass('context')) {
          this.element.addClass('context');
        }

        this.element.next('.icon').remove();
        if (this.element.parent().hasClass('searchfield-wrapper')) {
          this.element.parent().find('ul').remove();
          this.element.parent().find('.icon').remove();
        }

        return this;
      },

      /**
       * Destroys the Searchfield and removes all jQuery component instancing.
       * @param {boolean} dontDestroyToolbarSearchfield - if true, will not pass through and destroy a linked instance of the Toolbar Searchfield component.
       * @returns {undefined}
       */
      destroy: function(dontDestroyToolbarSearchfield) {
        this.teardown();

        // Destroy the linked Toolbar Searchfield instance
        var tbsf = this.element.data('toolbarsearchfield');
        if (!dontDestroyToolbarSearchfield && tbsf && typeof tbsf.destroy === 'function') {
          tbsf.destroy(true);
        }

        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {

      // Detect if we're inside of a Toolbar and invoke Toolbar Searchfield first, if applicable.
      // Added for SOHO-6448.
      // NOTE: If we merge the searchfield/toolbarsearchfield apis, revisit this solution.
      var sf = $(this),
        toolbarParent = sf.parents('.toolbar');
      if (toolbarParent.length && !options.noToolbarSearchfieldInvoke) {
        var tbsf = sf.data('toolbarsearchfield');
        if (!tbsf) {
          return sf.toolbarsearchfield(options);
        } else {
          tbsf.updated();
        }
      }

      // Normal invoke setup
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new SearchField(this, settings));
      }
    });
  };


  $.fn.signin = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'signin',
        defaults = {},
        settings = $.extend({}, defaults, options);

    /**
     * @class {SignIn}
     * @constructor
     * @param {Object} element
     */
    function SignIn(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    SignIn.prototype = {

      /**
       * @private
       */
      init: function() {
        this.settings = settings;
        this.handleKeys();
      },

      /**
       * Checks a keyboard event for a CAPS LOCK modifier.
       * @param {jQuery.Event} e
       * @returns {boolean}
       */
      isCapslock: function(e) {
        e = (e) ? e : window.event;
        var charCode = (e.which) ? e.which : ((e.keyCode) ? e.keyCode : false),
         shifton = (e.shiftKey) ? e.shiftKey : ((e.modifiers) ? (!!(e.modifiers & 4)) : false);

        if (charCode >= 97 && charCode <= 122 && shifton) {
          return true;
        }
        if (charCode >= 65 && charCode <= 90 && !shifton) {
          return true;
        }
        return false;
      },

      /**
       * Teardown - Remove added markup and events
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        $('body').off('keypress.signin blur.signin change.signin');
      },

      /**
       * @fires SignIn#events
       * @param {Object} keypress
       * @param {Object} blur
       * @param {Object} change
       *
       */
      handleKeys: function() {
        var self = this,
          cssIcon = $.createIconElement({ classes: 'icon-capslock', icon: 'capslock' });

        // Disable default [caps lock on] popup in IE
        document.msCapsLockWarningOff = true;

        this.element
        .on('keypress.signin', '[type="password"]', function (e) {
          var field = $(this),
            fieldParent = field.parent('.field'),
            iconCapslock = $('.icon-capslock', fieldParent);

          if (self.isCapslock(e) && !field.hasClass('error')) {
            if(!iconCapslock.length) {
              fieldParent.append(cssIcon);
              $('body').toast({audibleOnly: true, message: Locale.translate('CapsLockOn')});
            }
          } else {
            iconCapslock.remove();
          }

        })
        .on('blur.signin change.signin', '[type="password"]', function () {
          var field = $(this),
            fieldParent = field.closest('.field'),
            iconCapslock = $('.icon-capslock', fieldParent);

          // Wait for error class to be added
          setTimeout(function() {
            if (iconCapslock && iconCapslock.length) {
              if (field.hasClass('error')) {
                iconCapslock.remove();
              } else {
                fieldParent.append(cssIcon);
              }
            }
          }, 150);

        });
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new SignIn(this, settings));
      }
    });
  };


  $.fn.slider = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'slider',
        defaults = {
          value: [50],
          min: 0,
          max: 100,
          range: false,
          step: undefined,
          ticks: [],
          tooltipContent: undefined,
          persistTooltip: false
        };

    /**
     * Touch Enabled/Responsive and Accessible Slider Control
     * @class {Slider}
     * @param {Array} value
     * @param {Number} min
     * @param {Number} max
     * @param {boolean} range
     * @param {undefined|Number} step
     * @param {Array} ticks
     * @param {undefined|Array} tooltipContent
     * @param {boolean} persistTooltip
     */
    function Slider(element) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Check if is an integer
    function isInt(n) {
      return n % 1 === 0;
    }

    // Round a non-integer to an integer closest to the nearest increment/decrement.
    // If no increment is provided or the increment is 0, only round to the nearest whole number.
    function roundToIncrement(number, increment) {
      if (!increment || isNaN(increment) || increment === 0) {
        increment = 1;
      }
      return Math.round(number/increment) * increment;
    }

    // Get the distance between two points.
    // PointA & PointB are both arrays containing X and Y coordinates of two points.
    // Distance Formula:  http://www.purplemath.com/modules/distform.htm
    function getDistance(pointA, pointB) {
      var aX = pointA[0], aY = pointA[1],
        bX = pointB[0], bY = pointB[1];

      return Math.sqrt( Math.pow(bX - aX, 2) + Math.pow(bY - aY, 2) );
    }

    // Actual Plugin Code
    Slider.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        return this
          .buildSettings()
          .addMarkup()
          .bindEvents();
      },

      /**
       * Handles Data Attribute settings, some markup settings
       * @private
       * @returns {this}
       */
      buildSettings: function() {
        var self = this;

        // Add "is-disabled" css class to closest ".field" if element is disabled
        if (this.element.is(':disabled')) {
          this.element.closest('.field').addClass('is-disabled');
        }

        if (!this.settings) {
          this.settings = {};
        }
        this.settings.value = this.element.attr('value') !== undefined ? this.element.attr('value') : this.settings.value;
        this.settings.min = this.element.attr('min') !== undefined ? parseInt(this.element.attr('min')) : this.settings.min;
        this.settings.max = this.element.attr('max') !== undefined ? parseInt(this.element.attr('max')) : this.settings.max;
        this.settings.range = this.element.attr('data-range') !== undefined ? (this.element.attr('data-range') === 'true') : this.settings.range;
        this.settings.step = !isNaN(this.element.attr('step')) ? Number(this.element.attr('step')) : this.settings.step;

        if (this.settings.value === '') {
          this.settings.value = this.settings.min;
        }

        // build tick list
        var parsedTicks;
        if (this.element.attr('data-ticks') !== undefined) {
          try {
            parsedTicks = JSON.parse(self.element.attr('data-ticks'));
          } catch (e) {
          }

          if ($.isArray(parsedTicks)) {
            this.settings.ticks = parsedTicks;
          }
        }

        // build tooltip content
        var isTooltipPersist = (this.element.attr('data-tooltip-persist') === 'true' || this.element.attr('data-tooltip-persist') === true);
        this.settings.persistTooltip = this.element.attr('data-tooltip-persist') !== undefined ? isTooltipPersist : this.settings.persistTooltip;
        this.settings.tooltip = this.settings.tooltipContent;
        if (this.element.attr('data-tooltip-content') !== undefined) {
          try {
            self.settings.tooltip = JSON.parse(self.element.attr('data-tooltip-content'));
          } catch (e) {
          }
        }
        if (typeof this.settings.tooltip === 'string') {
          if (this.settings.tooltip.indexOf(',') === -1) {
            this.settings.tooltip = [this.settings.tooltip, ''];
          } else {
            var strings = this.settings.tooltip.split(',');
            this.settings.tooltip = [strings[0]];
            this.settings.tooltip.push( strings[1] ? strings[1] : '');
          }
        }
        if (this.settings.tooltip && this.settings.tooltip.length === 1) {
          this.settings.tooltip.push('');
        }

        // Build ticks.  All sliders have a tick for minimum and maximum by default.  Some will be provided as extra.
        this.ticks = [];
        var minTick = {
          'value' : this.settings.min,
          'description' : self.getModifiedTextValue(this.settings.min)
        }, maxTick = {
          'value' : this.settings.max,
          'description' : self.getModifiedTextValue(this.settings.max)
        };

        if (!this.settings.ticks) {
          this.ticks.push(minTick, maxTick);
        } else {
          // Check the type of the data-ticks.  If it's not a complete array
          // and doesn't have at least one option, ignore it.
          var ticks = self.settings.ticks || [];

          if ($.isArray(ticks) && ticks.length > 0) {
            // Filter through the incoming ticks to figure out if any have been defined
            // That match the values of min and max.
            var equalsMin = ticks.filter(function(obj) {
              return obj.value === self.settings.min;
            }),
            equalsMax = ticks.filter(function(obj) {
              return obj.value === self.settings.max;
            });

            // Overwrite description and color for min/max if they've been found.
            if (equalsMin.length > 0) {
              minTick.description = equalsMin[0].description;
              minTick.color = equalsMin[0].color;
              ticks = $.grep(ticks, function(val) {
                return val !== equalsMin[0];
              });
            }
            if (equalsMax.length > 0) {
              maxTick.description = equalsMax[0].description;
              maxTick.color = equalsMax[0].color;
              ticks = $.grep(ticks, function(val) {
                return val !== equalsMax[0];
              });
            }
          }

          // Push the values of all ticks out to the ticks array
          self.ticks.push(minTick);
          for (var i = 0; i < ticks.length; i++) {
            var tick = {};
            if (ticks[i].value !== undefined) {
              tick.value = ticks[i].value;
              tick.description = ticks[i].description !== undefined ? ticks[i].description : '';
              tick.color = ticks[i].color;
              self.ticks.push(tick);
            }
          }
          self.ticks.push(maxTick);
        }

        // configure the slider to deal with an array of values, and normalize the values to make sure they are numbers.
        if ($.isArray(this.settings.value)) {
          this.settings.value[0] = isNaN(this.settings.value[0]) ? (this.settings.min + this.settings.max)/2 : parseInt(this.settings.value[0]);
        } else if (typeof this.settings.value === 'number') {
          this.settings.value = [this.settings.value];
        } else {
          // String
          if (this.settings.value.indexOf(',') === -1) {
            this.settings.value = [isNaN(this.settings.value) ? (this.settings.min + this.settings.max)/2 : parseInt(this.settings.value)];
          } else {
            var vals = this.settings.value.split(',');
            vals[0] = isNaN(vals[0]) ? this.settings.min : parseInt(vals[0]);
            vals[1] = isNaN(vals[1]) ? this.settings.max : parseInt(vals[1]);
            this.settings.value = vals;
          }
        }

        // Add a second value to the array if we're dealing with a range.
        if (this.settings.range && !this.settings.value[1]) {
          this.settings.value.push(this.settings.max);
        }

        return this;
      },

      /**
       * Adds pseudo-markup that helps build the component
       * @private
       * @returns {this}
       */
      addMarkup: function() {
        var self = this,
          isVertical = false;

        if (self.element[0].tagName !== 'INPUT') {
          throw new Error('Element with ID "' + self.element.id + '" cannot invoke a slider;  it\'s not an Input element.');
        }

        // store values and attributes on the original element
        self.originalElement = {
          'type': self.element.attr('type')
        };

        // Hide the input element
        self.element.attr('type', 'hidden');

        // Build the slider controls
        self.wrapper = $('<div class="slider-wrapper"></div>').attr('id', self.element.attr('id') + '-slider').insertAfter(self.element);
        self.hitarea = $('<div class="slider-hit-area"></div>').appendTo(self.wrapper);
        self.range = $('<div class="slider-range"></div>').appendTo(self.wrapper);

          // Set to a vertical slider if the class exists on the input
        if (this.element.hasClass('vertical')) {
          this.wrapper.addClass('vertical');
          isVertical = true;
        }

        // Set RTL
        this.isRtlHorizontal = (Locale.isRTL() && !isVertical);
        this.isRtlVertical = (Locale.isRTL() && isVertical);

        // Retain any width or height size properties from the original range element onto the Pseudo-markup
        var style = this.element.attr('style');
        if (style) {
          if (style.match(/min-height/)) {
            this.wrapper[0].style.minHeight = this.element[0].style.minHeight;
            style = style.replace('min-height', '');
          }
          if (style.match(/height/)) {
            this.wrapper[0].style.height = this.element[0].style.height;
          }
          if (style.match(/min-width/)) {
            this.wrapper[0].style.minWidth = this.element[0].style.minWidth;
            style = style.replace('min-width', '');
          }
          if (style.match(/width/)) {
            this.wrapper[0].style.width = this.element[0].style.width;
          }
        }

        // Handles
        self.handles = [];
        var labelText = self.element.prev('label').text(),
          handleLower = $('<div class="slider-handle' + (self.settings.range ? ' lower' : '') +'" tabindex="0"></div>')
          .attr('aria-label', (self.settings.range ? Locale.translate('SliderMinimumHandle') : Locale.translate('SliderHandle')) + ' ' + labelText);
        self.handles.push(handleLower);
        if (self.settings.range) {
          var handleHigher = $('<div class="slider-handle higher" tabindex="0"></div>')
            .attr('aria-label', Locale.translate('SliderMaximumHandle') + ' ' + labelText);
          self.handles.push(handleHigher);
        }
        $.each(self.handles, function(i, handle) {
          // Add WAI-ARIA to the handles
          handle.attr({
            'role' : 'slider',
            'aria-orientation' : (isVertical ? 'vertical' : 'horizontal'),
            'aria-valuemin' : self.settings.min,
            'aria-valuemax' : self.settings.max
          }).hideFocus();
          handle.appendTo(self.wrapper);
        });

        function positionTick(tick) {
          var convertValueToPercentage = self.isRtlHorizontal ?
              (100 - self.convertValueToPercentage(tick.value)) :
              self.convertValueToPercentage(tick.value),
            pos = 'calc(' + convertValueToPercentage + '% - 4px)';

          tick.element = $('<div class="tick" data-value="'+ tick.value +'"></div>');
          tick.label = $('<span class="label">' + tick.description + '</span>');
          tick.element[0].style[isVertical ? 'bottom' : 'left'] = pos;
          tick.element.append(tick.label);
          self.wrapper.append(tick.element);

          if (isVertical) {
            return;
          }
          tick.label[0].style.left = -(tick.label.outerWidth()/2 - tick.element.width()/2) + 'px';
        }

        // Ticks
        self.ticks.forEach(function(tick) {
          positionTick(tick);
        });

        self.value(self.settings.value);
        self.updateRange();

        // Tooltip on handle needs to update later
        $.each(self.handles, function(i, handle) {
          if (self.settings.tooltip) {
            handle.tooltip({
              content: function() {
                return '' + self.getModifiedTextValue(Math.floor(self.value()[i]));
              },
              placement: (isVertical ? 'right' : 'bottom'),
              trigger: 'focus',
              keepOpen: self.settings.persistTooltip
            });
            handle.removeAttr('aria-describedby');
          }
        });

        if (this.element.prop('disabled') === true) {
          this.disable();
        }

        return self;
      },

      /**
       * User is interacting with the Slider Range (not the handle or ticks)
       * @param {jQuery.Event} e
       */
      handleRangeClick: function(e) {
          e.preventDefault();
          if (this.isDisabled()) {
            return;
          }

          var self = this,
            isVertical = this.wrapper.hasClass('vertical'),
            pageX = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageX : e.pageX,
            pageY = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageY : e.pageY,
            mouseX = pageX - self.wrapper.offset().left - $(document).scrollLeft(),
            mouseY = pageY - self.wrapper.offset().top - $(document).scrollTop(),
            clickCoords = [mouseX,mouseY],
            fhX = (self.handles[0].offset().left + (self.handles[0].width()/2)) - self.wrapper.offset().left - $(document).scrollLeft(),
            fhY = (self.handles[0].offset().top + (self.handles[0].height()/2)) - self.wrapper.offset().top - $(document).scrollTop(),
            firstHandleCoords = [fhX,fhY],
            shX,
            shY,
            secondHandleCoords,
            oldVals = self.value(),
            dLower = getDistance(clickCoords,firstHandleCoords),
            dHigher,
            targetOldVal = oldVals[0],
            targetHandle = self.handles[0];

          targetHandle.addClass('hide-focus');

          function conversion() {
            if (isVertical) {
              var wh = self.wrapper.height();
              return ((wh - mouseY) / wh) * 100;
            }
            return (mouseX / self.wrapper.width()) * 100;
          }

          // Convert the coordinates of the mouse click to a value
          var val = conversion(),
            rangeVal = self.convertPercentageToValue(val);

          // If the slider is a range, we may use the second handle instead of the first
          if (self.handles[1]) {
            shX = (self.handles[1].offset().left + (self.handles[1].width()/2)) - self.wrapper.offset().left - $(document).scrollLeft();
            shY = (self.handles[1].offset().top + (self.handles[1].height()/2)) - self.wrapper.offset().top - $(document).scrollTop();
            secondHandleCoords = [shX, shY];
            dHigher = getDistance(clickCoords,secondHandleCoords);

            if (dLower > dHigher) {
              self.value([undefined, rangeVal]);
              targetHandle = self.handles[1];
              targetOldVal = oldVals[1];
            } else {
              self.value([rangeVal]);
            }
          } else {
            self.value([rangeVal]);
          }

          self.checkHandleDifference(targetHandle, targetOldVal, rangeVal);

          if (rangeVal < targetOldVal) {
            self.decreaseValue(e, targetHandle, rangeVal, 0);
          } else {
            self.increaseValue(e, targetHandle, rangeVal, 0);
          }

          // Tooltip repositioner will focus the handle after positioning occurs, but if we are clicking a tick
          // on a slider with no tooltip, we need to focus it manually.
          if (!self.settings.tooltip) {
            targetHandle.focus();
          }
      },

      /**
       * Activates one of the slider handles
       * @param {jQuery[]} handle
       */
      activateHandle: function(handle) {
        handle.addClass('is-active');
      },

      /**
       * Deactivates one of the slider handles
       * @param {jQuery[]} handle
       */
      deactivateHandle: function(handle) {
        handle.removeClass('is-active');
      },

      /**
       * Enables the ability to drag one of the slider handles.
       * @param {jQuery[]} handle
       */
      enableHandleDrag: function(handle) {
        if (this.isDisabled()) {
          return;
        }

        var self = this,
          draggableOptions = {
            containment: 'parent',
            axis: (this.isVertical() ? 'y' : 'x'),
            clone: false
          };

        function updateHandleFromDraggable(e, handle, args) {
          if (self.isDisabled()) {
            return;
          }

          function conversion() {
            if (self.isVertical()) {
              var wh = self.wrapper.height(),
              // Vertical Slider accounts for limits set on the height by SoHo Xi Drag.js
              adjustedHeight = wh - handle.outerHeight();

              return ((adjustedHeight - args.top) / adjustedHeight) * 100;
            }
            return args.left / (self.wrapper.width() - handle.outerWidth()) * 100;
          }

          var val = conversion(),
            rangeVal = self.convertPercentageToValue(val);

          // Ranged values need to check to make sure that the higher-value handle doesn't drawindowg past the
          // lower-value handle, and vice-versa.
          if (self.settings.range) {
            var originalVal = self.value();
            if (handle.hasClass('higher') && rangeVal <= originalVal[0]) {
              rangeVal = originalVal[0];
            }
            if (handle.hasClass('lower') && rangeVal >= originalVal[1]) {
              rangeVal = originalVal[1];
            }
          }

          // Round the value to the nearest step, if the step is defined
          if (self.settings.step) {
            rangeVal = Math.round(rangeVal / self.settings.step) * self.settings.step;
          }

          if (!e.defaultPrevented) {
            self.value(handle.hasClass('higher') ? [undefined, rangeVal] : [rangeVal]);
            self.updateRange();
            self.updateTooltip(handle);
            self.element.trigger('sliding', handle, rangeVal);
          }

          return;
        }

        // Add/Remove Classes for canceling animation of handles on the draggable's events.
        handle.drag(draggableOptions)
        .on('drag.slider', function (e, args) {
          updateHandleFromDraggable(e, $(e.currentTarget), args);
        })
        .on('dragstart', function() {
          $(this).addClass('is-dragging');
          self.range.addClass('is-dragging');
          self.element.trigger('slidestart', handle);
        })
        .on('dragend', function() {
          $(this).removeClass('is-dragging');
          self.range.removeClass('is-dragging');
          self.element.trigger('slidestop', handle);
        });
      },

      /**
       * Disables the dragging of a handle.
       * @param {jQuery[]} handle
       */
      disableHandleDrag: function(handle) {
        handle.off('drag.slider dragstart dragend');

        this.range.removeClass('is-dragging');
        handle.removeClass('is-dragging');

        var dragAPI = handle.data('drag');
        if (dragAPI) {
          dragAPI.destroy();
        }
      },

      /**
       * @private
       * @param {Number} value
       * @returns {Number}
       */
      convertValueToPercentage: function(value) {
        return (((value - this.settings.min) / (this.settings.max - this.settings.min)) * 100);
      },

      /**
       * @private
       * @param {Number} percentage
       * @returns {Number}
       */
      convertPercentageToValue: function(percentage) {
        var val = (percentage / 100) * (this.settings.max - this.settings.min) + this.settings.min;
        return this.isRtlHorizontal ? (this.settings.max - val + this.settings.min) : val;
      },

      /**
       * Gets a 10% increment/decrement as a value within the range of minimum and maximum values.
       * @returns {Number}
       */
      getIncrement: function() {
        var increment = 0.1 * (this.settings.max - this.settings.min);
        if (this.settings.step !== undefined && increment <= this.settings.step) {
          increment = this.settings.step;
        }
        return increment;
      },

      /**
       * Handles Slider Component's keystrokes
       * @param {jQuery.Event} e
       * @param {this} self
       */
      handleKeys: function(e, self) {
        if (self.isDisabled()) {
          return;
        }

        var key = e.which,
          handle = $(e.currentTarget);

        handle.removeClass('hide-focus');

        // If the keycode got this far, it's an arrow key, Page Up, Page Down, HOME, or END.
        switch(key) {
          case 33: // Page Up increases the value by 10%
            self.increaseValue(e, handle, undefined, this.getIncrement());
            break;
          case 34: // Page Down decreases the value by 10%
            self.decreaseValue(e, handle, undefined, this.getIncrement());
            break;
          case 35: // End key sets the handle to its maximum possible value
            self.increaseValue(e, handle, this.settings.max);
            break;
          case 36: // Home key sets the handle to its lowest (either minimum value or as low as the "lower" handle)
            self.decreaseValue(e, handle, this.settings.min);
            break;
          case 38: case 39: // Right and Up increase the spinbox value
            if (self.isRtlHorizontal && key === 39) {
              self.decreaseValue(e, handle);
            } else {
              self.increaseValue(e, handle);
            }
            break;
          case 37: case 40: // Left and Down decrease the spinbox value
            if (self.isRtlHorizontal && key === 37) {
              self.increaseValue(e, handle);
            } else {
              self.decreaseValue(e, handle);
            }
            break;
        }
      },

      /**
       * Increases the value of one of the slider handles, accounting for step value, percentage, etc.
       * Also visually updates the handle on the visual part of the slider.
       * @param {jQuery.Event} e
       * @param {jQuery[]} handle
       * @param {Number} [value] - target value - will be automatically determined if not passed.
       * @param {Number} [increment] - an integer that will be used as the amount to increment.
       */
      increaseValue: function(e, handle, value, increment) {
        e.preventDefault();
        clearTimeout(handle.data('animationTimeout'));

        var val = this.value().slice(0),
          incrementBy = increment !== undefined ? increment : this.settings.step !== undefined ? this.settings.step : 1,
          testVal,
          updatedVal,
          finalVal;

        if (handle.hasClass('higher')) {
          testVal = value !== undefined ? value : val[1];
          incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : testVal % incrementBy;
          updatedVal = testVal + incrementBy < this.settings.max ? testVal + incrementBy : this.settings.max;
          finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
          this.value([undefined, finalVal]);
        } else {
          testVal = value !== undefined ? value : val[0];
          var maxValue = val[1] === undefined ? this.settings.max : val[1];
          incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : incrementBy - (testVal % incrementBy);
          updatedVal = testVal + incrementBy < maxValue ? testVal + incrementBy : maxValue;
          finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
          this.value([finalVal]);
        }
        this.checkHandleDifference(handle, testVal, finalVal);
        this.updateRange();
        this.updateTooltip(handle);
      },

      /**
       * Decreases the value of one of the slider handles, accounting for step value, percentage, etc.
       * Also visually updates the handle on the visual part of the slider.
       * @param {jQuery.Event} e
       * @param {jQuery[]} handle
       * @param {Number} [value] - target value - will be automatically determined if not passed.
       * @param {Number} [decrement] - an integer that will be used as the amount to decrement.
       */
      decreaseValue: function(e, handle, value, decrement) {
        e.preventDefault();
        clearTimeout(handle.data('animationTimeout'));

        var val = this.value(),
          decrementBy = decrement !== undefined ? decrement : this.settings.step !== undefined ? this.settings.step : 1,
          testVal,
          updatedVal,
          finalVal;

        if (handle.hasClass('higher')) {
          testVal = value !== undefined ? value : val[1];
          var minValue = val[0] === undefined ? this.settings.min : val[0];
          decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : decrementBy - (testVal % decrementBy);
          updatedVal = testVal - decrementBy > minValue ? testVal - decrementBy : minValue;
          finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
          this.value([undefined, finalVal]);
        } else {
          testVal = value !== undefined ? value : val[0];
          decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : testVal % decrementBy;
          updatedVal = testVal - decrementBy > this.settings.min ? testVal - decrementBy : this.settings.min;
          finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
          this.value([finalVal]);
        }
        this.checkHandleDifference(handle, testVal, finalVal);
        this.updateRange();
        this.updateTooltip(handle);
      },

      /**
       * Changes the position of the bar and handles based on their values.
       */
      updateRange: function() {
        var self = this,
          newVal = this.value(),
          percentages = [],
          color = this.getColorClosestToValue(),
          isVertical = self.wrapper.hasClass('vertical');

        for (var i = 0; i < this.ticks.length; i++) {
          var condition = !this.settings.range ? this.ticks[i].value <= newVal[0] :
            newVal[0] < this.ticks[i].value && this.ticks[i].value <= newVal[1];

          if (condition) {
            this.ticks[i].element.addClass('complete');
            if (color) {
              this.ticks[i].element[0].style.backgroundColor = color;
              this.ticks[i].element.addClass('inherit');
            }
          } else {
            this.ticks[i].element.removeClass('complete');
            if (color) {
              this.ticks[i].element[0].style.backgroundColor = '';
              this.ticks[i].element.removeClass('inherit');
            }
          }
        }

        if (color) {
          this.range[0].style.backgroundColor = color;
          $.each(this.handles, function(i, handle) {
            handle[0].style.backgroundColor = color;
            handle[0].style.borderColor = color;
          });
        }

        // Remove any text colors that already existed.
        $.each(self.ticks, function(i) {
          self.ticks[i].label[0].style.color = '';
        });

        // Convert the stored values from ranged to percentage
        percentages[0] = this.convertValueToPercentage(newVal[0]);
        if (newVal[1] !== undefined) {
          percentages[1] = this.convertValueToPercentage(newVal[1]);
        }

        var posAttrs = (isVertical ? ['bottom', 'top'] :
          (self.isRtlHorizontal ? ['right', 'left'] : ['left', 'right'])),
          cssProps = {};

        // If no arguments are provided, update both handles with the latest stored values.
        if (!this.handles[1]) {
          cssProps[posAttrs[0]] = '0%';
          cssProps[posAttrs[1]] = (100 - percentages[0]) + '%';
        } else {
          cssProps[posAttrs[0]] = percentages[0] + '%';
          cssProps[posAttrs[1]] = (100 - percentages[1]) + '%';
        }
        this.range.css(cssProps);

        function positionHandle(handle, percentage) {
          var basePosition = isVertical ? posAttrs[1] : posAttrs[0],
            realPercentage = isVertical ? 100 - percentage : percentage;

          handle.css(basePosition, 'calc(' + realPercentage + '% - ' + handle.outerWidth()/2 + 'px)');
        }

        if (this.handles[0].hasClass('is-animated')) {
          this.handles[0].data('animationTimeout', setTimeout( function() {
            self.handles[0].removeClass('is-animated').trigger('slide-animation-end');
            self.range.removeClass('is-animated');
          }, 201));
        }
        positionHandle(this.handles[0], percentages[0]);

        if (this.handles[1]) {
          if (this.handles[1].hasClass('is-animated')) {
            this.handles[1].data('animationTimeout', setTimeout( function() {
              self.handles[1].removeClass('is-animated').trigger('slide-animation-end');
              self.range.removeClass('is-animated');
            }, 201));
          }
          positionHandle(this.handles[1], percentages[1]);

          // update the 'aria-valuemin' attribute on the Max handle, and the 'aria-valuemax' attribute on the Min handle
          // for better screen reading compatability
          this.handles[0].attr('aria-valuemax', newVal[1]);
          this.handles[1].attr('aria-valuemin', newVal[0]);
        }
      },

      /**
       * Allows a handle to animate to a new position if the difference in value is greater than 3% of the size of the range.
       * @param {jQuery[]} handle
       * @param {Number} originalVal
       * @param {Number} updatedVal
       */
      checkHandleDifference: function(handle, originalVal, updatedVal) {
        // IE9 doesn't support animation so return immediately.
        if ($('html').hasClass('ie9')) {
          return;
        }
        var origPercent = this.convertValueToPercentage(originalVal),
          updatedPercent = this.convertValueToPercentage(updatedVal);

        if (Math.abs(origPercent - updatedPercent) > 3) {
          handle.addClass('is-animated');
          this.range.addClass('is-animated');
        }
      },

      /**
       * If tooltips are active, updates the current placement and content of the Tooltip.
       * If no handle argument is passed, this method simply hides both handles' tooltips.
       * @param {jQuery[]} [handle]
       */
      updateTooltip: function(handle) {
        if (!this.settings.tooltip) {
          return;
        }

        if (!handle) {
          var tooltipLow = this.handles[0].data('tooltip'),
            tooltipHigh;

          if (this.handles[1]) {
            tooltipHigh = this.handles[1].data('tooltip');
          }

          tooltipLow.hide();
          if (tooltipHigh) {
            tooltipHigh.hide();
          }

          return;
        }

        var tooltip = handle.data('tooltip');

        function update() {
          tooltip.position();
          handle.focus();
        }

        // NOTE: This is a bit hacky because it depends on the setTimeout() method for animation that is triggered
        // inside the self.updateRange() method to have not fired yet.  If you put a breakpoint anywhere in there you
        // may see strange results with animation.
        if (handle.hasClass('is-animated')) {
          tooltip.hide();
          handle.one('slide-animation-end', function() {
            update();
          });
        } else {
          update();
        }
      },

      /**
       * Gets a string-based hex value for the closest tick's defined color.
       * @returns {string}
       */
      getColorClosestToValue: function() {
        var currentTheme = Soho.theme,
          preColors = {
            'light': {
              'default'   : '#000000',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#f2bc41',
              'good'      : '#9cce7c',
              'very-good' : '#76b051',
              'superior'  : '#488421'
            },
            'dark': {
              'default'   : '#ffffff',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#f2bc41',
              'good'      : '#9cce7c',
              'very-good' : '#76b051',
              'superior'  : '#488421'
            },
            'high-contrast': {
              'default'   : '#000000',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#e4882b',
              'good'      : '#76b051',
              'very-good' : '#56932e',
              'superior'  : '#397514'
            }
          };

        var themeColors = preColors[currentTheme],
          val = this.value()[0],
          highestTickColor, c;

        for (var i = 0; i < this.ticks.length; i++) {
          c = this.ticks[i].color;
          if (c && val >= this.ticks[i].value) {
            highestTickColor = c;
            highestTickColor = (c.indexOf('#') > -1) ? c : (themeColors[c] || themeColors.default);
          }
        }

        return highestTickColor;
      },

      /**
       * External Facing Function to set the value. Works as percent for now but need it on ticks.
       * NOTE:  Does not visually update the range.  Use _setValue()_ to do both in one swoop.
       * @param {Number} minVal
       * @param {Number} [maxVal]
       * @returns {Array}
       */
      value: function(minVal, maxVal) {
        var self = this;

        // if both options are absent, act as a getter and return the current value
        if (minVal === undefined && maxVal === undefined) {
          return self._value;
        }

        // if an array is passed as the first argument, break it apart
        if (minVal && $.isArray(minVal)) {
          if (minVal[1] !== undefined) {
            maxVal = minVal[1];
          }
          minVal = minVal[0];
        }

        // set the values back to the existing one if they aren't passed.
        if (minVal === undefined && $.isArray(self._value) && self._value[0] !== undefined) {
          minVal = self._value[0];
        }
        if (maxVal === undefined && $.isArray(self._value) && self._value[1] !== undefined) {
          maxVal = self._value[1];
        }

        //set the internal value and the element's retrievable value.
        self._value = [minVal, maxVal];
        self.element.val(maxVal !== undefined ? self._value : self._value[0]);
        $.each(self.handles, function(i, handle) {
          var value = self._value[i],
            valueText = self.getModifiedTextValue(value);

          $.each(self.ticks, function(a, tick) {
            if (tick.value === value) {
              valueText = tick.description;
            }
          });

          handle.attr({
            'aria-valuenow': self._value[i],
            'aria-valuetext': valueText
          });
        });

        self.element.trigger('change');
        return self._value;
      },

      /**
       * Returns a value with prefixed/suffixed text content.
       * Used by the tooltip and default ticks to get potential identifiers like $ and %.
       * @param {string} content
       * @returns {string}
       */
      getModifiedTextValue: function(content) {
        if (!this.settings.tooltip) {
          return content;
        }
        return this.settings.tooltip[0] + content + this.settings.tooltip[1];
      },

      /**
       * Enables the slider instance.
       * @returns {this}
       */
      enable: function() {
        this.element.prop('disabled', false);
        this.wrapper.removeClass('is-disabled');

        var self = this;
        $.each(this.handles, function(i, handle) {
          self.enableHandleDrag(handle);
        });

        return this;
      },

      /**
       * Disables the slider instance.
       * @returns {this}
       */
      disable: function() {
        this.element.prop('disabled', true);
        this.wrapper.addClass('is-disabled');

        var self = this;
        $.each(this.handles, function(i, handle) {
          self.disableHandleDrag(handle);
        });

        return this;
      },

      /**
       * Detects whether or not this slider is disabled
       * @returns {boolean}
       */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Detects whether or not this slider is vertical
       * @returns {boolean}
       */
      isVertical: function() {
        return this.wrapper.hasClass('vertical');
      },

      /**
       * Externally-facing function that updates the current values and correctly animates the range handles, if applicable.
       * @param {Number} lowVal
       * @param {Number} [highVal]
       * @returns {Array}
       */
      setValue: function(lowVal, highVal) {
        var oldVals = this.value();

        this.checkHandleDifference(this.handles[0], oldVals[0], lowVal);
        if (this.handles[1]) {
            this.checkHandleDifference(this.handles[1], oldVals[1], highVal);
        }

        var vals = this.value(lowVal, highVal);
        this.updateRange();
        this.updateTooltip();

        return vals;
      },

      // NOTE: refresh() has been deprecated in Xi Controls v4.2 - has been replaced with setValue().
      // This method will be completely removed in v4.3 and v5.x.  Please update your code.
      /**
       * @private
       * @returns {Array}
       */
      refresh: function(lowVal, highVal) {
        return this.setValue(lowVal, highVal);
      },

      /**
       * Updates the slider instance after a settings change.
       * Settings and markup are complicated in the slider so we just destroy and re-invoke it
       * with fresh settings.
       * @returns {this}
       */
      updated: function() {
        this.element.removeAttr('value');
        return this
          .teardown()
          .init();
      },

      /**
       * Removes the events and pseudo-markup created by the slider
       * @returns {this}
       */
      teardown: function() {
        var self = this;
        $.each(self.handles, function (i, handle) {
          self.disableHandleDrag(handle);
          handle.off('mousedown.slider click.slider blur.slider keydown.slider keyup.slider');
        });
        this.wrapper.off('click.slider touchend.slider touchcancel.slider').remove();
        this.element.attr('type', this.originalElement.type);

        return this;
      },

      /**
       * Destroys the slider component instance and unlinks it from its base element.
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * @fires Slider#events
       * @param {Object} mousedown
       * @param {Object} click
       * @param {Object} keydown
       * @param {Object} keyup
       * @param {Object} touchend
       * @param {Object} touchcancel
       * @param {Object} updated
       * @returns {this}
       */
      bindEvents: function() {
        var self = this;

        $.each(self.handles, function (i, handle) {
          handle.on('mousedown.slider', function () {
            if (self.isDisabled()) {
              return;
            }
            $(this).focus();
          })
          .on('click.slider', function (e) {
            e.preventDefault(); //Prevent from jumping to top.
          })
          .on('keydown.slider', function(e) {
            self.activateHandle(handle);
            self.handleKeys(e, self);
          })
          .on('keyup.slider blur.slider', function() {
            self.deactivateHandle(handle);
          });

          self.enableHandleDrag(handle);
        });

        self.wrapper.on('click.slider touchend.slider touchcancel.slider', function(e) {
          self.handleRangeClick(e);
        });

        // Slider Control listens to 'updated' trigger on its base element to update values
        self.element.on('updated.slider', function() {
          self.updated();
        });

        return self;
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        } else {
          instance.settings = $.extend({}, instance.settings, options);
        }
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Slider(this, options));
      }
    });
  };


  $.fn.arrange = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'arrange',
        defaults = {
          handle: null, // The Class of the handle element
          itemsSelector: null,
          connectWith: false,
          placeholder: null,
          placeholderCssClass: 'arrange-placeholder'
        },
        settings = $.extend({}, defaults, options);


    /**
    * The Arrange Component allows touch and drag support to sort UI items.
    *
    * @class Arrange
    * @param {String} handle  &nbsp;-&nbsp; The class name of the handle element to connect
    * @param {String} itemsSelector  &nbsp;-&nbsp; The selector to match all the sortable elements.
    * @param {String} connectWith  &nbsp;-&nbsp; The optional element to connect with when using two lists
    * @param {String} placeholder  &nbsp;-&nbsp; The html for the element that appears while dragging
    * @param {String} placeholderCssClass  &nbsp;-&nbsp; The class to add to the ghost element that is being dragged.
    *
    */
    function Arrange(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Arrange Methods
    Arrange.prototype = {

      // example from: https://github.com/farhadi/html5arrangeable/blob/master/jquery.arrangeable.js
      init: function() {
        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');
        this.handleEvents();
      },

      // Get Element By Touch In List
      getElementByTouchInList: function(list, x, y) {
        var returns = false;
        $(list).each(function() {
          var item = $(this), offset = item.offset();
          if (!(x <= offset.left || x >= offset.left + item.outerWidth() ||
                y <= offset.top  || y >= offset.top + item.outerHeight())) {
            returns = item;
          }
        });
        return returns;
      },

      // Dragg touch element
      dragTouchElement: function(e, elm) {
        var orig = e.originalEvent.changedTouches[0];
        elm[0].style.top = (orig.pageY - this.offset.y) + 'px';
        elm[0].style.left = (orig.pageX - this.offset.x) + 'px';
      },

      unbind: function() {
        this.items
          .removeClass('draggable')
          .removeAttr('draggable')
          .off('selectstart.arrange '+ this.dragStart +' '+ this.dragEnd +' '+ this.dragWhileDragging);

        $(this.handle, this.items)
          .removeClass('draggable')
          .off('mousedown.arrange mouseup.arrange touchstart.arrange touchend.arrange');

        return this;
      },

      /**
      * Resync the UI and Settings.
      */
      updated: function() {
        return this
          .unbind()
          .init();
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      },


      /**
       *  This component fires the following events.
       *
       * @fires Arrange#events
       * @param {Object} beforearrange  &nbsp;-&nbsp; Fires before moving an element allowing you to access the ui to customize the draggable item
       * @param {Object} afterearrange  &nbsp;-&nbsp; Fires after moving an element allowing you do any follow up updating.
       *
       */
      handleEvents: function() {
        var self = this,
          index, isHandle,
          status = {},
          items = self.element.children().not('[data-arrange-exclude="true"]'),
          placeholder = $('<' + (/^(ul|ol)$/i.test(self.element[0].tagName) ? 'li' : 'div') +'>');

        if (settings.itemsSelector) {
          items = $(settings.itemsSelector, self.element).not('[data-arrange-exclude="true"]');
          placeholder = $('<'+ items.first()[0].tagName +' />');
        }

        if (settings.placeholder) {
          placeholder = $(settings.placeholder);
        }

        self.dragStart = 'dragstart.arrange touchstart.arrange gesturestart.arrange';
        self.dragEnd = 'dragend.arrange touchend.arrange touchcancel.arrange gestureend.arrange';
        self.dragWhileDragging = 'dragover.arrange dragenter.arrange drop.arrange touchmove.arrange gesturechange.arrange';

        self.handle = settings.handle || self.element.attr('data-arrange-handle');
        self.connectWith = self.element.attr('data-arrange-connectWith');
        self.placeholders = placeholder;

        if (!self.isTouch) {
          self.placeholders.addClass(settings.placeholderCssClass +' draggable');
        }

        // Use Handle if available
        $(self.handle, items).addClass('draggable')
          .on('mousedown.arrange touchstart.arrange', function() { isHandle = true; })
          .on('mouseup.arrange touchend.arrange', function() { isHandle = false; });

        // Add connect with
        if (self.connectWith) {
          items = items
            .add($(self.connectWith).children().not('[data-arrange-exclude="true"]'))
            .data('connectWith', self.connectWith);
        }

        self.items = items;

        // Draggable Items
        self.items
        .attr('draggable', true).addClass(self.handle ? '' : 'draggable')
        .add([this, placeholder])
        .not('a[href], img').on('selectstart.arrange', function() {
          if(this.dragDrop) {
            this.dragDrop();//ie9
          }
          return false;
        }).end()

        .each(function() {
          $(this)
          // Drag start --------------------------------------------------------------------------
          .on(self.dragStart, function(e) {
            if (self.handle && !isHandle) {
              if (self.isTouch) {
                return;
              } else {
                return false;
              }
            }
            isHandle = false;
            self.dragging = $(this);

            index = self.dragging.addClass('arrange-dragging').index();

            $.extend(status, {start: self.dragging, startIndex: index});
            self.element.triggerHandler('beforearrange', status);

            if (self.isTouch) {
              var rect = self.dragging[0].getBoundingClientRect(),
                touch = e.originalEvent.changedTouches[0];

              //Save offset
              self.offset = {
                x: touch.pageX - rect.left,
                y: touch.pageY - rect.top
              };
              self.placeholderTouch = self.dragging
                .clone().addClass('is-touch').attr('id', 'arrange-placeholder-touch')
                .insertBefore(self.dragging);

              self.dragTouchElement(e, self.placeholderTouch);
            } else {
              var dt = e.originalEvent.dataTransfer;
              dt.effectAllowed = 'move';
              dt.setData('Text', 'dummy');
            }

          })

          // Drag end ----------------------------------------------------------
          .on(self.dragEnd, function() {
            if (!self.dragging) {
              return;
            }

            if (self.isTouch) {
              self.dragging.css('opacity', 1);
              self.placeholderTouch.remove();
            }

            self.placeholders.filter(':visible').after(self.dragging);
            self.dragging.removeClass('arrange-dragging').show();
            self.placeholders.detach();

            if (index !== self.dragging.index()) {
              $.extend(status, {end: self.dragging, endIndex: self.dragging.index()});
              self.element.triggerHandler('arrangeupdate', status);
            }
            self.dragging = null;
            self.placeholderTouch = null;
          })

          // While dragging ----------------------------------------------------
          .on(self.dragWhileDragging, function(e) {
            if (!self.dragging) {
              return;
            }
            var overItem = this,
              overIndex;
            e.preventDefault();

            if (e.type==='drop') {
              e.stopPropagation();
              self.dragging.trigger('dragend.arrange');
              return false;
            }

            if (self.isTouch) {
              var touch = e.originalEvent.touches[0];
              overItem = self.getElementByTouchInList(items, touch.pageX, touch.pageY) || overItem;
            }
            overItem = $(overItem);

            if (!self.isTouch) {
              e.originalEvent.dataTransfer.dropEffect = 'move';
            }

            if (items.is(overItem) && placeholder.index() !== overItem.index()) {
              if (self.isTouch) {
                self.dragging.css('opacity', 0);
              } else {
                self.dragging.hide();
              }

              if (placeholder.index() < (overItem.index())) {
                placeholder.insertAfter(overItem);
                overIndex = overItem.index();
              }
              else {
                placeholder.insertBefore(overItem);
                overIndex = placeholder.index();
              }

              $.extend(status, {over: overItem, overIndex: overIndex});
              self.element.triggerHandler('draggingarrange', status);

              // Fix: IE-11 on windows-10 svg was disappering
              var svg = $('svg', overItem);
              if(self.isIe11 && svg.length) {
                overItem.html(overItem.html());
              }

              self.placeholders.not(placeholder).detach();
            }
            else if (!self.placeholders.is(this)) {
              self.placeholders.detach();
              self.element.append(placeholder);
            }

            if (self.isTouch) {
              self.dragTouchElement(e, self.placeholderTouch);
              return;
            } else {
              return false;
            }
          });//-----------------------------------------------------------------
        });//end each items
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Arrange(this, settings));
      }
    });
  };


  $.fn.scrollaction = function(options) {

    var pluginName = 'scrollaction';
    var defaults = {
      scrollActionTarget: '.js-scroll-target', // The element to add a class to based on scrolling logic
      classToAdd: 'scrolled-down' // The class added to the target element
    };

    var functions = {
      trackScrolling: function() {
        var self = this;
        self.lastScrollTop = 0;

        this.element.scroll(function() {
          var st = $(this).scrollTop();

          if (st > self.lastScrollTop){
            $(self.settings.scrollActionTarget).addClass(self.settings.classToAdd);
          } else {
            $(self.settings.scrollActionTarget).removeClass(self.settings.classToAdd);
          }

          self.lastScrollTop = st;
        });
      }
    };

    /**
     * A component that applies a class based on scroll direction
     * @constructor
     * @param {Object} [element=this] - The element to attach to (only when manually calling the constructor)
     * @param {Object} [options]
     * @param {string} [options.scrollActionTarget='.js-scroll-target'] - The selector of the element to add the class to
     * @param {string} [options.classToAdd='scrolled-down'] - The class name
     */
    function ScrollAction(element, options) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      functions.trackScrolling.call(this);
    }

    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
      } else {
        instance = $.data(this, pluginName, new ScrollAction(this, options));
      }
    });
  };



  $.fn.spinbox = function(options, args) {
    'use strict';

    // Settings and Options
    var pluginName = 'spinbox',
        defaults = {
          min: null,
          max: null,
          step: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Spinbox component provides easy access to modification of a numeric input field.
    *
    * @class Spinbox
    * @param {null|Number} min &nbsp;-&nbsp; if defined, provides a minimum numeric limit
    * @param {null|Number} max  &nbsp;-&nbsp; if defined, provides a maximum numeric limit
    * @param {null|Number} step  &nbsp;-&nbsp; if defined, increases or decreases the spinbox value by a specific interval whenever the control buttons are used.
    */
    function Spinbox(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Spinbox.prototype = {

      /**
       * @private
       */
      init: function() {
        this.settings = $.extend({}, settings);
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.isWrapped = this.element.parent().is('.spinbox-wrapper');

        this
          .setInitialValue()
          .addMarkup()
          .bindEvents()
          .setWidth();
      },

      /**
       * Sets the width of the spinbox input field.
       * @returns {this}
       */
      setWidth: function() {
        var style = this.element[0].style;

        if (style.width) {
          this.element.parent()[0].style.width = (parseInt(style.width) + (this.element.parent().find('.down').outerWidth() * 2)) + 'px';
        }

        return this;
      },

      /**
       * Sanitize the initial value of the input field.
       * @returns {this}
       */
      setInitialValue: function() {
        var self = this,
          val = self.checkForNumeric(self.element.val());

        this.element.val(val);
        // If using Dirty Tracking, reset the "original" value of the dirty tracker to the current value
        // of the input, since it may have changed after re-invoking the input field.
        if (this.element.attr('data-trackdirty')) {
          this.element.data('original', val);
        }

        //allow numeric input on iOS
        var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );
        if (iOS) {
          this.element.attr('pattern','\\d*');
        }

        if (this.settings.max) {
          this.element.attr('max', this.settings.max);
        }
        if (this.settings.step) {
          this.element.attr('step', this.settings.step);
        }
        if (this.settings.min) {
          this.element.attr('min', this.settings.min);
        }


        return this;
      },

      /**
       * Appends extra control markup to a Spinbox field.
       * @returns {this}
       */
      addMarkup: function() {
        var self = this;
        if (this.isInlineLabel) {
          this.inlineLabel.addClass('spinbox-wrapper');
        }
        else if (!this.isWrapped) {
          var spinboxWrapper = '<span class="spinbox-wrapper"></span>';
          if (this.element.is('.field-options')) {
            var field = this.element.closest('.field'),
              fieldOptionsTrigger = field.find('.btn-actions');

            this.element
              .add(fieldOptionsTrigger)
              .add(fieldOptionsTrigger.next('.popupmenu'))
              .wrapAll(spinboxWrapper);
          } else {
            this.element.wrap(spinboxWrapper);
          }
        }

        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (this.isWrapped) {
          this.buttons = {
            'down' : this.element.parent().find('.down').button(),
            'up' : this.element.parent().find('.up').button()
          };

          if (this.isTouch) {
            this.buttons.down.attr('aria-hidden', 'true');
            this.buttons.up.attr('aria-hidden', 'true');
          }
        }

        if (!this.buttons) {
          this.buttons = {
            'down' : $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control down">-</span>').insertBefore(this.element).button(),
            'up' : $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control up">+</span>').insertAfter(this.element).button()
          };
        }

        // Figure out minimum/maximum and data-masking attributes.  The user can provide the spinbox
        // plugin either the min/max or the mask, and the plugin will automatically figure out how to
        // use them.
        var min = this.element.attr('min'),
          max = this.element.attr('max'),
          mask = this.element.attr('data-mask'),
          maskSize, maskValue = '',
          attributes = {
            role: 'spinbutton'
          },
          i = 0;

        // Define a default Max value if none of these attributes exist, to ensure the mask plugin will
        // work correctly.  Cannot define a Min value here because the plugin must be able to invoke itself
        // with a NULL value.
        if (!min && !max && !mask) {
          max = '9999999';
        }

        // If a mask doesn't exist, but min and max values do exist, create a mask that reflects those min/max values
        if ((min || max) && !mask) {
          var newMask = '',
            tempMin = min ? min : '',
            tempMax = max ? max : '',
            longerVal = tempMin.length > tempMax.length ? tempMin : tempMax;
          i = 0;

          while (i <= longerVal.length) {
            newMask += '#';
            i++;
          }

          // Add a negative symbol to the mask if it exists within the longer value.
          if (tempMin.indexOf('-') !== -1 || tempMax.indexOf('-') !== -1) {
            newMask = '-' + newMask.substring(0, (newMask.length - 1));
          }

          attributes['data-mask'] = newMask;
          mask = newMask;
        }

        // If a "data-mask" attribute is already defined, use it to determine missing values for min/max, if they
        // don't already exist.
        maskSize = mask.length;
        i = 0;
        while (i <= maskSize) {
          maskValue += '9';
          i++;
        }

        // If no negative symbol exists in the mask, the minimum value must be zero.
        if (mask.indexOf('-') === -1) {
          attributes.min = min ? min : 0;
          attributes.max = max ? max : maskValue;
        } else {
          attributes.min = min ? min : maskValue;
          attributes.max = max ? max : maskValue.substring(0, (maskValue.length - 1));
        }

        if (!this.element.attr('data-mask-mode') || this.element.attr('data-mask-mode') !== 'number') {
          attributes['data-mask-mode'] = 'number';
        }

        // Destroy the Mask Plugin if it's already been invoked.  We will reinvoke it later on during
        // initialization.  Check to make sure its the actual Mask plugin object, and not the "data-mask"
        // pattern string.
        if (this.element.data('mask') && typeof this.element.data('mask') === 'object') {
          this.element.data('mask').destroy();
        }

        // Add Aria Properties for valuemin/valuemax
        if (min) {
          attributes['aria-valuemin'] = min;
        }
        if (max) {
          attributes['aria-valuemax'] = max;
        }
        this.element.attr(attributes);

        // Set an initial "aria-valuenow" value.
        this.updateAria(self.element.val());

        // Invoke the mask plugin
        this.element.mask();

        // Disable in full if the settings have determined we need to disable on init.
        if (this.isDisabled()) {
          this.disable();
        }

        return this;
      },

      /**
       * Enables Long Pressing one of the Spinbox control buttons.
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      enableLongPress: function(e, self) {
        self.addButtonStyle(e);
        self.longPressInterval = setInterval(function() {
          if ($(e.currentTarget).is(':hover')) {
            self.handleClick(e);
          }
        }, 140);
      },

      /**
       * Disables Long Pressing one of the Spinbox control buttons.
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      disableLongPress: function(e, self) {
        self.removeButtonStyle(e);
        clearInterval(self.longPressInterval);
        self.longPressInterval = null;
      },

      /**
       * Event handler for 'click' events
       * @param {jQuery.Event} e
       */
      handleClick: function(e) {
        if (this.isDisabled() || e.which !== 1) {
          return;
        }
        var target = $(e.currentTarget);
        if (target.hasClass('up')) {
          this.increaseValue();
        } else {
          this.decreaseValue();
        }

        if (!this.isTouch) {
          this.element.focus();
        } else {
          target.focus();
        }
      },

      /**
       * Event handler for 'keydown' events
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      handleKeyDown: function(e, self) {
        var key = e.which,
          validKeycodes = [35, 36, 37, 38, 39, 40];

        if ($.inArray(key, validKeycodes) === -1) {
          return;
        }

        // If the keycode got this far, it's an arrow key, HOME, or END.
        switch(key) {
          case 35: // End key sets the spinbox to its minimum value
            if (self.element.attr('min')) { self.element.val(self.element.attr('min')); }
            break;
          case 36: // Home key sets the spinbox to its maximum value
            if (self.element.attr('max')) { self.element.val(self.element.attr('max')); }
            break;
          case 38: case 39: // Right and Up increase the spinbox value
            if (Locale.isRTL() && key === 39) {
              self.addButtonStyle(self.buttons.down);
              self.decreaseValue();
            } else {
              self.addButtonStyle(self.buttons.up);
              self.increaseValue();
            }
            break;
          case 37: case 40: // Left and Down decrease the spinbox value
            if (Locale.isRTL() && key === 37) {
              self.addButtonStyle(self.buttons.up);
              self.increaseValue();
            } else {
              self.addButtonStyle(self.buttons.down);
              self.decreaseValue();
            }
            break;
        }
      },

      /**
       * Event handler for 'keypress' events
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      handleKeyPress: function(e, self) {
        if (self.isDisabled()) {
          return;
        }
        var key = e.which;

        // NOTE:
        if (key < 48 || (key > 57 && key < 96) || key > 105) {
          return;
        }

        // If the key is a number, pre-calculate the value of the number to see if it would be
        // greater than the maximum, or less than the minimum.  If it's fine, let it through.
        // Doing this check here prevents visual jitter.
        var num = Number(this.checkForNumeric(this.element.val())), // if using Numlock, subtract 48 to get the correct value from String.fromCharCode()
          min = self.element.attr('min'),
          max = self.element.attr('max');

        if (num < min) {
          e.preventDefault();
          return self.updateVal(min);
        }
        if (num > max) {
          e.preventDefault();
          return self.updateVal(max);
        }
      },

      /**
       * Event handler for 'keyup' events
       * @param {jQuery.Event} e
       * @param {Spinbox} self
       */
      handleKeyup: function(e, self) {
        if (self.isDisabled()) {
          return;
        }
        var key = e.which;

        // Spinbox Control Button styles are added/removed on keyup.
        switch (key) {
          case 38: case 39:
            if (Locale.isRTL() && key === 39) {
              self.removeButtonStyle(self.buttons.down);
            } else {
              self.removeButtonStyle(self.buttons.up);
            }
            break;
          case 37: case 40:
            if (Locale.isRTL() && key === 39) {
              self.removeButtonStyle(self.buttons.up);
            } else {
              self.removeButtonStyle(self.buttons.down);
            }
            break;
        }

        self.updateAria(self.element.val());
      },

      /**
       * Change a newly pasted value to this element's min or max values, if the pasted value goes
       * beyond either of those limits.  Listens to an event emitted by the Mask plugin after pasted content
       * is handled.
       * @param {Spinbox} self
       */
      handleAfterPaste: function(self) {
        var min = Number(self.element.attr('min')),
          max = Number(self.element.attr('max')),
          val = Number(self.element.val());

        val = (val < min ? min : (val > max ? max : val));
        self.updateVal(val);
      },

      /**
       * Increases the value of the Spinbox field, constrained by the step interval and maximum limit.
       */
      increaseValue: function() {
        var val = this.checkForNumeric(this.element.val()) + Number(this.element.attr('step') || 1);
        if (this.element.attr('max') && val > this.element.attr('max')) {
          return;
        }
        this.updateVal(val);
      },

      /**
       * Decreases the value of the Spinbox field, constrained by the step interval and minimum limit.
       */
      decreaseValue: function() {
        var val = this.checkForNumeric(this.element.val()) - Number(this.element.attr('step') || 1);
        if (this.element.attr('min') && val < this.element.attr('min')) {
          return;
        }
        this.updateVal(val);
      },

      /**
       * Sets a new spinbox value and focuses the spinbox.
       * @param {Number|String} newVal
       */
      updateVal: function(newVal) {
        this.element.val(newVal).trigger('change');
        this.updateAria(newVal);
        this.element.focus();
      },

      /**
       * Sanitizes the value of the input field to an integer if it isn't already established.
       * @param {Number|String} val - will be converted to a number if it's a string.
       * @returns {Number}
       */
      checkForNumeric: function(val) {
        // Allow for NULL
        if (val === '') {
          return val;
        }
        if ($.isNumeric(val)) {
          return Number(val);
        }
        val = parseInt(val);
        if ($.isNumeric(val)) {
          return Number(val);
        }
        // Zero out the value if a number can't be made out of it.
        return 0;
      },

      /**
       * Updates the "aria-valuenow" property on the spinbox element if the value is currently set
       */
      updateAria: function(val) {
        var min = this.element.attr('min'),
          max = this.element.attr('max');

        val = this.checkForNumeric(val);
        this.element.attr('aria-valuenow', (val !== '' ? val : ''));

        // Tougle min/max buttons
        this.setIsDisabled(this.buttons.up, (val !== '' && max && val >= max) ? 'disable' : 'enable');
        this.setIsDisabled(this.buttons.down, (val !== '' && min && val <= min) ? 'disable' : 'enable');
      },

      /**
       * adds a "pressed-in" styling for one of the spinner buttons
       */
      addButtonStyle: function(e) {
        if (this.isDisabled()) {
          return;
        }
        var target = e;
        if (e.currentTarget) {
          target = $(e.currentTarget);
        }
        target.addClass('is-active');
      },

      /**
       * Removes "pressed-in" styling for one of the spinner buttons
       */
      removeButtonStyle: function(e) {
        if (this.isDisabled()) {
          return;
        }
        var target = e;
        if (e.currentTarget) {
          target = $(e.currentTarget);
        }
        target.removeClass('is-active');
      },

      /**
       * Enables the Spinbox
       */
      enable: function() {
        this.element.prop('disabled', false);
        this.element.parent('.spinbox-wrapper').removeClass('is-disabled');
      },

      /**
       * Disables the Spinbox
       */
      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent('.spinbox-wrapper').addClass('is-disabled');
      },

      /**
       * Determines whether or not the spinbox is disabled.
       * @returns {boolean}
       */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Toggle whther or not the component is disabled.
       * @param {jQuery[]} button
       * @param {booelan} isDisabled
       */
      setIsDisabled: function(button, isDisabled) {
        isDisabled = isDisabled === undefined ? true :
          (!isDisabled || isDisabled === 'enable') ? false : true;

        button[isDisabled ? 'addClass' : 'removeClass']('is-disabled');
      },

      /**
       * Teardown
       */
      destroy: function() {
        var mask = this.element.data('mask');
        if (mask && typeof mask.destroy === 'function') {
          mask.destroy();
        }

        for (var button in this.buttons) {
          var buttonAPI = $(button).data('button');

          if (buttonAPI) {
            buttonAPI.destroy();
          }
        }

        this.buttons.up.off('click.spinbox mousedown.spinbox');
        this.buttons.up.remove();
        this.buttons.down.off('click.spinbox mousedown.spinbox');
        this.buttons.down.remove();
        this.element.off('focus.spinbox blur.spinbox keydown.spinbox keyup.spinbox');
        this.element.unwrap();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       *
       * @listens Spinbox#events
       * @param {Object} focus  &nbsp;-&nbsp;
       * @param {Object} blur  &nbsp;-&nbsp;
       * @param {Object} keydown  &nbsp;-&nbsp;
       * @param {Object} keypress  &nbsp;-&nbsp;
       * @param {Object} keyup  &nbsp;-&nbsp;
       * @param {Object} afterpaste  &nbsp;-&nbsp;
       */
      bindEvents: function() {
        var self = this,
          preventClick = false;

        // Main Spinbox Input
        this.element.on('focus.spinbox', function() {
          self.element.parent('.spinbox-wrapper').addClass('is-focused');
        }).on('blur.spinbox', function() {
          self.element.parent('.spinbox-wrapper').removeClass('is-focused');
          // Explicitly trigger the change event if the "original" value is different from its current value.
          // Prevents an issue where changing the value with arrow keys doesn't trigger the "change" event on blur.
          self.element.trigger('change');
        }).on('keydown.spinbox', function(e) {
          self.handleKeyDown(e, self);
        }).on('keypress.spinbox', function(e) {
          self.handleKeyPress(e, self);
        }).on('keyup.spinbox', function(e) {
          self.handleKeyup(e, self);
        }).on('afterpaste.mask', function() {
          self.handleAfterPaste(self);
        });

        // Up and Down Buttons
        var buttons = this.buttons.up.add(this.buttons.down[0]);
        buttons.on('touchstart.spinbox mousedown.spinbox', function(e) {
          if (e.which === 1) {

            if (!preventClick) {
              self.handleClick(e);
            }

            if (self.isTouch) {
              return;
            }

            preventClick = true;
            self.enableLongPress(e, self);

            $(document).one('mouseup', function() {
              self.disableLongPress(e, self);
              preventClick = false;
              self.element.focus();
            });

            //Stop MouseDown From Running
            if (this.isTouch) {
              e.preventDefault();
              e.stopPropagation();
            }
          }
        });

        return this;
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Spinbox(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.splitter = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'splitter',
        defaults = {
          axis: 'x',
          side: 'left', // or right
          resize: 'immediate',
          containment: null, //document or parent
          save: true
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Splitter(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Splitter.prototype = {
      init: function() {
        //Do other init (change/normalize settings, load externals, etc)
        return this
          .build()
          .handleEvents();
      },

      // Build the Control and Events
      build: function() {
        var self = this,
          s = this.settings,
          splitter = this.element,
          parent = splitter.parent(),
          w = parent.width(),
          direction = s.axis === 'x' ? 'left' : 'top',
          thisSide = parent.is('.content') ? parent.parent() : parent,
          parentHeight,
          defaultOffset = 299;

        setTimeout(function() {
          parentHeight = parent.height();
        }, 0);

        this.docBody = $('body');
        this.isSplitterRightSide = splitter.is('.splitter-right') || (s.axis === 'x' && s.side === 'right');
        this.isSplitterHorizontal = splitter.is('.splitter-horizontal') || s.axis === 'y';
        s.uniqueId = this.uniqueId();

        if (this.isSplitterRightSide) {
          var thisPrev = thisSide.prev();
          if (thisPrev.is('.main')) {
            this.leftSide = thisPrev;
            w = thisSide.parent().outerWidth() - w;
          } else {
            this.leftSide = thisSide;
            splitter.addClass('splitter-right');
          }

          thisSide.addClass('is-right-side')
            .next().addClass('flex-grow-shrink is-right-side')
            .parent().addClass('splitter-container');

          if (s.collapseButton) {
            var savedOffset = 0;
            var $splitterButton = $('<button type="button" class="splitter-btn" id="splitter-collapse-btn" title="Collapse"><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-double-chevron"></use></svg></button>');
            $splitterButton.appendTo(splitter);
            if (splitter[0].offsetLeft > 10) {
              $('#splitter-collapse-btn').addClass('rotate');
            }
            $('#splitter-collapse-btn').click(function() {
              if (savedOffset <= 0) {
                if (splitter[0].offsetLeft <= 10){
                  self.splitTo(defaultOffset, parentHeight);
                  $(this).addClass('rotate');
                } else {
                  savedOffset = splitter[0].offsetLeft;
                  self.splitTo(0, parentHeight);
                  $(this).removeClass('rotate');
                }
              } else {
                if (splitter[0].offsetLeft > 10){
                  savedOffset = splitter[0].offsetLeft;
                  self.splitTo(0, parentHeight);
                  $(this).removeClass('rotate');
                } else {
                  self.splitTo(savedOffset, parentHeight);
                  $(this).addClass('rotate');
                  savedOffset = 0;
                }
              }
            });
          }
        }
        else if (this.isSplitterHorizontal) {
          this.topPanel = splitter.prev();
          w = this.topPanel.height();

          parent.addClass('splitter-container is-horizontal');
          splitter.next().addClass('flex-grow-shrink');
          splitter.addClass('splitter-horizontal');
        } else {
          this.rightSide = thisSide;
          this.leftSide = thisSide.prev().parent();

          thisSide.prev()
            .addClass('flex-grow-shrink')
            .parent().addClass('splitter-container');
        }

        //Restore from local storage
        if (localStorage && s.save &&
          !isNaN(parseInt(localStorage[s.uniqueId]))) {
          w = localStorage[s.uniqueId];
        }

        w = parseInt(w);

        if (this.isSplitterHorizontal) {
          splitter[0].style.top = w + 'px';
        } else {
          splitter[0].style.top = 0;
        }

        this.splitTo(w, parentHeight);

        //Add the Splitter Events
        this.documentWidth = 0;

        this.element.drag({
          axis: s.axis,
          containment: s.containment || s.axis === 'x' ? 'document' : 'parent',
          containmentOffset: {left: 20, top: 0}
        })
        .on('dragstart.splitter', function () {
          var iframes = $('iframe');
          self.documentWidth = $(document).width();

          if (iframes.length > 0) {
            for (var i = 0, l = iframes.length; i < l; i++) {
              var frame = $(iframes[i]),
                width = parseInt(getComputedStyle(frame.parent()[0]).width, 10) - 40 +'px';
              frame.before('<div class="overlay" style="opacity: 0; visibility: visible; height: 100%; width: '+ width +'"></div>');
            }
          }
        })
        .on('dragend.splitter', function (e, args) {
          $('.overlay').remove();

          if (s.collapseButton) {
            if (args[direction] <= 10) {
              $('#splitter-collapse-btn').removeClass('rotate');
            } else {
              $('#splitter-collapse-btn').addClass('rotate');
            }
          }

          if (s.resize === 'end') {
            self.splitTo(args[direction], parentHeight);
          }

        })
        .on('drag.splitter', function (e, args) {
          if (args.left <= 0) {
            return false;
          }
          if (s.resize === 'immediate') {
            self.splitTo(args[direction], parentHeight);
          }
        });

        //Horizontal Splitter
        if (s.axis === 'y') {
          this.element.addClass('splitter-horizontal');
        }

        //Aria
        this.element.attr({'aria-dropeffect': 'move', 'tabindex': '0', 'aria-grabbed': 'false'});

        return this;
      },

      toggleSelection: function () {
        this.element.toggleClass('is-dragging');
      },

      //Resize the panel vertically
      resizeTop: function (splitter, top, parentHeight) {
        if (top > parentHeight || top < 0) {
          top = parseInt(parentHeight) / 2;
        }

        this.topPanel[0].style.height = top + 'px';
      },

      //Resize the panel to the Left
      resizeLeft: function (splitter, leftArg) {
        var left = this.leftSide.outerWidth() - leftArg;

        //Adjust Left and Right Side
        this.rightSide[0].style.width = left + 'px';

        //Reset the Width
        splitter[0].style.left = '';
      },

      //Resize the panel to the Right
      resizeRight: function (splitter, w) {
        //Adjust Left and Right Side
        this.leftSide[0].style.width = w + 'px';
        splitter[0].style.left = (w-1) +'px';
      },

      //Preferably use the id, but if none that make one based on the url and count
      uniqueId: function () {
        return this.element.attr('id') ||
          (window.location.pathname.split('/').pop()) + '-splitter-' + $('.splitter').length;
      },

      splitTo: function (split, parentHeight) {
        var self = this,
          splitter = this.element;

        if (this.isSplitterRightSide) {
          this.resizeRight(splitter, split);
        } else if (this.isSplitterHorizontal) {
          this.resizeTop(splitter, split, parentHeight);
        } else {
          this.resizeLeft(splitter, split);
        }

        this.element.trigger('split', [split]);
        this.docBody.triggerHandler('resize', [self]);

        //Save to local storage
        if (localStorage) {
          localStorage[this.settings.uniqueId] = split;
        }

        this.split = split;
        this.parentHeight = parentHeight;
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       *
       * @fires Splitter#events
       * @param {Object} updated  &nbsp;-&nbsp; Fires when the component updates.
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when a key is pressed while the component is focused.
       */
      handleEvents: function() {
        var self = this;

        this.element
          .on('updated.' + pluginName, function() {
            self.updated();
          })
          .on('keydown.' + pluginName, function(e) {
            //Space will toggle selection
            if (e.which === 32) {
              self.toggleSelection();
              e.preventDefault();
            }

            if (e.which === 37) {
              self.splitTo(self.split - 15, self.parentHeight);
            }

            if (e.which === 39) {
              self.splitTo(self.split + 15, self.parentHeight);
            }
          });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Splitter(this, settings));
      }
    });
  };


  $.fn.stepprocess = function(options) {
    var pluginName = 'stepprocess',
      defaults = {
        linearProgression: false,
        folderIconOpen: 'caret-up',
        folderIconClosed: 'caret-down',
        stepList: '#step-list',
        stepLi: '.js-step',
        stepLink: '.js-step-link',
        stepFolder: '.js-step-folder',
        btnPrev: '.js-step-link-prev',
        btnNext: '.js-step-link-next',
        beforeSelectStep: null,
      },
      settings = $.extend({}, defaults, options);

    /**
    * A Stepprocess/wizard control
    *
    * @class Stepprocess
    * @param {Boolean} linearProgression The Main Application Name to display in the header. (Defaults to false)
    * @param {String} folderIconOpen A specific folder open icon. (Defaults to 'caret-up')
    * @param {String} folderIconClosed A specific folder close icon. (Defaults to 'caret-down')
    * @param {Boolean} stepList Determines whether or not to display device information (Browser, Platform, Locale, Cookies Enabled).
    * @param {String} stepLi jQuery selector for the step elements.
    * @param {Boolean} stepLink jQuery selector for the step link elements.
    * @param {String} stepFolder jQuery selector for the step folder elements.
    * @param {String} btnPrev jQuery selector for the previous step button.
    * @param {String} btnNext jQuery selector for the next step button.
    * @param {Function} beforeSelectStep  A callback (function or promise) that gives args: stepLink (the step link element) and isStepping (whether we are prev/next'ing or not).
    *
    */
    function Stepprocess(element) {
      this.element = $(element);
      this.init();
    }

    // Stepprocess Methods
    Stepprocess.prototype = {
      init: function() {
        this.settings = $.extend({}, settings);
        this.$stepList = $(this.settings.stepList);
        this.initStepprocess();
        this.handleKeys();
        this.setupEvents();
        this.focusFirst();
      },

      /** @private  */
      initStepprocess: function() {
        var self = this,
          steps = self.$stepList.find(this.settings.stepLi);

        steps.each(function() {
          self.decorateNode(this);
        });

        var startingStep = $(this.settings.stepLi + '.is-selected');
        var startingStepLink = startingStep.find(this.settings.stepLink);
        this.selectStep(startingStepLink);
      },

       /**
       * @private
       * Set initial attributes on each step its counterparts
       * @param  {object} step - The step element to decorate
       */

      decorateNode: function(step) {
        var self = this,
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink),
            $stepFolder = $step.children(this.settings.stepFolder),
            isDisabled = $stepLink.hasClass('is-disabled'),
            isOpen = $stepFolder.hasClass('is-open');

        if (isDisabled) {
          $stepLink.attr('aria-disabled','true');
        }

        if ($stepFolder.length) {

          $step.addClass('folder');
          $stepFolder.attr('role', 'group');

          if (isDisabled) {
            $stepFolder.addClass('disabled');

            if (isOpen) {
              $stepFolder.children().each(function() {
                $(this).find(self.settings.stepLink)
                  .addClass('is-disabled')
                  .attr('aria-disabled', 'true');
              });
            }
          }

          $stepLink.attr('aria-expanded', isOpen);
        }

        // parentCount 'aria-level' to the node's level depth
        var parentCount = $stepLink.parentsUntil(this.$stepList, 'ul').length - 1;

        // Set the current stepprocess item node position relative to its aria-setsize
        var posinset = $step.index();

        // Set the current stepprocess item aria-setsize
        var listCount = $step.siblings().addBack().length;

        $stepLink
          .attr({
            'role': 'stepitem',
            'tabindex': '-1',
            'aria-selected': 'false',
            'aria-level': parentCount + 1,
            'aria-posinset': posinset + 1,
            'aria-setsize': listCount,
            'aria-disabled': isDisabled
          })
          .addClass('hide-focus')
          .hideFocus();
      },

       /** @private  */

        /**
       * @private
       * @param  {object} step - The step element
       * @return {boolean}
       */

      /** @private  */
      focusFirst: function () {
        this.$stepList.find(this.settings.stepLi + ':first').attr('tabindex', '0');
      },

          /**
       * @private
       * @param  {[type]} step - The step element
       */

      /**
       * @private
       * @param  {object} step - The step element
       */
      folderClose: function(step) {
        var self = this,
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink),
            $stepFolder = $step.children(this.settings.stepFolder);

        var treeIcon = $stepLink
                        .closest('.folder')
                          .removeClass('is-open')
                          .end()
                        .find('svg.icon-tree');

        this.setIcon(treeIcon, this.settings.folderIconClosed);

        this.isAnimating = true;

        $stepFolder
          .one('animateclosedcomplete', function() {
            $stepFolder.removeClass('is-open');
            self.isAnimating = false;
          })
          .animateClosed();

        $stepLink.attr('aria-expanded', 'false');
      },

      /**
       * @private
       * @param  {object} step - The step element
       */
      folderOpen: function(step) {
        var self = this,
            $step = $(step);

        if (!this.isOpen($step)) {

          var $stepLink = $step.children(this.settings.stepLink),
              $stepFolder = $step.children(this.settings.stepFolder);

          $step.addClass('is-open');
          $stepLink.attr('aria-expanded', 'true');

          var svgElem = $stepLink.find('svg.icon-tree');
          self.setIcon(svgElem, self.settings.folderIconOpen);

          self.isAnimating = true;

          $stepFolder
            .one('animateopencomplete', function() {
              self.isAnimating = false;
            })
            .addClass('is-open')
            .css('height', 0)
            .animateOpen();
        }
      },

      /**
       * @private
       * @param  {[type]} stepLink- Description
       * @return {[type]}     - Description
       */
      folderToggle: function(stepLink) {
        var $step = stepLink.closest(this.settings.stepLi);

        if (this.isFolder($step)) {
          var $stepFolder = $step.children(this.settings.stepFolder);
          if (this.isOpen($stepFolder)) {
            this.folderClose($step);
          } else {
            this.folderOpen($step);
          }
        }
      },


       /**
       * @private
       * @return {object} - the "step" element
       */

      /**
       * @private
       * @return {object}
       */
      getSelectedStep: function () {
        return $(this.settings.stepLi + '.is-selected', this.$stepList);
      },

      /**
       * @private
       * @param  {object} stepLink - The step link element
       * @return {object}
       */
      getNextNode: function(stepLink) {
        var next = stepLink.parent().next().find(this.settings.stepLink + ':first');
        var $nextStep = next.closest(this.settings.stepLi);

        // Possibly Move Into Children
        if (stepLink.next().is(this.settings.stepFolder) && stepLink.next().hasClass('is-open')) {
          next = stepLink.next().find(this.settings.stepLink + ':first');
        }

        //skip disabled
        if(next.hasClass('is-disabled')) {
          next = $nextStep.next().find(this.settings.stepLink + ':first');
        }

        //bottom of a group..{l=2: max folders to be deep }
        if (next.length === 0) {
          for (var i=0, l=2, closest=stepLink; i < l; i++) {
            closest = closest.parent().closest('.folder');
            next = closest.next().find(this.settings.stepLink + ':first');
            if (next.length) {
              break;
            }
          }
        }
        return next;
      },
       /**
       * @private
       * Get the next step in the tree
       * (not to be confused with getNextNode, which includes folders)
       * @return {object}
       */

      /**
       * @private
       * @return {object}
       */
      getNextStep: function() {
        var $curStep = this.getSelectedStep(),
            $curStepLink = $curStep.children(this.settings.stepLink),
            $curStepFolder = $curStep.next(this.settings.stepFolder),
            $nextStepLink = this.getNextNode($curStepLink),
            $nextStepFolder = $nextStepLink.next(this.settings.stepFolder),
            stepLinkToSelect = null,
            theFolder = null;

        if ($curStepFolder.length) {
          // Select the first node of the current folder,
          // unless its empty, which means nextStep will be the folder's "title"
          theFolder = $curStepFolder;
          stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : $nextStepLink;

        } else if ($nextStepFolder.length) {
          // Select the first node of the next node's folder,
          // unless its empty, which means nextStep will be the folder's "title"
          theFolder = $nextStepFolder;
          stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : $nextStepLink;

        } else {
          // Neither folders options work so select the next node
          stepLinkToSelect = $nextStepLink;
        }

        return stepLinkToSelect;
      },

      /**
       * @private
       * @param  {object} stepLink - The step link element
       * @return {object}
       */
      getPreviousNode: function(stepLink) {
        var prev = stepLink.parent().prev().find(this.settings.stepLink + ':first');
        var $prevStep = prev.closest(this.settings.stepLi);

        //move into children at bottom
        if ($prevStep.is('.folder.is-open') &&
            $prevStep.find('ul.is-open a').length &&
            !$prevStep.find('ul.is-disabled').length) {
          prev = $prevStep.find('ul.is-open ' + this.settings.stepLink + ':last');
        }

        //skip disabled
        if(prev.hasClass('is-disabled')) {
          prev = $prevStep.prev().find(this.settings.stepLink + ':first');
        }

        //top of a group
        if (prev.length === 0) {
          prev = stepLink.closest(this.settings.stepFolder).prev(this.settings.stepLink);
        }
        return prev;
      },

      /**
       * @private
       * Get the previous step in the tree
       * (not to be confused with getPreviousNode, which includes folders)
       * @return {object}
       */
      getPreviousStep: function() {
        // Get the currently select node
        var $curStep = this.getSelectedStep(),
            $curStepLink = $curStep.children(this.settings.stepLink);

        // Get the previous step to switch to
        var $prevStepLink = this.getPreviousNode($curStepLink),
            $prevStep = $prevStepLink.closest(this.settings.stepLi),
            stepLinkToSelect = $prevStepLink;

        // If we are moving upwards and hit a folder title step
        if (this.isFolder($prevStep)) {

          if (this.isOpen($prevStep)) {
            // If the folder is open, and we got here, that means we
            // were currently at the first step in the folder and need to
            // go to the prev step above the folder step (aka the prev to the prev)
            stepLinkToSelect = this.getPreviousNode($prevStepLink);

          } else {
            var theFolder = $prevStep.children(this.settings.stepFolder);

            if (theFolder.children().length) {
              stepLinkToSelect = theFolder.find(this.settings.stepLink).last();
            }
          }
        }

        return stepLinkToSelect;
      },

      /**
       * Go to the next step element
       */
      goToNextStep: function() {
        var stepLink = this.getNextStep();
        if (stepLink.length) {
          this.selectStep(stepLink, 'next');
        }
      },

      /**
       * Go to the previous step element
       */
      goToPreviousStep: function() {
        var stepLink = this.getPreviousStep();
        if (stepLink.length) {
          this.selectStep(stepLink, 'prev');
        }
      },

      /**
       * @private
       * Key Behavior as per:
       * http://access.aol.com/dhtml-style-guide-working-group/#treeview
       */
      handleKeys: function () {
        var self = this;

        this.$stepList.on('focus.stepprocess', this.settings.stepLink, function() {
          var target = $(this);
          if ((parseInt(target.attr('aria-level')) === 0) &&
              (parseInt(target.attr('aria-posinset')) === 1)) {

            // First element if disabled
            if (target.hasClass('is-disabled')) {
              var e = $.Event('keydown.stepprocess');
              e.keyCode= 40; // move down
              target.trigger(e);
              return;
            }
          }
        });

        // Handle Up/Down Arrow Keys and Space
        this.$stepList.on('keydown.stepprocess', this.settings.stepLink, function (e) {

          var charCode = e.charCode || e.keyCode,
              target = $(this),
              next, prev;

          if (self.isAnimating) {
            return;
          }

          //down arrow
          if (charCode === 40) {
            var nextNode = self.getNextNode(target);
            self.setFocus(nextNode);
          }

          //up arrow,
          if (charCode === 38) {
            var prevNode = self.getPreviousNode(target);
            self.setFocus(prevNode);
          }

          //space
          if (e.keyCode === 32) {
            target.trigger('click.stepprocess');
          }

          // Left arrow
          if (charCode === 37) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                prev = target.next().find(self.settings.stepLink + ':first');
                self.setFocus(prev);
              } else {
                self.folderToggle(target);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                self.folderToggle(target);
              } else {
                prev = target.closest('.folder').find(self.settings.stepLink + ':first');
                self.setFocus(prev);
              }
            }
            e.stopPropagation();
            return false;
          }

          // Right arrow
          if (charCode === 39) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                self.folderToggle(target);
              } else {
                next = target.closest('.folder').find(self.settings.stepLink + ':first');
                self.setFocus(next);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                next = target.next().find(self.settings.stepLink + ':first');
                self.setFocus(next);
              } else {
                self.folderToggle(target);
                self.setFocus(target);
              }

            }
            e.stopPropagation();
            return false;
          }

          // Home  (fn-right on mac)
          if (charCode === 36) {
            next = self.$stepList.find(self.settings.stepLink + ':first:visible');
            self.setFocus(next);
          }

          // End (fn-right on mac)
          if (charCode === 35) {
            next = self.$stepList.find(self.settings.stepLink + ':last:visible');
            self.setFocus(next);
          }

        });

        // Handle Left/Right Arrow Keys
        this.$stepList.on('keypress.stepprocess', this.settings.stepLink, function (e) {
          var charCode = e.charCode || e.keyCode,
            target = $(this);

          if ((charCode >= 37 && charCode <= 40) || charCode === 32) {
            e.stopPropagation();
            return false;
          }

          //Printable Chars Jump to first high level node with it...
           if (e.which !== 0) {
            target.closest(self.settings.stepLi).nextAll().find('.js-step-link:visible').each(function () {
              var node = $(this),
                first = node.text().substr(0,1).toLowerCase(),
                term = String.fromCharCode(e.which).toLowerCase();

              if (first === term) {
                self.setFocus(node);
                return false;
              }
            });
          }
        });
      },

      /**
       * @private
       * @param  {[type]}  step - The step Li element
       * @return {Boolean}
       */
      isFolder: function(step) {
        return $(step).hasClass('folder');
      },

      /**
       * @private
       * @param  {object} step - The step element
       * @return {boolean}
       */
      isInFolder: function(step) {
        return $(step).closest(this.settings.stepFolder, this.$stepList).length;
      },

      /**
       * @private
       * @param  {object}  stepFolder - The step folder element
       * @return {boolean}
       */
      isOpen: function(stepFolder) {
        return $(stepFolder).hasClass('is-open');
      },

      /**
       * @private
       * @param {object} stepLink
       */
      setFocus: function (stepLink) {
        stepLink.focus();
      },

      /**
       * @private
       * Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
       * @param {string} svg
       * @param {string} icon
       */
      setIcon: function(svg, icon) {
        var iconStr = icon.replace(/icon-|hide-focus|\s?/gi, '');
        svg.changeIcon(iconStr);
      },

        /**
       * Select a step
       * @param  {object} stepLink - The jquery object for the step link element
       * @param  {string} [linearDirection=none|previous|next] - Which direction we are traveling
       */
      selectStep: function (stepLink, linearDirection) {
        var self = this;
        if (linearDirection === undefined) {
          linearDirection = 'none';
        }

        // Possibly Call the beforeSelectStep
        var result;
        if (typeof self.settings.beforeSelectStep === 'function') {

          var args = {
            stepLink: stepLink,
            isStepping: linearDirection
          };
          result = self.settings.beforeSelectStep(args);

          if (result.done && typeof result.done === 'function') { // A promise is returned
            result.done(function(continueSelectNode, stepLinkToSelect) {
              if (continueSelectNode) {
                if (stepLinkToSelect) {
                  stepLink = stepLinkToSelect;
                }
                self.selectStepFinish(stepLink, linearDirection);
              }
            });
          } else if (result) { // boolean is returned instead of a promise
            self.selectStepFinish(stepLink, linearDirection);
          }

        } else { // No Callback specified
          self.selectStepFinish(stepLink, linearDirection);
        }
      },

      /**
       * @private
       * Finishes selecting a step
       * @param  {object} stepLink - Description
       * @param  {string} [linearDirection=previous|next] - Description
       *
       */
      selectStepFinish: function(stepLink, linearDirection) {
        var self = this,
            $allStepLinks = $(this.settings.stepLink, this.$stepList),
            $step = stepLink.closest(this.settings.stepLi);

        $allStepLinks
          .attr({
            'tabindex': '-1',
            'aria-selected': 'false'
          })
          .parent().removeClass('is-selected');

        stepLink.attr({
          'tabindex': '0',
          'aria-selected': 'true'
        });

        $step.addClass('is-selected');

        if (this.isFolder($step)) {
          // It is a folder
          if (linearDirection === 'none') {
            this.folderToggle($step); // clicking toggles
          } else {
            this.folderOpen($step); // going prev/next always opens
          }
        } else {
          // Its not a folder
          var parentIsFolder = $step.closest(this.settings.stepFolder, this.$stepList);

          if (parentIsFolder.length) {
            // If the step is in a folder, make sure that folder opens
            this.folderOpen(parentIsFolder.closest(this.settings.stepLi));
          }

          // Show the step's panel
          this.showStepPanel(stepLink.attr('href'));
        }
        stepLink.focus();

        setTimeout(function() {
          self.element.triggerHandler('selected', stepLink);
        }, 0);
      },

      /**
       * @private
       * @param  {object} step - The step element to decorate
       */
      unSelectedNode: function (step) {
        var aTags = $(this.settings.stepLink, this.$stepList),
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink);

        aTags.attr('tabindex', '-1');
        $stepLink.attr('tabindex', '0');

        $step.removeClass('is-selected');
        $stepLink.attr('aria-selected', 'false');
      },

      /**
       * @private
       * @return {[type]}- Description
       */
      setupEvents: function () {
        var self = this;

        // Updated and Click events
        self.$stepList
          .on('updated.stepprocess', function () {
            self.initStepprocess();
          })
          .on('click.stepprocess', self.settings.stepLink + ':not(.is-clone)', function (e) {
            e.preventDefault();

            if (!self.settings.linearProgression) {
              var $target = $(this);

              if (!$target.is('.is-disabled, .is-loading')) {
                self.selectStep($target);
                e.stopPropagation();
              }
            }
          });

        // Next Button Click
        $(this.settings.btnPrev).on('click', function(e) {
          e.preventDefault();
          self.goToPreviousStep.call(self);
        });

        // Previous Button Click
        $(this.settings.btnNext).on('click', function(e) {
          e.preventDefault();
          self.goToNextStep.call(self);
        });

        // Setup main scrolling
        $(this.settings.contentScroll).scrollaction({
          scrollActionTarget: '.main'
        });

        // Setup sidebar scrolling
        $(this.settings.stepListScroll).scrollaction({
          scrollActionTarget: '.sidebar'
        });

        // Toggle sidebar
        // Button to toggle the tree in responsive view
        $('.js-toggle-sidebar').click(function(e) {
          e.preventDefault();
          self.element
            .toggleClass('tablet-hide-steps')
            .toggleClass('phone-hide-steps');
        });
      },

      /**
       * @private
       * Show the content panel for the step
       * @param  {string} contentId - The contentId to show
       */
      showStepPanel: function(contentId) {
        $('.step-panel-active').removeClass('step-panel-active');
        $(contentId).addClass('step-panel-active');
        this.element.addClass('phone-hide-steps');
      },

      /** @private */
      destroy: function() {
        this.$stepList.removeData(pluginName);
        this.$stepList.off('updated.stepprocess click.stepprocess focus.stepprocess keydown.stepprocess keypress.stepprocess').empty();
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Stepprocess(this, settings));
      }
    });

  };


  window.Soho = window.Soho || {};
  window.Soho.components = window.Soho.components || {};

  var DEFAULT_STEPCHART_OPTIONS = {
    steps: 7,
    completed: 0,
    inProgress: null,
    iconType: null,
    completedText: null,
    extraText: '',
    completedColor: null,
    allCompletedColor: null,
    inProgressColor: null
  };

  /**
  * The Step Chart Component is displays visual info on step completion.
  *
  * @class StepChart
  * @param {Number} steps The number of steps to show.
  * @param {Number} completed The number of steps complete (linear).
  * @param {Number} inProgress The number of the in progress step (linear).
  * @param {Boolean} iconType The icon to display fx. 'icon-error', 'icon-confirm'
  * @param {String} completedText The completed text or uses a localized 'N of N Steps complete'. You can use {0} and {1} to replace n of n in the string.
  * @param {Boolean} extraText The additional text to show on the right. Defaults to none. You can use {0} to replace with the steps remaining count and {1} to replace the number of steps.
  * @param {String} completedColor The color to show completed steps. Defaults to primary color.
  * @param {String} allCompletedColor The color to steps when all are completed. Defaults to primary color.
  * @param {String} inProgressColor The color to show in-progress steps. Defaults to ruby02.
  *
  */
  function StepChart(element, options) {
    return this.init(element, options);
  }

  StepChart.prototype = {

    /**
    * Initialize and render the chart
    * @private
    */
    init: function(element, options) {

      if (!this.element && element instanceof HTMLElement) {
        this.element = $(element);
      }

      if (typeof options === 'object') {
        var previousOptions = this.options || DEFAULT_STEPCHART_OPTIONS;
        this.options = $.extend({}, previousOptions, options);
      }

      return this.render();
    },

    /**
    * Initialize and render the from the options
    * @private
    */
    render: function() {
      var container = $('<div class="step-chart-steps"></div>'),
        icon = '<svg class="icon {icon-name}" focusable="false" aria-hidden="true" role="presentation">'+
                '<use xlink:href="#icon-confirm"></use>'+
                '</svg>';

      if (this.element.attr('data-options')) {
        this.options = $.fn.parseOptions(this.element);
      }

      if (this.element.children().length > 0) {
        return;
      }

      for (var i = 0; i < this.options.steps; i++) {
        var step = $('<div class="step-chart-step"></div>');

        // Set up ticks
        if (i < this.options.completed) {
          step.addClass('is-complete');

          if (this.options.completedColor) {
            step.css('background-color', this.options.completedColor);
          }
        }

        if (i === this.options.inProgress-1) {
          step.addClass('is-inprogress');

          if (this.options.inProgressColor) {
            step.css('background-color', this.options.inProgressColor);
          }
        }

        container.append(step);
      }

      // Set up labels and alerts
      var completedText = this.options.completedText || Locale.translate('StepsCompleted');
      completedText = completedText.replace('{0}', this.options.completed);
      completedText = completedText.replace('{1}', this.options.steps);

      var label = $('<span class="step-chart-label">'+ completedText +'</span>');

      if (this.options.steps === this.options.completed) {
        container.addClass('is-complete');
        label.append(icon.replace('{icon-name}', 'icon-confirm'));
      }

      if (this.options.iconType) {
        label.append(icon.replace('{icon-name}', this.options.iconType));
      }

      if (this.options.extraText) {
        var extraText = this.options.extraText;
        extraText = (extraText === '{0} Days Remaining' ? Locale.translate('DaysRemaining') : extraText);
        extraText = (extraText === '{1} Days Overdue' ? Locale.translate('DaysOverdue') : extraText);
        extraText = extraText.replace('{0}', this.options.steps-this.options.completed);
        extraText = extraText.replace('{1}', this.options.completed);
        label.append('<span class="step-chart-label-small">' + extraText + '</span>');
      }

      this.element.append(label, container);

      // Adjust completed color
      if (this.options.steps === this.options.completed && this.options.allCompletedColor) {
        container.find('.step-chart-step').css('background-color',  this.options.allCompletedColor);
        label.find('.icon').attr('style', 'fill: '+ this.options.allCompletedColor + '!important');
      }

      return this;
    },

    /**
    * Update the chart with the current options.
    */
    updated: function() {
      this.element.empty();
      return this.render();
    },

    /**
    * Tear down and remove.
    */
    destroy: function() {
      this.element.empty();
      this.options = null;
      $.removeData(this.element[0], 'stepchart');

      return this;
    }
  };

  // Add to the Soho object
  window.Soho.components.stepchart = StepChart;

  $.fn.stepchart = function(options) {
    'use strict';

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, 'stepchart');
      if (instance) {
        instance.updated(options);
      } else {
        instance = $.data(this, 'stepchart', new StepChart(this, options));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, 'stepchart');
        };
      }
    });
  };


  $.fn.swaplist = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'swaplist',
        defaults = {
          // Searchable
          searchable: false,

          // Datasets
          available: null,
          selected: null,
          additional: null,

          // Main containers
          availableClass: '.available',
          selectedClass: '.selected',
          additionalClass: '.full-access',

          // Action buttons
          availableBtn: '.btn-moveto-selected',
          selectedBtnLeft: '.btn-moveto-left',
          selectedBtnRight: '.btn-moveto-right',
          additionalBtn: '.btn-moveto-selected',

          draggable: {
            available: true,
            selected: true,
            additional: true
          },

          // Template HTML
          template: ''+
            '<ul data-swap-handle=".handle">'+
              '{{#dataset}}'+
                '{{#text}}'+
                  '<li'+
                    '{{#value}} data-value="{{value}}"{{/value}}'+
                    '{{#selected}} selected="selected"{{/selected}}'+
                    '{{#disabled}} class="is-disabled"{{/disabled}}'+
                  '>'+
                    '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
                    '<div class="swaplist-item-content"><p>{{text}}</p></div>'+
                  '</li>'+
                '{{/text}}'+
              '{{/dataset}}'+
            '</ul>'
        },
        settings = $.extend({}, defaults, options);

    /**
    * The SwapList Component creates a list of options that can be picked and organized.
    *
    * @class SwapList
    * @param {Boolean} searchable  &nbsp;-&nbsp; If true, associates itself with a Searchfield/Autocomplete and allows itself to be filtered
    * @param {Array} available &nbsp;-&nbsp; An array containing items for the available bucket.
    * @param {Array} selected  &nbsp;-&nbsp;  An array containing items for the selected bucket.
    * @param {Array} additional  &nbsp;-&nbsp;  An array containing items for the additional bucket.
    * @param {String} availableClass  &nbsp;-&nbsp; A class name linking the available root element.
    * @param {String} selectedClass  &nbsp;-&nbsp; A class name linking the selected root element.
    * @param {String} additionalClass &nbsp;-&nbsp; A class name linking the additional root element.
    * @param {String} availableBtn &nbsp;-&nbsp; A class name linking the available button element.
    * @param {String} selectedBtnLeft &nbsp;-&nbsp;  A class name linking the move left button element.
    * @param {String} selectedBtnRight &nbsp;-&nbsp;  A class name linking the move right button element.
    * @param {String} additionalBtn &nbsp;-&nbsp;  A class name linking the additional button element.
    * @param {String} template &nbsp;-&nbsp; An Html String with the mustache template for the view.
    * @param {Object} draggable &nbsp;-&nbsp; An object containing boolean key/value to make container/s disable for dragging and moving items. Supported keys with draggable are "available", "selected", "additional".
    */
    function SwapList(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // SwapList Methods
    SwapList.prototype = {

      init: function() {
        var self = this,
          s = self.settings;
        s.draggable = $.extend(true, defaults.draggable, s.draggable);
        self.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        self.isAdditional = $(s.additionalClass +' .listview', self.element).length > 0;

        if (self.isTouch) {
          self.element.addClass('is-touch');
        }
        self.loadListview();
        self.initDataset();
        self.setElements();
        self.isMultiSelectClass();

        setTimeout(function() { // Wait for Listview availability
          self.makeDraggable();
          self.handleEvents();
          self.initSelected(s.availableClass);
          self.initSelected(s.additionalClass);
        }, 0);
      },

      /**
       * Load listview
       * @private
       */
      loadListview: function() {
        var i, l, lv, c,
          list, options, isSearchable,
          self = this,
          s = self.settings,
          containers = [
            { dataset: s.available, class: s.availableClass, draggable: s.draggable.available },
            { dataset: s.selected, class: s.selectedClass, draggable: s.draggable.selected },
            { dataset: s.additional, class: s.additionalClass, draggable: s.draggable.additional }
          ];

        for (i = 0, l = containers.length; i < l; i++) {
          c = containers[i];
          lv = $(c.class +' .listview', self.element);
          list = lv.data('listview');
          options = { selectable: 'multiple', showCheckboxes: false };
          isSearchable = ((s.searchable === true || s.searchable === 'true') && ($(c.class +' .searchfield', self.element).length > 0));

          if (isSearchable) {
            options.searchable = true;
          }

          // Initialize listview
          if (!c.dataset && lv.length && $('li', lv).length) {
            lv.listview(options);
          }
          else if (lv.length) {
            // Remove any previous listview instance
            if (list) {
              list.destroy();
            }
            options.template = s.template;
            options.dataset = c.dataset || [];
            lv.listview(options);
          }

          // Add css class('is-not-droppable') to ul in this container
          if (!c.draggable) {
            $('ul', lv).addClass('is-not-droppable');
          }
        }
      },


      /**
       * Set elements
       * @private
       */
      setElements: function() {
        var s = this.settings,
          disabledBtnStr = '';
        this.offset = null;

        this.containers = $(
          s.availableClass +','+
          s.selectedClass +','+
          s.additionalClass, this.element);

        this.actionButtons = $(
          s.availableBtn +','+
          s.additionalBtn +','+
          s.selectedBtnLeft +','+
          s.selectedBtnRight, this.element);

        this.selectedButtons = $(
          s.selectedBtnLeft +','+
          s.selectedBtnRight, this.element);

        this.tabButtonsStr = ''+
          s.availableBtn +' '+
          s.additionalBtn +' '+
          (this.selectedButtons.length > 1 ?
            s.selectedBtnRight : s.selectedBtnLeft);

        this.dragElements = 'ul:not(.is-not-droppable), ul:not(.is-not-droppable) li:not(.is-disabled)';
        this.dragStart = 'dragstart.swaplist touchstart.swaplist gesturestart.swaplist';
        this.dragEnterWhileDragging = 'dragenter.swaplist';
        this.dragOverWhileDragging = 'dragover.swaplist touchmove.swaplist gesturechange.swaplist';
        this.dragEnd = 'dragend.swaplist touchend.swaplist touchcancel.swaplist gestureend.swaplist';

        this.selections = {
          'items': [],
          'owner': null,
          'related': null,
          'droptarget': null,
          'isInSelection': null,
          'isHandle': null,
          'placeholder': null,
          'placeholderTouch': null,
          'dragged': null,
          'draggedIndex': null
        };

        // Dragging time placeholder
        s.numOfSelectionsClass = 'num-of-selections';
        s.itemContentClass = 'swaplist-item-content';
        s.itemContentTempl = $(
          '<div><p><span class="'+ s.numOfSelectionsClass +'">###</span> '+
            Locale.translate('ItemsSelected') +'</p><div/>'
        );

        // Make top buttons disable if not draggable
        if (!s.draggable.available) {
          disabledBtnStr = s.availableClass +' '+ s.availableBtn +','+ s.selectedBtnLeft;
          $(disabledBtnStr, this.element).prop('disabled', true);
        }
        if (!s.draggable.selected) {
          disabledBtnStr = s.selectedBtnLeft +','+ s.selectedBtnRight;
          if (!s.draggable.available) {
            disabledBtnStr += ','+ s.additionalClass +' '+ s.additionalBtn;
          }
          if (!this.isAdditional || !s.draggable.additional) {
            disabledBtnStr += ','+ s.availableClass +' '+ s.availableBtn;
          }
          $(disabledBtnStr, this.element).prop('disabled', true);
          $(s.additionalClass +' '+ s.additionalBtn, this.element).addClass('is-rotate');
        }
        if (!s.draggable.additional) {
          $(s.additionalClass +' '+ s.additionalBtn +','+
            s.selectedBtnRight, this.element).prop('disabled', true);
        }
      },

      /**
       * When list is Empty force to add css class "is-muliselect"
       * @private
       */
      isMultiSelectClass: function() {
        var i, l, lv,
          s = this.settings,
          containers = [s.availableClass, s.selectedClass, s.additionalClass];

        for (i=0,l=containers.length; i<l; i++) {
          lv = $(containers[i] +' .listview', this.element);
          if (!$('li', lv).length) {
            lv.addClass('is-muliselect');
          }
        }
      },

      /**
       * Initialize pre selected items
       * @private
       * @param {jQuery|HTMLElement} container
       */
      initSelected: function(container) {
        var list;
        container = this.isjQuery(container) ? container : $(container, this.element);
        if (container.length) {
          list = $('.listview', container).data('listview');
          $('li[selected]', container).each(function() {
            $(this).removeAttr('selected');
            list.select($(this));// Select this item
          });
          this.moveElements(container, this.settings.selectedClass);
        }
      },

      /**
       * Move Elements
       * @private
       * @param {jQuery[]|HTMLElement} from
       * @param {jQuery[]|HTMLElement} to
       */
      moveElements: function(from, to) {
        if (to === null) {
          return;
        }
        var ul, size, currentSize,
          self = this, list;

        from = (typeof from !== 'string') ? from : $(from, self.element);
        to = (typeof to !== 'string') ? to : $(to, self.element);
        list = $('.listview', from).data('listview');

        self.clearSelections();
        self.selections.owner = from;
        self.selections.droptarget = to;

        if (self.isTouch) {
          $.each(list.selectedItems, function(index, val) {
            self.selections.items[index] = val.closest('li');
          });
        } else {
          self.selections.items = list.selectedItems;
        }

        self.setSelectionsItems(self.selections.owner);
        self.unselectElements(list);

        if (self.selections.items.length) {
          self.element.triggerHandler('beforeswap', [self.selections.itemsData]);

          ul = $('ul', to);
          currentSize = $('li', ul).length;
          size = self.selections.items.length + currentSize;

          $.each(self.selections.items, function(index, val) {
            val = $(val);
            val.attr({ 'aria-posinset': currentSize + index + 1, 'aria-setsize': size }).find('mark.highlight').contents().unwrap();
            ul.append(val);
          });

          self.afterUpdate($('.listview', to).data('listview'));
          $('li:last-child', to).focus()
            // Fix: not sure why it added selected class and attribute on focus
            .removeAttr('aria-selected').removeClass('is-selected');
        }
      },

      /**
       * Un-select Elements
       * @private
       * @param {jQuery|HTMLElement} list
       */
      unselectElements: function(list) {
        $.each(list.selectedItems, function(index, val) {
          list.select(val);
        });
      },

      /**
       * Detect browser support for drag-n-drop
       * @private
       * @returns {boolean}
       */
      isDragAndDropSupports: function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
      },

      /**
       * Detect browser support for match-media
       * @private
       * @returns {boolean}
       */
      isMatchMediaSupports: function() {
        return (typeof window.matchMedia !== 'undefined' || typeof window.msMatchMedia !== 'undefined');
      },

      /**
       * Detect browser viewport
       * @private
       * @returns {Object}
       */
      viewport: function() {
        var e = window, a = 'inner';
        if (!('innerWidth' in window)) {
          a = 'client';
          e = document.documentElement || document.body;
        }
        return { width : e[a+'Width'] , height : e[a+'Height'] };
      },

      /**
       * Check given [max-width] is true/false
       * @private
       * @returns {boolean}
       */
      isMaxWidth: function(w) {
        return ((this.isMatchMediaSupports() && window.matchMedia('(max-width: '+ w +'px)').matches) || this.viewport().width <= w);
      },

      /**
       * Make Draggable
       * @private
       */
      makeDraggable: function() {
        var self = this,
          ul = $('ul', self.element);

        if (self.isDragAndDropSupports) {
          // Use Handle if available
          self.handle = ul.first().attr('data-swap-handle');
          self.handle = $(self.handle, ul).length > 0 ? self.handle : null;
          // self.handle = (!self.isTouch && $(self.handle, ul).length > 0) ? self.handle : null;
          $(self.handle, ul).addClass('draggable')
            .off('mousedown.swaplist touchstart.swaplist')
            .on('mousedown.swaplist touchstart.swaplist', function() { self.selections.isHandle = true; })
            .off('mouseup.swaplist touchend.swaplist')
            .on('mouseup.swaplist touchend.swaplist', function() { self.selections.isHandle = false; });

          self.targets = ul.attr({'aria-dropeffect': 'none'});

          self.items = $('li:not(.is-disabled)', self.element)
            .not('a[href], img')
              .off('selectstart.swaplist')
              .on('selectstart.swaplist', function() {
              if (this.dragDrop) { this.dragDrop(); } //ie9
              return false;
            }).end()
            .attr({'draggable': true})
            .addClass(self.handle ? '' : 'draggable');
        }
      },

      /**
       * Get Element By Touch In List
       * @private
       * @param {jQuery|HTMLElement} list
       * @param {Number} x
       * @param {Number} y
       */
      getElementByTouchInList: function(list, x, y) {
        var returns = false;
        $(list).each(function() {
          var item = $(this), offset = item.offset();
          if (!(x <= offset.left || x >= offset.left + item.outerWidth() ||
                y <= offset.top  || y >= offset.top + item.outerHeight())) {
            returns = item;
          }
        });
        return returns;
      },

      /**
       * Drag touch element
       * @private
       * @param {jQuery.Event} e
       * @param {jQuery[]} elm
       */
      draggTouchElement: function(e, elm) {
        var orig = e.originalEvent.changedTouches[0];
        elm[0].style.top = (orig.pageY - this.offset.y) + 'px';
        elm[0].style.left = (orig.pageX - this.offset.x) + 'px';
      },

      /**
       * Shorctut for testing whether a modifier is pressed
       * @private
       * @returns {boolean}
       */
      hasModifier: function(e) {
        return (e.ctrlKey || e.metaKey || e.shiftKey);
      },

      /**
       * Applying dropeffect to the target containers
       * @private
       */
      addDropeffects: function() {
        this.targets.each(function() {
          $(this).attr({'aria-dropeffect': 'move', 'tabindex': 0});
        });
        $.each(this.selections.items, function(index, val) {
          $(val).attr({'aria-grabbed': true, 'tabindex': 0});
        });
      },

      /**
       * Removing dropeffect from the target containers
       * @private
       */
      clearDropeffects: function() {
        this.targets.attr({'aria-dropeffect': 'none'}).removeAttr('tabindex');
        $.each(this.selections.items, function(index, val) {
          val = $(val);
          val.removeAttr('aria-grabbed' + (!val.is(':focus') ? ' tabindex' : ''));
        });
      },

      /**
       * Clear selections
       * @private
       */
      clearSelections: function() {
        this.selections.items = [];
        this.selections.itemsData = [];
        this.selections.owner = null;
        this.selections.related = null;
        this.selections.droptarget = null;
        this.selections.isInSelection = null;
        this.selections.dragged = null;
        this.selections.placeholder = null;
        this.selections.placeholderTouch = null;
        $('ul, li', this.element).removeClass('over');
        $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
      },

      /**
       * Set selections items
       * @private
       * @param {jQuery[]|HTMLElement} container
       */
      setSelectionsItems: function(container) {
        container = this.isjQuery(container) ? container : $(container, this.element);
        var nodes = $('.listview li', container),
          dataList = this.getDataList(container);
        for (var i=0,l=nodes.length; i<l; i++) {
          var li = $(nodes[i]);
          if (li.is('.is-selected')) {
            this.selections.itemsData.push(dataList[i]);
          }
        }
      },

      /**
       * Init dataset
       * @private
       */
      initDataset: function() {
        var s = this.settings,
          containers = [
            {type: 'available', dataset: s.available, class: s.availableClass},
            {type: 'selected', dataset: s.selected, class: s.selectedClass},
            {type: 'additional', dataset: s.additional, class: s.additionalClass}
          ];

        this.dataset = {'available': [], 'selected': []};
        if (this.isAdditional) {
          this.dataset.additional = [];
        }

        for (var i=0,l=containers.length; i<l; i++) {
          var c = containers[i],
            nodes = $(c.class +' .listview li', this.element);
          for (var nodeIndex=0,l2=nodes.length; nodeIndex<l2; nodeIndex++) {
            var data, value,
              li = $(nodes[nodeIndex]);
            if (c.dataset) {
              // Make sure it's not reference pointer to data object, make copy of data
              data = JSON.parse(JSON.stringify(c.dataset[nodeIndex]));
              delete data.selected;
            }
            else {
              data = {text: $.trim($('.swaplist-item-content', li).text())};
              value = li.attr('data-value');
              if (value) {
                data.value = value;
              }
            }
            if (this.dataset[c.type]) {
              data.node = li;
              this.dataset[c.type].push(data);
            }
          }
        }
      },

      /**
       * Get data list
       * @private
       * @param {jQuery[]|HTMLElement} container
       * @returns {Object}
       */
      getDataList: function(container) {
        var s = this.settings,
          d = this.dataset;
        container = this.isjQuery(container) ? container : $(container, this.element);
        return container.is(s.additionalClass) ? d.additional :
          (container.is(s.selectedClass) ? d.selected :
            (container.is(s.availableClass) ? d.available : []));
      },

      /**
       * Move an array element position
       * @private
       * @param {Array} arr
       * @param {Number} from
       * @param {Number} to
       */
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      /**
       * Sync dataset
       * @private
       * @param {} owner
       * @param {jQuery[]} droptarget
       */
      syncDataset: function(owner, droptarget) {
        var droptargetNodes = $('.listview li', droptarget),
          ownerDataList = this.getDataList(owner),
          dtDataList = this.getDataList(droptarget);

        for (var i=0,l=this.selections.items.length; i<l; i++) {
          var item = this.selections.items[i];
          for (var dtIndex=0,l2=droptargetNodes.length; dtIndex<l2; dtIndex++) {
            if ($(droptargetNodes[dtIndex]).is(item)) {
              for (var ownerIndex=0,l3=ownerDataList.length; ownerIndex<l3; ownerIndex++) {
                var ownerItem = ownerDataList[ownerIndex];
                if (ownerItem.node && ownerItem.node.is(item)) {
                  dtDataList.push(ownerItem);
                  ownerDataList.splice(ownerIndex, 1);
                  this.arrayIndexMove(dtDataList, dtDataList.length-1, dtIndex);
                  break;
                }
              }
            }
          }
        }
      },

      /**
       * Check if a object is jQuery object
       * @private
       * @param {Object} obj - the object being checked
       */
      isjQuery: function (obj) {
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      /**
       * Update attributes
       * @private
       * @param {jQuery[]} list
       */
      updateAttributes: function(list) {
        var items = $('li', list),
          size = items.length;

        items.each(function(i) {
          $(this).attr({ 'aria-posinset': i+1, 'aria-setsize': size });
        });
      },

      /**
       * After update
       * @private
       * @param {jQuery[]} list
       */
      afterUpdate: function(list) {
        var self = this;

        setTimeout(function() {
          if (list) {
            if (self.selections.placeholder) {
              list.select(self.selections.placeholder);
              self.selections.placeholder.focus();
            }
            self.unselectElements(list);
            self.syncDataset(self.selections.owner, self.selections.droptarget);
            self.updateAttributes($('.listview', self.selections.owner));
            self.updateAttributes($('.listview', self.selections.droptarget));
            if (self.selections.items.length) {
              self.element.triggerHandler('swapupdate', [self.selections.itemsData]);
            }
          }
          self.clearDropeffects();
          self.clearSelections();
          self.items.removeClass('is-dragging is-dragging-touch');
        }, 100);
      },

      /**
       * Get items from provided container
       * @private
       * @param {jQuery[]|HTMLElement} container
       * @returns {Object}
       */
      getItems: function(container) {
        container = this.isjQuery(container) ? container : $(container, this.element);
        return this.getDataList(container);
      },

      /**
        * Get the current representative dataset with only the available elements in it.
       */
      getAvailable: function() {
        return this.getDataList(this.settings.availableClass);
      },

      /**
       * Get the current representative dataset with only the selected elements in it.
       */
      getSelected: function() {
        return this.getDataList(this.settings.selectedClass);
      },

      /**
       * Get the current representative dataset with only the additional elements in it.
       */
      getAdditional: function() {
        return this.getDataList(this.settings.additionalClass);
      },

      /**
       * Make selected if dragged element was not selected
       * @private
       * @param {Object} list
       * @param {jQuery[]} target
       */
      draggedMakeSelected: function(list, target) {
        var self = this, isInSelection = false;
        if (!self.selections.isInSelection) {
          // Check if dragged element was selected or not
          $.each(list.selectedItems, function(index, val) {
            if (target[0] === val[0]) {
              isInSelection = true;
              return false;
            }
          });
          if (!isInSelection) {
            list.select(target); // Make selected
            self.selections.isInSelection = true;
          }
        }
      },

      /**
       * Updates the internal datasets and refresh the ui.
       * @param {Object} ds &nbsp;-&nbsp; The updated dataset(s) of the form `{available: [], selected: [], additional: []}`
       */
      updateDataset: function(ds) {
        var i, l, lv, c, api,
          self = this,
          s = self.settings,
          containers = [
            { type: 'available', dataset: ds.available, class: s.availableClass },
            { type: 'selected', dataset: ds.selected, class: s.selectedClass },
            { type: 'additional', dataset: ds.additional, class: s.additionalClass }
          ];

        for (i = 0, l = containers.length; i < l; i++) {
          c = containers[i];
          lv = $(c.class +' .listview', self.element);
          api = lv.data('listview');

          if (api) {
            api.deselectItemsBetweenIndexes([0, $('li', lv).length - 1]);
            s[c.type] = c.dataset || [];
            api.loadData(s[c.type]);
          }
        }

        self.initDataset();
        self.makeDraggable();
        self.initSelected(s.availableClass);
        self.initSelected(s.additionalClass);
      },

      /**
       * Removes event bindings from the swaplist instance.
       * @private
       * @returns {this}
       */
      unbind: function() {
        this.actionButtons.off('click.swaplist');
        this.containers.off('keydown.swaplist');
        this.selectedButtons.off('keydown.swaplist');
        this.element.off(this.dragStart+' '+this.dragEnterWhileDragging +' '+this.dragOverWhileDragging +' '+this.dragEnd, this.dragElements);

        $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
        return this;
      },

      /**
       * Updates this instance of the swaplist component with new settings.
       * @private
       * @returns {this}
       */
      updated: function() {
        return this
          .unbind()
          .init();
      },

      /**
       * Destroys this instance of the swaplist component and removes its link to its base element.
       */
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       *
       * @fires Swaplist#events
      * @param {Object} swapupdate &nbsp;-&nbsp; Fires when any bucket has its content changed.
       */
      handleEvents: function() {
        var self = this,
          settings = self.settings,
          selections = self.selections;

        // TOP BUTTONS =============================================================================
        self.actionButtons.off('click.swaplist').on('click.swaplist', function () {
          var actionButton = $(this),
            container = actionButton.closest('.card'), // Current list clicked from
            moveTo = null;

          if (container.is(settings.availableClass)) { // Move from Available to Selected or Additional
            moveTo = settings.draggable.selected ? settings.selectedClass :
              (self.isAdditional && settings.draggable.additional ? settings.additionalClass : null);
            self.moveElements(settings.availableClass, moveTo);
          }

          else if (container.is(settings.additionalClass)) { // Move from Additional to Selected or Available
            moveTo = settings.draggable.selected ? settings.selectedClass :
              (settings.draggable.available ? settings.availableClass : null);
            self.moveElements(settings.additionalClass, moveTo);
          }

          // Move from Selected
          else if (container.is(settings.selectedClass)) {
            if (actionButton.is(settings.selectedBtnLeft)) { // to Available
              self.moveElements(settings.selectedClass, settings.availableClass);
            }
            else if (actionButton.is(settings.selectedBtnRight)) { // to Additional
              self.moveElements(settings.selectedClass, settings.additionalClass);
            }
          }
        });


        // KEYSTROKE ===============================================================================
        // Keydown event to implement selections
        self.containers.on('keydown.swaplist', function(e) {
          var container = $(this);
          e = e || window.event;
          if (e.keyCode === 77 && self.hasModifier(e)) { // Modifier + M
            if (!container.is(settings.selectedClass) ||
              (container.is(settings.selectedClass) && self.selectedButtons.length === 1)) {
              container.find(self.actionButtons).trigger('click.swaplist');
            } else {
              self.selectedButtons.first().focus();
            }
            e.preventDefault();
          }
        });

        // Keydown event to handle selected container
        self.selectedButtons.on('keydown.swaplist', function(e) {
          var btn = $(this), index, move;
          e = e || window.event;
          if (e.keyCode === 13 || e.keyCode === 32) { // Enter or Space
            btn.trigger('click.swaplist');
            e.preventDefault();
          }
          // Left or Right arrow
          if ((e.keyCode === 37 || e.keyCode === 39) && self.selectedButtons.length > 1) {
            index = self.selectedButtons.index(this);
            move = e.keyCode === 37 ?
              (index > 0 ? index-1 : self.selectedButtons.length-1) :
              (index < self.selectedButtons.length-1 ? index+1 : 0);
            self.selectedButtons[move].focus();
          }
        });

        self.element.on('keydown.swaplist', self.tabButtonsStr, function(e) {
          var btn = $(this),
            keyCode = e.keyCode || e.which;

          if (keyCode === 9 && !e.shiftKey) { // Tab key
            $('li:first-child', btn.closest('.card')).focus();
            e.preventDefault();
          }
        });


        // DRAGGABLE ===============================================================================
        self.element
        .on('mousedown.swaplist', self.dragElements, function(e) {
          if (self.handle) {
            var target = $(e.target).closest('li');
            target.attr({ 'draggable': $(e.target).is('.draggable') });
          }
          e.stopPropagation();
        })
        .onTouchClick('swaplist', self.dragElements)

        // Dragstart - initiate dragging
        .on(self.dragStart, self.dragElements, function(e) {
          e.stopImmediatePropagation();
          if (self.handle && !selections.isHandle) {
            e.stopPropagation();
            return;
          }
          var rect, touch, placeholderContainer,
            target = $(e.target).closest('li'),
            list = $('.listview', target.closest('.card')).data('listview');

          // Not in draging area
          if (!list) {
            return;
          }

          if (!self.isTouch) {
            self.draggedMakeSelected(list, target);
          }

          self.clearSelections(); // Clear selection before fill

          selections.owner = target.closest('.card');
          selections.dragged = target;
          selections.draggedIndex = target.index();
          selections.placeholder = target.clone(true);
          selections.placeholder.attr('id', 'sl-placeholder');

          self.setSelectionsItems(selections.owner);

          selections.items = list.selectedItems;
          self.element.triggerHandler('beforeswap', [selections.itemsData]);

          $('.'+ settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
          self.addDropeffects();

          if (!self.isTouch) {
            selections.dragged.addClass('is-dragging');
            e.originalEvent.dataTransfer.setData('text', '');

            if (selections.items.length > 1) {
              $('.'+ settings.itemContentClass, selections.dragged).html(settings.itemContentTempl.html());
            }
          }
          else {
            rect = target[0].getBoundingClientRect();
            touch = e.originalEvent.changedTouches[0];

            //Save offset
            self.offset = {
              x: touch.pageX - rect.left,
              y: touch.pageY - rect.top
            };

            for (var i = 0, l = self.containers.length; i < l; i++) {
              self.containers[i].style.zIndex = '1';
            }
            selections.placeholderTouch = selections.dragged.clone(true);

            if (selections.items.length > 1 && !$('#sl-placeholder-touch2').length) {
              selections.dragged.clone()
                .addClass('is-dragging-touch').attr('id', 'sl-placeholder-touch2')
                .insertBefore(selections.dragged)
                .hide();
            }
            selections.placeholderTouch.attr('id', 'sl-placeholder-touch').removeClass('is-selected').hide();

            // Mobile view with three container(available, selected, additional) prepend to parent
            placeholderContainer = (self.element.is('.one-third') && self.isMaxWidth(766)) ? self.element.parent() : self.element;
            placeholderContainer.prepend('<ul id="sl-placeholder-container"></ul>');

            $('#sl-placeholder-container').append(selections.placeholderTouch);
            $('#sl-placeholder-container')[0].style.width = selections.owner.width() +'px';
            $('#sl-placeholder-touch')[0].style.width = selections.owner.width() +'px';

            self.draggTouchElement(e, selections.placeholderTouch);
          }
          e.stopPropagation();
        })

        // Dragenter - set that related/droptarget
        .on(self.dragEnterWhileDragging, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          self.element.triggerHandler('draggingswap', [selections.itemsData]);
          selections.related = e.target;
          $('ul, li', self.element).removeClass('over');
          $(e.target).closest('ul, li').addClass('over');
          selections.droptarget = $(selections.related).closest('.card');
          $('[aria-grabbed="true"]', self.element).not(selections.dragged).slideUp();
          e.stopPropagation();
        })

        // Dragover - allow the drag by preventing default, for touch set related/droptarget
        .on(self.dragOverWhileDragging, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          var touch,
            overItem = $(this),
            list = $('.listview', selections.dragged.closest('.card')).data('listview');

          if (self.isTouch) {
            if (!!self.handle && !selections.isHandle) {
              return;
            }

            if (!selections.isInSelection) {
              self.draggedMakeSelected(list, selections.dragged);
              selections.items = list.selectedItems;
              $('.'+ settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
            }

            touch = e.originalEvent.touches[0];
            overItem = self.getElementByTouchInList($('ul, li', self.element), touch.pageX, touch.pageY) || overItem;

            selections.dragged.addClass('is-dragging');
            selections.placeholderTouch.addClass('is-dragging is-dragging-touch');
            selections.placeholderTouch.show();

            $('[aria-grabbed="true"]', self.element)
              .not(selections.dragged)
              .not(selections.placeholderTouch)
              .not('#sl-placeholder-touch2')
              .slideUp();

            if (selections.items.length > 1) {
              $('.'+ settings.itemContentClass, (selections.placeholderTouch.add('#sl-placeholder-touch2')))
                .html(settings.itemContentTempl.html());

              $('#sl-placeholder-touch2').show();
              selections.dragged.hide();
            }
            self.draggTouchElement(e, selections.placeholderTouch);

            self.element.triggerHandler('draggingswap', [selections.itemsData]);
            selections.related = overItem;
            $('ul, li', this.element).removeClass('over');
            overItem.closest('ul, li').addClass('over');
            selections.droptarget = selections.related.closest('.card');
          }
          e.preventDefault();
          e.stopPropagation();
        })

        // Dragend - implement items being validly dropped into targets
        .on(self.dragEnd, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          var related = $(selections.related).closest('li'),
          ul = $('ul', selections.droptarget),
          currentSize = $('li', ul).length,
          size = selections.items.length + currentSize;

          self.unselectElements($('.listview', selections.owner).data('listview'));

          $.each(selections.items, function(index, val) {
            val = $(val);
            val.find('mark.highlight').contents().unwrap();
            if (currentSize && !$(selections.related).is('ul')) {
              var isLess = (related.index() < selections.draggedIndex),
                el = isLess ? val : $(selections.items[(selections.items.length-1) - index]),
                posinset = related.index()+(isLess ? index+1 : index+2);

              val.attr({ 'aria-posinset': posinset, 'aria-setsize': size });
              related[isLess ? 'before' : 'after'](el);

            } else {
              val.attr({ 'aria-posinset': currentSize+index+1, 'aria-setsize': size });
              ul.append(val);
            }
            val.focus();
          });

          if (selections.items.length > 1) {
            $('.'+ settings.itemContentClass, selections.dragged).html(
              $('.'+ settings.itemContentClass, selections.placeholder).html()
            );
            if (self.isTouch) {
              selections.dragged.show();
            }
          }

          if (self.isTouch) {
            for (var i = 0, l = self.containers.length; i < l; i++) {
              self.containers[i].style.zIndex = '';
            }
          }

          selections.isHandle = null;
          $('[aria-grabbed="true"]', self.element).show();
          self.afterUpdate($('.listview', selections.droptarget).data('listview'));
          e.preventDefault();
          e.stopPropagation();
        });
      } // END: Handle Events ---------------------------------------------------------------------

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new SwapList(this, settings));
      }
    });
  };


  $.fn.toast = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'toast',
        defaults = {
          title: '(Title)',
          message: '(Content)',
          position: 'top right',  //top left, bottom left, bottom right (center??)
          audibleOnly: false,
          progressBar: true,
          timeout: 6000
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Toast(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Toast Methods
    Toast.prototype = {

      init: function() {
        this.settings = settings;
        this.show();
      },

      // Show a Single Toast Message
      show: function() {
        var self = this,
          settings = self.settings,
          maxHideTime = parseFloat(settings.timeout),
          isPausePlay = false,
          percentage = 100,
          timer,
          container = $('#toast-container'),
          toast = $('<div class="toast"><span class="toast-title">'+ settings.title+
            '</span><span class="toast-message">'+ settings.message + '</span></div>'),
          closeBtn = $('<button type="button" class="btn-icon btn-close" title="'+ Locale.translate('Close')+
            '" aria-hidden="true">' + $.createIcon('close') + '<span class="audible"> '+ Locale.translate('Close')+'</span></button>'),
          progress = $('<div class="toast-progress"></div>');

        if (!container.length) {
          container = $('<div id="toast-container" class="toast-container" aria-relevant="additions" aria-live="polite"></div>').appendTo('body');
        }

        container.removeClass('toast-top-left toast-top-right toast-bottom-right toast-bottom-left')
          .addClass('toast-' + settings.position.replace(' ', '-'));

        settings.timeout = settings.audibleOnly ? 100 : settings.timeout;

        // Start timer
        timer = new $.fn.timer(function() {
          self.remove(toast);
        }, settings.timeout);

        if (settings.progressBar) {
          toast.append(progress);
        }

        $(timer.event).on('update', function(e, data) {
          percentage = ((maxHideTime - data.counter) / maxHideTime) * 100;

          if (Locale.isRTL()) {
            percentage = 100 - percentage;
          }

          if (settings.progressBar) {
            progress[0].style.width = percentage + '%';
          }
        });

        container.append(toast);
        toast.addClass((settings.audibleOnly ? 'audible' : 'effect-scale'));
        toast.append(closeBtn);

        $(document).on('keydown keyup', function(e) {
          e = e || window.event;
          if(e.ctrlKey && e.altKey && e.keyCode === 80) { //[Control + Alt + P] - Pause/Play toggle
            isPausePlay = e.type === 'keydown' ? true : false;
            timer[isPausePlay ? 'pause' : 'resume']();
          }
        });

        toast.on('mousedown.toast touchstart.toast mouseup.toast touchend.toast', function (e) {
          isPausePlay = /mousedown|touchstart/i.test(e.type) ? true : false;
          timer[isPausePlay ? 'pause' : 'resume']();
        });

        closeBtn.on('click', function () {
          timer.cancel();
          self.remove(toast);
        });
      },

      // Remove the Message and Animate
      remove: function (toast) {
        if (this.settings.audibleOnly) {
          toast.remove();
          return;
        }

        toast.addClass('effect-scale-hide');
        setTimeout(function () {
          toast.remove();
        }, 500);
      },

      // Teardown
      destroy: function() {
        $('#toast-container').remove();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
        instance.show();
      } else {
        instance = $.data(this, pluginName, new Toast(this, settings));
      }
    });
  };


  $.fn.tabs = function(options) {

    // Tab Settings and Options
    var pluginName = 'tabs',
        defaults = {
          addTabButton: false, // If set to true, creates a button at the end of the tab list that can be used to add an empty tab and panel
          addTabButtonCallback: null, // if defined as a function, will be used in-place of the default Tab Adding method
          appMenuTrigger: false, // If set to true, will force an App Menu trigger to be present on Non-Vertical Tabs implementatations.
          ajaxOptions: null, // if defined, will be used by any internal Tabs AJAX calls as the desired request settings.
          beforeActivate: undefined, // If defined as a function, fires this before a tab is activated to allow a possible "veto" of the tab swap (SOHO-5250).
          containerElement: null, // Defines a separate element to be used for containing the tab panels.  Defaults to a `.tab-panel-container` element that is created if it doesn't already exist.
          changeTabOnHashChange: false, // If true, will change the selected tab on invocation based on the URL that exists after the hash
          hashChangeCallback: null, // If defined as a function, provides an external method for adjusting the current page hash used by these tabs
          lazyLoad: true, // if true, when using full URLs in tab HREFs, or when using Ajax calls, tabs will be loaded as needed instead of the markup all being established at once.
          moduleTabsTooltips: false, // if true, will display a tooltip on Module Tabs with cut-off text content.
          source: null, // If defined, will serve as a way of pulling in external content to fill tabs.
          sourceArguments: {}, // If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
          tabCounts: false, // If true, Displays a modifiable count above each tab.
          verticalResponsive: false // If Vertical Tabs & true, will automatically switch to Horizontal Tabs on smaller breakpoints.
        },
        tabContainerTypes = ['horizontal', 'vertical', 'module-tabs', 'header-tabs'],
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tabs(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Tabs.prototype = {

      init: function(){
        return this
          .setup()
          .build()
          .setupEvents();
      },

      setup: function() {
        // Used by the $(body).resize event to correctly identify the tabs container element
        this.tabsIndex = $('.tab-container').index(this.element);
        return this;
      },

      build: function() {
        var self = this,
          tabPanelContainer,
          moveTabPanelContainer = false;

        // Check for a tab panel container immediately after the `.tab-container` element (default as of Soho Xi 4.3.0)
        tabPanelContainer = this.element.next('.tab-panel-container');

        // Auto-detect and move existing tab-panel containers in key areas, if applicable.
        // Check inside the container first
        if (!tabPanelContainer.length) {
          tabPanelContainer = this.element.children('.tab-panel-container');

          if (!this.isVerticalTabs()) {
            moveTabPanelContainer = true;
          }
        }

        // Special case for Header Tabs, find the page container and use that as the container
        var bodyPageContainer = $('body > .page-container, .application-menu + .page-container');
        if (this.element.closest('.header').length > 0 && bodyPageContainer.length) {
          tabPanelContainer = bodyPageContainer;
        }

        // Special case for Module Tabs, where it's possible for layout reasons for there to be
        // an application menu element adjacent between the Tab list and the Tab Panel container
        if (this.element.next('.application-menu').length) {
          tabPanelContainer = this.element.next().next('.page-container');
          moveTabPanelContainer = false;
        }

        // Defining `this.settings.containerElement` ultimately overrides any internal changes to the tab panel container.
        if (this.settings.containerElement && $(this.settings.containerElement).length) {
          tabPanelContainer = $(this.settings.containerElement);
          moveTabPanelContainer = false;
        }

        // If a `.tab-panel-container` still doesn't exist, create one.
        if (!tabPanelContainer || !tabPanelContainer.length) {
          tabPanelContainer = $('<div class="tab-panel-container"></div>');
          moveTabPanelContainer = true;
        }

        if (!tabPanelContainer[0].classList.contains('tab-panel-container')) {
          tabPanelContainer[0].classList.add('tab-panel-container');
        }
        if (moveTabPanelContainer) {
          tabPanelContainer.insertAfter(this.element);
        }

        this.container = tabPanelContainer;

        // Detect the existence of a "tab-list-container" element, if applicable.
        // Tab List containers are optional for all tab container types, but mandatory for
        // Composite Form tabs.
        var tablistContainer = this.element.children('.tab-list-container');
        if (!tablistContainer.length && this.isScrollableTabs()) {
          tablistContainer = $('<div class="tab-list-container"></div>').prependTo(this.element);
        }
        if (tablistContainer.length) {
          this.tablistContainer = tablistContainer;
        }

        // Add a default tabs class of "horizontal" if it doesn't already exist
        var noClass = true,
          closestHeader = this.element.closest('.header');
        tabContainerTypes.forEach(function tabTypeIterator(val, i) {
          if (self.element.hasClass(tabContainerTypes[i])) {
            noClass = false;
          }
        });
        if (noClass) {
          if (closestHeader.length) {
            self.element.addClass('header-tabs');
          } else {
            self.element.addClass('horizontal');
          }
        }

        // Build Tab Counts
        if (self.settings.tabCounts) {
          self.element.addClass('has-counts');
        }

        //Attach Tablist role and class to the tab headers container
        this.tablist = this.element.children('.tab-list');
        if (!this.tablist.length) {

          // If we have a `.tab-list-container` element, check that before creating markup
          if (this.tablistContainer) {
            this.tablist = this.tablistContainer.children('.tab-list');
          }

          // Create and append the `.tab-list` if it still doesn't exist.
          if (!this.tablist.length) {
            this.tablist = $('<ul class="tab-list"></ul>');
            if (this.tablistContainer) {
              this.tablist.appendTo(this.tablistContainer);
            } else {
              this.tablist.appendTo(this.element);
            }
          }
        }

        // Double-check that the `.tab-list-container` actually contains the `.tab-list`.
        // Move it if necessary.
        if (this.tablistContainer) {
          if (!this.tablist.parent().is(this.tablistContainer)) {
            this.tablistContainer.append(this.tablist);
          }

          this.tablistContainer.on('mousewheel.tabs', function(e) {
            if (e.deltaY) {
              this.scrollLeft += e.deltaY;
            }
          });
        }

        self.tablist
          .attr({
            'class': 'tab-list',
            'role': 'tablist',
            'aria-multiselectable': 'false'
          });

        // Conditionally Change layout classes if veritcal tabs is in responsive mode, and breakpoints match
        this.checkResponsive();

        // Handle Focus State, Animated Bar, More Button, Add Tabs Button, and App Menu Button.
        this.renderHelperMarkup();

        //for each item in the tabsList...
        self.anchors = self.tablist.children('li:not(.separator)').children('a');
        self.anchors.each(function prepareAnchor() {
          var a = $(this);
          a.attr({'role': 'tab', 'aria-expanded': 'false', 'aria-selected': 'false', 'tabindex': '-1'})
           .parent().attr('role', 'presentation').addClass('tab');

          if (a.parent().hasClass('dismissible') && !a.parent().children('.icon').length) {
            $.createIconElement({ icon: 'close', classes: 'icon close' }).insertAfter(a);
          }

          // Find and configure dropdown tabs
          var dd = a.nextAll('ul').first();
          if (dd.length > 0) {
            dd.addClass('dropdown-tab');
            var li = a.parent();

            li.addClass('has-popupmenu').popupmenu({
              menu: dd,
              trigger: 'click',
              attachToBody: true
            });

            a.removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected');

            if (!a.parent().children('.icon.icon-more').length) {
              $.createIconElement({ classes: 'icon-more', icon: 'dropdown' }).insertAfter(a);
            }
          }

          if (self.settings.tabCounts && $(this).find('.count').length === 0) {
            $(this).prepend('<span class="count">0 </span>');
          }

          // Make it possible for Module Tabs to display a tooltip containing their contents
          // if the contents are cut off by ellipsis.
          if (self.settings.moduleTabsTooltips) {
            a.on('beforeshow.toolbar', function() {
              return a.data('cutoffTitle') === 'yes';
            }).tooltip({
              content: '' + a.text().trim()
            });
          }
        });

        // Build/manage tab panels
        function associateAnchorWithPanel() {
          var a = $(this),
            li = a.parent(),
            popup = li.data('popupmenu'),
            panel;

          // Associated the current one
          var href = a.attr('href');

          if (href.substr(0, 1) !== '#') {
            //is an outbound Link
            return;
          }

          if (href !== undefined && href !== '#') {
            panel = $(href);

            if (li.is(':not(.has-popupmenu)') && !panel.length) {
              return;
            }

            a.data('panel-link', panel);
            panel.data('tab-link', a);
            self.panels = self.panels.add(panel);
          }

          // If dropdown tab, add the contents of the dropdown
          // NOTE: dropdown tabs shouldn't have children, so they aren't accounted for here
          if (popup) {
            popup.menu.children('li').each(function() {
              var li = $(this),
                a = li.children('a'),
                href = a.attr('href'),
                panel = $(href);

              a.data('panel-link', panel);
              panel.data('tab-link', a);

              self.panels = self.panels.add(panel);
              self.anchors = self.anchors.add(a);

              if (!li.hasClass('dismissible')) {
                return;
              }

              var icon = li.children('.icon');
              if (!icon.length) {
                icon = $.createIconElement({icon: 'close', classes: 'icon close'});
              }
              icon.detach().appendTo(a);

            }).on('click.popupmenu', '.icon', function iconClickHandler(e) {
              var icon = $(this),
                li = icon.closest('li');

              if (li.is('.dismissible') && icon.is('.icon')) {
                e.preventDefault();
                e.stopPropagation();
                self.closeDismissibleTab(li.children('a').attr('href'));
              }
            });
          }
        }

        self.panels = $();
        self.anchors.each(associateAnchorWithPanel);
        self.panels
          .addClass('tab-panel')
          .attr({'role': 'tabpanel'})
          .find('h3:first').attr('tabindex', '0');

        self.panels.appendTo(self.container);

        var excludes = ':not(.separator):not(.is-disabled):not(.is-hidden)',
          tabs = this.tablist.children('li' + excludes),
          selected = this.tablist.children('li.is-selected' + excludes),
          selectedAnchor = selected.children('a');

        // Setup a hash for nested tab controls
        self.nestedTabControls = self.panels.find('.tab-container');

        if (tabs.length) {
          // If the hashChange setting is on, change the selected tab to the one referenced by the hash
          if (this.settings.changeTabOnHashChange) {
            var hash = window.location.hash;
            if (hash && hash.length) {
              var matchingTabs = tabs.find('a[href="'+ hash +'"]');
              if (matchingTabs.length) {
                selected = matchingTabs.first().parent();
                selectedAnchor = selected.children('a');
              }
            }
          }

          // If there is no selected tab, try to find the first available tab (if there are any present)
          if (!selected.length) {
            selected = tabs.not('.add-tab-button, .application-menu-trigger').first();
            selectedAnchor = selected.children('a');
          }

          // If there are tabs present, activate the first one
          if (selected.length) {
            this.activate(selectedAnchor.attr('href'));
          }
        }

        if (this.isModuleTabs() && this.element.children('.toolbar').length) {
          this.element.addClass('has-toolbar');
        }

        this.setOverflow();

        if (this.hasSquareFocusState()) {
          this.positionFocusState(selectedAnchor);
        }

        if (this.hasAnimatedBar()) {
          this.animatedBar.addClass('no-transition');
          this.focusBar(undefined, function transitionRemover() {
            setTimeout(function() {
              self.animatedBar.removeClass('no-transition');
            }, 0);
          });
        }

        // Setup Edge Fades
        if (this.tablistContainer) {
          this.tablistContainer.on('scroll.tabs', function() {
            self.renderEdgeFading();
          });
          this.renderEdgeFading();
        }

        return this;
      },

      /**
       * Adds/removes helper buttons and accessibility-centric markup, based on Tabs' configuration
       * Designed to be run at any point in the Tabs lifecycle.
       * @returns {this}
       */
      renderHelperMarkup: function() {
        var auxilaryButtonLocation = this.tablistContainer || this.tablist;
        if (this.isModuleTabs()) {
          auxilaryButtonLocation = this.tablist;
        }

        // Square Focus State
        if (this.hasSquareFocusState()) {
          this.focusState = this.element.find('.tab-focus-indicator');
          if (!this.focusState.length) {
            this.focusState = $('<div class="tab-focus-indicator" role="presentation"></div>').insertBefore(this.tablist);
          }
        } else {
          if (this.focusState && this.focusState.length) {
            this.focusState.off().remove();
            this.focusState = undefined;
          }
        }

        // Animated Bar
        if (this.hasAnimatedBar()) {
          this.animatedBar = this.element.find('.animated-bar');
          if (!this.animatedBar.length) {
            this.animatedBar = $('<div class="animated-bar" role="presentation"></div>');
          }
          this.animatedBar.insertBefore(this.tablist);
        } else {
          if (this.animatedBar && this.animatedBar.length) {
            this.animatedBar.off().remove();
            this.animatedBar = undefined;
          }
        }

        // Add the markup for the "More" button if it doesn't exist.
        if (!this.moreButton) {
          this.moreButton = $();
        }

        if (!this.isVerticalTabs()) {
          if (!this.moreButton.length) {
            this.moreButton = auxilaryButtonLocation.next('.tab-more');
          }
          // If we still don't have a More Button, create one
          if (!this.moreButton.length) {
            this.moreButton = $('<div>').attr({'class': 'tab-more'});
            this.moreButton.append( $('<span class="more-text">').text(Locale.translate('More')));
            this.moreButton.append($.createIconElement({ classes: 'icon-more', icon: 'dropdown' }));
          }

          // Append in the right place based on configuration
          auxilaryButtonLocation.after(this.moreButton);
        } else {
          if (this.moreButton.length) {
            this.moreButton.off().remove();
            this.moreButton = $();
          }
        }

        // Add the application menu Module Tab, if applicable
        var appMenuTrigger = this.tablist.find('.application-menu-trigger');
        if (this.settings.appMenuTrigger === true) {
          // Backwards Compatibility for the original Application Menu codepath.
          if (this.isModuleTabs()) {
            if (!appMenuTrigger.length) {
              appMenuTrigger = $('<li class="tab application-menu-trigger"><a href="#">' +
                '<span class="icon app-header"><span class="one"></span><span class="two"></span><span class="three"></span></span>' +
                '<span>Menu</span>' +
                '</a></tab>');
              this.tablist.prepend(appMenuTrigger);
            }
          } else {
            if (this.isVerticalTabs() && appMenuTrigger.length) {
              appMenuTrigger.off().remove();
            }
          }
        } else {
          // New Codepath for the "non-forced" App Menu trigger.
          // If no App Menu Trigger is manually defined, it doesn't get added.
          if (appMenuTrigger.length) {
            if (this.isVerticalTabs()) {
              appMenuTrigger.off().remove();
            } else {
              this.tablist.prepend(appMenuTrigger);
            }
          }
        }

        // Add Tab Button
        if (this.settings.addTabButton) {
          if (!this.addTabButton || !this.addTabButton.length) {
            this.addTabButton = $('<div class="add-tab-button" tabindex="0" role="button">' +
              '<span aria-hidden="true" role="presentation">+</span>' +
              '<span class="audible">'+ Locale.translate('AddNewTab') +'</span>' +
              '</div>');
            this.addTabButton.insertAfter(this.moreButton);
            this.element.addClass('has-add-button');
          }
        } else {
          if (this.addTabButton && this.addTabButton.length) {
            this.addTabButton.remove();
            this.addTabButton = undefined;
            this.element.removeClass('has-add-button');
          }
        }

        return this;
      },

      setupEvents: function() {
        var self = this;

        // Set animation bar if tabs under modal
        var modal = self.element.closest('.modal');
        if (modal.length) {
          modal.on('afteropen', function () {
            if (self.hasAnimatedBar()) {
              self.focusBar();
            }
          });
        }

        // Clicking the 'a' triggers the click on the 'li'
        function routeAnchorClick(e) {
          var a = $(e.currentTarget);

          if (this.wasTapped === true) {
            this.wasTapped = false;
            return;
          }

          if (e.type === 'touchend') {
            this.wasTapped = true;
          }

          if (a.attr('href').substr(0, 1) !== '#') {
            //is an outbound Link
            return;
          }
          e.preventDefault();
        }

        // Some tabs have icons that can be clicked and manipulated
        function handleIconClick(e) {
          var elem = $(this);
          if (elem.is('[disabled]') || elem.parent().hasClass('is-disabled')) {
            return;
          }

          var li = $(elem).parent();

          if (li.hasClass('dismissible')) {
            e.preventDefault();
            e.stopPropagation();
            self.closeDismissibleTab(li.children('a').attr('href'));
          }
        }

        function handleTabBlur() {
          $(this).parent().removeClass('is-focused');
        }

        // Any events bound to individual tabs (li) and their anchors (a) are bound to the tablist
        // element so that tabs can be added/removed/hidden/shown without needing to change event bindings.
        this.tablist
          .on('mousedown.tabs', '> li', function(e) {
            self.handleAddFocusData(e, $(this));

            // let right click pass through
            if (e.which !== 3) {
              return self.handleTabClick(e, $(this));
            }
          })
          .on('click.tabs', 'a', routeAnchorClick)
          .on('click.tabs', '.icon', handleIconClick)
          .on('focus.tabs', 'a', function(e) {
            return self.handleTabFocus(e, $(this));
          })
          .on('blur.tabs', 'a', handleTabBlur)
          .on('keydown.tabs', 'a', function(e) {
            return self.handleTabKeyDown(e);
          });

        // Setup events on Dropdown Tabs
        function dropdownTabEvents(i, tab) {
          var li = $(tab),
            a = li.children('a'),
            menu = li.data('popupmenu').menu;

          // Alt+Del or Alt+Backspace closes a dropdown tab item
          function closeDropdownMenuItem(e) {
            if (!e.altKey || !li.is('.dismissible')) {
              return;
            }

            self.closeDismissibleTab(a.attr('href'));
            return;
          }

          menu.on('keydown.popupmenu', 'a', function(e) {
            switch(e.which) {
              case 27: // escape
                li.addClass('is-selected');
                a.focus();
                break;
              case 8: // backspace (delete on Mac)
                closeDropdownMenuItem(e);
                break;
              case 46: // The actual delete key
                closeDropdownMenuItem(e);
                break;
            }
          });

          li.on('selected.tabs', function(e, anchor) {
            var li = $(this),
              href = $(anchor).attr('href');

            if (!self.activate(href)) {
              return false;
            }

            if (self.hasSquareFocusState()) {
              self.positionFocusState(a);
            }

            if (self.hasAnimatedBar()) {
              self.focusBar(li);
            }

            a.focus();
            self.scrollTabList(li);

            li.addClass('is-selected');
            return false;
          });
        }

        var ddTabs = self.tablist.find('li').filter('.has-popupmenu');
        ddTabs.each(dropdownTabEvents);

        function dismissibleTabEvents(i, tab) {
          var li = $(tab),
            a = li.children('a');

          a.on('keydown.tabs', function(e) {
            self.handleDismissibleTabKeydown(e);
          });
        }

        var dismissible = self.tablist.find('li').filter('.dismissible');
        dismissible.each(dismissibleTabEvents);

        // Events specific to markup that can be re-rendered mid-lifecycle
        // The responsive vertical tabs system will set this up automatically, so skip
        if (!this.isResponsiveVerticalTabs()) {
          this.setupHelperMarkupEvents();
        }

        this.panels.on('keydown.tabs', function(e) {
          self.handlePanelKeydown(e);
        });

        // Check whether or not all of the tabs + more button are de-focused.
        // If true, the focus-state and animated bar need to revert positions
        // back to the currently selected tab.
        this.element.on('focusout.tabs', function allTabsFocusOut() {
          var noFocusedTabs = !$.contains(self.element[0], document.activeElement),
            noPopupMenusOpen = self.tablist.children('.has-popupmenu.is-open').length === 0;

          if (noFocusedTabs && noPopupMenusOpen && !self.moreButton.is('.is-selected, .popup-is-open')) {
            self.hideFocusState();
          }
        }).on('updated.tabs', function() {
          self.updated();
        }).on('activated.tabs', function(e) {
          // Stop propagation of the activate event from going higher up into the DOM tree
          e.stopPropagation();
        }).on('add.tabs', function(e, newTabId, newTabOptions, newTabIndex) {
          self.add(newTabId, newTabOptions, newTabIndex);
        }).on('remove.tabs', function(e, tabId) {
          self.remove(tabId);
        });

        // Check to see if we need to add/remove the more button on resize
        $('body').on('resize.tabs' + this.tabsIndex, function() {
          self.handleResize();
        });
        self.handleResize(true);

        $('input').on('isvalid', function() {
            var currentLi = $('li.is-selected');
            self.focusBar(currentLi);
        });

        return this;
      },

      /**
       * Adds events associated with elements that are re-renderable during the Tabs lifecycle
       * @private
       * @returns {this}
       */
      setupHelperMarkupEvents: function () {
        var self = this;

        // Setup the "more" function
        this.moreButton
          .onTouchClick('tabs')
          .on('click.tabs', function(e) {
            self.handleMoreButtonClick(e);
          })
          .on('keydown.tabs', function(e) {
            self.handleMoreButtonKeydown(e);
          })
          .on('focus.tabs', function(e) {
            self.handleMoreButtonFocus(e);
          })
          .on('mousedown.tabs', function(e) {
            self.handleAddFocusData(e, $(this));
          });

        if (this.settings.addTabButton) {
          this.addTabButton
            .onTouchClick('tabs')
            .on('click.tabs', function() {
              self.handleAddButton();
            })
            .on('keydown.tabs', function(e) {
              self.handleAddButtonKeydown(e);
            })
            .on('focus.tabs', function(e) {
              self.handleAddButtonFocus(e);
            });
        }
      },

      /**
       * Removes events associated with elements that are re-renderable during the Tabs lifecycle
       * @private
       * @returns {this}
       */
      removeHelperMarkupEvents: function() {
        if (this.moreButton && this.moreButton.length) {
          this.moreButton.offTouchClick('tabs')
            .off('click.tabs keydown.tabs focus.tabs mousedown.tabs');
        }

        if (this.addTabButton && this.addTabButton.length) {
          this.addTabButton.offTouchClick('tabs')
            .off('click.tabs keydown.tabs focus.tabs');
        }

        return this;
      },

      /**
       * Setup a mousedown event on tabs to determine in the focus handler whether or a not a keystroked cause
       * a change in focus, or a click.  Keystroke focus changes cause different visual situations
       * @param {$.Event} e
       * @param {jQuery[]} elem
       * @returns {undefined}
       */
      handleAddFocusData: function(e, elem) {
        var tab = elem;
        if (tab.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        if (!tab.is(this.moreButton)) {
          tab = tab.children('a');
        }

        this.hideFocusState();
        tab.data('focused-by-click', true);
      },

      handleTabClick: function(e, li) {
        if (this.element.is('.is-disabled') || (li && (li.is('.is-disabled') || li.is('.separator')))) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        var appMenuResult = this.handleAppMenuTabKeydown(e);
        if (!appMenuResult) {
          return;
        }

        var a = li.children('a');
        a.data('focused-by-click', true);

        if (this.popupmenu && this.popupmenu.element.hasClass('is-open')) {
          this.popupmenu.close();
        }

        // Don't activate a dropdown tab.  Clicking triggers the Popupmenu Control attached.
        if (li.is('.has-popupmenu')) {
          this.positionFocusState(a);
          return;
        }

        var href = a.attr('href');

        if (li.is('.add-tab-button')) {
          a = this.handleAddButton();
          li = a.parent();
          href = a.attr('href');
          this.element.trigger('tab-added', [a]);
        }

        // close tab on middle click
        if (e.which === 2) {
          if (li.is('.dismissible') && $(e.target).is('.close')) {
            this.closeDismissibleTab(href);
          }
          e.preventDefault();
          return;
        }

        if (!this.activate(href)) {
          return;
        }
        this.changeHash(href);

        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
        }

        a.focus();

        if (this.isScrollableTabs()) {
          this.scrollTabList(li);
        }

        // Hide these states
        this.focusBar(li);
        this.positionFocusState(a);

        if (this.settings.lazyLoad === true && this.isURL(href)) {
          return false;
        }
      },

      handleMoreButtonClick: function(e) {
        if (this.element.is('.is-disabled') || this.moreButton.is('.is-disabled')) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        this.moreButton.data('focused-by-click', true);

        if (!(this.container.hasClass('has-more-button'))) {
          e.stopPropagation();
        }
        if (this.moreButton.hasClass('popup-is-open')) {
          this.popupmenu.close();
          this.moreButton.removeClass('popup-is-open');
        } else {
          this.buildPopupMenu();
        }

        this.hideFocusState();
      },

      handleTabFocus: function(e, a) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var li = a.parent(),
          dataFocusedClick = a.data('focused-by-click'),
          focusedByKeyboard = dataFocusedClick === undefined || (dataFocusedClick && dataFocusedClick === false);

        $.removeData(a[0], 'focused-by-click');

        if (this.isTabOverflowed(li)) {
          this.buildPopupMenu(a.attr('href'));
          this.moreButton.addClass('is-focused');
          this.positionFocusState(this.moreButton);
        } else {
          li.addClass('is-focused');
          this.positionFocusState(a, focusedByKeyboard);
        }
      },

      handleMoreButtonFocus: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return;
        }

        var dataFocusedClick = this.moreButton.data('focused-by-click'),
          focusedByKeyboard = (dataFocusedClick && dataFocusedClick === false);

        $.removeData(this.moreButton[0], 'focused-by-click');

        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
          this.positionFocusState(this.moreButton, focusedByKeyboard);
        }
      },

      handleTabKeyDown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        if (e.shiftKey || e.ctrlKey || e.metaKey || (e.altKey && e.which !== 8)) {
          return;
        }

        var self = this,
          passableKeys = [8, 13, 32];

        function isPassableKey() {
          return $.inArray(e.which, passableKeys) > -1;
        }

        if ((e.which < 32 && !isPassableKey()) || e.which > 46) {
          return;
        }

        if (isPassableKey()) {
          var appMenuResult = this.handleAppMenuTabKeydown(e);
          if (!appMenuResult) {
            return;
          }
        }

        function openMenu(oldHref) {
          e.preventDefault();
          // setTimeout is used to bypass triggering of the keyboard when self.buildPopupMenu() is invoked.
          setTimeout(function() {
            self.buildPopupMenu(oldHref);
          }, 0);
        }

        var allExcludes = ':not(.separator):not(.is-disabled):not(:hidden)',
          currentLi = $(e.currentTarget).parent(),
          currentA = currentLi.children('a'),
          targetLi,
          tabs = self.tablist.children('li' + allExcludes),
          isRTL = Locale.isRTL();

        function previousTab() {
          var i = tabs.index(currentLi) - 1;
          while (i > -1 && !targetLi) {
            if (tabs.eq(i).is(allExcludes)) {
              return tabs.eq(i);
            }
            i = i - 1;
          }

          if (self.settings.addTabButton) {
            return self.addTabButton;
          }

          var last = self.tablist.children('li' + allExcludes).last();

          if (self.hasMoreButton() && self.isScrollableTabs()) {
            openMenu(last.find('a').attr('href'));
          }

          return last;
        }

        function nextTab() {
          var i = tabs.index(currentLi) + 1;
          while(i < tabs.length && !targetLi) {
            if (tabs.eq(i).is(allExcludes)) {
              return tabs.eq(i);
            }
            i++;
          }

          var first = self.tablist.children('li' + allExcludes).first();

          if (self.hasMoreButton() && self.isScrollableTabs()) {
            openMenu(first.find('a').attr('href'));
            return first;
          }

          if (self.settings.addTabButton) {
            return self.addTabButton;
          }
          return first;
        }

        function checkAngularClick() {
          if (currentA.attr('ng-click') || currentA.attr('data-ng-click')) { // Needed to fire the "Click" event in Angular situations
            currentA.click();
          }
        }

        function activate() {
          if (currentLi.hasClass('has-popupmenu')) {
            currentLi.data('popupmenu').open();
            return;
          }

          var href = currentA.attr('href');

          if (currentLi.is('.add-tab-button')) {
            currentA = self.handleAddButton();
            currentLi = currentA.parent();
            href = currentA.attr('href');
            self.element.trigger('tab-added', [currentA]);
          }

          if (!self.activate(href)) {
            return;
          }

          self.changeHash(href);
          self.focusBar(currentLi);
          checkAngularClick();
          currentA[0].focus();
          self.hideFocusState();

          // In the event that the activated tab is a full link that should be followed,
          // the keystroke events need to manually activate the link change.  Clicks are handled
          // automatically by the browser.
          self.handleOutboundLink(href);
        }

        switch(e.which) {
          case 8:
            if (e.altKey && currentLi.is('.dismissible')) {
              e.preventDefault();
              self.closeDismissibleTab(currentA.attr('href'));
            }
            return;
          case 13: // Enter
            activate();
            return false;
          case 32: // Spacebar
            activate();
            return false;
          case 38:
            targetLi = previousTab();
            e.preventDefault(); // jshint ignore:line
            break;
          case 37:
            targetLi = isRTL ? nextTab() : previousTab();
            e.preventDefault();
            break;
          case 40:
            targetLi = nextTab();
            e.preventDefault(); // jshint ignore:line
            break;
          case 39:
            targetLi = isRTL ? previousTab() : nextTab();
            e.preventDefault();
            break;
        }

        if (targetLi) {
          var isAddTabButton = targetLi.is('.add-tab-button'),
            focusStateTarget = isAddTabButton ? targetLi : targetLi.children('a');

          // Use the matching option in the popup menu if the target is hidden by overflow.
          if (this.isTabOverflowed(targetLi)) {
            return openMenu(targetLi.children('a').attr('href'));
          }

          if (!isAddTabButton) {
            focusStateTarget.focus();
          } else {
            self.addTabButton.focus();
          }

          if (this.isScrollableTabs()) {
            this.scrollTabList(focusStateTarget);
          }

          if (self.hasSquareFocusState()) {
            self.positionFocusState(focusStateTarget, true);
          }
        }
      },

      handleDismissibleTabKeydown: function(e) {
        var key = e.which,
          tab = $(e.target);

        if (tab.is('a')) {
          tab = tab.parent();
        }

        if (e.altKey && key === 46) { // Alt + Del
          if (tab.children('a').is('[disabled]') || tab.hasClass('is-disabled')) {
            return;
          }

          e.preventDefault();
          this.closeDismissibleTab(tab.children('a').attr('href'));
        }
      },

      handleAppMenuTabKeydown: function(e) {
        var target = $(e.target),
          li = target.parent();

        if (!(li.is('.application-menu-trigger') || target.is('.application-menu-trigger'))) {
          return true;
        }

        // If the tab is an application-menu trigger, open the app menu
        // Used by Module Tabs
        var menu = $('#application-menu');
        if (!menu.length) {
          return false;
        }

        e.preventDefault();

        this.hideFocusState();

        if (menu.hasClass('is-open')) {
          menu.trigger('close-applicationmenu');
          return false;
        }

        menu.trigger('open-applicationmenu');
        return false;
      },

      handleMoreButtonKeydown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var self = this,
          isRTL = Locale.isRTL();

        function openMenu() {
          e.preventDefault();
          self.buildPopupMenu(self.tablist.find('.is-selected').children('a').attr('href'));
          self.positionFocusState(self.moreButton, true);
        }

        function lastTab() {
          e.preventDefault();
          self.findLastVisibleTab();
        }

        switch(e.which) {
          case 37: // left
            if (isRTL) {
              openMenu();
              break;
            }
            lastTab();
            break;
          case 38: // up
            lastTab();
            break;
          case 13: // enter
          case 32: // spacebar
            e.preventDefault(); //jshint ignore:line
          case 39: // right
            if (isRTL) {
              lastTab();
              break;
            }
            openMenu();
            break;
          case 40: // down
            openMenu();
            break;
        }
      },

      handlePanelKeydown: function(e) {
        var key = e.which,
          panel = $(e.target),
          a = this.anchors.filter('#' + panel.attr('id')),
          tab = this.anchors.filter('#' + panel.attr('id')).parent();

        if (tab.is('.dismissible')) {
          // Close a Dismissible Tab
          if (e.altKey && key === 46) { // Alt + Delete
            e.preventDefault();
            return this.closeDismissibleTab(a.attr('href'));
          }
        }

        // Takes focus away from elements inside a Tab Panel and brings focus to its corresponding Tab
        if ((e.ctrlKey && key === 38) && $.contains(document.activeElement, panel[0])) { // Ctrl + Up Arrow
          e.preventDefault();
          return this.activate(a.attr('href'));
        }
      },

      handleAddButton: function() {
        var cb = this.settings.addTabButtonCallback;
        if (cb && typeof cb === 'function') {
          var newTabId = cb();
          return this.anchors.filter('[href="#'+ newTabId +'"]');
        }

        function makeId() {
          var stringName = 'new-tab',
            existing = $('[id^="'+ stringName +'"]');

          if (!existing.length) {
            return stringName + '-0';
          }
          return stringName + '-' + existing.length;
        }

        function makeName(id) {
          var nameParts = id.toString().split('-');
          nameParts.forEach(function(val, i) {
            nameParts[i] = val.charAt(0).toUpperCase() + val.slice(1);
          });

          return nameParts.join(' ');
        }

        var newIndex = this.tablist.children().index(this.addTabButton),
          newId = makeId(),
          newName = makeName(newId),
          settings = {
            name: newName,
            content: '&nbsp;',
            isDismissible: true
          };

        if (newIndex < 0) {
          newIndex = this.tablist.find('li:not(.separator)').length;
        }

        // Allow the opportunity to pass in external settings for the new tab control
        var externalSettings = this.element.triggerHandler('before-tab-added', [newId, settings, newIndex]);
        if (!externalSettings) {
          this.add(newId, settings, newIndex);
          return this.anchors.filter('[href="#'+ newId +'"]');
        }

        if (externalSettings.newId && externalSettings.newId.length && typeof externalSettings.newId === 'string') {
          newId = externalSettings.newId;
        }
        if (externalSettings.settings && typeof externalSettings.settings === 'object') {
          settings = externalSettings.settings;
        }
        if (!isNaN(externalSettings.newIndex)) {
          newIndex = externalSettings.newIndex;
        }

        this.add(newId, settings, newIndex);
        return this.anchors.filter('[href="#'+ newId +'"]');
      },

      handleAddButtonKeydown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var self = this,
          isRTL = Locale.isRTL(),
          targetLi,
          filter = 'li:not(.separator):not(.is-disabled):not(:hidden)';

        function openMenu() {
          e.preventDefault();
          targetLi = self.tablist.find(filter).last();

          if (self.isTabOverflowed(targetLi)) {
            // Open the spillover
            self.buildPopupMenu(targetLi.children('a').attr('href'));
            self.positionFocusState(self.moreButton, true);
            return;
          }
        }

        function firstTab() {
          targetLi = self.tablist.find(filter).first();
        }

        switch(e.which) {
          case 37: // left
            if (isRTL) {
              firstTab();
              break;
            }
            openMenu();
            break;
          case 38: // up
            openMenu();
            break;
          case 13: // enter
          case 32: // spacebar
            e.preventDefault(); //jshint ignore:line
            return this.handleAddButton();
          case 39: // right
            if (isRTL) {
              openMenu();
              break;
            }
            firstTab();
            break;
          case 40: // down
            firstTab();
            break;
          default:
            return;
        }

        targetLi.children('a').focus();
      },

      handleAddButtonFocus: function() {
        var tabs = this.tablist.find('li:not(.separator)');
        tabs.add(this.moreButton).removeClass('is-focused');

        this.addTabButton.addClass('is-focused');
        this.positionFocusState(this.addTabButton, true);
      },

      handleResize: function(ignoreResponsiveCheck) {
        if (!ignoreResponsiveCheck) {
          this.checkResponsive();
        }

        this.setOverflow();

        var selected = this.tablist.find('.is-selected');
        if (!selected.length || this.moreButton.is('.is-selected') || this.isTabOverflowed(selected)) {
          selected = this.moreButton;
        }

        if (!selected.length) {
          this.defocusBar();
          this.hideFocusState();
        } else {
          this.focusBar(selected);
          this.positionFocusState(selected);
        }

        this.handleVerticalTabResize();
        this.renderVisiblePanel();
        this.renderEdgeFading();
      },

      checkResponsive: function() {
        var self = this,
          classList = self.element[0].classList;

        function rebuild() {
          self.removeHelperMarkupEvents();
          self.renderHelperMarkup();
          self.setupHelperMarkupEvents();
        }

        function makeResponsive() {
          if (!classList.contains('is-in-responsive-mode')) {
            classList.add('is-in-responsive-mode');
            classList.add('header-tabs');
            classList.add('alternate');
            classList.remove('vertical');
            rebuild();
          }
        }

        function makeVertical() {
          if (classList.contains('is-in-responsive-mode')) {
            classList.add('vertical');
            classList.remove('is-in-responsive-mode');
            classList.remove('header-tabs');
            classList.remove('alternate');
            rebuild();
          }
        }

        // Check for responsive mode for Vertical tabs
        if (this.isResponsiveVerticalTabs()) {
          if (Soho.breakpoints.isBelow('phone-to-tablet')) {
            makeResponsive();
          } else {
            makeVertical();
          }
        } else {
          makeVertical();
        }
      },

      handleVerticalTabResize: function() {
        if (!this.isVerticalTabs()) {
          return;
        }

        // When tabs are full-size (part of a layout) CSS rules should handle this better
        // due to less strange sizing constraints.  JS resizing is necessary for nesting.
        if (!this.isNested() || this.isNestedInLayoutTabs() || this.isHidden()) {
          return;
        }

        var elemStyle = window.getComputedStyle(this.element[0]),
          elemOuterHeight = elemStyle.getPropertyValue('height') + elemStyle.getPropertyValue('margin-top') + elemStyle.getPropertyValue('margin-bottom');

        this.tablist[0].style.height = elemOuterHeight;
      },

      // Changes the location in the browser address bar to force outbound links.
      handleOutboundLink: function(href, useRelativePath) {
        if (href.charAt(0) === '#') {
          return false;
        }

        if (href.charAt(0) === '/' && (!useRelativePath || useRelativePath === false)) {
          href = window.location.origin + href;
        }

        window.location = href;
      },

      hasAnimatedBar: function() {
        return !this.isModuleTabs() && !this.isVerticalTabs();
      },

      hasSquareFocusState: function() {
        return true;
      },

      hasMoreButton: function() {
        return this.element[0].classList.contains('has-more-button');
      },

      isInResponsiveMode: function() {
        return this.element[0].classList.contains('is-in-responsive-mode');
      },

      isModuleTabs: function() {
        return this.element.hasClass('module-tabs');
      },

      isVerticalTabs: function() {
        return this.element.hasClass('vertical');
      },

      isResponsiveVerticalTabs: function() {
        return this.settings.verticalResponsive === true;
      },

      isHeaderTabs: function() {
        return this.element.hasClass('header-tabs');
      },

      isScrollableTabs: function() {
        return !this.isModuleTabs() && !this.isVerticalTabs();
      },

      isHidden: function() {
        return this.element.is(':hidden');
      },

      isNested: function() {
        return this.element.closest('.tab-panel').length;
      },

      isActive: function(href) {
        if (!href || !href.length || (href.length === 1 && href.indexOf('#') < 1)) {
          return false;
        }

        var panel = this.getPanel(href);
        return panel[0].classList.contains('can-show');
      },

      isNestedInLayoutTabs: function() {
        var nestedInModuleTabs = this.element.closest('.module-tabs').length,
          nestedInHeaderTabs = this.element.closest('.header-tabs').length,
          hasTabContainerClass = this.element.closest('.tab-panel-container').length;

        return (nestedInModuleTabs > 0 || nestedInHeaderTabs > 0 || hasTabContainerClass > 0);
      },

      isTab: function(obj) {
        return obj instanceof jQuery && obj.length && obj.is('li.tab');
      },

      isAnchor: function(obj) {
        return obj instanceof jQuery && obj.length && obj.is('a');
      },

      getAnchor: function(href) {
        if (this.isAnchor(href)) {
          return href;
        }

        if (href.indexOf('#') === -1 && href.charAt(0) !== '/') {
          href = '#' + href;
        }
        return this.anchors.filter('[href="' + href + '"]');
      },

      getPanel: function(href) {
        if (this.isTab(href)) {
          href = href.children('a');
        }

        if (this.isAnchor(href)) {
          href = href.attr('href');
        }

        if (!href || href === '' || href === '#') {
          return $();
        }

        return this.panels.filter('[id="' + href.replace(/#/g, '') + '"]');
      },

      getMenuItem: function(href) {
        if (this.isAnchor(href)) {
          href = href.attr('href');
        }

        if (href.indexOf('#') === -1) {
          href = '#' + href;
        }
        return this.moreMenu.children().children().filter('[data-href="'+ href +'"]').parent();
      },

      // Takes a tab ID and returns a jquery object containing the previous available tab
      getPreviousTab: function(tabId) {
        var tab = this.getTab(null, tabId),
          filter = 'li:not(.separator):not(:hidden):not(.is-disabled)',
          tabs = this.tablist.find(filter),
          target = tabs.eq(tabs.index(tab) - 1);

        while(target.length && !target.is(filter)) {
          target = tabs.eq(tabs.index(target) - 1);
        }

        // Top-level Dropdown Tabs don't have an actual panel associated with them.
        // Get a Dropdown Tab's first child as the target.
        if (target.is('.has-popupmenu')) {
          var menuAPI = target.data('popupmenu');
          if (menuAPI) {
            target = menuAPI.menu.children('li').first();
          }
        }

        return target;
      },

      // Takes a tab ID and returns a jquery object containing the previous available tab
      // If an optional target Tab (li) is provided, use this to perform activation events
      activatePreviousTab: function(tabId, target) {
        var tab = this.getTab(null, tabId);

        if (!target || !(target instanceof jQuery)) {
          target = this.getPreviousTab(tabId);
        }

        if (!target.length) {
          this.hideFocusState();
          this.defocusBar();
          return target;
        }

        var a = target.children('a');
        if (tab.is('.is-selected')) {
          if (!this.activate(a.attr('href'))) {
            return;
          }
          a.focus();
        }
        this.positionFocusState(a);
        this.focusBar(target);

        return target;
      },

      isURL: function(href) {
        if (!href || href.indexOf('#') === 0) {
          return false;
        }

        return true;
      },

      activate: function(href) {
        var self = this,
          a, targetTab, targetPanel, targetPanelElem, oldTab, oldPanel,
          selectedStateTarget,
          activeStateTarget;

        if (self.isURL(href)) {
          return this.callSource(href, true);
        }

        a = self.getAnchor(href);
        targetTab = a.parent();
        targetPanel = self.getPanel(href);
        targetPanelElem = targetPanel[0];
        oldTab = self.anchors.parents().filter('.is-selected');

        // Avoid filter(:visible)
        for (var i = 0; i < self.panels.length; i++) {
          if (self.panels[i].classList.contains('is-visible')) {
            oldPanel = $(self.panels[i]);
          }
        }

        if (!oldPanel) {
          oldPanel = self.panels;
        }

        // NOTE: Breaking Change as of 4.3.3 - `beforeactivate` to `beforeactivated`
        // See SOHO-5994 for more details
        var isCancelled = self.element.trigger('beforeactivated', [a]);
        if (!isCancelled) {
          return;
        }

        function completeActivate(vetoResult) {
          if (targetPanel.length < 1) {
            if (self.settings.source) {
              return self.callSource(href);
            }
          } else {
            oldPanel[0].classList.remove('can-show');
            oldPanel[0].classList.remove('is-visible');
            oldPanel.closeChildren();
            self.element.trigger('activated', [a]);

            targetPanelElem.classList.add('can-show');
            self.renderVisiblePanel();
            // trigger reflow as display property is none for animation
            targetPanelElem.offsetHeight; // jshint ignore:line

            targetPanel.one($.fn.transitionEndName() + '.tabs', function() {
              self.element.trigger('afteractivated', [a]);
            });

            // Triggers the CSS Animation
            targetPanelElem.classList.add('is-visible');
          }

          // Update the currently-selected tab
          self.updateAria(a);
          oldTab.add(self.moreButton).removeClass('is-selected');

          if (targetTab[0].classList.contains('tab')) {
            selectedStateTarget = targetTab;
            activeStateTarget = targetTab;
          }

          var ddMenu = targetTab.parents('.popupmenu'),
            ddTab;

          if (ddMenu.length) {
            ddTab = ddMenu.data('trigger');
            if (ddTab.length) {
              selectedStateTarget = ddTab;
              activeStateTarget = ddTab;
            }
          }

          if (self.isTabOverflowed(activeStateTarget)) {
            activeStateTarget = self.moreButton;
            selectedStateTarget = self.moreButton;
          }
          self.focusBar(activeStateTarget);

          selectedStateTarget.addClass('is-selected');

          // Fires a resize on any invoked child toolbars inside the tab panel.
          // Needed to fix issues with Toolbar alignment, since we can't properly detect
          // size on hidden elements.
          var childToolbars = targetPanel.find('.toolbar');
          if (childToolbars.length) {
            childToolbars.each(function() {
              var api = $(this).data('toolbar');
              if (api && typeof api.handleResize === 'function') {
                api.handleResize();
              }
            });
          }

          return vetoResult || false;
        }

        // Handle an optional, veto-able "beforeActivate" callback.
        if (this.settings.beforeActivate && typeof this.settings.beforeActivate === 'function') {
          return this.settings.beforeActivate(oldTab, targetTab, completeActivate);
        }

        // Otherwise, simply continue
        return completeActivate(true);
      },

      /**
       * Shows/Hides some tabsets' faded edges based on scrolling position, if applicable.
       * @returns {undefined}
       */
      renderEdgeFading: function() {
        if (!this.isScrollableTabs() || !this.tablistContainer) {
          return;
        }

        var isRTL = Locale.isRTL(),
          tablistContainerElem = this.tablistContainer[0],
          scrollLeft = tablistContainerElem.scrollLeft,
          scrollWidth = tablistContainerElem.scrollWidth,
          containerWidth = parseInt(window.getComputedStyle(tablistContainerElem).getPropertyValue('width'));

        if (isRTL) {
          this.element[0].classList[ scrollLeft > 0 ? 'add' : 'remove' ]('scrolled-left');
          this.element[0].classList[ (scrollWidth - scrollLeft) <= containerWidth ? 'remove' : 'add' ]('scrolled-right');
        } else {
          this.element[0].classList[ scrollLeft > 0 ? 'add' : 'remove' ]('scrolled-right');
          this.element[0].classList[ (scrollWidth - scrollLeft) <= containerWidth ? 'remove' : 'add' ]('scrolled-left');
        }
      },

      /**
       * Calls an options-provided source method to fetch content that will be displayed inside a tab.
       * @param {string} href - string representing the target tab to load content under.
       * @param {function} callback - method that fires after a successful source call.
       * @returns {boolean|$.Deferred} true if source call was successful, false for failure/ignore, or a promise object that will fire callbacks in either "success" or "failure" scenarios.
       */
      callSource: function(href, isURL) {
        if ((isURL === undefined || isURL === null || isURL === false) && !this.settings.source) {
          return false;
        }
        if (this.settings.lazyLoad !== true) {
          return false;
        }

        var self = this,
          sourceType = typeof this.settings.source,
          response = function(htmlContent) {
            if (htmlContent === undefined || htmlContent === null) {
              return;
            }

            htmlContent = $.sanitizeHTML(htmlContent);

            // Get a new random tab ID for this tab if one can't be derived from the URL string
            if (isURL) {
              var anchor = self.tablist.find('[href="'+ href +'"]'),
                containerId = self.element[0].id || '',
                id = anchor.uniqueId('tab', containerId);

              href = '#' + id;
              // Replace the original URL on this anchor now that we've loaded content.
              anchor.attr('href', href);
            }

            self.createTabPanel(href, htmlContent, true);
            self.activate(href);

            self.element.triggerHandler('complete'); // For Busy Indicator
            self.element.trigger('requestend', [href, htmlContent]);
          };

        this.container.triggerHandler('start'); // For Busy Indicator
        this.container.trigger('requeststart');

        function handleStringSource(url, options) {
          var opts = $.extend({ dataType: 'html' }, options, {
            url: url
          });

          var request = $.ajax(opts);
          request.done(response);
          return request;
        }

        if (isURL) {
          return handleStringSource(href, this.ajaxOptions);
        }

        // return _true_ from this source function on if we're just loading straight content
        // return a promise if you'd like to setup async handling.
        if (sourceType === 'function') {
          return this.settings.source(response, href, this.settings.sourceArguments);
        }

        if (sourceType === 'string') {
          // Attempt to resolve source as a URL string.  Make an $.ajax() call with the URL
          var safeHref = href.replace(/#/g, ''),
            sourceURL = this.settings.source.toString(),
            hasHref = sourceURL.indexOf(safeHref) > -1;

          if (!hasHref) {
            var param = 'tab=' + safeHref,
              paramIndex = sourceURL.indexOf('?'),
              hashIndex = sourceURL.indexOf('#'),
              insertIndex = sourceURL.length;

            if (paramIndex < 0) {
              param = '?' + param;
              if (hashIndex > -1) {
                insertIndex = hashIndex + 1;
              }
            } else {
              param = param + '&';
              insertIndex = paramIndex + 1;
            }

            sourceURL = Soho.string.splice(sourceURL, insertIndex, 0, param);
          }

          return handleStringSource(sourceURL, this.ajaxOptions);
        }

        return false;
      },

      renderVisiblePanel: function() {
        // Recalculate all components inside of the visible tab to adjust widths/heights/display if necessary
        this.resizeNestedTabs();
        //TJM: Prioritizing performance fix.
        //this.panels.filter(':visible').handleResize();
      },

      changeHash: function(href) {
        if (!this.settings.changeTabOnHashChange) {
          return;
        }

        if (!href) {
          href = '';
        }

        href.replace(/#/g, '');

        var cb = this.settings.hashChangeCallback;
        if (cb && typeof cb === 'function') {
          cb(href);
        } else {
          window.location.hash = href;
        }

        this.element.triggerHandler('hash-change', [href]);
      },

      updateAria: function(a) {
        if (!a) {
          return;
        }
        //hide old tabs
        this.anchors.attr({
          'aria-selected': 'false',
          'aria-expanded': 'false',
          'tabindex': '-1'
        });
        this.moreButton.attr({
          'tabindex': '-1'
        });

        //show current tab
        if (a.length && this.element.is(':not(.is-disabled)')) {
          a.parent().removeClass('is-selected');
          if (!this.isTabOverflowed(a.parent())) {
            a.attr({
              'aria-selected': 'true',
              'aria-expanded': 'true',
              'tabindex': '0'
            }).parent().addClass('is-selected');
          } else {
            this.moreButton.attr({
              'tabindex': '0'
            });
          }
        }
      },

      resizeNestedTabs: function() {
        this.nestedTabControls.each(function(i, container) {
          var c = $(container),
            api = c.data('tabs');

          if (api && api.handleResize && typeof api.handleResize === 'function') {
            api.handleResize(true);
          }
        });
      },

      // Adds a new tab into the list and properly binds events
      add: function(tabId, options, atIndex) {
        if (!tabId) {
          return this;
        }

        if (!options) {
          options = {};
        }

        var startFromZero = this.tablist.find('li').not('.application-menu-trigger, .add-tab-button').length === 0;

        // Sanitize
        tabId = '' + tabId.replace(/#/g, '');
        options.name = options.name ? options.name.toString() : '&nbsp;';
        options.isDismissible = options.isDismissible ? options.isDismissible === true : false;
        options.isDropdown = options.isDropdown ? options.isDropdown === true : false;

        function getObjectFromSelector(sourceString) {
          var contentType = typeof sourceString;
          switch(contentType) {
            case 'string':
              var hasId = sourceString.match(/#/g);
              // Text Content or a Selector.
              if (hasId !== null) {
                var obj = $(sourceString);
                sourceString = obj.length ? $(sourceString).clone() : sourceString;
              }
              // do nothing if it's just a string of text.
              break;
            case 'object':
              // jQuery object or HTML Element
              sourceString = $(sourceString).clone();
              break;
          }
          return sourceString;
        }

        if (options.content) {
          options.content = getObjectFromSelector(options.content);
        }
        if (options.dropdown) {
          options.dropdown = getObjectFromSelector(options.dropdown);
        }

        // Build
        var tabHeaderMarkup = $('<li role="presentation" class="tab"></li>'),
          anchorMarkup = $('<a href="#'+ tabId +'" role="tab" aria-expanded="false" aria-selected="false" tabindex="-1">'+ options.name +'</a>'),
          tabContentMarkup = this.createTabPanel(tabId, options.content);

        tabHeaderMarkup.html(anchorMarkup);

        if (options.isDismissible) {
          tabHeaderMarkup.addClass('dismissible');
          tabHeaderMarkup.append($.createIconElement({ icon: 'close', classes: 'close icon' }));
        }

        if (this.settings.tabCounts) {
          anchorMarkup.prepend('<span class="count">0 </span>');
        }

        if (options.dropdown) {
          // TODO: Need to implement the passing of Dropdown Tab menus into this method.
        }

        function insertIntoTabset(self, targetIndex) {
          var method,
            tabs = self.tablist.children('li'),
            nonSpecialTabs = tabs.not('.application-menu-trigger, .add-tab-button'),
            finalIndex = tabs.length - 1;

          if (!tabs.length) {
            tabHeaderMarkup.appendTo(self.tablist);
            tabContentMarkup.appendTo(self.container);
            return;
          }

          var addTabButton = tabs.filter('.add-tab-button'),
            appMenuTrigger = tabs.filter('.application-menu-trigger');

          // NOTE: Cannot simply do !targetIndex here because zero is a valid index
          if (targetIndex === undefined || targetIndex === null || isNaN(targetIndex)) {
            targetIndex = tabs.length;
          }

          function pastEndOfTabset(index) {
            return index > tabs.length - 1;
          }

          function atBeginningOfTabset(index) {
            return index <= 0;
          }

          if (tabs.length > nonSpecialTabs.length) {
            if (pastEndOfTabset(targetIndex) && addTabButton && addTabButton.length) {
              targetIndex = targetIndex - 1;
            }

            if (atBeginningOfTabset(targetIndex) && appMenuTrigger && appMenuTrigger.length) {
              targetIndex = targetIndex + 1;
            }
          }

          var conditionInsertTabBefore = tabs.eq(targetIndex).length > 0;

          finalIndex = conditionInsertTabBefore ? targetIndex : finalIndex;

          method = 'insertAfter';
          if (conditionInsertTabBefore) {
            method = 'insertBefore';
          }

          tabHeaderMarkup[method](tabs.eq(finalIndex));
          tabContentMarkup.appendTo(self.container);
          return;
        }

        insertIntoTabset(this, atIndex);

        // Add each new part to their respective collections.
        this.panels = this.panels.add(tabContentMarkup);
        this.anchors = this.anchors.add(anchorMarkup);

        // Link the two items via data()
        anchorMarkup.data('panel-link', tabContentMarkup);
        tabContentMarkup.data('tab-link', anchorMarkup);
        // TODO: When Dropdown Tabs can be added/removed, add that here

        // Make it possible for Module Tabs to display a tooltip containing their contents
        // if the contents are cut off by ellipsis.
        if (this.settings.moduleTabsTooltips) {
          anchorMarkup.on('beforeshow.toolbar', function() {
            return anchorMarkup.data('cutoffTitle') === 'yes';
          }).tooltip({
            content: '' + anchorMarkup.text().trim()
          });
        }

        // Adjust tablist height
        this.setOverflow();

        // If started from zero, position the focus state/bar and activate the tab
        if (startFromZero) {
          this.positionFocusState(anchorMarkup);
          this.focusBar(tabHeaderMarkup);
          if (!this.activate(anchorMarkup.attr('href'))) {
            return this;
          }
          anchorMarkup.focus();
        }

        return this;
      },

      // Removes a tab from the list and cleans up properly
      // NOTE: Does not take advantage of _activatePreviousTab()_ due to specific needs of selecting certain
      // Tabs/Anchors at certain times.
      remove: function(tabId, disableBeforeClose) {
        var self = this,
          targetLi = this.doGetTab(null, tabId);

        if (!targetLi || !targetLi.length) {
          return;
        }

        var targetAnchor = targetLi.children('a'),
          targetPanel = this.getPanel(tabId),
          hasTargetPanel = (targetPanel && targetPanel.length),
          targetLiIndex = this.tablist.children('li').index(targetLi),
          notATab = '.application-menu-trigger, .separator, .is-disabled, :hidden',
          prevLi = targetLi.prev();

        if (!disableBeforeClose) {
          var canClose = this.element.triggerHandler('beforeclose', [targetLi]);
          if (canClose === false) {
            return false;
          }
        }

        var wasSelected = false;
        if (targetLi.hasClass('is-selected')) {
          wasSelected = true;
        } else {
          prevLi = this.tablist.children('li').not(notATab).filter('.is-selected');
        }

        // Remove these from the collections
        if (hasTargetPanel) {
          this.panels = this.panels.not(targetPanel);
        }
        this.anchors = this.anchors.not(targetAnchor);

        // Destroy Anchor tooltips, if applicable
        if (this.settings.moduleTabsTooltips) {
          targetAnchor.off('beforeshow.toolbar').data('tooltip').destroy();
        }

        // Close Dropdown Tabs in a clean fashion
        var popupAPI = targetLi.data('popupmenu');
        if (targetLi.hasClass('has-popupmenu')) {
          if (popupAPI) {
            popupAPI.menu.children('li').each(function() {
              self.remove($(this).children('a').attr('href'));
            });
            popupAPI.destroy();
          }
        }

        // If this tab is inside of a Dropdown Tab's menu, detect if it was the last one
        // remaining, and if so, close the entire Dropdown Tab.
        // The actual check on these elements needs to be done AFTER the targetLi is removed
        // from a Dropdown Tab, to accurately check the number of list items remaining.
        // See: _isLastDropdownTabItem()_
        var parentMenu = targetLi.closest('.dropdown-tab'),
          trigger = parentMenu.data('trigger');

        // Kill associated events
        targetLi.off('click.tabs');
        targetAnchor.off('click.tabs focus.tabs keydown.tabs');

        // Remove Markup
        targetLi.remove();
        if (hasTargetPanel) {
          targetPanel.remove();
        }

        var menuItem = targetAnchor.data('moremenu-link');
        if (menuItem) {
          menuItem.parent().off().remove();
          $.removeData(targetAnchor[0], 'moremenu-link');
        }

        function isLastDropdownTabItem(menu) {
          return menu.length && menu.children('li:not(.separator)').length === 0;
        }
        if (isLastDropdownTabItem(parentMenu)) {
          prevLi = this.getPreviousTab(trigger);

          setTimeout(function() {
            self.remove(trigger);
          }, 1);
        }

        // Close dropdown tab's menu
        if (trigger && trigger.length) {
          trigger.data('popupmenu').close();
        }

        // Adjust tablist height
        this.setOverflow();

        this.element.trigger('close', [targetLi]);

        // If any tabs are left in the list, set the previous tab as the currently selected one.
        var count = targetLiIndex - 1;
        while (count > -1) {
          count = -1;
          if (prevLi.is(notATab)) {
            prevLi = prevLi.prev();
            count = count - 1;
          }
        }

        // If we find nothing, search for ANY available tab
        if (!prevLi.length) {
          prevLi = this.tablist.children('li').not(notATab).first();
        }

        // If there's really nothing, kick on out and defocus everything.
        if (!prevLi.length) {
          this.hideFocusState();
          this.defocusBar();

          this.element.trigger('afterclose', [targetLi]);
          return this;
        }

        var a = prevLi.children('a'),
          activateTargetA = a;

        this.positionFocusState(a);

        if (wasSelected) {
          if (prevLi.is('.has-popupmenu') && prevLi.data('popupmenu')) {
            activateTargetA = prevLi.data('popupmenu').menu.children().first().children('a');
          }
          if (!this.activate(activateTargetA.attr('href'))) {
            return this;
          }
        }

        this.focusBar(prevLi);
        a.focus();

        this.element.trigger('afterclose', [targetLi]);

        return this;
      },


      createTabPanel: function(tabId, content, doInsert) {
        tabId = tabId.replace(/#/g, '');

        // If a jQuery-wrapped element is provided, actually append the element.
        // If content is text/string, simply inline it.
        var markup = $('<div id="'+ tabId +'" class="tab-panel" role="tabpanel"></div>');
        if (content instanceof $) {
          markup.append(content);
        } else {
          markup[0].innerHTML = content || '';
        }

        if (doInsert === true) {
          this.container.append(markup);
        }

        this.panels = this.panels.add(markup);

        return markup;
      },

      checkPopupMenuItems: function(tab) {
        function getRemainingMenuItems(popupAPI) {
          if (!popupAPI || !popupAPI.menu) {
            return $();
          }
          var menu = popupAPI.menu,
            items = menu.children('li');

          if (!items.length) {
            popupAPI.destroy();
            return $();
          }
          return items;
        }

        if (tab.is('.has-popupmenu')) {
          return getRemainingMenuItems(tab.data('popupmenu'));
        }

        var ddTab = tab.closest('.dropdown-tab');
        if (!ddTab.length) {
          return $();
        }
        return getRemainingMenuItems(ddTab.data('popupmenu'));
      },

      getTab: function(e, tabId) {
        var self = this,
          tab = $();

        function getTabFromEvent(ev) {
          var t = $(ev.currentTarget);
          if (t.is('.tab')) {
            return t;
          }
          if (t.closest('.tab').length) {
            return t.closest('.tab').first();
          }
          return null;
        }

        function getTabFromId(id) {
          if (!id || id === '' || id === '#') {
            return null;
          }

          if (id.indexOf('#') === -1) {
            id = '#' + id;
          }

          var anchor = self.anchors.filter('[href="' + id + '"]');
          if (!anchor.length) {
            return null;
          }

          return anchor.parent();
        }

        // TabId can also be a jQuery object containing a tab.
        if (tabId instanceof $ && tabId.length > 0) {
          if (tabId.is('a')) {
            return tabId.parent();
          }
          return tabId;
        }

        return e ? getTabFromEvent(e) : tabId ? getTabFromId(tabId) : tab;
      },

      doGetTab: function(e, tabId) {
        if (!e && !tabId) { return $(); }
        if (e && !(e instanceof $.Event) && typeof e !== 'string') {
          return $();
        }

        if (e) {
          if (typeof e !== 'string') { // jQuery Event
            return this.getTab(e);
          }
          return this.getTab(null, e); // String containing a selector
        }

        // Straight to the TabID
        return this.getTab(null, tabId);
      },

      // Hides a tab
      hide: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        if (tab.is('.is-selected')) {
          this.activatePreviousTab(tabId);
        }
        tab.addClass('hidden');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Shows a tab
      show: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        tab.removeClass('hidden');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Disables an individual tab
      disableTab: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        if (tab.is('.is-selected')) {
          this.activatePreviousTab(tabId);
        }
        tab.addClass('is-disabled');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Enables an individual tab
      enableTab: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        tab.removeClass('is-disabled');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Renames a tab and resets the focusable bar/animation.
      rename: function(e, tabId, name) {
        // Backwards compatibility with 4.2.0
        if (e && typeof e === 'string') {
          name = tabId;
          tabId = e;
        }

        if (!name) {
          return;
        }

        var tab = this.doGetTab(e, tabId),
          hasCounts = this.settings.tabCounts,
          hasTooltip = this.settings.moduleTabsTooltips,
          anchor = tab.children('a'),
          count;

        if (hasCounts) {
          count = anchor.find('.count').clone();
        }

        anchor.text(name.toString());

        if (hasCounts) {
          anchor.prepend(count);
        }

        if (hasTooltip) {
          anchor.data('tooltip').setContent(name.trim());
        }

        var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

        this.positionFocusState(doesTabExist);
        this.focusBar(doesTabExist);
      },

      // For tabs with counts, updates the count and resets the focusable bar/animation
      updateCount: function(e, tabId, count) {
        // Backwards compatibility with 4.2.0
        if (e && typeof e === 'string') {
          count = tabId;
          tabId = e;
        }

        if (!this.settings.tabCounts || !count) {
          return;
        }

        var tab = this.doGetTab(e, tabId);

        tab.children('a').find('.count').text(count.toString() + ' ');

        var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

        this.positionFocusState(doesTabExist);
        this.focusBar(doesTabExist);
      },

      // returns the currently active tab
      getActiveTab: function() {
        var visible = this.panels.filter(':visible');
        return this.anchors.filter('[href="#'+ visible.first().attr('id') +'"]');
      },

      getVisibleTabs: function() {
        var self = this,
          tabHash = $();

        this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)')
          .each(function tabOverflowIterator() {
            var tab = $(this);

            if (!self.isTabOverflowed(tab)) {
              tabHash = tabHash.add(tab);
            }
          });

        return tabHash;
      },

      getOverflowTabs: function() {
        var self = this,
          tabHash = $();

        this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)')
          .each(function tabOverflowIterator() {
            var tab = $(this);

            if (self.isTabOverflowed(tab)) {
              tabHash = tabHash.add(tab);
            }
          });

        return tabHash;
      },

      setOverflow: function () {
        var elem = this.element[0],
          tablist = this.tablist[0],
          HAS_MORE = 'has-more-button',
          hasMoreIndex = this.hasMoreButton(),
          isScrollableTabs = this.isScrollableTabs();

        // Recalc tab width before detection of overflow
        if (this.isModuleTabs()) {
          this.adjustModuleTabs();
        }

        var tablistStyle, tablistHeight,
          tablistContainerScrollWidth, tablistContainerWidth,
          overflowCondition;

        if (isScrollableTabs) {
          tablistContainerScrollWidth = this.tablistContainer[0].scrollWidth;
          tablistContainerWidth = this.tablistContainer[0].offsetWidth;
          overflowCondition = tablistContainerScrollWidth > tablistContainerWidth;
        } else {
          tablistStyle = window.getComputedStyle(tablist, null);
          tablistHeight = parseInt(tablistStyle.getPropertyValue('height')) + 1; // +1 to fix an IE bug
          overflowCondition = tablist.scrollHeight > tablistHeight; // Normal tabs check the height
        }

        // Add "has-more-button" class if we need it, remove it if we don't
        // Always display the more button on Scrollable Tabs
        if (overflowCondition) {
          if (!hasMoreIndex) {
            elem.classList.add(HAS_MORE);
          }
        } else if (hasMoreIndex) {
          elem.classList.remove(HAS_MORE);
        }

        this.adjustSpilloverNumber();
      },

      adjustModuleTabs: function() {
        var self = this,
          sizeableTabs = this.tablist.find('li:not(.separator):not(.application-menu-trigger):not(:hidden)'),
          appTrigger = this.tablist.find('.application-menu-trigger'),
          hasAppTrigger = appTrigger.length > 0,
          tabContainerW = this.tablist.outerWidth(),
          defaultTabSize = 120,
          visibleTabSize = 120,
          appTriggerSize = (hasAppTrigger ? appTrigger.outerWidth() : 0),
          anchorStyle,
          anchorPadding;

        // Remove overflowed tabs
        sizeableTabs.children('a').removeAttr('style');
        sizeableTabs.removeAttr('style').each(function() {
          var t = $(this);
          if (self.isTabOverflowed(t)) {
            sizeableTabs = sizeableTabs.not(t);
          }
        });

        // Resize the more button to fit the entire space if no tabs can show
        // Math: +101 is the padding of the <ul class="tab-list"> element
        if (!sizeableTabs.length) {
          visibleTabSize = (tabContainerW - appTriggerSize + 101);
          this.moreButton[0].style.width = visibleTabSize + 'px';
          return;
        } else {
          anchorStyle = window.getComputedStyle(sizeableTabs.eq(0).children()[0]);
          anchorPadding = parseInt(anchorStyle.paddingLeft) + parseInt(anchorStyle.paddingRight);

          if (this.moreButton[0].hasAttribute('style')) {
            this.moreButton[0].removeAttribute('style');
          }
        }

        // Math explanation:
        // Width of tab container - possible applcation menu trigger
        // Divided by number of visible tabs (doesn't include app menu trigger which shouldn't change size)
        // Minus one (for the left-side border of each tab)
        visibleTabSize = ((tabContainerW - appTriggerSize) / sizeableTabs.length - 1);

        if (visibleTabSize < defaultTabSize) {
          visibleTabSize = defaultTabSize;
        }

        var a,
          prevWidth,
          cutoff = 'no';

        for (var i = 0; i < sizeableTabs.length; i++) {
          a = sizeableTabs.eq(i).children('a');
          a[0].style.width = '';

          if (this.settings.moduleTabsTooltips === true) {
            cutoff = 'no';

            prevWidth = parseInt(window.getComputedStyle(sizeableTabs[i]).width);

            if (prevWidth > (visibleTabSize - anchorPadding)) {
              cutoff = 'yes';
            }
            a.data('cutoffTitle', cutoff);
          }

          sizeableTabs[i].style.width = visibleTabSize + 'px';
          a[0].style.width = visibleTabSize + 'px';
        }

        this.adjustSpilloverNumber();
      },

      adjustSpilloverNumber: function() {
         var moreDiv = this.moreButton.find('.more-text'),
          tabs = this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)'),
          overflowedTabs = this.getOverflowTabs();

        if (tabs.length <= overflowedTabs.length) {
          moreDiv.text('' + Locale.translate('Tabs'));
        } else {
          moreDiv.text('' + Locale.translate('More'));
        }

        var countDiv = this.moreButton.find('.count');
        if (!countDiv.length) {
          countDiv = $('<span class="count"></span>');
          this.moreButton.children('span').first().prepend(countDiv);
        }

        countDiv.text('' + overflowedTabs.length + ' ');

        return;
      },

      //Selects a Tab
      select: function (href) {
        var modHref = href.replace(/#/g, ''),
          anchor = this.getAnchor(modHref);

        this.positionFocusState(undefined, false);
        this.focusBar(anchor.parent());

        if (!this.activate(anchor.attr('href'))) {
          return this;
        }
        this.changeHash(modHref);

        anchor.focus();
      },

      buildPopupMenu: function(startingHref) {
        var self = this;
        if (self.popupmenu) {
          self.popupmenu.destroy();
          $('#tab-container-popupmenu').off('focus.popupmenu').remove();
          $(document).off('keydown.popupmenu');
        }

        // Build the new markup for the popupmenu if it doesn't exist.
        // Reset it if it does exist.
        var menuHtml = $('#tab-container-popupmenu'),
          shouldBeSelectable = '';
        if (this.isScrollableTabs()) {
          shouldBeSelectable = ' is-selectable';
        }

        if (menuHtml.length === 0) {
          menuHtml = $('<ul id="tab-container-popupmenu" class="tab-list-spillover'+ shouldBeSelectable +'">').appendTo('body');
        } else {
          menuHtml.html('');
        }

        // Build menu options from overflowed tabs
        var tabs = self.tablist.children('li'),
          isRTL = Locale.isRTL();

        function buildMenuItem(item) {
          var $item = $(item),
            $itemA = $item.children('a');

          if ($item.is(':hidden')) {
            return;
          }

          if (!self.isScrollableTabs() && !self.isTabOverflowed($item)) {
            return;
          }

          if ($item.is('.separator')) {
            $item.clone().appendTo(menuHtml);
            return;
          }

          var popupLi = $item.clone(),
            popupA = popupLi.children('a');

          popupLi[0].classList.remove('tab');
          if (popupLi[0].classList.contains('is-selected')) {
            popupLi[0].classList.remove('is-selected');
            if (self.isScrollableTabs()) {
              popupLi[0].classList.add('is-checked');
            }
          }

          popupLi[0].removeAttribute('style');

          popupLi.children('.icon').off().appendTo(popupA);
          popupLi.appendTo(menuHtml);

          // Link tab to its corresponding "More Tabs" menu option
          $item.data('moremenu-link', popupA);
          popupA.find('.icon-more').remove();

          // Link "More Tabs" menu option to its corresponding Tab.
          // Remove onclick methods from the popup <li> because they are called
          // on the "select" event in context of the original button
          popupA.data('original-tab', $itemA);
          popupA.onclick = undefined;

          if (!$item.is('.has-popupmenu')) {
            return;
          }

          // If this is a Dropdown Tab, clone its menu and add it to the "More Tabs" menu
          // As a submenu of the "popupLi".
          var submenu = $('#' + item.getAttribute('aria-controls')),
            clone = submenu.clone(),
            cloneLis = clone.children('li');

          clone[0].classList.remove('has-popupmenu');

          cloneLis.each(function(i) {
            var li = $(this),
              a = li.children('a'),
              originalLi = submenu.children('li').eq(i),
              originalA = originalLi.children('a');

            a.data('original-tab', originalA);
            originalA.data('moremenu-link', a);
          });

          clone.insertAfter(popupA);
        }

        // Build spillover menu options
        for (var i = 0; i < tabs.length; i++) {
          buildMenuItem(tabs[i]);
        }

        self.tablist.children('li:not(.separator)').removeClass('is-focused');
        var xOffset = 1;
        if (!this.isScrollableTabs()) {
          xOffset = 3;
        }

        // Invoke the popup menu on the button.
        self.moreButton.popupmenu({
          autoFocus: false,
          attachToBody: true,
          menu: 'tab-container-popupmenu',
          trigger: 'immediate',
          offset: { x: xOffset }
        });
        self.moreButton.addClass('popup-is-open');
        self.popupmenu = self.moreButton.data('popupmenu');

        if (self.hasSquareFocusState()) {
          self.positionFocusState(self.moreButton);
        }

        function closeMenu() {
          $(this).off('close.tabs selected.tabs');
          self.moreButton.removeClass('popup-is-open');
          self.positionFocusState(undefined);
          self.focusBar();
        }

        function selectMenuOption(e, anchor) {
          var href = anchor.attr('href'),
            id = href.substr(1, href.length),
            tab = self.doGetTab(id) || $(),
            a = tab ? tab.children('a') : $(),
            originalTab = anchor.data('original-tab').parent();

          if (originalTab.is('.add-tab-button')) {
            a = self.handleAddButton();
            originalTab = a.parent();
            href = a.attr('href');
            self.element.trigger('tab-added', [a]);
          }

          self.activate(href);

          // Fire an onclick event associated with the original tab from the spillover menu
          if (tab.length && a.length && typeof a[0].onclick === 'function') {
            a[0].onclick.apply(a[0]);
          }

          // Focus the More Button
          // NOTE: If we switch the focusing-operations back to how they used to be (blue bar moving around with the focus state)
          // remove the line below.
          self.moreButton.focus();

          self.scrollTabList(tab);
        }

        self.moreButton
          .on('close.tabs', closeMenu)
          .on('selected.tabs', selectMenuOption);

        var menu = self.popupmenu.menu;

        function handleDestroy() {
          menu.off();
          self.hideFocusState();
          $('#tab-container-popupmenu').remove();
        }

        function handleDismissibleIconClick(e) {
          var icon = $(this),
            li = icon.closest('li');

          if (!li.is('.dismissible') || !icon.is('.close')) {
            return;
          }

          e.preventDefault();
          e.stopPropagation();
          self.closeDismissibleTab(li.children('a').attr('href'));
          self.popupmenu.close();
        }

        menu
          .on('destroy.popupmenu', handleDestroy)
          .on('touchend.popupmenu touchcancel.popupmenu', '.icon', handleDismissibleIconClick)
          .on('click.popupmenu', '.icon', handleDismissibleIconClick);

        // If the optional startingIndex is provided, focus the popupmenu on the matching item.
        // Otherwise, focus the first item in the list.
        if (startingHref) {
          self.popupmenu.highlight(menu.find('a[href="' + startingHref + '"]'));
        } else if (self.tablist.children('.is-selected').length > 0) {
          self.popupmenu.highlight(menu.find('a[href="' + self.tablist.children('.is-selected').children('a').attr('href') + '"]'));
        } else {
          self.popupmenu.highlight(menu.find('li:first-child > a'));
        }

        // Overrides a similar method in the popupmenu code that controls escaping of this menu when
        // pressing certain keys.  We override this here so that the controls act in a manner as if all tabs
        // are still visible (for accessiblity reasons), meaning you can use left and right to navigate the
        // popup menu options as if they were tabs.
        $(document).bindFirst('keydown.popupmenu', function handlePopupMenuKeydown(e) {
          var key = e.which,
            currentMenuItem = $(e.target);

          function isFocusedElement() {
            return this === document.activeElement;
          }

          function prevMenuItem() {
            // If the first item in the popup menu is already focused, close the menu and focus
            // on the last visible item in the tabs list.
            var first = menu.find('li:first-child > a');
            if (first.filter(isFocusedElement).length > 0) {
              e.preventDefault();
              $(document).off(e);
              self.popupmenu.close();
              self.findLastVisibleTab();
            }
          }

          function nextMenuItem() {
            // If the last item in the popup menu is already focused, close the menu and focus
            // on the first visible item in the tabs list.
            var last = menu.find('li:last-child > a');
            if (last.filter(isFocusedElement).length > 0 && last.parent().is(':not(.submenu)')) {
              e.preventDefault();
              $(document).off(e);
              self.popupmenu.close();

              if (self.settings.addTabButton) {
                self.addTabButton.focus();
                return;
              }
              self.findFirstVisibleTab();
            }
          }

          // Alt+Del or Alt+Backspace closes a dropdown tab item
          function closeDropdownMenuItem(e) {
            if (!e.altKey || !currentMenuItem.parent().is('.dismissible')) {
              return;
            }
            //self.popupmenu.close();
            self.closeDismissibleTab(currentMenuItem.attr('href'));
            return;
          }

          var pseudoKeycode;

          switch(key) {
            case 8:
            case 46:
              closeDropdownMenuItem(e);
              break;
            case 37: // left
              pseudoKeycode = isRTL ? 40 : 38;
              if (currentMenuItem.is('a')) {
                if (currentMenuItem.parent().is(':not(:first-child)')) {
                  e.preventDefault(); // Prevent popupmenu from closing on left key
                }
                $(document).trigger({type: 'keydown.popupmenu', which: pseudoKeycode});
              }
              break;
            case 38: // up
              prevMenuItem();
              break;
            case 39: // right
              pseudoKeycode = isRTL ? 38 : 40;
              if (currentMenuItem.is('a') && !currentMenuItem.parent('.submenu').length) {
                $(document).trigger({type: 'keydown.popupmenu', which: pseudoKeycode});
              }
              break;
            case 40: // down
              nextMenuItem();
              break;
          }
        });
      },

      // Used for checking if a particular tab (in the form of a jquery-wrapped list item) is spilled into
      // the overflow area of the tablist container <UL>.
      isTabOverflowed: function(li) {
        if (this.isVerticalTabs() || this.isScrollableTabs()) {
          return false;
        }

        if (this.tablist.scrollTop() > 0) {
          this.tablist.scrollTop(0);
        }

        var liTop = Math.round(li[0].getBoundingClientRect().top),
          tablistTop = Math.round(this.tablist[0].getBoundingClientRect().top + 1);

        // +1 to compensate for top border on Module Tabs
        if (this.isModuleTabs()) {
          tablistTop = tablistTop + 1;
        }

        return liTop > tablistTop;
      },

      findLastVisibleTab: function() {
        var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)'),
          targetFocus = tabs.first();

        // if Scrollable Tabs, simply get the last tab and focus.
        if (this.isScrollableTabs()) {
          return tabs.last().find('a').focus();
        }

        while(!(this.isTabOverflowed(targetFocus))) {
          targetFocus = tabs.eq(tabs.index(targetFocus) + 1);
        }
        tabs.eq(tabs.index(targetFocus) - 1).find('a').focus();
      },

      findFirstVisibleTab: function() {
        var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
        tabs.eq(0).find('a').focus();
      },

      focusBar: function(li, callback) {
        if (!this.hasAnimatedBar()) {
          return;
        }

        if (!(li instanceof $) || !li.length) {
          return;
        }

        var self = this,
          target = li,
          scrollingTablist = this.tablistContainer,
          isRTL = Locale.isRTL(),
          paddingLeft, paddingRight, width,
          tabMoreWidth,
          tablistScrollWidth,
          tablistScrollLeft,
          anchorStyle, targetStyle;

        this.animatedBar.removeClass('no-transition');

        if (!target || target === undefined || !target.length || !self.anchors.length) {
          this.animatedBar.removeClass('visible');
          return;
        }

        targetStyle = window.getComputedStyle(target[0], null);
        paddingLeft = parseInt(targetStyle.getPropertyValue('padding-left'), 10) || 0;
        paddingRight = parseInt(targetStyle.getPropertyValue('padding-right'), 10) || 0;
        width = parseInt(targetStyle.getPropertyValue('width')) || 0;

        if (target.is('.tab')) {
          anchorStyle = window.getComputedStyle(target.children('a')[0]);
          paddingLeft += parseInt(anchorStyle.getPropertyValue('padding-left'), 10) || 0;
          paddingRight += parseInt(anchorStyle.getPropertyValue('padding-right'), 10) || 0;
        }

        var left = isRTL ?
          (paddingRight + target.position().left + target.outerWidth(true)) : (target.position().left);

        clearTimeout(self.animationTimeout);
        this.animatedBar.addClass('visible');

        function animationTimeout(cb) {
          var style = self.animatedBar[0].style;
          tablistScrollLeft = scrollingTablist[0].scrollLeft;
          tablistScrollWidth = scrollingTablist[0].scrollWidth;
          tabMoreWidth = this.moreButton.outerWidth(true);

          if (isRTL) {
            style.right = tablistScrollWidth + paddingRight - (left + tablistScrollLeft) + 'px';
          } else {
            style.left = left + tablistScrollLeft + 'px';
          }
          style.width = width + 'px';

          if (cb && typeof cb === 'function') {
            cb();
          }
        }
        this.animationTimeout = setTimeout(animationTimeout.apply(this, [callback]), 0);
      },

      defocusBar: function() {
        if (!this.hasAnimatedBar()) {
          return;
        }

        var self = this,
          left = Locale.isRTL() ? 0 : (self.animatedBar.position().left+(self.animatedBar.outerWidth()/2));

        clearTimeout(self.animationTimeout);

        this.animatedBar[0].style.left = left + 'px';
        this.animatedBar[0].style.width = 0;

        this.animationTimeout = setTimeout(function() {
          if (self.animatedBar && self.animatedBar.length) {
            self.animatedBar.removeClass('visible').removeAttr('style');
          }
        }, 350);
      },

      /**
       * Wrapper for the Soho behavior _smoothScrollTo()_ that will determine scroll distance.
       * @param {jQuery[]} target - the target <li> or <a> tag
       * @param {Number} duration - the time it will take to scroll
       * @returns {undefined}
       */
      scrollTabList: function(target) {
        if (!this.tablistContainer || !target || !(target instanceof $) || !target.length) {
          return;
        }

        var tabCoords = Soho.DOM.getDimensions(target[0]),
          tabContainerDims = Soho.DOM.getDimensions(this.tablistContainer[0]),
          d;

        var FADED_AREA = 40, // the faded edges on the sides of the tabset
          adjustedLeft = tabCoords.left,
          adjustedRight = tabCoords.right;

        if (adjustedLeft < tabContainerDims.left + FADED_AREA) {
          d = (Math.round(Math.abs(tabContainerDims.left - adjustedLeft)) * -1) - FADED_AREA;
        }
        if (adjustedRight > tabContainerDims.right - FADED_AREA) {
          d = Math.round(Math.abs(adjustedRight - tabContainerDims.right)) + FADED_AREA;
        }

        if (d === 0) {
          d = undefined;
        }

        // Scroll the tablist container
        this.tablistContainer.smoothScroll(d, 250);
      },

      hideFocusState: function() {
        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
        }
      },

      positionFocusState: function(target, unhide) {
        if (!this.hasSquareFocusState()) {
          return;
        }

        var self = this;
        target = target !== undefined ? $(target) :
            self.moreButton.hasClass('is-selected') ? self.moreButton :
            self.tablist.children('.is-selected').length > 0 ? self.tablist.children('.is-selected').children('a') : undefined;

        if (!target || target === undefined || !target.length || (target.is(this.moreButton) && this.isScrollableTabs())) {
          this.focusState.removeClass('is-visible');
          return;
        }

        // Use the parent <li> for anchors to get their dimensions.
        if (target.is('a')) {
          target = target.parent();
        }

        // Move the focus state from inside the tab list container, if applicable.
        // Put it back into the tab list container, if not.
        if (target.is('.add-tab-button, .tab-more')) {
          if (!this.focusState.parent().is(this.element)) {
            this.focusState.prependTo(this.element);
          }
        } else {
          if (!this.focusState.parent().is(this.tablistContainer)) {
            this.focusState.prependTo(this.tablistContainer);
          }
        }

        var focusStateElem = this.focusState[0],
          targetPos = Soho.DOM.getDimensions(target[0]),
          targetClassList = target[0].classList,
          isNotHeaderTabs = (!this.isHeaderTabs() || this.isHeaderTabs() && this.element[0].classList.contains('alternate')),
          isVerticalTabs = this.isVerticalTabs(),
          isRTL = Locale.isRTL(),
          tabMoreWidth = !isVerticalTabs ? this.moreButton.outerWidth(true) : 0,
          parentContainer = this.element,
          scrollingTablist = this.tablistContainer,
          accountForPadding = scrollingTablist && this.focusState.parent().is(scrollingTablist);

        function adjustForParentContainer(targetRectObj, parentElement, tablistContainer) {
          var parentRect = parentElement[0].getBoundingClientRect(),
            parentPadding,
            tabLeftMargin,
            tablistScrollWidth,
            tablistScrollLeft;

          // Adjust from the top
          targetRectObj.top = targetRectObj.top - parentRect.top;
          if (isVerticalTabs) {
            targetRectObj.top = targetRectObj.top + parentElement[0].scrollTop;
          }

          if (isRTL) {
            targetRectObj.right = parentRect.right - targetRectObj.right;
          } else {
            targetRectObj.left = targetRectObj.left - parentRect.left;
          }

          // If inside a scrollable tablist, account for the scroll position
          if (tablistContainer) {
            tablistScrollLeft = tablistContainer ? tablistContainer[0].scrollLeft : 0;
            tablistScrollWidth = tablistContainer ? tablistContainer[0].scrollWidth : 0;

            if (isRTL && !isVerticalTabs) {
              // TODO: Improve this calculation because there's something off
              var tmpLeft = targetRectObj.left;
              if (isNotHeaderTabs) {
                tabLeftMargin = parseInt(window.getComputedStyle(target[0]).marginLeft);
                targetRectObj.left = tablistScrollWidth - tabLeftMargin - targetRectObj.right + tablistScrollLeft;
                targetRectObj.right = tablistScrollWidth - tabLeftMargin - tmpLeft + tablistScrollLeft;
              } else {
                targetRectObj.left = tablistScrollWidth - (targetRectObj.right + tablistScrollLeft + (tabMoreWidth) + 32);
                targetRectObj.right = tablistScrollWidth - (tmpLeft + tablistScrollLeft + (tabMoreWidth) + 32);
              }
            } else {
              targetRectObj.left = targetRectObj.left + tablistScrollLeft;
              targetRectObj.right = targetRectObj.right + tablistScrollLeft;
            }

            if (accountForPadding) {
              parentPadding = parseInt(window.getComputedStyle(parentElement[0])[ 'padding' + (isRTL ? 'Right' : 'Left') ]);
              targetRectObj.left = targetRectObj.left + (isRTL ? parentPadding : (parentPadding * -1));
              targetRectObj.right = targetRectObj.right + (isRTL ? parentPadding : (parentPadding * -1));
            }
          }

          // Alternate Header Tabs have 1px removed from bottom to prevent overlap onto the bottom border
          if (isNotHeaderTabs && !isVerticalTabs) {
            targetRectObj.height = targetRectObj.height - 1;
          }

          return targetRectObj;
        }

        // Adjust the values one more time if we have tabs contained inside of a page-container, or some other scrollable container.
        targetPos = adjustForParentContainer(targetPos, parentContainer, scrollingTablist);

        // build CSS string containing each prop and set it:
        var targetPosString = '';
        for (var property in targetPos) {
          if (targetPos.hasOwnProperty(property)) {
            if (targetPosString.length) {
              targetPosString += ' ';
            }
            targetPosString += '' + property + ': ' + targetPos[property] + 'px;';
          }
        }
        focusStateElem.setAttribute('style', targetPosString);

        var selected = targetClassList.contains('is-selected') ? 'add' : 'remove';
        focusStateElem.classList[selected]('is-selected');

        var doHide = unhide === true ? 'add' : 'remove';
        focusStateElem.classList[doHide]('is-visible');
      },

      checkFocusedElements: function() {
        var self = this,
          focusableItems = self.tablist;

        if (this.hasSquareFocusState() && focusableItems.find('.is-focused').length === 0 && !self.moreButton.hasClass('is-focused') && !self.moreButton.hasClass('popup-is-open')) {
          self.focusState.removeClass('is-visible');
        }

        if (this.hasAnimatedBar() && focusableItems.find('.is-selected').length === 0 && !self.moreButton.hasClass('is-selected')) {
          self.defocusBar();
        }
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Disables all tabs in the
      disableOtherTabs: function() {
        return this.disable(true);
      },

      disable: function(isPartial) {
        if (!isPartial) {
          this.element.prop('disabled', true).addClass('is-disabled');
        }

        if (!this.disabledElems) {
          this.disabledElems = [];
        }

        var self = this,
          tabs = this.tablist.children('li:not(.separator)');
          if (isPartial) {
            tabs = tabs.filter(':not(.application-menu-trigger)');
          }


        tabs.each(function() {
          var li = $(this);
          var a = li.children('a');

          if (isPartial && self.isActive(a.attr('href'))) {
            return;
          }

          if (li.is('.is-disabled') || a.prop('disabled') === true) {
            self.disabledElems.push({
              elem: li,
              originalTabindex: li.attr('tabindex'),
              originalDisabled: a.prop('disabled')
            });
          }

          li.addClass('is-disabled');
          a.prop('disabled', true);

          if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
            return;
          }

          var panel = $(a.attr('href'));
          panel.addClass('is-disabled');
          panel.find('*').each(function() {
            var t = $(this);

            // These are shadow inputs.  They are already handled by virtue of running .disable() on the original select tag.
            if (t.is('input.dropdown, input.multiselect')) {
              return;
            }

            if (t.attr('tabindex') === '-1' || t.attr('disabled')) {
              self.disabledElems.push({
                elem: t,
                originalTabindex: t.attr('tabindex'),
                originalDisabled: t.prop('disabled')
              });
            }

            t.disable();
          });
        });

        this.moreButton.addClass('is-disabled');

        if (this.isModuleTabs() && !isPartial) {
          this.element.children('.toolbar').disable();
        }

        this.updateAria($());
      },

      enable: function() {
        this.element.prop('disabled', false).removeClass('is-disabled');

        var self = this,
          tabs = this.tablist.children('li:not(.separator)');

        tabs.each(function() {
          var li = $(this);
          var a = li.children('a');

          li.removeClass('is-disabled');
          a.prop('disabled', false);

          if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
            return;
          }

          var panel = $(a.attr('href'));
          panel.removeClass('is-disabled');
          panel.find('*').each(function() {
            var t = $(this);
            if (t.enable && typeof t.enable === 'function') {
              t.enable();
            }
          });

          $.each(self.disabledElems, function(i, obj) {
            var attrTarget = obj.elem.is('.tab') ? obj.elem.children('a') : obj.elem;
            if (obj.elem.disable && typeof obj.elem.disable === 'function') {
              obj.elem.disable();
            }

            if (obj.elem.is('li')) {
              obj.elem.addClass('is-disabled');
              return;
            }

            // These are shadow inputs.  They are already handled by virtue of running .disable() on the original select tag.
            if (obj.elem.is('input.dropdown, input.multiselect')) {
              return;
            }

            obj.elem.attr('tabindex', obj.originalTabindex);
            attrTarget.prop('disabled', obj.originalDisabled);
          });
        });

        this.moreButton.removeClass('is-disabled');

        if (this.isModuleTabs()) {
          this.element.children('.toolbar').enable();
        }

        this.disabledElems = [];

        this.updateAria(this.tablist.find('.is-selected > a'));
      },

      closeDismissibleTab: function(tabId) {
        return this.remove(tabId);
      },

      teardown: function() {
        this.panels.removeAttr('style');

        this.tablist
          .off()
          .removeAttr('role')
          .removeAttr('aria-multiselectable');

        var tabs = this.tablist.children('li');
        tabs
          .off()
          .removeAttr('role')
          .removeClass('is-selected');

        var dds = tabs.filter('.has-popupmenu');
        dds.each(function() {
          var popup = $(this).data('popupmenu');
          if (popup) {
            popup.menu.children('li:not(.separator)').each(function() {
              var li = $(this),
                a = li.children('a'),
                panel = a.data('panel-link');

              $.removeData(a[0], 'panel-link');
              if (panel && panel.length) {
                $.removeData(panel[0], 'tab-link');
              }
            });
            popup.destroy();
          }
        });

        this.panels
          .off();

        this.anchors
          .off()
          .removeAttr('role')
          .removeAttr('aria-expanded')
          .removeAttr('aria-selected')
          .removeAttr('tabindex');

        if (this.settings.moduleTabsTooltips) {
          this.anchors.each(function() {
            var api = $(this).data('tooltip');
            if (api && typeof api.destroy === 'function') {
              api.destroy();
            }
          });
        }

        this.element.off('focusout.tabs updated.tabs activated.tabs');
        $('body').off('resize.tabs' + this.tabsIndex);
        this.tabsIndex = undefined;

        if (this.moreButton.data('popupmenu')) {
          var popup = this.moreButton.data('popupmenu');
          popup.menu.find('li:not(.separator)').each(function() {
            var li = $(this),
              a = li.children('a');

            if (a.data('original-tab')) {
              $.removeData(a[0], 'original-tab');
            }
          });
          popup.destroy();
        }

        this.removeHelperMarkupEvents();

        if (this.tablistContainer) {
          this.tablistContainer.off('mousewheel.tabs');
        }

        if (this.hasSquareFocusState()) {
          this.focusState.remove();
          this.focusState = undefined;
        }

        if (this.hasAnimatedBar()) {
          this.animatedBar.remove();
          this.animatedBar = undefined;
        }

        return this;
      },

      destroy: function(){
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Tabs(this, settings));
      }
    });
  };

  // Deprecated the old Vertical Tabs code in favor of using the Tabs class.
  $.fn.verticaltabs = $.fn.tabs;


  $.fn.tag = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'tag',
        defaults = {
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tag(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Tag Methods
    Tag.prototype = {

      /**
       * @private
       */
      init: function() {
        this.element.hideFocus();
        this.handleEvents();
      },

      /**
       * Remove the tag from the DOM
       */
      remove: function(event, el) {
        el = el instanceof jQuery ? el : $(el);
        var parent = el.parent();
        this.element.triggerHandler('beforetagremove', {event: event, element: el});
        el.remove();
        parent.triggerHandler('aftertagremove', {event: event});
      },

      /**
       * Destroy this component instance and remove the link from its base element.
       */
      destroy: function() {
        this.element.off('keydown.tag');
        $('.dismissable-btn, .dismissible-btn', this.element).off('click.tag').remove();

        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Tag#events
       * @param {Object} click  &nbsp;-&nbsp; Fires when the tag is clicked (if enabled).
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when the tag is focused.
       */
      handleEvents: function() {
        var self = this,
          btnDismissable = $(
            '<span class="dismissible-btn">' +
              $.createIcon('close') +
              '<span class="audible"> '+ Locale.translate('Close') +'</span>' +
            '</span>'),
          dismissibleClass = '.is-dismissable, .is-dismissible';

        // EPC: Deprecating "dismissable" in favor of "dismissible" as of 4.3.0
        if (self.element.is(dismissibleClass)) {
          self.element.append(btnDismissable);

          // Handle Click
          btnDismissable.on('click.tag', function(event) {
            self.remove(event, self.element);
          });

          // Handle Keyboard
          self.element.on('keydown.tag', function(event) {
            var e = event || window.event;
            if (e.keyCode === 8) { // Backspace
              self.remove(event, this);
            }
          });
        }
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Tag(this, settings));
      }
    });
  };


  $.fn.textarea = function(options) {

    // Settings and Options
    var pluginName = 'textarea',
        defaults = {
		  autoGrow: false,
		  autoGrowAnimate: true,
		  autoGrowAnimateSpeed: 200,
          characterCounter: true,
          printable: true,
          charRemainingText: null,
          charMaxText: null

        },
        settings = $.extend({}, defaults, options);

    /**
    * The Textarea Component wraps a standard HTML Textarea element and provides additional features.
    *
    * @class Textarea
    * @param {boolean} autoGrow &nbsp;-&nbsp; Will automatically expand the text area to fit the contents.
    * @param {boolean} autoGrowAnimate &nbsp;-&nbsp; Will animate the text area growing.
    * @param {integer} autoGrowAnimateSpeed &nbsp;-&nbsp; The speed of the animation.
    * @param {boolean} characterCounter &nbsp;-&nbsp; Displays a counter that counts down from the maximum length allowed.
    * @param {boolean} printable &nbsp;-&nbsp; Determines whether or not the text area can be displayed on a printed page.
    * @param {null|String} charRemainingText  &nbsp;-&nbsp; Text that will be used in place of the "remaining" text.
    * @param {null|String} charMaxText  &nbsp;-&nbsp; Text that will be used in place of the "Max" text.
    */
    function Textarea(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Textarea.prototype = {

      /**
       * @private
       */
      init: function() {
        this.isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        this.isSafari = (
          navigator.userAgent.indexOf('Safari')  !== -1 &&
          navigator.userAgent.indexOf('Chrome') === -1 &&
          navigator.userAgent.indexOf('Android') === -1
        );

        this.element.addClass(this.element.is('.textarea-xs') ? 'input-xs' :
            this.element.is('.textarea-sm') ? 'input-sm' :
            this.element.is('.textarea-lg') ? 'input-lg' : '');

        if (this.settings.characterCounter && this.element.attr('maxlength')) {
          this.counter = $('<span class="textarea-wordcount">Chars Left..</span>').insertAfter(this.element);
        }
        if (this.settings.printable) {
          this.printarea = $('<span class="textarea-print"></span>').insertBefore(this.element);
        }

        if (this.element.hasClass('autogrow')) {
          this.settings.autoGrow = true;
        }

        if (this.settings.autoGrow && this.element.length) {
          this.element.css('overflow','hidden');
          this.handleResize(this);
        }

        this.handleEvents();
        this.updateCounter(this);
      },

      /**
       * @private
       */
      // TODO: What does this do?
      isSelected: function (input) {
        if (typeof input.selectionStart === 'number') {
          return input.selectionStart === 0 && input.selectionEnd === input.value.length;
        } else if (typeof document.selection !== 'undefined') {
          return document.selection.createRange().text === input.value;
        }
      },

      /**
       * Checks a keycode value and determines if it belongs to a printable character.
       * @param {Number} keycode - a number representing an ASCII keycode value
       * @returns {boolean}
       */
      isPrintable: function(keycode) {
        var valid =
          (keycode > 47 && keycode < 58)   || // number keys
          (keycode > 64 && keycode < 91)   || // letter keys
          (keycode > 95 && keycode < 112)  || // numpad keys
          (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
          (keycode > 218 && keycode < 223);   // [\]' (in order)
        return valid;
      },

      /**
      * resizes the texarea based on the content.
      * @private
      * @param {TextArea} self
      * @param {event} e
      */
      handleResize: function (self, e) {
        var value = self.element.val(),
          oldHeight = self.element.innerHeight(),
          newHeight = self.element.get(0).scrollHeight,
          minHeight = self.element.data('autogrow-start-height') || 0,
          clone;

        if (oldHeight < newHeight) {
          self.scrollTop = 0;

          if (self.settings.autoGrowAnimate) {
            self.element.stop().animate({height: newHeight}, self.settings.autoGrowAnimateSpeed);
    		  } else {
            self.element.innerHeight(newHeight);
    		  }
        } else if (!e || e.which === 8 || e.which === 46 || (e.ctrlKey && e.which === 88)) {

          if (oldHeight > minHeight) {
            clone = self.element.clone()
            .addClass('clone')
            .css({position: 'absolute', zIndex:-10, height: ''})
            .val(value);

            self.element.after(clone);
            do {
              newHeight = clone[0].scrollHeight - 1;
              clone.innerHeight(newHeight);
            } while (newHeight === clone[0].scrollHeight);

            newHeight++;
            clone.remove();

            if (newHeight < minHeight) {
              newHeight = minHeight;
    		    }

            if (oldHeight > newHeight && self.settings.autoGrowAnimate) {
              self.element.stop().animate({height: newHeight}, self.settings.autoGrowAnimateSpeed);
            } else {
              self.element.innerHeight(newHeight);
            }
          } else {
            self.element.innerHeight(minHeight);
          }
        }
      },

      /**
       * Counts the number of line breaks in a string
       * @param {String} s
       * @returns {Number}
       */
      countLinebreaks: function(s) {
        return (s.match(/\n/g) || []).length;
      },

      /**
       * Updates the descriptive markup (counter, etc) to notify the user how many characters can be typed.
       * @private
       * @param {TextArea} self
       */
      updateCounter: function (self) {
        var value = self.element.val(),
          isExtraLinebreaks = this.isChrome || this.isSafari,
          length = value.length + (isExtraLinebreaks ? this.countLinebreaks(value) : 0),
          max = parseInt(self.element.attr('maxlength')),
          remaining = (parseInt(max)-length),
          text = (self.settings.charRemainingText ? self.settings.charRemainingText : (Locale.translate('CharactersLeft') === 'CharactersLeft' ? 'Characters Left' : Locale.translate('CharactersLeft'))).replace('{0}', remaining.toString());

        if (self.counter) {
          if (length === max) {
            text = (self.settings.charMaxText ? self.settings.charMaxText.replace('{0}', max) : Locale.translate('CharactersMax')+ max) ;
            self.counter.text(text);
            self.counter.removeClass('almost-empty');
          } else {
            self.counter.text(text);
            if (remaining < 10) {
              self.counter.addClass('almost-empty');
            } else {
              self.counter.removeClass('almost-empty');
            }
          }
        }

        if (self.printarea) {
          self.printarea.text(self.element.val());
        }
      },

      /**
       * Enables this component instance.
       */
      enable: function () {
        this.element.prop('disabled', false).prop('readonly', false);
      },

      /**
       * Disables this component instance.
       */
      disable: function () {
        this.element.prop('disabled', true);
      },

      /**
      * Returns true if the texarea is disabled.
      */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Sets this component instance to "readonly"
       */
      readonly: function () {
        this.element.prop('readonly', true);
      },

      /**
       * Call whenever the plugin's settings are changed
       */
      updated: function () {
        this.destroy();
        this.init();
      },

      /**
       * Destroys this component instance and unlinks it from its element.
       */
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        if (this.printarea && this.printarea.length) {
          this.printarea.remove();
        }
        if (this.counter && this.counter.length) {
          this.counter.remove();
        }
        this.element.off('keyup.textarea, focus.textarea, updated.dropdown, keypress.textarea, blur.textarea');
      },

      /**
       *  This component fires the following events.
       *
       * @fires Textarea#events
       * @param {Object} keyup  &nbsp;-&nbsp; Fires when the button is clicked (if enabled).
       * @param {Object} focus  &nbsp;-&nbsp; Fires when the menu is focused.
       * @param {Object} keypress  &nbsp;-&nbsp;
       * @param {Object} blur  &nbsp;-&nbsp;
       */
      handleEvents: function() {
        var self = this;

        this.element.on('keyup.textarea', function (e) {
          self.updateCounter(self);

    		  if (self.settings.autoGrow) {
    		    self.handleResize(self, e);
    		  }
        }).on('focus.textarea', function () {
          if (self.counter) {
            self.counter.addClass('focus');
          }
        }).on('updated.dropdown', function () {
          self.updated();
        }).on('keypress.textarea', function (e) {
          var length = self.element.val().length,
          max = self.element.attr('maxlength');

          if ([97, 99, 118, 120].indexOf(e.which) > -1 && (e.metaKey || e.ctrlKey)) {
            self.updateCounter(self);
            return;
          }

          if (!self.isPrintable(e.which)) {
            return;
          }

          if (length >= max && !self.isSelected(this)) {
            e.preventDefault();
          }
        })
        .on('blur.textarea', function () {
          self.updateCounter(self);
          if (self.counter) {
            self.counter.removeClass('focus');
          }
        });
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Textarea(this, settings));
      }
    });
  };


  $.fn.timepicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'timepicker',
        defaults = {
          timeFormat: Locale.calendar().timeFormat || 'h:mm a', // The time format
          minuteInterval: 5,
          secondInterval: 5,
          mode: 'standard',
          roundToInterval: true,
          parentElement: null,
          returnFocus: true
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Timepicker Component provides a click/touch user interface for setting a time.
    *
    * @class TimePicker
    * @param {String} timeFormat &nbsp;-&nbsp; The time format
    * @param {Number} minuteInterval  &nbsp;-&nbsp; Integer from 1 to 60.  Multiples of this value are displayed as options in the minutes dropdown.
    * @param {Number} secondInterval  &nbsp;-&nbsp; Integer from 1 to 60.
    * @param {String} mode  &nbsp;-&nbsp; can be set to 'standard', 'range',
    * @param {boolean} roundToInterval  &nbsp;-&nbsp; if `false`, does not automatically round user-entered values from the pickers to their nearest interval.
    * @param {null|jQuery[]} [parentElement] &nbsp;-&nbsp;  if defined as a jQuery-wrapped element, will be used as the target element.
    * @param {String} returnFocus  &nbsp;-&nbsp; If set to false, focus will not be returned to the calling element. It usually should be for accessibility purposes.
    */
    function TimePicker(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    TimePicker.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        this
          .setup()
          .build()
          .handleEvents()
          .roundMinutes();
      },

      /**
       * Configure any settings for the Timepicker
       * @private
       * @returns {this}
       */
      setup: function() {

        function sanitizeIntervals(value, type) {
          if (!type || ['minute', 'second'].indexOf(type) < 0) {
            type = 'minute';
          }

          var defaultInterval = defaults[(type + 'Interval')];
          if (value === undefined || isNaN(value)) {
            return defaultInterval;
          }
          var intValue = parseInt(value, 10);
          return intValue > 0 && intValue < 60 ? intValue : defaultInterval;
        }

        function sanitizeTimeFormat(value) {
          if (!value || (!value.match('h') && !value.match('HH')) || !value.match('mm')) {
            return defaults.timeFormat;
          }

          return value;
        }

        function sanitizeRoundToInterval(value) {
          return value === true;
        }

        function sanitizeMode(value) {
          var modes = ['standard', 'range'];
          return $.inArray(value, modes) > -1 ? value : defaults.mode;
        }

        if (this.element.is('[data-round-to-interval]')) {
          this.settings.roundToInterval = sanitizeRoundToInterval(this.element.attr('data-round-to-interval'));
        }
        if (this.element.is('[data-minute-interval]')) {
          this.settings.minuteInterval = sanitizeIntervals(this.element.attr('data-minute-interval'), 'minute');
        }

        this.settings.timeFormat = sanitizeTimeFormat(parseInt(this.element.attr('data-force-hour-mode')) === 24 ? 'HH:mm' : this.settings.timeFormat);
        this.settings.minuteInterval = sanitizeIntervals(this.settings.minuteInterval, 'minute');
        this.settings.secondInterval = sanitizeIntervals(this.settings.secondInterval, 'second');
        this.settings.mode = sanitizeMode(this.settings.mode);
        this.settings.roundToInterval = sanitizeRoundToInterval(this.settings.roundToInterval);

        this.dayPeriods = Locale.calendar().dayPeriods;

        return this;
      },

      /**
       * Add any markup
       * @private
       * @returns {this}
       */
      build: function() {
        //With this option forgoe the input and append the dropdowns/popup to the parent element
        if (this.settings.parentElement) {
          this.trigger = $();
          this.buildStandardPopup();
          this.setupStandardEvents();
          return this;
        }

        //Append a Button
        this.trigger = this.element.next('svg.icon');
        if (this.trigger.length === 0) {
          this.trigger = $.createIconElement('clock').insertAfter(this.element);
        }

        this.addAria();

        // Add Mask and Validation plugins for time
        this.addMask();

        return this;
      },

      /**
       * Adds ARIA-related attributes
       * @private
       * @returns {this}
       */
      addAria: function () {
        this.element.attr({
          'aria-expanded': 'false',
          'role': 'combobox'
        });

        //TODO: Confirm this with Accessibility Team
        this.label = $('label[for="'+ this.element.attr('id') + '"]');
        this.label.append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
      },

      /**
       * Sets up a `keydown` event listener.
       */
      handleKeys: function() {
        var self = this;

        this.element.on('keydown.timepicker', function (e) {
          var handled = false;

          // Esc closes an open popup with no action
          if (e.which === 27 && self.isOpen()) {
            handled = true;
            self.closeTimePopup();
          }

          //Arrow Down or Alt first opens the dialog
          if (e.which === 40 && !self.isOpen()) {
            handled = true;
            self.openTimePopup();
          }

          if (handled) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
        });
      },

      /**
       * Sets up a `blur` event listener.
       */
      handleBlur: function() {
        var self = this;

        this.element.on('blur.timepicker', function() {
          self.roundMinutes();

          // The action of closing the popup menu is set on a timer because technically there are no fields focused
          // on frame 0 of the popup menu's existence, which would cause it to close immediately on open.
          setTimeout(function() {
            if (self.isOpen() && self.popup.find(':focus').length === 0) {
              self.closeTimePopup();
            }
          }, 20);
        });
      },

      /**
       * Checks a time format value to see if it is a Military (24-hour) format.
       * @param {String} value - a string value representing a time format.
       * @returns {boolean}
       */
      is24HourFormat: function(value) {
        if (!value) { value = this.settings.timeFormat; }
        return (value.match('HH') || []).length > 0;
      },

      /**
       * Checks a time format value to see if it includes seconds.
       * @param {String} value - a string value representing a time format.
       * @returns {boolean}
       */
      hasSeconds: function(value) {
        if (!value) { value = this.settings.timeFormat; }
        return (value.match('ss') || []).length > 0;
      },

      /**
       * Gets a Locale-defined version of the time separator.
       * @returns {String}
       */
      getTimeSeparator: function() {
        return Locale.calendar().dateFormat.timeSeparator;
      },

      /**
       * Rounds the current value of the minutes picker to its nearest interval value.
       */
      roundMinutes: function() {
        if (!this.getBoolean(this.settings.roundToInterval)) {
          return;
        }

        // separate out the minutes value from the rest of the value.
        var val = this.element.val(),
          timeSeparator = this.getTimeSeparator(),
          parts = val ? val.split(timeSeparator) : [],
          interval = this.settings.minuteInterval;

        if (!parts[1]) {
          return;
        }

        if (!this.is24HourFormat(this.settings.timeFormat)) {
          var periodParts = parts[1].split(' ');
          parts[1] = periodParts[0];
          if (periodParts[1]) {
            parts.push(periodParts[1]);
          }
        }

        parts[1] = parseInt(parts[1], 10);
        if (parts[1] % interval === 0) {
          return;
        }

        parts[1] = Math.round(parts[1] / interval) * interval;

        parts[1] = parts[1].toString();
        parts[1] = (parts[1].length < 2 ? '0' : '') + parts[1];

        if (parts[1] === '60') {
          parts[1] = '00';
          parts[0] = (parseInt(parts[0]) + 1).toString();
        }

        var newVal = parts[0] + timeSeparator + parts[1] + ' ' + (parts[2] ? parts[2] : '');
        this.element.val(newVal);
      },

      // Add masking with the mask function
      addMask: function () {
        if (this.element.data('mask') && typeof this.element.data('mask') === 'object') {
          this.element.data('mask').destroy();
        }
        this.element.data('mask', undefined);

        var maskOptions = {
          keepCharacterPositions: true,
          process: 'date',
          patternOptions: {
            format: this.settings.timeFormat
          }
        };

        var validation = 'time',
          events = {'time': 'blur'},
          customValidation = this.element.attr('data-validate'),
          customEvents = this.element.attr('data-validation-events');

        if (customValidation === 'required' && !customEvents) {
            validation = customValidation + ' ' + validation;
            $.extend(events, {
                'required': 'change blur'
            });
        } else if (!!customValidation && !!customEvents) {
            // Remove default validation, if found "no-default-validation" string in "data-validate" attribute
            if (customValidation.indexOf('no-default-validation') > -1) {
                validation = customValidation.replace(/no-default-validation/g, '');
                events = $.fn.parseOptions(this.element, 'data-validation-events');
            }
            // Keep default validation along custom validation
            else {
                validation = customValidation + ' ' + validation;
                $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
            }
        }

        this.element
          .attr('data-validate', validation)
          .attr('data-validation-events', JSON.stringify(events))
          .mask(maskOptions)
          .validate()
          .triggerHandler('updated');
      },

      /**
       * Constructs all markup and subcomponents needed to build the standard Timepicker popup.
       * @private
       */
      buildStandardPopup: function() {
        var self = this,
          popupContent = $('<div class="timepicker-popup-content"></div>'),
          timeSeparator = this.getTimeSeparator(),
          textValue = '',
          selected;

        this.initValues = self.getTimeFromField();
        var timeParts = $('<div class="time-parts"></div>').appendTo(popupContent);

        // Build the inner-picker HTML
        var is24HourFormat = this.is24HourFormat(),
          hasSeconds = this.hasSeconds(),
          hourCounter = is24HourFormat ? 0 : 1,
          maxHourCount = is24HourFormat ? 24 : 13;

        this.hourSelect = $('<select id="timepicker-hours" data-options="{\'noSearch\': \'true\'}" class="hours dropdown"></select>');

        while(hourCounter < maxHourCount) {
          selected = '';
          if (parseInt(self.initValues.hours, 10)  === hourCounter) {
            selected = ' selected';
          }
          self.hourSelect.append($('<option' + selected + '>' + hourCounter + '</option>'));
          hourCounter++;
        }
        timeParts.append($('<label for="timepicker-hours" class="audible">' + Locale.translate('Hours') + '</label>'));
        timeParts.append(this.hourSelect);
        timeParts.append($('<span class="label colons">'+ timeSeparator +'</span>'));

        // Minutes Picker
        var minuteCounter = 0;
        this.minuteSelect = $('<select id="timepicker-minutes" data-options="{\'noSearch\': \'true\'}" class="minutes dropdown"></select>');

        while(minuteCounter <= 59) {
          textValue = minuteCounter < 10 ? '0' + minuteCounter : minuteCounter;

          selected = '';
          if (parseInt(self.initValues.minutes, 10) === minuteCounter) {
            selected = ' selected';
          }
          self.minuteSelect.append($('<option' + selected + '>' + textValue + '</option>'));
          minuteCounter = minuteCounter + self.settings.minuteInterval;
        }

        // If the value inside the picker doesn't match an interval, add the value as the currently selected option, right at the top
        if (!this.minuteSelect.find('option[selected]').length) {
          this.minuteSelect.prepend($('<option selected>' + self.initValues.minutes + '</option>'));
        }

        timeParts.append($('<label for="timepicker-minutes" class="audible">' + Locale.translate('Minutes') + '</label>'));
        timeParts.append(this.minuteSelect);

        // Seconds Picker
        if (hasSeconds) {
          var secondCounter = 0;
          this.secondSelect = $('<select id="timepicker-seconds" data-options="{\'noSearch\': \'true\'}" class="seconds dropdown"></select>');

          while(secondCounter <= 59) {
            textValue = secondCounter < 10 ? '0' + secondCounter : secondCounter;

            selected = '';
            if (parseInt(self.initValues.seconds, 10) === secondCounter || (!self.initValues.seconds && textValue === '00')) {
              selected = ' selected';
            }
            this.secondSelect.append($('<option' + selected + '>' + textValue + '</option>'));
            secondCounter = secondCounter + self.settings.secondInterval;
          }

          // If the value inside the picker doesn't match an interval, add the value as the currently selected option, right at the top
          if (!this.secondSelect.find('option[selected]').length) {
            this.secondSelect.prepend($('<option selected>' + self.initValues.seconds + '</option>'));
          }

          timeParts.append($('<span class="label colons">'+ timeSeparator +'</span>'));
          timeParts.append($('<label for="timepicker-seconds" class="audible">' + Locale.translate('Seconds') + '</label>'));
          timeParts.append(this.secondSelect);
        }

        this.periodSelect = $('<select id="timepicker-period" class="period dropdown"></select>');
        if (!is24HourFormat) {
          timeParts.append($('<span class="label colons"></span>'));
          var localeDays = Locale.calendar().dayPeriods,
            localeCount = 0,
            regexDay = new RegExp(self.initValues.period, 'i'),
            realDayValue = 'AM'; // AM

          while(localeCount < 2) {
            realDayValue = localeCount === 0 ? 'AM' : 'PM';  // ? AM : PM
            selected = '';
            if (regexDay.test(localeDays[localeCount])) {
              selected = ' selected';
            }
            this.periodSelect.append($('<option value="' + realDayValue + '"'+ selected +'>' + localeDays[localeCount] + '</option>'));

            localeCount++;
          }
          timeParts.append($('<label for="timepicker-period" class="audible">' + Locale.translate('TimePeriod') + '</label>'));
          timeParts.append(this.periodSelect);
        }

        if (this.settings.parentElement) {
          this.settings.parentElement.append(popupContent);
          //self.afterShow(this.settings.parentElement);
          self.popup = this.settings.parentElement.find('.timepicker-popup-content').addClass('timepicker-popup').attr('id', 'timepicker-popup');
        } else {

          popupContent.append('<div class="modal-buttonset"><button type="button" class="btn-modal-primary set-time">' + Locale.translate('SetTime') + '</button></div>');

          var placementParent = this.element,
            placementParentXAlignment = (Locale.isRTL() ? 'right' : 'left'),
            parent = this.element.parent();

          if (parent.is('.datagrid-cell-wrapper')) {
            placementParentXAlignment = 'center';
            placementParent = this.element.next('.icon');
          }

          this.trigger.popover({
            content: popupContent,
            trigger: 'immediate',
            placement: 'bottom',
            placementOpts: {
              parent: placementParent,
              parentXAlignment: placementParentXAlignment,
              strategies: ['flip', 'nudge', 'shrink']
            },
            tooltipElement: '#timepicker-popup'})
          .on('show.timepicker', function(e, ui) {
            self.afterShow(ui);
          }).on('hide.timepicker', function() {
            if (self.settings.returnFocus) {
              self.element.focus();
            }
          });

        }

        // Make adjustments to the popup HTML specific to the timepicker
        if (this.trigger.data('tooltip')) {
          var tooltip = self.popup = this.trigger.data('tooltip').tooltip;
          tooltip.addClass('timepicker-popup');
        }
      },

      afterShow: function (ui) {
        var self = this;

        ui.find('button').button();

        // Set default values based on what's retrieved from the Timepicker's input field.
        this.hourSelect.val(this.initValues.hours);
        this.hourSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.hours);
        this.minuteSelect.val(this.initValues.minutes);
        this.minuteSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.minutes);

        if (this.secondSelect) {
          this.secondSelect.val(this.initValues.seconds);
          this.secondSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.seconds);
        }

        if (!self.is24HourFormat()) {
          this.periodSelect.val(this.initValues.period);
          this.periodSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.period);
        }

        ui.find('div.dropdown').first().focus();
        ui.find('.set-time').off('click.timepicker').on('click.timepicker', function(e) {
          e.preventDefault();
          self.setTimeOnField();
          self.closeTimePopup();
        });

        // Handle Tabbing on the dialog
        if (!this.settings.parentElement) {

          ui.on('keydown.timepicker', 'button, div.dropdown', function (e) {
            var key = e.keyCode || e.charCode || 0;

            if (key === 9) {
              self.containFocus(e);
              e.stopPropagation();
              e.preventDefault();
              return false;
            }
          });

        }

      },

      /**
       * Focus the next prev focusable element on the popup
       * @private
       */
      containFocus: function (e) {
        var reverse = e.shiftKey;

        // Set focus on (opt: next|prev) focusable element
        var focusables = this.popup.find(':focusable'),
          index = focusables.index($(':focus'));

        index = (!reverse) ?
          ((index+1) >= focusables.length ? 0 : (index+1)) :
          ((index-1) < 0 ? focusables.length : (index-1));

        focusables.eq(index).focus();
      },

      /**
       * Sets up events that need to be bound to a standard time picker.
       * @private
       */
      setupStandardEvents: function() {
        var self = this;

        self.popup.on('touchend.timepicker touchcancel.timepicker', '.set-time', function(e) {
          e.preventDefault();
          e.target.click();
        }).on('keydown.timepicker', 'input.dropdown', function(e) {
          var handled = false;

          // Pressing Esc when focused on a closed dropdown menu causes the entire popup to close.
          if (e.which === 27) {
            handled = true;
            self.closeTimePopup();
            self.element.focus();
          }

          // Pressing Spacebar while the popup is open submits with the new time value.
          if (e.which === 32) {
            handled = true;
            self.popup.find('.set-time').click();
          }

          // Left & Right Arrows will switch between the available dropdowns
          if (e.which === 37 || e.which === 39) {
            handled = true;
            var inputs = self.popup.find('input[id$="-shdo"]');

            if (e.which === 37) {
              var prev = inputs.eq(inputs.index(this) - 1);
              if (!prev || prev.length === 0) {
                prev = inputs.eq(inputs.length);
              }
              prev.focus();
            }

            if (e.which === 39) {
              var next = inputs.eq(inputs.index(this) + 1);
              if (!next || next.length === 0) {
                next = inputs.eq(0);
              }
              next.focus();
            }
          }

          if (handled) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        });

        // Listen to the popover/tooltip's "hide" event to properly close out the popover's inner controls.
        self.trigger.on('hide.timepicker', function() {
          self.onPopupHide();
        });
      },

      /**
       * @private
       */
      buildRangePopup: function() {
        // TODO: Build this
      },

      /**
       * @private
       */
      setupRangeEvents: function() {
        // TODO: Build this
      },

      /**
       * Gets the value of the Timepicker field as an object separated into hours, minutes, (optional) seconds, and (optional) day period.
       * @param {String} [value] - this method can optionally be passed a string-based time value to calculate instead of the current field's value.
       * @returns {Object}
       * @returns {Object.hours}
       * @returns {Object.minutes}
       * @returns {Object.seconds}
       * @returns {Object.period}
       */
      getTimeFromField: function(value) {
        var self = this,
          val = value || this.element.val(),
          sep = this.getTimeSeparator(),
          parts,
          endParts,
          timeparts = {};

		val = val.replace(/[T\s:.-]/g, sep).replace(/z/i, '');
		parts = val.split(sep);

        // Check the last element in the array for a time period, and add it as an array
        // member if necessary
        if (!this.is24HourFormat()) {
          endParts = parts[parts.length - 1].split(' ');
          parts.pop();
          parts = parts.concat(endParts);
        }

        function isDayPeriod(value) {
          return self.dayPeriods.indexOf(value) > -1;
        }

        function removeLeadingWhitespace(value) {
          return value.replace(/^\s+|\s+$/g, '');
        }

        function addLeadingZero(value) {
          if (!value || isNaN(value)) {
            return '00';
          }
          value = parseInt(value);
          value = value < 10 ? '0' + value : value;
          return value;
        }

        // Handle Hours
        if (!parts[0] || !parts[0].length || isNaN(parts[0])) {
          parts[0] = '1';
        }

        parts[0] = parseInt(parts[0], 10);
        if (isNaN(parts[0])) {

        } else {
          parts[0] = '' + parseInt(parts[0], 10);
        }
        timeparts.hours = parts[0];

        // Handle Minutes
        if (parts[1]) {
          // remove leading whitespace
          parts[1] = removeLeadingWhitespace(parts[1]);
          parts[1] = addLeadingZero(parts[1]);
          timeparts.minutes = parts[1];
        } else {
          timeparts.minutes = '00';
        }

        // Handle Seconds/Period (slot 3)
        function handleSlot2(value) {
          // Should not kick off at all if we don't pass it a value, OR if this field is 24-hour display with no seconds
          if (!value) {
            if (!self.is24HourFormat()) {
              if (self.hasSeconds()) {
                value = '00';
                timeparts.seconds = value;
              } else {
                value = Locale.translateDayPeriod('AM');
                timeparts.period = value;
              }
            }

            return value;
          }

          value = removeLeadingWhitespace(value);

          // Has seconds
          if (self.hasSeconds()) {
            value = addLeadingZero(value);
            timeparts.seconds = value;
            return value;
          }
          // No seconds, but has a day period
          if (!isDayPeriod(value)) {
            value = Locale.translateDayPeriod('AM');
          }
          timeparts.period = value;
          return;
        }
        handleSlot2(parts[2]);

        // Handle Period after seconds (slot 4)
        if (parts[3]) {
          parts[3] = removeLeadingWhitespace(parts[3]);
          timeparts.period = parts[3];
        } else {
          if (!this.is24HourFormat() && this.hasSeconds()) {
            timeparts.period = Locale.translateDayPeriod('AM');
          }
        }

        return timeparts;
      },

      /**
       * Retrieves the values from the Timepicker popup's pickers and uses those values to set
       * the contents of the Timepicker field.
       */
      setTimeOnField: function() {
        var hours = $('#timepicker-hours').val() || '',
          minutes = $('#timepicker-minutes').val() || '',
          seconds = $('#timepicker-seconds').val() || '',
          period = ($('#timepicker-period').val() || '').toUpperCase(),
          sep = this.getTimeSeparator(),
          timeString = '' + hours + sep + minutes + (this.hasSeconds() ? sep + seconds : '');

        period = (!this.is24HourFormat() && period === '') ? $('#timepicker-period-shdo').val() : period;
        timeString += period ? ' ' + Locale.translateDayPeriod(period) : '';

        this.element.val(timeString)
          .trigger('change');

        this.element
          .focus();
      },

      /**
       * Return whether or not the Timepicker popup is open.
       * @returns {boolean}
       */
      isOpen: function () {
        return (this.popup && !this.popup.hasClass('is-hidden'));
      },

      /**
       * Opens the Timepicker popup, intializing all the dropdown elements and setting up internal events.
       */
      openTimePopup: function() {
        var self = this;

        // Get all current settings.
        self.setup();

        if (this.element.is(':disabled') || this.element.attr('readonly')) {
          return;
        }

        if (this.popup && !this.popup.hasClass('is-hidden')) {
          self.closeTimePopup();
        }

        this.element.addClass('is-active is-open');

        // Build a different Time Popup based on settings
        if (self.settings.mode === 'range') {
          self.buildRangePopup();
          self.setupRangeEvents();
        } else {
          self.buildStandardPopup();
          self.setupStandardEvents();
        }

        this.element.attr({'aria-expanded': 'true'});
        this.popup.find('div.dropdown').first().focus();
      },

      /**
       * Triggers the "hide" method on the tooltip plugin.  The Timepicker officially "closes" after the popover's
       * hide event fully completes because certain events need to be turned off and certain markup needs to be
       * removed only AFTER the popover is hidden.
       */
      closeTimePopup: function() {
        if (this.trigger.data('tooltip')) {
          this.trigger.data('tooltip').hide();
        }
      },

      /**
       * This gets fired on the popover's "hide" event
       */
      onPopupHide: function() {
        if (this.settings.mode === 'standard') {
          $('#timepicker-hours').data('dropdown').destroy();
          $('#timepicker-minutes').data('dropdown').destroy();
          if (this.hasSeconds()) {
            $('#timepicker-seconds').data('dropdown').destroy();
          }
          if (!this.is24HourFormat()) {
            $('#timepicker-period').data('dropdown').destroy();
          }
          this.popup.off('click.timepicker touchend.timepicker touchcancel.timepicker keydown.timepicker');
        }
        this.element.attr({'aria-expanded': 'false'});
        this.trigger.off('hide.timepicker show.timepicker');
        this.trigger.data('tooltip').destroy();
        this.trigger.data('tooltip', undefined);
        $('#timepicker-popup').remove();
        this.element.removeClass('is-active is-open');
      },

      /**
       * Toggles the visibility of the Timepicker popup.
       */
      toggleTimePopup: function() {
        if (this.isOpen()) {
          this.closeTimePopup();
        } else {
          this.openTimePopup();
        }
      },

      /**
       * Getter method for retrieving the value of the Timepicker.
       * @param {boolean} [removePunctuation] - Gets rid of all the value's punctatuion on return.
       * @returns {String}
       */
      value: function(removePunctuation) {
        var val = this.element.val();
        if (!removePunctuation || removePunctuation === false) {
          return val;
        }

        var timeSeparator = Locale.calendar().dateFormat.timeSeparator,
          sepRegex = new RegExp(timeSeparator, 'g');

        // Remove punctuation
        val = val.replace(sepRegex, '');

        // Add leading zero for times without a double digit hour
        var parts = val.split(' ');
        if (parts[0].length < 4) {
          val = '0' + parts[0] + (parts[1] ? parts[1] : '');
        }

        return val;
      },

      /**
       * Enables the Timepicker
       */
      enable: function() {
        this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
      },

      /**
      * Set input to readonly.
      */
      readonly: function() {
        this.enable();
        this.element.attr('readonly', 'readonly');
      },

      /**
       * Disables the Timepicker
       */
      disable: function() {
        this.enable();
        this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
      },

      /**
       * Detects whether or not the component is disabled
       * @returns {boolean}
       */
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      /**
       * Convert a string to boolean
       * @param {String} val - a text string ("true" or "false") that can be converted to a boolean.
       * @returns {boolean}
       */
      // TODO: Move this to Soho.utils?
      getBoolean: function(val) {
        var num = +val;
        return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
      },

      /**
       * Updates the component instance.  Can be used after being passed new settings.
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
       * Removes all event bindings, subcomponents and unnecessary markup from this component instance.
       * @private
       * @returns {this}
       */
      teardown: function() {
        this.trigger.off('keydown.timepicker');
        this.element.off('focus.timepicker blur.timepicker keydown.timepicker');
        if (this.popup) {
          this.closeTimePopup();
        }

        this.trigger.remove();

        var mask = this.element.data('mask');
        if (mask && typeof mask.destroy === 'function') {
          mask.destroy();
        }

        this.label.find('.audible').remove();

        return this;
      },

      /**
       * Destroys the component instance.
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], 'validate');
        $.removeData(this.element[0], pluginName);
      },

      /**
       * Add any markup
       * @fires TimePicker#events
       * @param {Object} click  &nbsp;-&nbsp;
       * @param {Object} touchstart  &nbsp;-&nbsp;
       * @param {Object} touchmove  &nbsp;-&nbsp;
       * @param {Object} touchend  &nbsp;-&nbsp;
       * @param {Object} blur  &nbsp;-&nbsp;
       */
      handleEvents: function () {
        var self = this;
        this.trigger.onTouchClick('timepicker').on('click.timepicker', function () {
          self.toggleTimePopup();
        });

        this.handleKeys();
        this.handleBlur();

        return this;
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new TimePicker(this, settings));
      }
    });
  };

/**
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  @private
 */


  var Tmpl = window.Tmpl = {};

  Tmpl.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = '';
  };

  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      rLineSep = /\u2028/,
      rParagraphSep = /\u2029/;

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val;

    if (scope && typeof scope === 'object') {

      if (scope[key] !== undefined) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get === 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function write(s) {
    return 't.b(' + s + ');';
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o === token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c === close && tags[i].o === open) {
        return true;
      }
    }
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\'')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r')
            .replace(rLineSep, '\\u2028')
            .replace(rParagraphSep, '\\u2029');
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {}
    PartialTemplate.prototype = instance;
    function Substitutions() {}
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = '';

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) {
        stackSubs[key] = subs[key];
      }
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) {
       stackPartials[key] = partials[key];
      }
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) !== tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) !== tag.charAt(i)) {
        return false;
      }
    }
    return true;
  }

  function TmplEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  Tmpl.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; }, // jshint ignore:line

    // variable escaping
    v: TmplEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base === template) {
        return partial.instance;
      }

      if (typeof template === 'string') {
        if (!this.c) {
          throw new Error('No compiler available.');
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) {
          partials.stackText = {};
        }
        for (var key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!$.isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if ($.isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val === 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val === 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && $.isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found !== undefined) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val === 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val !== undefined) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : '';
      }

      if (!returnFound && typeof val === 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = ''; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result === 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result === 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }
  };

  Tmpl.tags = {
    '#': 1, '^': 2, '<': 3, '$': 4,
    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
    '{': 10, '&': 11, '_t': 12
  };

  Tmpl.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push({tag: '_t', text: new String(buf)}); // jshint ignore:line
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (Tmpl.tags[tokens[j].tag] < Tmpl.tags._v) ||
          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null); // jshint ignore:line
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) && next.tag === '>') {
              // set indent to token value
              next.indent = tokens[j].text.toString();
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state === IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) === '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state === IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Tmpl.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType === '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType === '/') ? seenTag - otag.length : i + ctag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType === '{') {
            if (ctag === '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);
    return tokens;
  };

  // the tags allowed inside super templates
  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length > 0) {
      token = tokens.shift();

      if (tail && tail.tag === '<' && !(token.tag in allowedInSuper)) {
        throw new Error('Illegal content in < super tag.');
      }

      if (Tmpl.tags[token.tag] <= Tmpl.tags.$ || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag === '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n !== opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag === '\n') {
        token.last = (tokens.length === 0) || (tokens[0].tag === '\n');
      }

      instructions.push(token);
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
    }
    return '{ ' + items.join(',') + ' }';
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + '}');
    }
    return 'partials: {' + partials.join(',') + '}, subs: ' + stringifySubstitutions(codeObj.subs);
  }

  Tmpl.stringify = function(codeObj, text, options) { // jshint ignore:line
    return '{code: function (c,p,i) { ' + Tmpl.wrapMain(codeObj.code) + ' },' + stringifyPartials(codeObj) +  '}';
  };

  var serialNo = 0;
  Tmpl.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: '', subs: {}, partials: {} };
    Tmpl.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  };

  Tmpl.wrapMain = function(code) {
    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
  };

  Tmpl.template = Tmpl.Template;

  Tmpl.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code)); // jshint ignore:line
    return new this.template(template, text, this, options);
  };

  Tmpl.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]); // jshint ignore:line
    }
    return template;
  };

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function createPartial(node, context) {
    var prefix = '<' + (context.prefix || '');
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
    return sym;
  }

  function tripleStache(node, context) {
    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
  }

  Tmpl.codegen = {
    '#': function(node, context) {
      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + ' ' + node.ctag + '")){' +
                      't.rs(c,p,' + 'function(c,p,t){';
      Tmpl.walk(node.nodes, context);
      context.code += '});c.pop();}';
    },

    '^': function(node, context) {
      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
      Tmpl.walk(node.nodes, context);
      context.code += '};';
    },

    '>': createPartial,
    '<': function(node, context) {
      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
      Tmpl.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    '$': function(node, context) {
      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
      Tmpl.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
      }
    },

    '\n': function(node, context) {
      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
    },

    '_v': function(node, context) {
      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    },

    '_t': function(node, context) {
      context.code += write('"' + esc(node.text) + '"');
    },

    '{': tripleStache,

    '&': tripleStache
  };

  Tmpl.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i < l; i++) {
      func = Tmpl.codegen[nodelist[i].tag];
      if (func) {
        func(nodelist[i], context);
      }
    }
    return context;
  };

  Tmpl.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  };

  Tmpl.cache = {};

  Tmpl.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
  };

  Tmpl.compile = function(text, options) {
    options = options || {};
    var key = Tmpl.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    this.cache[key] = template;
    return template;
  };



  $.fn.toolbar = function(options) {
    'use strict';

    var pluginName = 'toolbar',
        defaults = {
          rightAligned: false,
          maxVisibleButtons: 3,
          resizeContainers: true,
          favorButtonset: true,
          noSearchfieldReinvoke: false,
        },
        settings = $.extend({}, defaults, options);

    /**
     * The Toolbar Component manages various levels of application navigation.  It contains a group of buttons that functionally
     * related content. Each panel consists of two levels: the top level identifies the
     * category or section header, and the second level provides the associated options.
     *
     * @class Toolbar
     *
     * @param {boolean} rightAligned   &nbsp;-&nbsp; Will always attempt to right-align the contents of the toolbar. By default if there is no title it will left align. This forces right alignment.
     * @param {Number} maxVisibleButtons   &nbsp;-&nbsp; Total amount of buttons that can be present, not including the More button.
     * @param {boolean} resizeContainers   &nbsp;-&nbsp; If true, uses Javascript to size the Title and Buttonset elements in a way that shows as much of the Title area as possible.
     * @param {boolean} favorButtonset   &nbsp;-&nbsp; If "resizeContainers" is true, setting this to true will try to display as many buttons as possible while resizing the toolbar.  Setting to false attempts to show the entire title instead.
     * @param {boolean} noSearchfieldReinvoke   &nbsp;-&nbsp; If true, does not manage the lifecycle of an internal toolbarsearchfield automatically.  Allows an external controller to do it instead.
     */
    function Toolbar(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Toolbar.prototype = {

      /**
       * Initializes the Toolbar Component
       * @private
       * @chainable
       * @returns {this}
       */
      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      /**
       * Detects discrepencies in settings.  In general, configures the component based on user settings.
       * @private
       * @chainable
       * @returns {this}
       */
      setup: function() {
        // Can't have zero buttons
        if (this.settings.maxVisibleButtons <= 0) {
          this.settings.maxVisibleButtons = defaults.maxVisibleButtons;
        }

        return this;
      },

      /**
       * Adds additional markup, wraps some internal elements, and helps construct a complete Toolbar representation in the HTML Markup.  This method also builds the "More Actions" menu and ties its elements to the toolbar items.
       * @private
       * @chainable
       * @returns {this}
       */
      build: function() {
        var self = this;

        this.element.attr('role', 'toolbar');
        if (this.settings.resizeContainers && this.element.is(':not(:hidden)')) {
          this.element[0].classList.add('do-resize');
        }

        this.buildAriaLabel();

        // keep track of how many popupmenus there are with an ID.
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = (parseInt($('.toolbar, .formatter-toolbar').index(this.element), 10));
        }

        // Check for a "title" element.  This element is optional.
        // If a title element exists, a tooltip will be created for when it's not
        // possible to show the entire title text on screen.
        this.title = this.element.children('.title');
        if (this.title.length) {
          this.element[0].classList.add('has-title');

          this.cutoffTitle = false;
          this.title.on('beforeshow.toolbar', function() {
            return self.cutoffTitle;
          }).tooltip({
            content: '' + this.title.text().trim()
          });
        } else {
          this.element[0].classList.remove('has-title');
        }

        // Container for main group of buttons and input fields.  Only these spill into the More menu.
        this.buttonset = this.element.children('.buttonset');
        if (!this.buttonset.length) {
          this.buttonset = $('<div class="buttonset"></div>');
          if (this.title.length) {
            this.buttonset.insertAfter(this.title);
          } else {
            this.buttonset.prependTo(this.element);
          }
        }

        this.element[this.settings.rightAligned ? 'addClass' : 'removeClass']('right-aligned');

        // Add and invoke More Button, if it doesn't exist
        this.more = this.element.find('.btn-actions');
        if (this.more.length === 0 && !this.element.hasClass('no-actions-button')) {
          var moreContainer = this.element.find('.more');

          if (!moreContainer.length) {
            moreContainer = $('<div class="more"></div>').appendTo(this.element);
          }

          this.more = $('<button class="btn-actions" type="button"></button>')
            .html($.createIcon({icon: 'more'}) +
              '<span class="audible">'+Locale.translate('MoreActions')+'</span>')
            .appendTo(moreContainer);
        }

        // Reference all interactive items in the toolbar
        this.buttonsetItems = this.buttonset.children('button')
          .add(this.buttonset.find('input')); // Searchfield Wrappers

        // Items contains all actionable items in the toolbar, including the ones in the title, and the more button
        this.items = this.buttonsetItems
          .add(this.title.children('button'))
          .add(this.more);

        // Invoke buttons
        var buttons = this.items.filter('button, input[type="button"], [class^="btn"]');
        buttons.each(function() {
          var buttonControl = $(this).data('button');
          if (!buttonControl) {
            $(this).button();
          }
        });

        // Invoke searchfields
        if (!this.settings.noSearchfieldReinvoke) {
          var searchfields = this.items.filter('.searchfield, .toolbar-searchfield-wrapper, .searchfield-wrapper');
          searchfields.each(function(i, item) {
            var sf = $(item);
            if (sf.is('.toolbar-searchfield-wrapper, .searchfield-wrapper')) {
              sf = sf.children('.searchfield');
            }

            if (!sf.data('searchfield')) {
              var searchfieldOpts = $.extend({}, $.fn.parseOptions(sf[0]));
              sf.toolbarsearchfield(searchfieldOpts);
            }
          });
        }

        // Setup the More Actions Menu.  Add Menu Items for existing buttons/elements in the toolbar, but
        // hide them initially.  They are revealed when overflow checking happens as the menu is opened.
        var popupMenuInstance = this.more.data('popupmenu'),
          moreAriaAttr = this.more.attr('aria-controls');

        if (!popupMenuInstance) {
          this.moreMenu = $('#' + moreAriaAttr);
          if (!this.moreMenu.length) {
            this.moreMenu = this.more.next('.popupmenu, .popupmenu-wrapper');
          }
          if (!this.moreMenu.length) {
            this.moreMenu = $('<ul id="popupmenu-toolbar-'+ this.id +'" class="popupmenu"></ul>').insertAfter(this.more);
          }

          // Allow toolbar to understand pre-wrapped popupmenus
          // Angular Support -- See SOHO-7008
          if (this.moreMenu.is('.popupmenu-wrapper')) {
            this.moreMenu = this.moreMenu.children('.popupmenu');
          }
        } else {
          this.moreMenu = popupMenuInstance.menu;
        }

        this.defaultMenuItems = this.moreMenu.children('li:not(.separator)').length > 0;

        function menuItemFilter() {
          //jshint validthis:true
          return $(this).parent('.buttonset, .inline').length;
        }

        var menuItems = [];
        this.items.not(this.more).filter(menuItemFilter).each(function() {
          menuItems.push(self.buildMoreActionsMenuItem($(this)));
        });

        menuItems.reverse();
        $.each(menuItems, function(i, item) {
          if (item.text() !== '') {
            item.prependTo(self.moreMenu);
          }
        });

        // Setup an Event Listener that will refresh the contents of the More Actions
        // Menu's items each time the menu is opened.
        if (popupMenuInstance) {
          this.more
            .on('beforeopen.toolbar', function() {
              self.refreshMoreActionsMenu(self.moreMenu);
            })
            .triggerHandler('updated');
        } else {
          var actionButtonOpts = $.fn.parseOptions(this.more[0]);

          this.more.popupmenu($.extend({}, actionButtonOpts, {
            trigger: 'click',
            menu: this.moreMenu
          })).on('beforeopen.toolbar', function() {
            self.refreshMoreActionsMenu(self.moreMenu);
          });
        }

        // Setup the tabindexes of all items in the toolbar and set the starting active button.
        function setActiveToolbarItem() {
          self.items.attr('tabindex', '-1');

          var active = self.items.filter('.is-selected');
          if (active.length) {
            self.activeButton = active.first().attr('tabindex', '0');
            self.items.not(self.activeButton).removeClass('is-selected');
            return;
          }

          // Set active to the first item in the toolbar.
          active = self.items.filter(':visible:not(:disabled)').first().attr('tabindex', '0');
          self.activeButton = active;

          // If the whole toolbar is hidden (contextual toolbars, etc),
          // automatically set the first non-disabled item as visible
          if (self.element.is(':hidden, .is-hidden')) {
            self.activeButton = self.items.filter(':not(:disabled)').first().attr('tabindex', '0');
            return;
          }

          if (self.isItemOverflowed(active)) {
            active.attr('tabindex', '-1');
            self.activeButton = self.more.addClass('is-selected').attr('tabindex', '0');
          }
          return;
        }

        setActiveToolbarItem();

        // Toggles the More Menu based on overflow of toolbar items
        this.adjustMenuItemVisibility();
        this.handleResize();

        this.element.triggerHandler('rendered');

        var searchfieldWrapper = this.buttonset.find('.searchfield-wrapper, .toolbar-searchfield-wrapper');
        if (searchfieldWrapper.length) {
          searchfieldWrapper.trigger('reanimate');
        }

        return this;
      },

      /**
       * Builds a single "More Actions Menu" item from a source toolbar item.
       * Also sets up linkage between the menu item and the original toolbar item to allow events/properties
       * to propagate when the More Actions item is acted upon.
       * @param {jQuery[]} item - the source item from the toolbar.
       * @returns {jQuery[]} - a jQuery-wrapped <li> representing a More Actions menu implementation of the toolbar item.
       */
      buildMoreActionsMenuItem: function(item) {
        var isSplitButton = false;

        // If this item should be skipped, just return out
        if (item.data('skipit') === true) {
          item.data('skipit', undefined);
          return;
        }

        // Attempt to re-use an existing <li>, if possible.
        // If a new one is created, setup the linkage between the original element and its
        // "More Actions" menu counterpart.
        var a = item.data('action-button-link'),
          popupLi;

        if (!a || !a.length) {
          popupLi = $('<li></li>');
          a = $('<a href="#"></a>').appendTo(popupLi);

          // Setup data links between the buttons and their corresponding list items
          item.data('action-button-link', a);
          a.data('original-button', item);
        } else {
          popupLi = a.parent();
        }

        // Refresh states
        if (item.hasClass('hidden')) {
          popupLi.addClass('hidden');
        }
        if (item.is(':disabled')) {
          popupLi.addClass('is-disabled');
          a.prop('disabled', true);
        } else {
          popupLi.removeClass('is-disabled');
          a.prop('disabled', false);
        }

        // Refresh Text
        a.text(this.getItemText(item));

        // Pass along any icons except for the dropdown (which is added as part of the submenu design)
        var submenuDesignIcon = $.getBaseURL('#icon-dropdown');
        var icon = item.children('.icon').filter(function() {
          var iconName = $(this).getIconName();
          return iconName && iconName !== submenuDesignIcon && iconName.indexOf('dropdown') === -1;
        });

        if (icon && icon.length) {
          a.html('<span>' + a.text() + '</span>');
          icon.clone().detach().prependTo(a);
        }

        var linkspan = popupLi.find('b');
        if (linkspan.length) {
          this.moreMenu.addClass('has-icons');
          linkspan.detach().prependTo(popupLi);
        }

        function addItemLinksRecursively(menu, diffMenu, parentItem) {
          var children = menu.children('li'),
            id = diffMenu.attr('id');

          diffMenu.children('li').each(function(i, diffMenuItem) {
            var dmi = $(diffMenuItem), // "Diffed" Menu Item
              omi = children.eq(i), // Corresponding "Original" menu item
              dmiA = dmi.children('a'), // Anchor inside of "Diffed" menu item
              omiA = omi.children('a'), // Anchor inside of "Original" menu item
              dmiID = dmi.attr('id'),
              dmiAID = dmiA.attr('id');

            // replace menu item ids with spillover-menu specific ids.
            if (dmiID) {
              dmi.removeAttr('id').attr('data-original-menu-item', dmiID);
            }
            if (dmiAID) {
              dmiA.removeAttr('id').attr('data-original-menu-anchor', dmiAID);
            }

            omiA.data('action-button-link', dmiA);
            dmiA.data('original-button', omiA);

            var omiSubMenu = omi.children('.wrapper').children('.popupmenu'),
              dmiSubMenu = dmi.children('.wrapper').children('.popupmenu');

            if (omiSubMenu.length && dmiSubMenu.length) {
              addItemLinksRecursively(omiSubMenu, dmiSubMenu, dmi);
            }

            if (isSplitButton) {
              dmi.removeClass('is-checked');
            }
          });

          diffMenu.removeAttr('id').attr('data-original-menu', id);
          parentItem.addClass('submenu');

          var appendTarget;
          if (parentItem.is(popupLi)) {
            appendTarget = parentItem.children('.wrapper');
            if (!appendTarget || !appendTarget.length) {
              appendTarget = $('<div class="wrapper"></div>');
            }
            appendTarget.html(diffMenu);
            parentItem.append(appendTarget);
          }
        }

        if (item.is('.btn-menu')) {
          if (!item.data('popupmenu')) {
            item.popupmenu();
          } else {
            if (!a.children('.icon.arrow').length) {
              a.append($.createIcon({
                classes: 'icon arrow icon-dropdown',
                icon: 'dropdown'
              }));
            }
          }

          var menu = item.data('popupmenu').menu,
            diffMenu = menu.clone();

          addItemLinksRecursively(menu, diffMenu, popupLi);
        }

        if (item.is('[data-popdown]')) {
          item.popdown();
        }

        return popupLi;
      },

      /**
       * Refreshes the More Actions Menu items' text content, icons, states, and submenu content
       * based on changes made directly to their counterpart elements in the Toolbar.  Can also
       * optionally refresh only part of the menu.
       * @param {jQuery[]} menu - the menu/submenu to be refreshed.
       */
      refreshMoreActionsMenu: function(menu) {
        var self = this;

        $('li > a', menu).each(function () {
          var a = $(this),
              li = a.parent(),
              item = a.data('originalButton'),
              itemParent,
              text = self.getItemText(item),
              submenu;

          if (item) {
            if (a.find('span').length) {
              a.find('span').text(text.trim());
            } else {
              a.text(text.trim());
            }

            if (item.isHiddenAtBreakpoint() || item.parent().isHiddenAtBreakpoint()) {
              li.addClass('hidden');
            } else {
              li.removeClass('hidden');
            }

            if (item.parent().is('.is-disabled') || item.is(':disabled')) { // if it's disabled menu item, OR a disabled menu-button
              li.addClass('is-disabled');
              a.prop('disabled', true);
              a.attr('tabindex', '-1');
            } else {
              li.removeClass('is-disabled');
              a.prop('disabled', false);
            }

            if (item.is('a')) {
              itemParent = item.parent('li');

              if (itemParent.is('.is-checked')) {
                li.addClass('is-checked');
              } else {
                li.removeClass('is-checked');
              }
            }

            if (item.is('.btn-menu')) {
              submenu = a.parent().find('.popupmenu').first();
              self.refreshMoreActionsMenu(submenu);
            }
          }
        });
      },

      /**
       * Gets the complete text contnts of a Toolbar Item, in order to create its corresponding "more actions" menu item.
       *
       * Order of operations for populating the List Item text:
       * 1. span contents (.audible), then
       * 2. button title attribute, then
       * 3. tooltip text (if applicable)
       * @param {jQuery[]} item - the item being evaluated.
       * @returns {string} - the complete text representation.
       */
      getItemText: function (item) {
        if (!item) {
          return;
        }
        var span = item.find('.audible'),
          title = item.attr('title'),
          tooltip = item.data('tooltip'),
          tooltipText = tooltip && typeof tooltip.content === 'string' ? tooltip.content : undefined;

        var popupLiText = span.length ? span.text() :
          title !== '' && title !== undefined ? item.attr('title') :
          tooltipText ? tooltipText : item.text();

        return popupLiText;
      },

      /**
       * Sets up all necessary event handling on a Toolbar component
       * @private
       * @chainable
       * @returns {this}
       */
      handleEvents: function() {
        var self = this;

        this.items
          .off('keydown.toolbar').on('keydown.toolbar', function(e) {
            self.handleKeys(e);
          }).off('click.toolbar').on('click.toolbar', function(e) {
            self.handleClick(e);
          });

        this.items.filter('.btn-menu, .btn-actions')
          .off('close.toolbar').on('close.toolbar', function onClosePopup() {
            var el = $(this),
              last;

            if (el.is('.is-overflowed')) {
              last = self.getLastVisibleButton();
              if (last && last.length) {
                last[0].focus();
              }
              return;
            }

            el.focus();
            self.buttonset.scrollTop(0);
          });

        this.items.not(this.more).off('selected.toolbar').on('selected.toolbar', function(e, anchor) {
          e.stopPropagation();
          self.handleSelected(e, anchor);
        });

        this.more.on('keydown.toolbar', function(e) {
          self.handleKeys(e);
        }).on('beforeopen.toolbar', function() {
          self.adjustMenuItemVisibility();
        }).on('selected.toolbar', function(e, anchor) {
          e.stopPropagation();
          self.handleSelected(e, anchor);
        });

        // Handle possible AJAX calls on Toolbar Menu buttons
        // TODO: Need to handle mouseenter/touchstart/keydown events that will cause this to trigger,
        // instead of directly handling this itself.
        this.more
          .off('show-submenu.toolbar')
          .on('show-submenu.toolbar', function(e, li) {
          self.handleTransferToMenuButtonItem(e, li);
        });

        this.element.off('updated.toolbar').on('updated.toolbar', function(e) {
          e.stopPropagation();
          self.updated();
        }).off('recalculate-buttons.toolbar').on('recalculate-buttons.toolbar', function(e, containerDims) {
          self.handleResize(containerDims);
        }).off('scrollup.toolbar').on('scrollup.toolbar', function() {
          var moduleTabsParent = self.element.parents('.tab-container.module-tabs');
          if (moduleTabsParent.length) {
            moduleTabsParent.scrollTop(0);
          }
        });

        $('body').off('resize.toolbar-' + this.id).on('resize.toolbar-' + this.id, function() {
          self.handleResize();
        });

        // Trigger _handleResize()_ once to fix container sizes.
        this.handleResize();

        return this;
      },

      /**
       * Event Handler for the Soho Popupmenu's custom 'show-submenu' event, specifically for
       * the case of a menu button that's been spilled over into this Toolbar's More Actions menu.
       * @param {jQuery.Event} e
       * @param {jQuery[]} li - the `li.submenu` element.
       */
      handleTransferToMenuButtonItem: function(e, li) {
        var originalMenuButton = li.children('a').data('original-button');
        if (!originalMenuButton) {
          return;
        }

        var popupAPI = originalMenuButton.data('popupmenu');
        if (!popupAPI || typeof popupAPI.settings.beforeOpen !== 'function') {
          return;
        }

        // Call out to the MenuButton's AJAX source, get its contents, and populate
        // the corresponding More Actions menu sub-item.
        popupAPI.callSource(e);
        this.buildMoreActionsMenuItem(originalMenuButton);
      },

      /**
       * Event handler for the Soho `selected` event on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {undefined}
       */
      handleSelected: function(e, anchor) {
        var itemLink = anchor.data('original-button'),
          li = anchor.parent(),
          itemEvts,
          toolbarEvts,
          popup, popupTrigger;

        // Don't continue if hidden/readonly/disabled
        if (li.is('.hidden, .is-disabled') || anchor.is('[readonly], [disabled]')) {
          e.preventDefault();
          return;
        }

        if (itemLink && itemLink.length > 0) {
          itemEvts = itemLink.listEvents();
          toolbarEvts = this.element.listEvents();

          // Make sure the active button is set properly
          this.setActiveButton(itemLink);

          // Handle popdowns with a custom placement algorithm that correctly pops the menu
          // open against the "More Actions" button instead of in an empty space
          // SOHO-7087
          if (itemLink.is('[data-popdown]')) {
            popupTrigger = itemLink.data('popdown');

            if (this.isItemOverflowed(itemLink)) {
              popupTrigger.settings.trigger = this.more;
              popupTrigger.updated();
            }
          }

          // Fire Angular Events
          if (itemLink.attr('ng-click') || itemLink.attr('data-ng-click')) {
            itemLink.trigger('click');
            return;
          }

          // Check the Toolbar Button for the existence of certain event types.
          // Checks the button, and checks the toolbar container element for delegated events.
          var evtTypes = ['click', 'touchend', 'touchcancel'];
          for (var i = 0; i < evtTypes.length; i++) {
            var type = evtTypes[i];

            // Check toolbar element for delegated-down events first
            if (toolbarEvts && toolbarEvts[type] && toolbarEvts[type].delegateCount > 0) {
              var el = this.element,
                evt = $.Event(type);

              evt.target = el.find(itemLink)[0];
              el.trigger(evt);
              return;
            }

            // Check for events directly on the element
            if ((itemEvts && itemEvts[type]) || itemLink[0]['on' + type]) {
              itemLink.trigger(type);
              return;
            }
          }

          // If the linked element is a child of a menu button, trigger its 'selected' event.
          popup = itemLink.parents('.popupmenu');
          popupTrigger = popup.data('trigger');
          if (popup.length && popupTrigger instanceof $ && popupTrigger.length) {
            popupTrigger.triggerHandler('selected', [itemLink]);
            return;
          }

          // Manually Trigger Select on the linked item, since it won't be done by another event
          this.triggerSelect(itemLink);
          return;
        }

        // If no item link exists, it's a pre-defined menu item.
        // Trigger 'selected' manually on the toolbar element.
        // Normally this would happen by virtue of triggering the "click" handlers on a linked button above.
        this.triggerSelect(anchor);
      },

      /**
       * Event handler for clicks on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {false}
       */
      handleClick: function(e) {
        this.setActiveButton($(e.currentTarget));
        this.triggerSelect($(e.currentTarget));
        return false;
      },

      /**
       * Event handler for key presses on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {undefined}
       */
      handleKeys: function(e) {
        var self = this,
          key = e.which,
          target = $(e.target),
          isActionButton = target.is('.btn-actions'),
          isRTL = Locale.isRTL();

        if ((key === 37 && target.is(':not(input)')) ||
          (key === 37 && target.is('input') && e.shiftKey) || // Shift + Left Arrow should be able to navigate away from Searchfields
          (key === 38 && target.is(':not(input.is-open)'))) { // Don't navigate away if Up Arrow in autocomplete field that is open
          e.preventDefault();

          if (isActionButton) {
            self.setActiveButton( isRTL ? self.getFirstVisibleButton() : self.getLastVisibleButton() );
          } else {
            self.navigate( isRTL ? 1 : -1 );
          }
        }

        if ((key === 39 && target.is(':not(input)')) ||
          (key === 39 && target.is('input') && e.shiftKey) || // Shift + Right Arrow should be able to navigate away from Searchfields
          (key === 40 && target.is(':not(input.is-open)'))) { // Don't navigate away if Down Arrow in autocomplete field that is open
          e.preventDefault();

          if (isActionButton) {
            self.setActiveButton( isRTL ? self.getLastVisibleButton() : self.getFirstVisibleButton() );
          } else {
            self.navigate( isRTL ? -1 : 1 );
          }
        }

        return;
      },

      /**
       * Re-renders the toolbar element and adjusts all internal parts to account for the new size.
       * @param {Object} [containerDims] - an object containing dimensions that can be set on the Toolbar's title and buttonset elements.
       * @param {number} [containerDims.title] - represents the width that will be applied to the title element
       * @param {number} [containerDims.buttonset] - represents the width that will be applied to the buttonset element
       * @returns {undefined}
       */
      handleResize: function(containerDims) {
        if (this.settings.resizeContainers) {
          var title = containerDims ? containerDims.title : undefined,
            buttonset = containerDims ? containerDims.buttonset : undefined;

          this.sizeContainers(title, buttonset);
        }

        var buttons = this._getButtonsetButtons();
        for (var i = 0; i < buttons.length; i++) {
          buttons[i].removeClass('is-overflowed');
        }

        if (this.element.is(':not(:hidden)')) {
          this.adjustMenuItemVisibility();
          this.toggleMoreMenu(); // Added 9/16/2015 due to issue HFC-2876
        }
      },

      /**
       * Resizes the Toolbar's internal container areas (title, buttonset) to make efficient use of their space.
       * @private
       * @chainable
       * @param {number} titleSize - desired size of the title element.
       * @param {number} buttonsetSize - desired size of the buttonset element.
       * @returns {this}
       */
      sizeContainers: function(titleSize, buttonsetSize) {
        var containerElem = this.element[0],
          titleElem = this.title[0],
          buttonsetElem = this.buttonset[0],
          moreElem = this.more[0];

        // Don't do this at all unless we have a title element (which is optional)
        if (!this.title || !this.title.length) {
          return;
        }

        // If the element's hidden and has defined sizes, remove them so we can use the defaults.
        if (this.element.is(':hidden')) {
          buttonsetElem.style.width = '';
          titleElem.style.width = '';
          containerElem.classList.remove('do-resize');
          return;
        }

        var WHITE_SPACE = 30,
          MIN_TITLE_SIZE = 44 + WHITE_SPACE,
          MIN_BUTTONSET_SIZE = 0;

        buttonsetElem.style.width = '';
        titleElem.style.width = '';

        if (!containerElem.classList.contains('do-resize')) {
          containerElem.classList.add('do-resize');
        }

        var toolbarDims = $(containerElem).getHiddenSize(),
          buttonsetDims = $(buttonsetElem).getHiddenSize(),
          titleDims = $(titleElem).getHiddenSize(),
          moreDims = $(moreElem).getHiddenSize(),
          toolbarPadding = parseInt(toolbarDims.padding.left) + parseInt(toolbarDims.padding.right);

        if (isNaN(moreDims.width)) {
          moreDims.width = 50;
        }

        if (isNaN(buttonsetDims.width) || buttonsetDims.width < MIN_BUTTONSET_SIZE) {
          buttonsetDims.width = MIN_BUTTONSET_SIZE;
        }

        function addPx(val) {
          return val + 'px';
        }

        // Get the target size of the title element
        var hasTitleSizeGetter = (titleSize !== undefined && !isNaN(titleSize)),
          hasButtonsetSizeGetter = (buttonsetSize !== undefined && !isNaN(buttonsetSize)),
          targetTitleWidth, targetButtonsetWidth, d;
        this.cutoffTitle = false;


        // Determine the target sizes for title and buttonset, based on external setters, or building an estimated size.
        targetTitleWidth = hasTitleSizeGetter ?
          parseInt(titleSize) :
          this.settings.favorButtonset === true ?
            toolbarDims.width - (toolbarPadding + (hasButtonsetSizeGetter ? parseInt(buttonsetSize) : buttonsetDims.width) + moreDims.width) :
            titleDims.scrollWidth;
        targetButtonsetWidth = hasButtonsetSizeGetter ?
          parseInt(buttonsetSize) :
          this.settings.favorButtonset === true ?
            buttonsetDims.width :
            toolbarDims.width - (toolbarPadding + (hasTitleSizeGetter ? parseInt(titleSize) : titleDims.scrollWidth) + moreDims.width);


        if (this.settings.favorButtonset) {
          // Cut off the buttonset anyway if title is completely hidden.  Something's gotta give!
          if (targetTitleWidth < MIN_TITLE_SIZE) {
            this.cutoffTitle = true;
            d = Math.abs(targetTitleWidth - MIN_TITLE_SIZE);
            targetTitleWidth = MIN_TITLE_SIZE;
            targetButtonsetWidth = targetButtonsetWidth - d;
          }

          buttonsetElem.style.width = addPx(targetButtonsetWidth + 2);
          titleElem.style.width = addPx(targetTitleWidth - 2);

          return this;
        }
        //==========================
        // Favor the title element
        // Cut off the title anyway if buttonset is completely hidden.  Something's gotta give!
        if (targetButtonsetWidth < MIN_BUTTONSET_SIZE) {
          this.cutoffTitle = true;
          d = Math.abs(targetButtonsetWidth - MIN_BUTTONSET_SIZE);
          targetButtonsetWidth = MIN_BUTTONSET_SIZE;
          targetTitleWidth = targetTitleWidth - d;
        }

        // Always favor the title by one extra px for Chrome
        titleElem.style.width = addPx(targetTitleWidth + 2);
        buttonsetElem.style.width = addPx(targetButtonsetWidth - 2);
        return this;
      },

      /**
       * Changes the "active" button on the toolbar.
       * @param {number} direction - can be `-1` (previous), `1` (next), or `0` (remain on current).
       * @returns {jQuery[]}
       */
      navigate: function (direction) {
        var items = this.items.filter(':visible:not(:disabled)'),
          current = items.index(this.activeButton),
          next = current + direction,
          target;

        if (next >= 0 && next < items.length) {
          target = items.eq(next);
        }

        if (next >= items.length) {
          target = items.first();
        }

        if (next === -1) {
          target = items.last();
        }

        if (this.isItemOverflowed(target)) {
          target = this.more;
        }

        this.setActiveButton(target);
        return false;
      },

      /**
       * Gets a reference to the last visible (not overflowed) button inside of the buttonset.
       * @returns {jQuery[]}
       */
      getLastVisibleButton: function() {
        var items = $(this.items.get().reverse()).not(this.more),
          target;

        var i = 0,
          elem;

        while(!target && i < items.length) {
          elem = $(items[i]);
          if (!this.isItemOverflowed(elem)) {
            target = elem;
            break;
          }
          i++;
        }

        if (!target || target.length === 0) {
          target = items.first();
        }

        while(target.length && target.is('.separator, *:disabled, *:hidden')) {
          target = target.prev();
        }

        return target;
      },

      /**
       * Gets a reference to the first visible (not overflowed) button inside of the buttonset.
       * @returns {jQuery[]}
       */
      getFirstVisibleButton: function() {
        var i = 0,
          items = this.items,
          target = items.eq(i);

        while(target.is('.separator, *:disabled, *:hidden')) {
          i++;
          target = items.eq(i);
        }

        return target;
      },

      /**
       * Sets the currently "active" (focused) Toolbar item
       * @param {jQuery[]} activeButton - the preferred target element to make active.
       * @param {boolean} [noFocus] - if defined, prevents this method from giving focus to the new active button.
       */
      setActiveButton: function(activeButton, noFocus) {
        // Return out of this if we're clicking the currently-active item
        if (activeButton[0] === this.activeButton[0]) {
          return;
        }

        var self = this;

        function getMoreOrLast() {
          if (self.hasNoMoreButton() || !self.element.hasClass('has-more-button')) {
            return self.getLastVisibleButton();
          }

          return self.more;
        }

        function getActiveButton() {
          // Menu items simply set the "More Actions" button as active
          if (activeButton.is('a')) {
            return getMoreOrLast();
          }

          // If it's the more button, hide the tooltip and set it as active
          var tooltip = self.more.data('tooltip');
          if (activeButton[0] === self.more[0]) {
            if (tooltip && tooltip.tooltip.is(':not(.hidden)')) {
              tooltip.hide();
            }
            return getMoreOrLast();
          }

          // Overflowed items also set
          if (self.isItemOverflowed(activeButton)) {
            if (!activeButton.is('.searchfield')) {
              return getMoreOrLast();
            }
          }

          return activeButton;
        }

        this.items.add(this.more).attr('tabindex', '-1').removeClass('is-selected');

        this.activeButton = getActiveButton();
        this.activeButton.addClass('is-selected').attr('tabindex', '0');

        if (!noFocus) {
          this.activeButton[0].focus();
          this.element.triggerHandler('navigate', [this.activeButton]);
        }
      },

      /**
       * Triggers a "selected" event on the base Toolbar element using a common element as an argument.
       * @param {HTMLElement|SVGElement|jQuery[]} element - a jQuery Object containing an anchor tag, button, or input field.
       */
      triggerSelect: function(element) {
        var elem = $(element);
        if (elem.is(this.more) || (elem.is('.btn-menu, li.submenu'))) {
          return;
        }

        this.element.triggerHandler('selected', [elem]);
      },

      /**
       * Assembles and returns a list of all buttons inside the Buttonset element.
       * @returns {Array}
       */
      _getButtonsetButtons: function() {
        var buttons = [],
          items = this.buttonsetItems,
          item;

        for (var i = 0; i < items.length; i++) {
          item = items.eq(i);
          if (item.data('action-button-link') !== undefined && item.is(':not(.searchfield)')) {
            buttons.push(item);
          }
        }

        return buttons;
      },

      /**
       * Gets and Iterates through a list of toolbar items and determines which are currently overflowed, and which are visible.
       * @param {Array} buttons - an Array of jQuery-wrapped elements that represents toolbar items.
       * @returns {VisibilitySortedToolbarItems}
       * @returns {VisibilitySortedToolbarItems.Array} visible - An array containing all visible items.
       * @returns {VisibilitySortedToolbarItems.Array} hidden - An array containing all hidden (overflowed) items.
      */
      getVisibleButtons: function(buttons) {
        var self = this,
          hiddenButtons = [],
          visibleButtons = [],
          i;

        if (!buttons || !Array.isArray(buttons)) {
          buttons = this._getButtonsetButtons();
        }

        for (i = 0; i < buttons.length; i++) {
          buttons[i][0].classList.remove('is-overflowed');
        }

        function getButtonVisibility(i, button) {
          if (!self.isItemOverflowed(button)) {
            visibleButtons.push(button);
          } else {
            hiddenButtons.push(button);
          }
        }

        for (i = 0; i < buttons.length; i++) {
          getButtonVisibility(i, buttons[i]);
        }

        return {
          visible: visibleButtons,
          hidden: hiddenButtons
        };
      },

      /**
       * Gets and Iterates through the full list of Toolbar Items and determines which ones should currently be present in the More Actions menu.
       * @param {Object} items - an object (normally generated by `_.getVisibleButtons()`) containing arrays of currently visible and hidden buttons, along with some meta-data.
       * @returns {undefined}
       */
      adjustMenuItemVisibility: function(items) {
        var iconDisplay = 'removeClass';

        if (!items) {
          items = this.getVisibleButtons();
        }

        function toggleClass($elem, doHide) {
          var elem = $elem[0],
            li = $elem.data('action-button-link').parent()[0],
            elemIsHidden = $elem.isHiddenAtBreakpoint();

          if (doHide) {
            li.classList.add('hidden');
            elem.classList.remove('is-overflowed');

            /*
            if (elem.classList.contains('btn-split-menu') && elem.classList.contains('btn-menu')) {
              $elem.last().last().removeClass('is-overflowed');
            }
            */
            return;
          }

          if (!elemIsHidden) {
            li.classList.remove('hidden');
          }
          elem.classList.add('is-overflowed');

          /*
          if (elem.classList.contains('btn-split-menu') && elem.classList.contains('btn-menu')) {
            $elem.last().last().addClass('is-overflowed');
          }
          */

          if ($elem.find('.icon').length) {
            iconDisplay = 'addClass';
          }
        }

        var i = 0;
        for (i; i < items.visible.length; i++) {
          toggleClass(items.visible[i], true);
        }
        for (i = 0; i < items.hidden.length; i++) {
          toggleClass(items.hidden[i], false);
        }

        var numIcons = 0;
        this.moreMenu.find('.icon').each(function () {
          if (!$(this).parent().parent().hasClass('hidden')) {
            numIcons ++;
          }
        });

        if (numIcons > 0) {
          iconDisplay = 'addClass';
        }

        this.moreMenu[iconDisplay]('has-icons');
      },

      /**
       * Detects whether or not a toolbar item is currently overflowed.  In general, toolbar items are considered overflow if their right-most edge sits past the right-most edge of the buttonset border.  There are some edge-cases.
       * @param {jQuery[]} item - the Toolbar item being tested.
       * @returns {boolean}
       */
      isItemOverflowed: function(item) {
        if (this.hasNoMoreButton()) {
          return false;
        }

        if (!item || item.length === 0) {
          return true;
        }

        // In cases where a Title is present and buttons are right-aligned, only show up to the maximum allowed.
        if (this.title.length && this.buttonsetItems.filter(':not(.hidden)').index(item) >= this.settings.maxVisibleButtons) { // Subtract one to account for the More Button
          // ONLY cause this to happen if there are at least two items that can be placed in the overflow menu.
          // This prevents ONE item from being present in the menu by itself
          //if (!this.buttonsetItems.last().is(item)) {
            //return true;
          //}
          return true;
        }

        if (this.buttonset.scrollTop() > 0) {
          this.buttonset.scrollTop(0);
        }

        // unwrap from jQuery
        if (item instanceof $ && item.length) {
          item = item[0];
        }

        var classList = item.classList,
          style = window.getComputedStyle(item);

        if (classList.contains('btn-actions')) {
          return true;
        }
        if (classList.contains('searchfield')) {
          return false;
        }
        if (style.display === 'none') {
          return true;
        }

        var isRTL = Locale.isRTL(),
          itemRect = item.getBoundingClientRect(),
          buttonsetRect = this.buttonset[0].getBoundingClientRect(),
          itemOutsideXEdge = isRTL ? (itemRect.left <= buttonsetRect.left) : (itemRect.right >= buttonsetRect.right),
          itemBelowYEdge = itemRect.bottom >= buttonsetRect.bottom;

        return (itemBelowYEdge === true || itemOutsideXEdge === true);
      },

      /**
       * Detection for this toolbar to have a More Button
       * @returns {boolean}
       */
      hasNoMoreButton: function() {
        return this.element[0].classList.contains('no-more-button');
      },

      /**
       * Determines whether or not the "more actions" button should be displayed.
       * @private
       * @returns {undefined}
       */
      toggleMoreMenu: function() {
        if (this.element.hasClass('no-actions-button')) {
          return;
        }

        var overflowItems = this.moreMenu.children('li:not(.separator)'),
          hiddenOverflowItems = overflowItems.not('.hidden');

        var method = 'removeClass';
        if (this.defaultMenuItems || hiddenOverflowItems.length > 0) {
          method = 'addClass';
        }

        this.element[method]('has-more-button');

        var popupAPI = this.more.data('popupmenu');
        if (method === 'removeClass') {
          if (!popupAPI) {
            return;
          }

          popupAPI.close();

          var menuItems = popupAPI.menu.find('li:not(.separator)').children('a'),
            shouldFocus = false;

          menuItems.add(this.more).each(function() {
            if (document.activeElement === this) {
              shouldFocus = true;
            }
          });

          if (shouldFocus) {
            this.getLastVisibleButton()[0].focus();
          }
        }
      },

      /**
       * Creates an `aria-label` attribute on the toolbar, for bettery accessibility
       * @private
       * @returns {undefined}
       */
      buildAriaLabel: function() {
        // Set up an aria-label as per AOL guidelines
        // http://access.aol.com/dhtml-style-guide-working-group/#toolbar
        if (!this.element.attr('aria-label')) {
          var isHeader = (this.element.closest('.header').length ===1),
            id = this.element.attr('id') || '',
            title = this.element.children('.title'),
            prevLabel = this.element.prev('label'),
            prevSpan = this.element.prev('.label'),
            labelText = isHeader ? $('header.header').find('h1').text() :
            title.length ? title.filter('div').text() :
            prevLabel.length ? prevLabel.text() :
            prevSpan.length ? prevSpan.text() : id + ' ' + Locale.translate('Toolbar');

          this.element.attr('aria-label', labelText.replace(/\s+/g,' ').trim());
        }
      },

      updated: function() {
        this
          .unbind()
          .teardown()
          .init();
      },

      /**
       * Enables the entire Toolbar component
       * @returns {undefined}
       */
      enable: function() {
        this.element.prop('disabled', false);
        this.items.prop('disabled', false);
        this.more.prop('disabled', false);
      },

      /**
       * Disables the entire Toolbar component
       * @returns {undefined}
       */
      disable: function() {
        this.element.prop('disabled', true);
        this.items.prop('disabled', true);
        this.more.prop('disabled', true).data('popupmenu').close();
      },

      /**
       * Removes currently associated event listeners from the Toolbar.
       * @private
       * @chainable
       * @returns {this}
       */
      unbind: function() {
        this.items
          .offTouchClick('toolbar')
          .off('keydown.toolbar click.toolbar focus.toolbar blur.toolbar');

        this.more.off('keydown.toolbar beforeopen.toolbar selected.toolbar');
        $('body').off('resize.toolbar-' + this.id);
        return this;
      },

      /**
       * Returns the Toolbar's internal markup to its original state.
       * @chainable
       * @returns {this}
       */
      teardown: function() {
        var self = this;

        if (this.title && this.title.length) {
          var dataTooltip = this.title.off('beforeshow.toolbar').data('tooltip');
          if (dataTooltip) {
            dataTooltip.destroy();
          }
        }

        this.moreMenu.children('li').each(function() {
          self.teardownMoreActionsMenuItem($(this), true);
        });
        return this;
      },

      /**
       * Tears down a More Actions Menu item.
       * @param {jQuery[]} item - the existing <li> from inside the More Actions menu.
       * @param {boolean} doRemove - if defined, causes the list item to be removed from the more actions menu.
       */
      teardownMoreActionsMenuItem: function(item, doRemove) {
        var self = this,
          li = $(item),
          a = li.children('a'),
          itemLink = a.data('original-button');

        a.off('updated.toolbar mousedown.toolbar click.toolbar touchend.toolbar touchcancel.toolbar recalculate-buttons.toolbar');

        var icons = li.find('.icon');
        if (icons.length) {
          icons.remove();
        }

        var submenuContainer;
        if (li.is('.submenu')) {
          submenuContainer = li.children('.wrapper').children('.popupmenu');
          submenuContainer.children('li').each(function(){
            self.teardownMoreActionsMenuItem($(this), true);
          });
        }

        if (itemLink && itemLink.length) {
          $.removeData(a[0], 'original-button');
          $.removeData(itemLink[0], 'action-button-link');
          a.remove();

          if (submenuContainer) {
            submenuContainer
              .off()
            .parent('.wrapper')
              .off()
              .remove();
          }

          if (doRemove) {
            li.remove();
          }
        }
      },

      /**
       * Destroys this Toolbar Component instance and completely disassociates it from its corresponding DOM Element.
       * @returns {undefined}
       */
      destroy: function() {
        this
          .unbind()
          .teardown();

        if (this.buttonset.children('.searchfield-wrapper').length) {
          var searchFields = this.buttonset.children('.searchfield-wrapper').children('.searchfield');
          if (searchFields.data('toolbarsearchfield')) {
            searchFields.data('toolbarsearchfield').destroy();
          }
        }

        /*
        // Remove split button wrappers
        if (this.splitButtonWrappers.length) {
          $.each(this.splitButtonWrappers, function(wrapper) {
            var els = wrapper.children().detach();
            els.insertAfter(wrapper);
            wrapper.remove();
          });
        }
        */

        if (this.more.length && this.more.data('popupmenu') !== undefined) {
          this.more.data('popupmenu').destroy();
        }

        this.element[0].classList.remove('do-resize');
        this.buttonset[0].style.width = '';
        if (this.title && this.title.length) {
          this.title[0].style.width = '';
        }

        this.element.removeAttr('role').removeAttr('aria-label');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Toolbar(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.
  var TOOLBARSEARCHFIELD_EXPAND_SIZE = 280,
    MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE = 450;

  $.fn.toolbarsearchfield = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'toolbarsearchfield',
        defaults = {
          clearable: true,
          collapsible: true,
          collapsibleOnMobile: true
        },
        settings = $.extend({}, defaults, options);

    /**
     * Searchfield Component Wrapper that extends normal Searchfield functionality and provides collapse/expand behavior.  For use inside of Toolbars.
     *
     * @class ToolbarSearchfield
     *
     * @param {boolean} clearable  &nbsp;-&nbsp;  If "true", provides an "x" button on the right edge that clears the field
     * @param {boolean} collapsible  &nbsp;-&nbsp;  If "true", allows the field to expand/collapse on larger breakpoints when focused/blurred respectively
     * @param {boolean} collapsibleOnMobile &nbsp;-&nbsp;  If true, overrides `collapsible` only on mobile settings.
     */
    function ToolbarSearchfield(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ToolbarSearchfield.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      /**
       * Creates and manages any markup the control needs to function.
       * @returns {this}
       */
      build: function() {
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = this.element.uniqueId('toolbar-searchfield');
        }

        // Build the searchfield element
        this.input = this.element;

        // If inside a toolbar, make sure to append it to the root toolbar element.
        this.toolbarParent = this.element.parents('.toolbar');
        this.containmentParent = this.toolbarParent;
        var moduleTabs = this.containmentParent.closest('.module-tabs');
        if (moduleTabs.length) {
          this.containmentParent = moduleTabs;
        }

        this.getToolbarElements();

        // Setup ARIA
        var label = this.element.attr('placeholder') || this.element.prev('label, .label').text().trim();
        if (!label || label === '') {
          label = Locale.translate('Keyword');
        }
        this.input.attr({
          'aria-label': label,
        });

        // Invoke Searchfield, pass settings on
        var sfSettings = $.extend({ 'noToolbarSearchfieldInvoke': true }, this.settings, $.fn.parseOptions(this.input[0]));
        this.input.searchfield(sfSettings);
        this.inputWrapper = this.input.parent();
        this.inputWrapper.addClass('toolbar-searchfield-wrapper');

        // Disable animation/transitions initially
        // For searchfields in "non-collapsible" mode, this helps with sizing algorithms.
        this.element.addClass('no-transition no-animation');
        this.inputWrapper.addClass('no-transition no-animation');

        if (sfSettings.categories) {
          this.categoryButton = this.inputWrapper.find('.searchfield-category-button');
        }

        // Add/remove the collapsible setting
        var collapsibleMethod = this.settings.collapsible ? 'removeClass' : 'addClass';
        this.inputWrapper[collapsibleMethod]('non-collapsible');

        this.xButton = this.inputWrapper.children('.icon.close');

        this.adjustOnBreakpoint();

        if (!this.settings.collapsible || !this.settings.collapsibleOnMobile) {
          this.inputWrapper.addClass('is-open');
        } else {
          this.inputWrapper.removeClass('is-open');
        }

        return this;
      },

      /**
       * TODO: Deprecate in 4.4.0
       * @private
       */
      handleDeactivationEvents: function() {
        return this.addDocumentDeactivationEvents();
      },

      /**
       * @private
       * Sets up event listeners that need to be handled at the global (document) level, since they deal
       * with general keystrokes.
       */
      addDocumentDeactivationEvents: function() {
        var self = this;

        $(document)
          .on('click.' + this.id, function(e) {
            self.handleOutsideClick(e);
          })
          .on('keydown.' + this.id, function(e) {
            self.handleOutsideKeydown(e);
          });
      },

      /**
       * @private
       * Removes global (document) level event handlers.
       */
      removeDocumentDeactivationEvents: function() {
        $(document).off('click.' + this.id + ' keydown.' + this.id);
      },

      /**
       * Detects whether or not the Toolbar Searchfield has focus.
       * @returns {boolean}
       */
      hasFocus: function() {
        return this.element.data('searchfield').hasFocus();
      },

      /**
       * Detects the existence of a "Categories" button added to the searchfield
       * @returns {boolean}
       */
      hasCategories: function() {
        var searchfieldAPI = this.input.data('searchfield');
        if (searchfieldAPI === undefined || typeof searchfieldAPI.hasCategories !== 'function') {
          return false;
        }

        return searchfieldAPI.hasCategories();
      },

      /**
       * Detects the existence of a "Go" button added to the main searchfield API
       * @returns {boolean}
       */
      hasGoButton: function() {
        var searchfieldAPI = this.input.data('searchfield');
        if (!searchfieldAPI || !searchfieldAPI.goButton || !searchfieldAPI.goButton.length) {
          return false;
        }

        return searchfieldAPI.hasGoButton();
      },

      /**
       * Handles the focus of the searchfield.
       */
      handleFocus: function() {
        if (this.isExpanded) {
          return;
        }

        this.inputWrapper.addClass('has-focus');
        this.expand(true);
      },

      /**
       * Triggers an artificial "blur" of the searchfield, resulting in a time-delayed collapse.
       * TODO: Deprecate in 4.4.0
       */
      handleFakeBlur: function(e) {
        return this.handleFocusOut(e);
      },

      /**
       * Handles the "focusout" event
       */
      handleFocusOut: function() {
        if (this.isFocused || !this.settings.collapsible) {
          return;
        }

        this.collapse();
      },

      /**
       * Detects whether or not an element is part of this instance of the Searchfield component
       * @param {HTMLElement} element
       * @returns {boolean}
       */
      isSearchfieldElement: function(element) {
        if ($.contains(this.inputWrapper[0], element)) {
          return true;
        }

        // Don't close if a category is being selected from a category menu
        if (this.categoryButton && this.categoryButton.length) {
          var menu = this.categoryButton.data('popupmenu').menu;
          if (menu.has(element).length) {
            return true;
          }
        }

        return false;
      },

      /**
       * Event Handler for dealing with global (document) level clicks.
       */
      handleOutsideClick: function(e) {
        var target = e.target;
        if (this.isSearchfieldElement(target)) {
          return;
        }

        $(document).off(this.outsideEventStr);
        this.collapse();
      },

      /**
       * Handles Keydown Events
       * @param {jQuery.Event} e - jQuery-wrapped Keydown event.
       */
      handleKeydown: function(e) {
        var key = e.which;

        if (key === 9) { // Tab
          return this.handleFocusOut(e);
        }
      },

      /**
       * Handles global (document) level keydown events that are established to help
       * collapse/de-highlight searchfields on a timer.
       * @param {jQuery.Event} e - jQuery-wrapped Keydown event
       */
      handleOutsideKeydown: function(e) {
        var key = e.which,
          target = e.target;

        if (key === 9 && !this.isSearchfieldElement(target)) {
          this.isFocused = false;
          return this.handleFocusOut(e);
        }
      },

      /**
       * Event Handler for the Popupmenu Component's custom `beforeopen` event.
       * @param {jQuery.Event} e - jQuery-wrapped `beforeopen` Event
       */
      handlePopupBeforeOpen: function(e, menu) {
        if (!menu) {
          return false;
        }

        if (!this.isOpen()) {
          this.categoryButton.focus();
          return false;
        }

        return true;
      },

      /**
       * Retrieves the distance between a left and right boundary.
       * Used on controls like Lookup, Contextual Panel, etc. to fill the space remaining in a toolbar.
       * @param {Number|jQuery[]} leftBoundary
       * @param {Number|jQuery[]} rightBoundary
       * @returns {Number}
       */
      getFillSize: function(leftBoundary, rightBoundary) {
        var leftBoundaryNum = 0,
          rightBoundaryNum = 0;

        function sanitize(boundary) {
          if (!boundary) {
            return 0;
          }

          // Return out if the boundary is just a number
          if (!isNaN(parseInt(boundary))) {
            return parseInt(boundary);
          }

          if (boundary instanceof jQuery) {
            if (!boundary.length) {
              return;
            }

            if (boundary.is('.title')) {
              boundary = boundary.next('.buttonset');
            }

            boundary = boundary[0];
          }

          return boundary;
        }

        function getEdgeFromBoundary(boundary, edge) {
          if (!isNaN(boundary)) {
            return (boundary === null || boundary === undefined) ? 0 : boundary;
          }

          if (!edge || typeof edge !== 'string') {
            edge = 'left';
          }

          var edges = ['left', 'right'];
          if ($.inArray(edge, edges) === -1) {
            edge = edges[0];
          }

          var rect;

          if (boundary instanceof HTMLElement || boundary instanceof SVGElement) {
            rect = boundary.getBoundingClientRect();
          }

          return rect[edge];
        }

        leftBoundary = sanitize(leftBoundary);
        rightBoundary = sanitize(rightBoundary);

        function whichEdge() {
          var e = 'left';
          if (leftBoundary === rightBoundary || ($(rightBoundary).length && $(rightBoundary).is('.buttonset'))) {
            e = 'right';
          }

          return e;
        }

        leftBoundaryNum = getEdgeFromBoundary(leftBoundary);
        rightBoundaryNum = getEdgeFromBoundary(rightBoundary, whichEdge());

        if (!leftBoundaryNum && !rightBoundaryNum) {
          return TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        var distance = rightBoundaryNum - leftBoundaryNum;

        // TODO: Remove this once we figure out how to definitively fix the searchfield sizing.
        // Toolbar Searchfield needs a way to demand that the parent toolbar increase the size of its buttonset
        // and decrease the size of its title under this condition -- currently there is no way.
        if (distance <= TOOLBARSEARCHFIELD_EXPAND_SIZE) {
          return TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        if (distance >= MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE) {
          return MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        return distance;
      },

      /**
       * @private
       */
      setClosedWidth: function() {
        var closedWidth = 0;

        // If the searchfield category button exists, change the width of the
        // input field on the inside to provide space for the (variable) size of the currently-selected
        // category (or categories)
        if ((this.categoryButton instanceof $) && this.categoryButton.length) {
          var buttonStyle = window.getComputedStyle(this.categoryButton[0]),
            buttonWidth = this.categoryButton.width(),
            buttonBorder = parseInt(buttonStyle.borderLeftWidth) * 2,
            buttonPadding = parseInt(buttonStyle.paddingLeft) + parseInt(buttonStyle.paddingRight);

            closedWidth = closedWidth + (buttonWidth + buttonBorder + buttonPadding + 4);
        }

        if (this.inputWrapper[0]) {
          this.inputWrapper[0].style.width = closedWidth + 'px';
        }
      },

      /**
       * @private
       */
      setOpenWidth: function() {
        var subtractWidth = 0;

        if (this.inputWrapper[0]) {
          this.inputWrapper[0].style.width = this.openWidth;
        }

        // If the searchfield category button exists, change the width of the
        // input field on the inside to provide space for the (variable) size of the currently-selected
        // category (or categories)
        if (this.hasCategories()) {
          var categoryButtonStyle = window.getComputedStyle(this.categoryButton[0]),
            categoryButtonWidth = this.categoryButton.width(),//parseInt(categoryButtonStyle.width),
            categoryButtonPadding = parseInt(categoryButtonStyle.paddingLeft) + parseInt(categoryButtonStyle.paddingRight),
            categoryButtonBorder = (parseInt(categoryButtonStyle.borderLeftWidth) * 2);

          subtractWidth = subtractWidth + (categoryButtonWidth + categoryButtonPadding + categoryButtonBorder);
        }

        if (this.hasGoButton()) {
          var goButton = this.element.data('searchfield').goButton,
            goButtonStyle = window.getComputedStyle(goButton[0]),
            goButtonWidth = goButton.width(),
            goButtonPadding = parseInt(goButtonStyle.paddingLeft) + parseInt(goButtonStyle.paddingRight),
            goButtonBorder = (parseInt(goButtonStyle.borderLeftWidth) * 2);

          subtractWidth = subtractWidth + (goButtonWidth + goButtonPadding + goButtonBorder);
        }

        if (subtractWidth > 0) {
          this.input[0].style.width = 'calc(100% - ' + subtractWidth + 'px)';
        }
      },

      /**
       * @private
       */
      calculateOpenWidth: function() {
        var buttonset = this.element.parents('.toolbar').children('.buttonset'),
          nextElem = this.inputWrapper.next(),
          width;

        // If small form factor, use the right edge
        if (nextElem.is('.title')) {
          nextElem = buttonset;
        }

        if (this.shouldBeFullWidth()) {
          width = '100%';

          if (this.toolbarParent.closest('.header').length) {
            width = 'calc(100% - 40px)';
          }
          if (this.toolbarParent.closest('.tab-container.module-tabs').length) {
            width = 'calc(100% - 1px)';
          }

          this.openWidth = width;
          return;
        }

        if (!buttonset.length) {
          return;
        }

        // Figure out boundaries
        // +10 on the left boundary reduces the likelyhood that the toolbar pushes other elements
        // into the spillover menu whenever the searchfield opens.
        var leftBoundary = buttonset.offset().left + 10;
        var rightBoundary = nextElem;

        // If the search input sits alone, just use the other side of the buttonset to measure
        if (!rightBoundary.length) {
          rightBoundary = buttonset.offset().left + 10 + buttonset.outerWidth(true);
        }

        width = this.getFillSize(leftBoundary, rightBoundary);
        this.openWidth = (width - 6) + 'px';
      },

      /**
       * Detects whether or not one of the components inside of this searchfield is the document's "active" element.
       * @returns {boolean}
       */
      isActive: function() {
        return this.inputWrapper.hasClass('active');
      },

      /**
       * Detects whether or not this searchfield instance is currently expanded.
       * @returns {boolean}
       */
      isOpen: function() {
        return this.inputWrapper.hasClass('is-open');
      },

      /**
       * Makes necessary adjustments to the DOM surrounding the Searchfield element to accommodate
       * breakpoint changes.
       */
      adjustOnBreakpoint: function() {
        // On smaller form-factor (tablet/phone)
        if (this.shouldBeFullWidth()) {

          this.inputWrapper.removeAttr('style');
          this.input.removeAttr('style');

          if (this.hasFocus()) {
            this.appendToParent();

            this.calculateOpenWidth();
            this.setOpenWidth();

            if (this.isExpanded) {
              return;
            }

            this.expand(true);
          } else {

            if (this.settings.collapsibleOnMobile === true && this.isExpanded) {
              this.collapse();
            }
          }

          return;
        }

        // On larger form-factor (desktop)
        this.appendToButtonset();

        if (!this.settings.collapsible) {
          this.calculateOpenWidth();
          this.setOpenWidth();

          if (!this.isExpanded) {
            this.expand();
            return;
          }
        }

        if (!this.hasFocus() && this.settings.collapsible === true && this.isExpanded) {
          this.collapse();
        }
      },

      /**
       * Angular may not be able to get these elements on demand so we need to be
       * able to call this during the expand method.
       * @private
       */
      getToolbarElements: function() {
        if (!(this.toolbarParent instanceof $) || !this.toolbarParent.length) {
          this.toolbarParent = this.element.parents('.toolbar');
        }

        this.buttonsetElem = this.toolbarParent.children('.buttonset')[0];
        if (this.toolbarParent.children('.title').length) {
          this.titleElem = this.toolbarParent.children('.title')[0];
        }
      },

      /**
       * Expands the Searchfield
       */
      expand: function(noFocus) {
        var self = this,
          notFullWidth = !this.shouldBeFullWidth();

        if (this.isActive()) {
          return;
        }

        var toolbarAPI = this.toolbarParent.data('toolbar'),
          toolbarSettings,
          containerSizeSetters;

        if (toolbarAPI) {
           toolbarSettings = this.toolbarParent.data('toolbar').settings;
        }

        if (this.buttonsetElem === undefined) {
          this.getToolbarElements();
        }

        // Places the input wrapper into the toolbar on smaller breakpoints
        if (!notFullWidth) {
          this.appendToParent();
        } else {
          // Re-adjust the size of the buttonset element if the expanded searchfield would be
          // too large to fit.
          var buttonsetWidth = parseInt(window.getComputedStyle(this.buttonsetElem).width),
            d = TOOLBARSEARCHFIELD_EXPAND_SIZE;

          if (buttonsetWidth < TOOLBARSEARCHFIELD_EXPAND_SIZE) {
            d = TOOLBARSEARCHFIELD_EXPAND_SIZE - buttonsetWidth;
          }

          var buttonsetElemWidth = buttonsetWidth + TOOLBARSEARCHFIELD_EXPAND_SIZE;
          containerSizeSetters = {
            buttonset: buttonsetElemWidth
          };
        }

        this.inputWrapper.addClass('active');
        this.addDocumentDeactivationEvents();

        // Don't continue if we shouldn't expand in a mobile setting.
        if (this.shouldExpandOnMobile()) {
          self.calculateOpenWidth();
          self.setOpenWidth();
          return;
        }

        if (!self.isOpen()) {
          self.inputWrapper.addClass('is-open');
          self.calculateOpenWidth();
          self.setOpenWidth();
        }

        if (!noFocus || Soho.env.os.name === 'ios') {
          self.input.focus();
        }

        // Recalculate the Toolbar Buttonset/Title sizes.
        var eventArgs = [];
        if (containerSizeSetters) {
          eventArgs.push(containerSizeSetters);
        }
        self.toolbarParent.triggerHandler('recalculate-buttons', eventArgs);

        self.inputWrapper.one($.fn.transitionEndName(), function() {
          if (!self.isFocused && self.hasFocus() && document.activeElement !== self.input[0]) {
            self.isFocused = true;
            self.input.focus();
          }

          self.toolbarParent.triggerHandler('recalculate-buttons', eventArgs);
          self.inputWrapper.triggerHandler('expanded');
          self.isExpanded = true;
        });

      },

      /**
       * Collapses the Searchfield
       */
      collapse: function() {
        var self = this,
          textMethod = 'removeClass';

        // Puts the input wrapper back where it should be if it's been moved due to small form factors.
        this.appendToButtonset();

        if (this.input.val().trim() !== '') {
          textMethod = 'addClass';
        }
        this.inputWrapper[textMethod]('has-text');

        self.inputWrapper.removeClass('active');
        if (!self.hasFocus()) {
          self.inputWrapper.removeClass('has-focus');
          self.isFocused = false;
        }

        // Return out without collapsing or handling callbacks for the `collapse` event if:
        // Searchfield is not collapsible in general -OR-
        // Searchfield is only collapsible on mobile, and we aren't below the mobile breakpoint
        if ((self.settings.collapsible === false && self.settings.collapsibleOnMobile === false) ||
           (self.settings.collapsible === false && self.settings.collapsibleOnMobile === true && !self.shouldBeFullWidth())) {
          return;
        }

        if (this.shouldExpandOnMobile()) {
          return;
        }

        this.inputWrapper.removeAttr('style');
        this.input.removeAttr('style');

        if (self.categoryButton && self.categoryButton.length) {
          self.categoryButton.data('popupmenu').close(false, true);
        }

        self.inputWrapper
          .removeClass('is-open')
          .triggerHandler('collapsed');

        self.removeDocumentDeactivationEvents();

        self.isExpanded = false;

        if (Soho.env.os.name === 'ios') {
          $('head').triggerHandler('enable-zoom');
        }

        self.inputWrapper.one($.fn.transitionEndName(), function() {
          self.toolbarParent.triggerHandler('recalculate-buttons');
        });
      },

      /**
       * If focused, we need to store a reference to the element with focus (searchfield, internal buttons, etc)
       * because once the element becomes removed from the DOM, focus is lost.
       * @private
       */
      saveFocus: function() {
        if (!this.hasFocus()) {
          return;
        }
        this.focusElem = document.activeElement;
      },

      /**
       * Restores focus to an element reference that was previously focused.
       * @private
       */
      restoreFocus: function() {
        if (!this.focusElem) {
          return;
        }

        this.focusElem.focus();
        this.focusElem = undefined;
      },

      /**
       * Appends this searchfield to the `containmentParent` element
       * Used when the small-form-factor searchfield needs to be established.
       * @private
       */
      appendToParent: function() {
        if (this.inputWrapper.parent().is(this.containmentParent)) {
          return;
        }

        this.saveFocus();

        this.elemBeforeWrapper = this.inputWrapper.prev();
        this.inputWrapper.detach().prependTo(this.containmentParent);
        Soho.utils.fixSVGIcons(this.inputWrapper);

        this.restoreFocus();
      },

      /**
       * Removes this searchfield from the `containmentParent` element, and places it back into the buttonset.
       * Used when the small-form-factor searchfield needs to be established.
       * @private
       */
      appendToButtonset: function() {
        if (!this.inputWrapper.parent().is(this.containmentParent)) {
          return;
        }

        this.saveFocus();

        if (!(this.elemBeforeWrapper instanceof $) || !this.elemBeforeWrapper.length) {
          this.inputWrapper.prependTo(this.toolbarParent.children('.buttonset'));
        } else {
          this.inputWrapper.detach().insertAfter(this.elemBeforeWrapper);
          this.elemBeforeWrapper = null;
        }

        this.removeDocumentDeactivationEvents();
        this.toolbarParent.triggerHandler('scrollup');
        Soho.utils.fixSVGIcons(this.inputWrapper);

        this.restoreFocus();
      },

      /**
       * Determines whether or not the full-size Searchfield should open over top of its sibling Toolbar elements.
       * @private
       * @returns {boolean}
       */
      shouldBeFullWidth: function() {
        var header = this.inputWrapper.closest('.header'),
          headerCondition = false;

        if (header.length) {
          headerCondition = header.width() < Soho.breakpoints.phone;
        }

        return headerCondition || Soho.breakpoints.isBelow('phone-to-tablet');
      },

      /**
       * Determines whether or not the Searchfield should expand on the Mobile breakpoint.
       * @private
       * @returns {boolean}
       */
      shouldExpandOnMobile: function() {
        if (this.settings.collapsible === true) {
          return false;
        }
        if (this.settings.collapsibleOnMobile === true) {
          return true;
        }
        return this.shouldBeFullWidth();
      },

      /**
       * Used when the control has its settings or structural markup changed.  Rebuilds key parts of the control that
       * otherwise wouldn't automatically update.
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
       * Enables the Searchfield
       */
      enable: function() {
        this.inputWrapper.addClass('is-disabled');
        this.input.prop('disabled', true);
      },

      /**
       * Disables the Searchfield
       */
      disable: function() {
        this.inputWrapper.removeClass('is-disabled');
        this.input.prop('disabled', false);
      },

      /**
       * Tears down events, properties, etc. and resets the control to "factory" state
       * @returns {this}
       */
      teardown: function() {
        this.inputWrapper.off('mousedown.toolbarsearchfield focusin.toolbarsearchfield keydown.toolbarsearchfield collapse.toolbarsearchfield');
        this.inputWrapper.find('.icon').remove();

        this.toolbarParent.off('navigate.toolbarsearchfield');
        this.element.off('blur.toolbarsearchfield');

        if (this.xButton && this.xButton.length) {
          this.xButton.remove();
        }

        // Used to determine if the "Tab" key was involved in switching focus to the searchfield.
        this.removeDocumentDeactivationEvents();
        $('body').off('resize.' + this.id);

        return this;
      },

      /**
       * Removes the entire control from the DOM and from this element's internal data
       * @param {boolean} dontDestroySearchfield - if true, will not pass through and destroy a linked instance of the Searchfield component.
       */
      destroy: function(dontDestroySearchfield) {
        this.teardown();

        // Destroy the linked Searchfield instance
        var sf = this.element.data('searchfield');
        if (!dontDestroySearchfield && sf && typeof sf.destroy === 'function') {
          sf.destroy(true);
        }

        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires ToolbarSearchfield#events
       * @param {Object} mousedown  &nbsp;-&nbsp; Fires when the searchfield is clicked (if enabled).
       * @param {Object} focusin  &nbsp;-&nbsp; Fires when the searchfield is focused.
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when a key is pressed inside of the searchfield.
       * @param {Object} collapse  &nbsp;-&nbsp; Fires when a `collapse` event is triggered externally on the searchfield.
       *
       * @param {Object} beforeopen  &nbsp;-&nbsp; Fires when a `beforeopen` event is triggered on the searchfield's optional categories menubutton.
       *
       * @param {Object} navigate  &nbsp;-&nbsp; Fires when a `navigate` event is triggered on the searchfield's parent toolbar.
       *
       * @param {Object} keydown  &nbsp;-&nbsp; Fires when a `keydown` event is triggered at the `document` level.
       * @param {Object} resize  &nbsp;-&nbsp; Fires when a `resize` event is triggered at the `body` level.
       */
      handleEvents: function() {
        var self = this;

        this.element.on('cleared.toolbarsearchfield', function() {
          self.element.addClass('active is-open has-focus');
          self.isFocused = true;
        });

        this.inputWrapper.on('mousedown.toolbarsearchfield', function() {
          self.fastExpand = true;
        }).on('focusin.toolbarsearchfield', function(e) {
          self.handleFocus(e);
        }).on('keydown.toolbarsearchfield', function(e) {
          self.handleKeydown(e);
        }).on('collapse.toolbarsearchfield', function() {
          self.collapse();
        }).on('reanimate.toolbarsearchfield', function() {
          self.element.removeClass('no-transition no-animation');
          self.inputWrapper.removeClass('no-transition no-animation');
        });

        if (this.categoryButton && this.categoryButton.length) {
          this.categoryButton.on('beforeopen.toolbarsearchfield', function(e, menu) {
            return self.handlePopupBeforeOpen(e, menu);
          });
        }

        this.toolbarParent.on('navigate.toolbarsearchfield', function() {
          if (!self.hasFocus()) {
            self.collapse();
          }
        });

        $('body').on('resize.' + this.id, function() {
          self.adjustOnBreakpoint();
        });
        self.adjustOnBreakpoint();

        if (Soho.env.os.name === 'ios') {
          this.element.on('blur.toolbarsearchfield', function() {
            $('head').triggerHandler('disable-zoom');
          });
        }

        return this;
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ToolbarSearchfield(this, settings));
      }
    });
  };


  $.fn.tooltip = function(options, args) {
    'use strict';

    // Settings and Options
    var pluginName = 'tooltip',
      defaults = {
        content: null,
        offset: {top: 10, left: 10},
        placement: 'top',
        trigger: 'hover',
        title: null,
        beforeShow: null,
        popover: null ,
        closebutton: null,
        isError: false,
        isErrorColor: false,
        tooltipElement: null,
        parentElement: null,
        keepOpen: false,
        extraClass: null,
        placementOpts: {},
        maxWidth: null
      };

    /**
     * Tooltip and Popover Control
     * @constructor
     * @param {Object} element
     * @param {Object|Function} options
     * @param {(string|Function)} [options.content] - Takes title attribute or feed content. Can be a string or jQuery markup
     * @param {Object} [options.offset={top: 10, left: 10}] - How much room to leave
     * @param {string} [options.placement=top|bottom|right|offset]
     * @param {string} [options.trigger=hover] - supports click and immediate and hover (and maybe in future focus)
     * @param {string} [options.title] - Title for Infor Tips
     * @param {string} [options.beforeShow] - Call back for ajax tooltip
     * @param {string} [options.popover] - force it to be a popover (no content)
     * @param {string} [options.closebutton] - Show X close button next to title in popover
     * @param {Boolean} [options.isError=false] - Add error classes
     * @param {Boolean} [options.isErrorColor=false] - Add error color only not description
     * @param {string} [options.tooltipElement] - ID selector for an alternate element to use to contain the tooltip classes
     * @param {Object} [options.parentElement=this.element] - jQuery-wrapped element that gets passed to the 'place' behavior as the element to place the tooltip against.
     * @param {Boolean} [options.keepOpen=false] - Forces the tooltip to stay open in situations where it would normally close.
     * @param {string} [options.extraClass] - Extra css class
     * @param {string} [options.maxWidth] - Toolip max width
     */
    function Tooltip(element, options) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Tooltip.prototype = {
      init: function() {
        this.setup();
        this.appendTooltip();

        // Initial Content Setting.
        // Don't do this if we're using an "immediate" trigger because _setContent()_ is handled at
        // display time in that case.
        var shouldRender = this.settings.trigger !== 'immediate';
        if (shouldRender) {
          this.setContent(this.settings.content, true);
        }

        this.handleEvents();
      },


      setup: function() {
        // "this.activeElement" is the target element that the Tooltip will display itself against
        this.activeElement = this.settings.parentElement instanceof $ && this.settings.parentElement.length ? this.settings.parentElement : this.element;

        this.descriptionId = $('.tooltip-description').length + 1;
        this.description = this.element.parent().find('.tooltip-description');
        if (!this.description.length && this.settings.isError) {
          this.description = $('<span id="tooltip-description-'+ this.descriptionId +'" class="tooltip-description audible"></span>').insertAfter(this.element);
        }

        if (this.element.is('.dropdown, .multiselect')) {
          this.activeElement = this.element.nextAll('.dropdown-wrapper:first').find('>.dropdown');
        }

        var titleAttr = this.element.attr('title');
        if ((!this.settings.popover && titleAttr && titleAttr.length) || (!this.settings.popover && this.settings.title)) {
          this.settings.content = this.settings.title ? this.settings.title : titleAttr;
          this.element.removeAttr('title');
        }

        this.isPopover = (this.settings.content !== null && typeof this.settings.content === 'object') || this.settings.popover === true;

        this.settings.closebutton = (this.settings.closebutton || this.element.data('closebutton')) ? true : false;

        if (this.element.data('extraClass') && this.element.data('extraClass').length) {
          this.settings.extraClass = this.element.data('extraClass');
        }

        this.isRTL = Locale.isRTL();
      },

      addAria: function() {
        if (!this.content) {
          return;
        }

        this.description.text(this.content);
        this.content = this.addClassToLinks(this.content, 'links-clickable');

        if (!this.isPopover) {
          this.element.removeAttr('title').attr('aria-describedby', this.description.attr('id'));
        }

        if (this.isPopover && this.settings.trigger === 'click') {
          this.element.attr('aria-haspopup', true);
        }
      },

      addClassToLinks: function(content, thisClass) {
        var isjQuery = (content instanceof $ && content.length > 0);
        if (isjQuery) {
          return content;
        }

        var d = $('<div/>').html(content);
        $('a', d).addClass(thisClass);
        return d.html();
      },

      appendTooltip: function() {
        this.tooltip = this.settings.tooltipElement ? $(this.settings.tooltipElement) : $('#tooltip');
        if (!this.tooltip.length) {
          var name = (this.settings.tooltipElement ? this.settings.tooltipElement.substring(1, this.settings.tooltipElement.length) : 'tooltip');
          this.tooltip = $('<div class="' + (this.isPopover ? 'popover' : 'tooltip') + ' bottom is-hidden" role="tooltip" id="' + name + '"><div class="arrow"></div><div class="tooltip-content"></div></div>');
        }

        this.tooltip.place({
          container: this.scrollparent,
          parent: this.activeElement,
          placement: this.settings.placement,
          strategy: 'flip'
        });

        this.setTargetContainer();
      },

      handleEvents: function() {
        var self = this, timer, delay = 400;

        if (this.settings.trigger === 'hover' && !this.settings.isError) {
          ((this.element.is('.dropdown, .multiselect')) ? this.activeElement : this.element)
            .on('mouseenter.tooltip', function() {
              timer = setTimeout(function() {
                self.show();
              }, delay);
            })
            .on('mouseleave.tooltip mousedown.tooltip click.tooltip mouseup.tooltip', function() {
                clearTimeout(timer);
                setTimeout(function() {
                  self.hide();
                }, delay);
            })
            .on('updated.tooltip', function() {
              self.updated();
            });
        }

        function toggleTooltipDisplay() {
          if (!self.tooltip.hasClass('is-hidden')) {
            self.hide();
          } else {
            self.show();
          }
        }

        if (this.settings.trigger === 'click') {
          this.element.on('click.tooltip', function() {
            toggleTooltipDisplay();
          });
        }

        if (this.settings.trigger === 'immediate') {
          timer = setTimeout(function() {
            toggleTooltipDisplay();
          }, 1);
        }

        // Uncomment the line below to get focus support on some elements all the time, regardless of trigger setting.
        //var isFocusable = (this.element.filter('button, a').length && this.settings.trigger !== 'click') || this.settings.trigger === 'focus';
        var isFocusable = this.settings.trigger === 'focus';
        if (isFocusable) {
          this.element.on('focus.tooltip', function() {
            self.show();
          })
          .on('blur.tooltip', function() {
            if (!self.settings.keepOpen) {
              self.hide();
            }
          });
        }

        // Close the popup/tooltip on orientation changes (but not when keyboard is open)
        $(window).on('orientationchange.tooltip', function() {
          // Match every time.
          if (self.tooltip.hasClass('is-hidden')) {
            return;
          }
          self.close();
        }, false);

      },

      setContent: function(content, dontRender) {
        var self = this,
          specified,
          settingsContent = this.settings.content,
          noIncomingContent = (content === undefined || content === null),
          noSettingsContent = (settingsContent === undefined || settingsContent === null);

        function doRender() {
          if (dontRender === true) {
            return;
          }
          self.addAria();
          self.render();
        }

        // If all sources of content are undefined, just return false and don't show anything.
        if (noIncomingContent && noSettingsContent) {
          return false;
        }

        // If the settingsContent type is a function, we need to re-run that function to update the content.
        // NOTE: If you need to use a function to generate content, understand that the tooltip/popover will not
        // cache your content for future reuse.  It will ALWAYS override incoming content.
        if (typeof settingsContent === 'function') {
          content = settingsContent;
        }

        // Use the pre-set content if we have no incoming content
        if (noIncomingContent) {
          content = settingsContent;
        }

        // If the incoming/preset content is exactly the same as the stored content, don't continue with this step.
        // Deep object comparison for jQuery objects is done further down the chain.
        if (content === this.content) {
          doRender();
          return true;
        }

        // jQuery-wrapped elements don't get manipulated.
        // Simply store the reference, render, and return.
        if (content instanceof $ && content.length) {
          this.content = content.addClass('hidden');
          doRender();
          return true;
        }

        // Handle setting of content based on its Object type.
        // If type isn't handled, the tooltip will not display.
        if (typeof content === 'string') {
          if (!content.length) {
            return false;
          }

          // Could be a translation definition
          content = Locale.translate(content, true) || content;

          // Could be an ID attribute
          // If it matches an element already on the page, grab that element's content and store the reference only.
          if (content.indexOf('#') === 0) {
            var contentCheck = $('' + content);
            if (contentCheck.length) {
              this.content = contentCheck;
              doRender();
              return true;
            }
            return false;
          }

        // functions
        } else if (typeof content === 'function') {
          var callbackResult = content.call(this.element);
          if (!callbackResult || typeof callbackResult !== 'string' || !callbackResult.length) {
            return false;
          }
          content = callbackResult;

        // if type isn't handled, return false
        } else {
          return false;
        }

        // Store an internal copy of the processed content
        this.content = $.sanitizeHTML(content);

        // Wrap tooltip content in <p> tags if there isn't already one present.
        // Only happens for non-jQuery markup.
        if (!specified) {
          this.content = '<p>' + this.content + '</p>';
        }

        doRender();
        return true;
      },

      render: function() {
        if (this.isPopover) {
          return this.renderPopover();
        }
        return this.renderTooltip();
      },

      renderTooltip: function() {
        var titleArea = this.tooltip[0].querySelectorAll('.tooltip-title')[0],
          contentArea = this.tooltip[0].querySelectorAll('.tooltip-content')[0],
          extraClass = this.settings.extraClass,
          content = this.content,
          tooltip = this.tooltip[0],
          classes = 'tooltip is-hidden';

        if (extraClass) {
          classes += ' ' + extraClass;
        }
        tooltip.setAttribute('class', classes);

        if (titleArea) {
          titleArea.style.display = 'none';
        }

        if (!contentArea.previousElementSibling.classList.contains('arrow')) {
          contentArea.insertAdjacentHTML('beforebegin', '<div class="arrow"></div>');
        }

        if (typeof this.content === 'string') {
          contentArea.innerHTML = content;
        } else {
          contentArea.innerHTML = content[0].innerHTML;
        }
      },

      renderPopover: function() {
        var self = this,
          extraClass = this.settings.extraClass,
          content = this.content,
          contentArea = this.tooltip.find('.tooltip-content'),
          title = this.tooltip[0].querySelector('.tooltip-title'),
          classes = 'popover is-hidden';

        if (extraClass) {
          classes += ' ' + extraClass;
        }

        this.tooltip[0].setAttribute('class', classes);

        if (typeof content === 'string') {
          content = $(content);
          contentArea.html(content);
          contentArea.find('.hidden').removeClass('hidden');
        } else {
          contentArea.html(content);
        }

        if (!this.settings.placementOpts) {
          this.settings.placementOpts = {};
        }

        if (!this.settings.placementOpts.parent) {
          this.settings.placementOpts.parent = this.element;
        }

        content[0].classList.remove('hidden');
        contentArea[0].firstElementChild.classList.remove('hidden');

        var popoverWidth = this.settings.content.width();
        var parentWidth = this.settings.placementOpts.parent.width();

        if (Locale.isRTL()) {
          this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'left' : 'right';
        } else {
          this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'right' : 'left';
        }

        if (this.settings.title !== null) {
          if (!title) {
            var titleFrag = document.createDocumentFragment();
            title = document.createElement('div');
            title.innerHTML = this.settings.title;
            title.classList.add('tooltip-title');
            titleFrag.appendChild(title);
            this.tooltip[0].insertBefore(titleFrag, this.tooltip[0].firstChild);
          } else {
            title.style.display = '';
            title.childNodes[0].nodeValue = this.settings.title;
          }
        } else {
          if(title) {
            title.style.display = 'none';
          }
        }

        if (this.settings.closebutton && title && !title.firstElementChild) {
          var closeBtnX = $(
            '<button type="button" class="btn-icon l-pull-right" style="margin-top: -9px">' +
              $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
              '<span>Close</span>' +
            '</button>'
          ).on('click', function() {
            self.hide();
          });

          title.appendChild(closeBtnX[0]);
        }

        content.initialize();
      },

      // Alias for _show()_.
      open: function() {
        return this.show();
      },

      show: function(newSettings, ajaxReturn) {
        var self = this;
        this.isInPopup = false;

        if (newSettings) {
          this.settings = $.extend({}, this.settings, newSettings);
        }

        if (this.settings.beforeShow && !ajaxReturn) {
          var response = function (content) {
            self.show({content: content}, true);
          };

          if (typeof this.settings.beforeShow === 'string') {
            window[this.settings.beforeShow](response);
            return;
          }

          this.settings.beforeShow(response);
          return;
        }

        var okToShow = true;

        okToShow = this.setContent(this.content);
        if (okToShow === false) {
          return;
        }

        okToShow = this.element.triggerHandler('beforeshow', [this.tooltip]);
        if (okToShow === false) {
          return;
        }

        this.tooltip[0].setAttribute('style', '');
        this.tooltip[0].classList.add(this.settings.placement);


        if (this.settings.isError || this.settings.isErrorColor) {
          this.tooltip[0].classList.add('is-error');
        }

        this.position();
        Soho.utils.fixSVGIcons(this.tooltip);
        this.element.trigger('show', [this.tooltip]);

        setTimeout(function () {
          $(document).on('mouseup.tooltip', function (e) {
            var target = $(e.target);

            if (self.settings.isError || self.settings.trigger === 'focus') {
             return;
            }

            if (target.is(self.element) && target.is('svg.icon')) {
              return;
            }

            if ($('#editor-popup').length && $('#colorpicker-menu').length) {
              return;
            }

            if (target.closest('.popover').length === 0 &&
                target.closest('.dropdown-list').length === 0) {
              self.hide(e);
            }
          })
          .on('keydown.tooltip', function (e) {
            if (e.which === 27 || self.settings.isError) {
              self.hide();
            }
          });

          if (self.settings.isError &&
              !self.element.is(':visible, .dropdown') &&
              self.element.is('[aria-describedby]')) {
            self.hide();
          }

          if (window.orientation === undefined) {
            $('body').on('resize.tooltip', function() {
              self.hide();
            });
          }

          // Hide on Page scroll
          $('body').on('scroll.tooltip', function() {
            self.hide();
          });

          self.element.closest('.modal-body-wrapper').on('scroll.tooltip', function() {
            self.hide();
          });

          self.element.closest('.scrollable').on('scroll.tooltip', function() {
            self.hide();
          });

          self.element.closest('.datagrid-body').on('scroll.tooltip', function() {
            self.hide();
          });

          // Click to close
          if (self.settings.isError) {
            self.tooltip.on('click.tooltip', function () {
              self.hide();
            });
          }
          self.element.trigger('aftershow', [self.tooltip]);
        }, 400);

      },

      // Places the tooltip element itself in the correct DOM element.
      // If the current element is inside a scrollable container, the tooltip element goes as high as possible in the DOM structure.
      setTargetContainer: function() {
        var targetContainer = $('body');

        // adjust the tooltip if the element is being scrolled inside a scrollable DIV
        this.scrollparent = this.element.closest('.page-container.scrollable');
        if (this.scrollparent.length) {
          targetContainer = this.scrollparent;
        }

        if (this.settings.parentElement) {
          targetContainer = this.settings.parentElement;
        }

        //this.tooltip.detach().appendTo(targetContainer);
        targetContainer[0].appendChild(this.tooltip[0]);
      },

      // Placement behavior's "afterplace" handler.
      // DO NOT USE FOR ADDITIONAL POSITIONING.
      handleAfterPlace: function(e, placementObj) {
        this.tooltip.data('place').setArrowPosition(e, placementObj, this.tooltip);
        this.tooltip.triggerHandler('tooltipafterplace', [placementObj]);
      },

      position: function () {
        this.setTargetContainer();
        this.tooltip[0].classList.remove('is-hidden');

        var self = this,
          distance = this.isPopover ? 20 : 10,
          tooltipPlacementOpts = this.settings.placementOpts || {},
          opts = $.extend({}, {
            x: 0,
            y: distance,
            container: this.scrollparent,
            containerOffsetX: tooltipPlacementOpts.containerOffsetX || this.settings.offset.left,
            containerOffsetY: tooltipPlacementOpts.containerOffsetY || this.settings.offset.top,
            parent: tooltipPlacementOpts.parent || this.activeElement,
            placement: tooltipPlacementOpts.placement || this.settings.placement,
            strategies: ['flip', 'nudge']
          }, tooltipPlacementOpts);

        if (opts.placement === 'left' || opts.placement === 'right') {
          opts.x = distance;
          opts.y = 0;
        }

        this.tooltip.one('afterplace.tooltip', function(e, placementObj) {
          self.handleAfterPlace(e, placementObj);
        });

        this.tooltip.data('place').place(opts);
        return this;
      },

      // Alias for _hide()_ that works with the global _closeChildren()_ method.
      close: function() {
        return this.hide();
      },

      hide: function() {
        if (this.settings.keepOpen) {
          return;
        }

        if (this.isInPopup) {
          this.settings.content.addClass('hidden');
          return;
        }

        this.tooltip[0].classList.add('is-hidden');
        this.tooltip[0].style.left = '';
        this.tooltip[0].style.top = '';
        this.tooltip.find('.arrow').removeAttr('style');

        this.detachOpenEvents();

        if ($('.popover').not('.is-hidden').length === 0) {
          $(document).off('mouseup.tooltip keydown.tooltip');
          $('body').off('resize.tooltip');
        }

        this.element.trigger('hide', [this.tooltip]);
      },

      updated: function() {
        var self = this;

        if (self.settings.trigger === 'immediate') {
          setTimeout(function() {
            self.show();
          }, 100);
        } else {
          self.setContent();
        }

        return this;
      },

      detachOpenEvents: function () {

        this.tooltip.off('click.tooltip');
        $(document).off('mouseup.tooltip');
        $('body').off('resize.tooltip scroll.tooltip');
        this.element.closest('.modal-body-wrapper').off('scroll.tooltip');
        this.element.closest('.scrollable').off('scroll.tooltip');
        this.element.closest('.datagrid-body').off('scroll.tooltip');

      },

      teardown: function() {
        this.description.remove();
        this.descriptionId = undefined;
        this.activeElement = undefined;

        this.element.removeAttr('aria-describedby').removeAttr('aria-haspopup');
        if (!this.tooltip.hasClass('is-hidden')) {
          this.hide();
        }

        if (this.tooltip && this.tooltip.data('place')) {
          this.tooltip.data('place').destroy();
        }

        this.element.off('mouseenter.tooltip mouseleave.tooltip mousedown.tooltip click.tooltip mouseup.tooltip updated.tooltip focus.tooltip blur.tooltip');
        this.detachOpenEvents();

        $(window).off('orientationchange.tooltip');

        return this;
      },

      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {

      var instance = $.data(this, pluginName);

      //Allow one tooltip and one popover
      if (instance /*&& (instance.settings.popover == null || instance.settings.popover !== settings.popover)*/) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }

        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();

        return;
      }

      instance = $.data(this, pluginName, new Tooltip(this, options));
    });
  };

  // Popover & Tooltip are the same control
  $.fn.popover = $.fn.tooltip;


  //TODO: - Context Menus
  //      - Search
  $.fn.tree = function(options) {

    /**
     * @class {Tree}
     *
     * @param {string} selectable &nbsp;-&nbsp; 'single' or 'multiple'
     * @param {boolean} hideCheckboxes &nbsp;-&nbsp; Only applies when `selectable` is set to 'multiple'.
     * @param {null|string} menuId &nbsp;-&nbsp; if defined, will be used to identify a Context Menu by ID attribute in which to add nodes.
     * @param {boolean} useStepUI &nbsp;-&nbsp; if `true`, turns this tree instance into a "Stepped" tree.
     * @param {string} folderIconOpen &nbsp;-&nbsp; the icon used when a tree folder node is open.
     * @param {string} folderIconClosed &nbsp;-&nbsp; the icon used when a tree folder node is closed.
     * @param {boolean} sortable &nbsp;-&nbsp; if `true`, allows nodes to become sortable.
     * @param {null|function} onBeforeSelect &nbsp;-&nbsp; if defined as a function, fires that function as a callback before the selection on a node occurs.
     */
    var pluginName = 'tree',
      defaults = {
        selectable: 'single', // ['single'|'multiple']
        hideCheckboxes: false, // [true|false] -apply only with [selectable: 'multiple']
        menuId: null, //Context Menu to add to nodes
        useStepUI: false, // When using the UI as a stepped tree
        folderIconOpen: 'open-folder',
        folderIconClosed: 'closed-folder',
        sortable: false, // Allow nodes to be sortable
        onBeforeSelect: null
      },
      settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tree(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Tree Methods
    Tree.prototype = {

      /**
       * @private
       * @returns {undefined}
       */
      init: function() {
        this.settings = $.extend({}, settings);
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');
        this.initTree();
        this.handleKeys();
        this.setupEvents();

        if (this.loadData(this.settings.dataset) === -1) {
          this.syncDataset(this.element);
          this.initSelected();
          this.focusFirst();
          this.attachMenu(this.settings.menuId);
          this.createSortable();
        }
      },

      /**
       * Init Tree from ul, li, a markup structure in DOM
       */
      initTree: function() {
        var self = this,
          s = this.settings,
          links = this.element.find('a'),
          selectableAttr = this.element.attr('data-selectable');

        // Set attribute "data-selectable"
        s.selectable = ((typeof selectableAttr !== 'undefined') &&
         (selectableAttr.toLowerCase() === 'single' ||
           selectableAttr.toLowerCase() === 'multiple')) ?
            selectableAttr : s.selectable;

        // Set isMultiselect and checkboxes show/hide
        this.isMultiselect = s.selectable === 'multiple';
        s.hideCheckboxes = s.hideCheckboxes || !this.isMultiselect;

        this.element.addClass(this.isMultiselect ? ' is-muliselect' : '');

        links.each(function() {
          var a = $(this);
          self.decorateNode(a);
        });
      },

      /**
       * Init selected notes
       */
      initSelected: function () {
        var self = this;
        this.element.find('li').each(function() {
          self.setNodeStatus($('a:first', this));
        });
      },

      /**
       * Focus the first tree node
       */
      focusFirst: function () {
        this.element.find('a:first').attr('tabindex', '0');
      },

      /**
       * Set focus
       * @param {jQuery[]} node
       */
      setFocus: function (node) {
        node.focus().removeClass('hide-focus');
      },

      /**
       * From the LI, Read props and add stuff
       * @param {jQuery[]} a - an anchor tag reference wrapped in a jQuery object.
       */
      decorateNode: function(a) {
        var subNode,
        parentCount = 0,
        badgeData = a.attr('data-badge'),
        alertIcon = a.attr('data-alert-icon'),
        badge = {elem: $('<span class="tree-badge badge"></span>')},
        isParentsDisabled = a.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0,
        isDisabled = a.hasClass('is-disabled') || isParentsDisabled;

        if (typeof badgeData !== 'undefined') {
          badgeData = $.fn.parseOptions(a, 'data-badge');
        }

        //set initial 'role', 'tabindex', and 'aria selected' on each link (except the first)
        a.attr({'role': 'treeitem', 'tabindex': '-1', 'aria-selected': 'false'});

        // Add Aria disabled
        if (isDisabled) {
          a.addClass('is-disabled').attr('aria-disabled','true');
          var childSection = a.next();

          if (childSection.is('ul.is-open')) {
            $('a', childSection).addClass('is-disabled').attr('aria-disabled','true');
            $('ul', a.parent()).addClass('is-disabled');
          }
        }

        //parentCount 'aria-level' to the node's level depth
        parentCount = a.parentsUntil(this.element, 'ul').length - 1;
        a.attr('aria-level', parentCount + 1);

        //Set the current tree item node position relative to its aria-setsize
        var posinset = a.parent().index();
        a.attr('aria-posinset', posinset + 1);

        //Set the current tree item aria-setsize
        var listCount = a.closest('li').siblings().addBack().length;
        a.attr('aria-setsize', listCount);

        //Set the current tree item node expansion state
        if (a.next('ul').children().length > 0) {
          a.attr('aria-expanded', a.next().hasClass('is-open') ? 'true' : 'false');
        }

        //adds role=group' to all subnodes
        subNode = a.next();

        //Inject Icons
        var text = a.contents().filter(function() {
          return !$(this).is('.tree-badge');// Do not include badge text
        }).text();

        a.text('');
        if (a.children('svg.icon-tree').length === 0) {
          a.prepend($.createIcon({ icon: 'tree-node', classes: ['icon-tree'] }));

          if (this.settings.useStepUI) {
            a.prepend($.createIcon({ icon: alertIcon, classes: ['step-alert', 'icon-' + alertIcon] }));
          }
        }

        //Inject checkbox
        if (this.isMultiselect && !this.settings.hideCheckboxes) {
          a.append('<span class="tree-checkbox"></span>');
        }

        //Inject badge
        if (badgeData && !badgeData.remove) {
          badge.text = '';

          if (typeof badgeData.text !== 'undefined') {
            badge.text = badgeData.text.toString();
            badge.elem.html(badge.text);
            if (badge.text.length === 1) {
              badge.elem.addClass('round');
            }
          }

          var badgeStyle = '';
          if (/info|good|error|alert|pending/i.test(badgeData.type)) {
            badge.elem.addClass(badgeData.type);
          } else if (badgeData.type && badgeData.type.charAt(0) === '#' && badgeData.type.length === 7) {
            badgeStyle = 'background-color: ' + badgeData.type + ' !important;';
          }
          if (badgeData.backColor) {
            badgeStyle = 'background-color: ' + badgeData.backColor + ' !important;';
          }
          if (badgeData.foreColor) {
            badgeStyle += 'color: ' + badgeData.foreColor + ' !important;';
          }

          badge.elem.attr('style', badgeStyle);

          if (badge.elem.text() !== '') {
            a.append(badge.elem);
          }
          if (badgeData.type && badgeData.type.indexOf('pending') !== -1) {
            badge.elem.text('');
          }
        }

        a.append($('<span class="tree-text"></span>').text(text));

        if (a.is('[class^="icon"]')) {
          //createIconPath
          this.setTreeIcon(a.find('svg.icon-tree'), a.attr('class'));
        }

        if (subNode.is('ul')) {
          subNode.attr('role', 'group').parent().addClass('folder');
          this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);

          if (a.attr('class') && a.attr('class').indexOf('open') === -1 && a.attr('class').indexOf('closed') === -1) {
            a.attr('class', isDisabled ? 'is-disabled' : '');
            this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);
          }

          if (a.is('[class^="icon"]')) {
            this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ?  a.attr('class') : a.attr('class').replace('open', 'closed') );
          }
        }

        a.addClass('hide-focus');
        a.hideFocus();
      },

      /**
       * Sets the correct icon to use on a particular SVG element.
       * @param {jQuery[]} svg - an SVG element reference wrapped in a jQuery object
       * @param {string} icon - the ID of a Soho Icon type.
       */
      setTreeIcon: function(svg, icon) {
        // Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
        var iconStr = icon.replace(/#?icon-|hide-focus|\s?/gi, '');
        svg.changeIcon(iconStr);
      },

      /**
       * Expands a collection of tree nodes.
       * @param {jQuery[]} nodes - a jQuery-wrapped collection of tree node elements.  If left undefined, this will automatically use all `ul[role=group]` elements.
       */
      expandAll: function(nodes) {
        var self = this;
        nodes = nodes || this.element.find('ul[role=group]');

        nodes.each(function () {
          var node = $(this);
          node.addClass('is-open');
          self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconOpen);

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class'));
          }

        });
      },

      /**
       * Collapses a collection of tree nodes.
       * @param {jQuery[]} nodes - a jQuery-wrapped collection of tree node elements.  If left undefined, this will automatically use all `ul[role=group]` elements.
       */
      collapseAll: function (nodes) {
        var self = this;
        nodes = nodes || this.element.find('ul[role=group]');

        nodes.each(function () {
          var node = $(this);
          node.removeClass('is-open');
          self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconClosed);

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('a').find('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed').replace(' hide-focus', '').replace(' is-selected', '') );
          }

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed'));
          }

        });
      },

      /**
       * Check if an object is an instance of a jQuery object
       * @param {Object} obj - the object being tested.
       * @returns {boolean}
       */
      isjQuery: function (obj) {
        // TODO: Move this to a Soho utility object?
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      /**
       * Selects a tree node specifically using it's ID attribute.
       * @param {string} id - the ID string to use.
       */
      selectNodeById: function (id) {
        this.selectNodeByJquerySelector('#'+ id);
      },

      /**
       * Selects a tree node by [jquery selector] -or- [jquery object]
       * @param {string|jQuery[]} selector - uses a string that represents a jQuery-wrapped element's ID attribute, or a jQuery-wrapped reference to the element itself.
       */
      selectNodeByJquerySelector: function (selector) {
        var target = this.isjQuery(selector) ? selector : $(selector);
        if (target.length && !target.is('.is-disabled')) {
          var nodes = target.parentsUntil(this.element, 'ul[role=group]');
          this.expandAll(nodes);
          this.selectNode(target, true);
        }
      },

      /**
       * Deselects a tree node
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} focus - if defined, causes the node to become focused.
       */
      unSelectedNode: function (node, focus) {
        if (node.length === 0) {
          return;
        }

        var self = this,
          aTags = $('a', this.element);

        aTags.attr('tabindex', '-1');
        node.attr('tabindex', '0');

        $('a:not(.is-disabled)', node.parent()).attr('aria-selected', 'false').parent().removeClass('is-selected');

        this.syncNode(node);
        this.setNodeStatus(node);

        if (focus) {
          node.focus();
        }

        // Set active css class
        $('li', self.element).removeClass('is-active');
        node.parent().addClass('is-active');

        setTimeout(function() {
          var jsonData = node.data('jsonData') || {};
          self.element.triggerHandler('unselected', {node: node, data: jsonData});
        }, 0);
      },

      /**
       * Selects a tree node
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} focus - if defined, causes the node to become focused.
       */
      selectNode: function (node, focus) {
        var self = this;

        if (node.length === 0) {
          return;
        }

        // Possibly Call the onBeforeSelect
        var result;
        if (typeof self.settings.onBeforeSelect === 'function') {

          result = self.settings.onBeforeSelect(node);

          if (result.done && typeof result.done === 'function') { // A promise is returned
            result.done(function(continueSelectNode) {
              if (continueSelectNode) {
                self.selectNodeFinish(node, focus);
              }
            });
          } else if (result) { // Boolean is returned instead of a promise
            self.selectNodeFinish(node, focus);
          }

        } else { // No Callback specified
          self.selectNodeFinish(node, focus);
        }
      },

      /**
       * ?
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} focus - if defined, causes the node to become focused.
       */
      selectNodeFinish: function(node, focus) {
        var self = this;
        var aTags = $('a', this.element);
        aTags.attr('tabindex', '-1');
        node.attr('tabindex', '0');

        if (this.isMultiselect) {
          $('a:not(.is-disabled)', node.parent())
            .attr('aria-selected', 'true').parent().addClass('is-selected');
        }
        else {
          aTags.attr('aria-selected', 'false').parent().removeClass('is-selected');
          aTags.attr('aria-selected', 'false').removeClass('is-selected');
          node.attr('aria-selected', 'true').parent().addClass('is-selected');
        }

        this.syncNode(node);
        if (!this.loading) {
          this.setNodeStatus(node);
        }

        if (focus) {
          node.focus();
        }

        // Set active css class
        $('li', self.element).removeClass('is-active');
        node.parent().addClass('is-active');

        setTimeout(function() {
          var jsonData = node.data('jsonData') || {};
          self.element.triggerHandler('selected', {node: node, data: jsonData});
        }, 0);
      },

      /**
       * Deselects a tree node
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       */
      setNodeStatus: function(node) {
        var self = this,
          data = node.data('jsonData'),
          nodes;

        // Not multiselect
        if (!this.isMultiselect) {
          node.removeClass('is-selected is-partial');
          if (data && data.selected) {
            node.addClass('is-selected');
          }
          return;
        }

        var setStatus = function (nodes, isFirstSkipped) {
          nodes.each(function() {
            var node = $('a:first', this),
              parent = node.parent(),
              status = self.getSelectedStatus(node, isFirstSkipped);

            if (status === 'mixed') {
              parent.removeClass('is-selected is-partial').addClass('is-partial');
            }
            else if (status) {
              parent.removeClass('is-selected is-partial').addClass('is-selected');
            }
            else {
              parent.removeClass('is-selected is-partial');
            }
            self.syncNode(node);
          });
        };

        // Multiselect
        var isFirstSkipped = false;
        nodes = node.parent().find('li.folder');
        setStatus(nodes, isFirstSkipped);

        isFirstSkipped = (!nodes.length && data && !data.selected) ? false : true;
        nodes = node.parentsUntil(this.element, 'li.folder');
        setStatus(nodes, isFirstSkipped);
      },

      /**
       * Get's a tree node's current 'selected' status
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       * @param {boolean} isFirstSkipped - ?
       */
      getSelectedStatus: function(node, isFirstSkipped) {
        var status,
          total = 0,
          selected = 0,
          unselected = 0,
          data;

        node.parent().find('a').each(function(i) {
          if (isFirstSkipped && i === 0) {
            return;
          }
          total++;
          data = $(this).data('jsonData');
          if (data && data.selected) {
            selected++;
          } else {
            unselected++;
          }
        });

        status = ((total === selected) ? true : ((total === unselected) ? false : 'mixed'));
        return status;
      },

      /**
       * Changes a node's selected status to its opposite form.
       * @param {jQuery[]} node - a jQuery-wrapped element reference to a tree node.
       */
      toggleNode: function(node) {
        var next = node.next(),
          self = this;

        if (next.is('ul[role="group"]')) {
          if (next.hasClass('is-open')) {

            self.setTreeIcon(node.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconClosed);

            if (node.closest('.folder a').is('[class^="icon"]')) {
              self.setTreeIcon(node.closest('.folder a').find('svg.icon-tree'),
                node.closest('.folder a').attr('class').replace('open', 'closed').replace(' hide-focus', '').replace(' is-selected', ''));
            }

            self.isAnimating = true;

            if (!self.isMultiselect) {
              self.unSelectedNode(node.parent().find('li.is-selected'), false);
              node.removeClass('is-selected');
            }

            next.one('animateclosedcomplete', function() {
              next.removeClass('is-open');
              self.isAnimating = false;
            }).animateClosed();

            node.attr('aria-expanded', node.attr('aria-expanded')!=='true');



          } else {
            var nodeData = node.data('jsonData');

            if (self.settings.source && nodeData.children && nodeData.children.length === 0) {
              var response = function (nodes) {
                var id = nodeData.id,
                elem = self.findById(id);

                //Add DB and UI nodes
                elem.children = nodes;
                self.addChildNodes(elem, node.parent());
                node.removeClass('is-loading');
                self.loading = false;

                //open
                self.openNode(next, node);

                //sync data on node
                nodeData.children = nodes;
                node.data('jsonData', nodeData);
                self.selectNode(node, true);
                self.initSelected();
              };

              var args = {node: node, data: node.data('jsonData')};
              self.settings.source(args, response);
              node.addClass('is-loading');
              self.loading = true;

              return;
            }
            self.openNode(next, node);
          }
        }
      },

      //Open the node
      openNode: function(next, node) {
        var self = this;

        self.setTreeIcon(node.closest('.folder').addClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconOpen);

        if (node.is('[class^="icon"]')) {
          self.setTreeIcon(node.find('svg.icon-tree'), node.attr('class').replace(' hide-focus', '').replace(' is-selected', ''));
        }

        self.isAnimating = true;

        next.one('animateopencomplete', function() {
          self.isAnimating = false;
        }).addClass('is-open').css('height', 0).animateOpen();
        node.attr('aria-expanded', node.attr('aria-expanded')!=='true');
      },

      //Setup event handlers
      setupEvents: function () {
        var self = this;
        self.element.on('updated.tree', function () {
          self.initTree();
        });
      },

      //Handle Keyboard Navigation
      handleKeys: function () {

        //Key Behavior as per: http://access.aol.com/dhtml-style-guide-working-group/#treeview
        var self = this;
        //on click give clicked element 0 tabindex and 'aria-selected=true', resets all other links
        this.element.on('click.tree', 'a:not(.is-clone)', function (e) {
          var target = $(this),
            parent = target.parent();
          if (!target.is('.is-disabled, .is-loading')) {
            if (self.isMultiselect) {
              if ($(e.target).is('.icon') && parent.is('.folder')) {
                self.toggleNode(target);
              }
              else if (parent.is('.is-selected, .is-partial')) {
                self.unSelectedNode(target, true);
              }
              else {
                self.selectNode(target, true);
              }
            }
            else {
              self.selectNode(target, true);
              self.toggleNode(target);
            }
            e.stopPropagation();
          }
          return false; //Prevent Click from Going to Top
        });

        this.element
        //Focus on "a" elements
        .on('focus.tree', 'a', function() {
          var target = $(this);
          if ((parseInt(target.attr('aria-level')) === 0) &&
              (parseInt(target.attr('aria-posinset')) === 1)) {

            // First element if disabled
            if (target.hasClass('is-disabled')) {
              var e = $.Event('keydown.tree');
              e.keyCode = 40; // move down
              target.trigger(e);
              return;
            }
          }
        });

        //Handle Up/Down Arrow Keys and Space
        this.element.on('keydown.tree', 'a', function (e) {

          var charCode = e.charCode || e.keyCode,
              target = $(this),
              next, prev;

          if (self.isAnimating) {
            return;
          }

          //down arrow
          if (charCode === 40) {
            var nextNode = self.getNextNode(target);
            self.setFocus(nextNode);
          }

          //up arrow,
          if (charCode === 38) {
            var prevNode = self.getPreviousNode(target);
            self.setFocus(prevNode);
          }

          //space
          if (e.keyCode === 32) {
            target.trigger('click.tree');
          }

          // Left arrow
          if (charCode === 37) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                prev = target.next().find('a:first');
                self.setFocus(prev);
              } else {
                self.toggleNode(target);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                self.toggleNode(target);
              } else {
                prev = target.closest('.folder').find('a:first');
                self.setFocus(prev);
              }
            }
            e.stopPropagation();
            return false;
          }

          // Right arrow
          if (charCode === 39) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                self.toggleNode(target);
              } else {
                next = target.closest('.folder').find('a:first');
                self.setFocus(next);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                next = target.next().find('a:first');
                self.setFocus(next);
              } else {
                self.toggleNode(target);
                self.setFocus(target);
              }

            }
            e.stopPropagation();
            return false;
          }

          //Home  (fn-right on mac)
          if (charCode === 36) {
            next = self.element.find('a:first:visible');
            self.setFocus(next);
          }

          //End (fn-right on mac)
          if (charCode === 35) {
            next = self.element.find('a:last:visible');
            self.setFocus(next);
          }

        });

        //Handle Left/Right Arrow Keys
        this.element.on('keypress.tree', 'a', function (e) {
          var charCode = e.charCode || e.keyCode,
            target = $(this);

          if ((charCode >= 37 && charCode <= 40) || charCode === 32) {
            e.stopPropagation();
            return false;
          }

          //Printable Chars Jump to first high level node with it...
           if (e.which !== 0) {
            target.closest('li').nextAll().find('a:visible').each(function () {
              var node = $(this),
                first = node.text().substr(0,1).toLowerCase(),
                term = String.fromCharCode(e.which).toLowerCase();

              if (first === term) {
                self.setFocus(node);
                return false;
              }
            });
          }

        });
      },

      //handle Loading JSON
      loadData: function (dataset) {
        var self = this;
        if (!dataset) {
          return -1;
        }

        self.element.empty();

        self.loading = true;
        for (var i = 0; i < dataset.length; i++) {
          self.addNode(dataset[i], 'bottom');
        }
        self.loading = false;

        self.syncDataset(self.element);
        self.initSelected();
        self.focusFirst();
        self.attachMenu(self.settings.menuId);
        self.createSortable();
      },

      //Functions to Handle Internal Data Store
      addToDataset: function (node, location) {
        var elem;

        if (node.parent) {
          elem = this.findById(node.parent);
        }

        if (location === 'bottom' && !node.parent && !elem) {
          this.settings.dataset.push(node);
        }

        if (location === 'top' && !node.parent && !elem) {
          this.settings.dataset.unshift(node);
        }

        if (node.parent && elem) {

          if (!elem.children) {
            elem.children = [];
          }

          if (location === 'bottom') {
            elem.children.push(node);
          } else {
            elem.children.unshift(node);
          }
        }

        return ((node.parent && !elem) ? false : true);
      },

      //Find the Node (Dataset) By Id
      findById: function (id, source) {
        var key,
          self = this;

        if (!source) {
          source = this.settings.dataset;
        }

        for (key in source) {
            var item = source[key];
            if (item.id === id) {
              return item;
            }

            if (item.children) {
              var subresult = self.findById(id, item.children);

              if (subresult) {
                return subresult;
              }
            }
        }
        return null;
      },

      // Get node by ID if selected
      getNodeByIdIfSelected: function (id, source) {
        var node = this.findById(id, source);
        return (node && node.selected) ? node : null;
      },

      // Get selected nodes
      getSelectedNodes: function () {
        var node, data,
          selected = [];

        $('li.is-selected', this.element).each(function() {
          node = $('a:first', this);
          data = node.data('jsonData');
          selected.push({'node': node, 'data': data});
        });
        return selected;
      },

      getNextNode: function(target) {
        var next = target.parent().next().find('a:first'),
          subTarget = target.next();

        //Move Into Children
        if (subTarget.is('ul.is-open')) {
          next = subTarget.find('a:first');
        }

        //skip disabled
        if (next.hasClass('is-disabled')) {
          next = next.parent().next().find('a:first');
        }

        //bottom of a group..{l=1000: max folders to be deep }
        if (next.length === 0) {
          for (var i = 0, l = 1000, closest = target; i < l; i++) {
            closest = closest.parent().closest('.folder');
            next = closest.next().find('a:first');
            if (next.length) {
              break;
            }
          }
        }

        //another check for disabled
        if (next.hasClass('is-disabled')) {
          next = this.getNextNode(next);
        }

        return next;
      },

      getPreviousNode: function(target) {
        var prev = target.parent().prev().find('a:first'),
          subTarget = prev.parent();

        //move into children at bottom
        if (subTarget.is('.folder.is-open') &&
            subTarget.find('ul.is-open a').length &&
            !subTarget.find('ul.is-disabled').length) {
          prev = subTarget.find('ul.is-open a:last');
        }

        //skip disabled
        if (prev.hasClass('is-disabled')) {
          prev = prev.parent().prev().find('a:first');

          //another check if get to prev open folder
          subTarget = prev.parent();
          if (subTarget.is('.folder.is-open') &&
              subTarget.find('ul.is-open a').length &&
              !subTarget.find('ul.is-disabled').length) {
            prev = subTarget.find('ul.is-open a:last');
          }
        }

        //top of a group
        if (prev.length === 0) {
          prev = target.closest('ul').prev('a');
        }

        //another check for disabled
        if (prev.hasClass('is-disabled')) {
          prev = this.getPreviousNode(prev);
        }

        return prev;
      },


      //Sync the tree with the underlying dataset
      syncDataset: function (node) {

        var json = [],
          self = this;

        node.children('li').each(function () {
          var elem = $(this),
            tag = elem.find('a:first');

          var entry = self.syncNode(tag);
          json.push(entry);

        });

        this.settings.dataset = json;
      },

      //Sync a node with its dataset 'record'
      syncNode: function (node) {
        var entry = {},
          self = this,
          jsonData = node.data('jsonData');

        entry.node = node;
        entry.id = node.attr('id');
        entry.text = node.find('.tree-text').text();

        if (node.hasClass('is-open')) {
          entry.open = true;
        }

        if (node.attr('href')) {
          entry.href = node.attr('href');
        }

        if (node.parent().is('.is-selected')) {
          entry.selected = true;
        }

        //icon
        var clazz = node.attr('class');
        if (clazz && clazz.indexOf('icon') > -1) {
          entry.icon = node.attr('class');
        }

        if (node.next().is('ul')) {
          var ul = node.next();
          entry.children = [];

          ul.children('li').each(function () {
            var elem = $(this),
              tag = elem.find('a:first');

            entry.children.push(self.syncNode(tag));
          });
        }

        if (jsonData) {
          delete jsonData.selected;
          entry = $.extend({}, jsonData, entry);
        }

        node.data('jsonData', entry);
        return entry;
      },

      // Add a node and all its related markup
      addNode: function (nodeData, location) {
        var li = $('<li></li>'),
          a = $('<a href="#"></a>').appendTo(li),
          badgeAttr = typeof nodeData.badge === 'object' ? JSON.stringify(nodeData.badge) : nodeData.badge;

        location = (!location ? 'bottom' : location); //supports button or top or jquery node

        a.attr({
          'id': nodeData.id,
          'href': nodeData.href,
          'data-badge': badgeAttr,
          'data-alert-icon': nodeData.alertIcon
        }).text(nodeData.text);

        if (nodeData.open) {
          a.parent().addClass('is-open');
        }

        if (nodeData.disabled) {
          a.addClass('is-disabled');
        }

        if (nodeData.icon) {
          a.addClass(nodeData.icon);
        }

        //Handle Location
        var found = this.loading ? true : this.addToDataset(nodeData, location);

        if (nodeData.parent instanceof jQuery) {
          found = true;
        }

        if (location instanceof jQuery && (!nodeData.parent || !found) && !(nodeData.parent instanceof jQuery)) {
          location.append(li);
          found = true;
        }

        if (location === 'bottom' && (!nodeData.parent || !found)) {
          this.element.append(li);
        }

        if (location === 'top' && (!nodeData.parent || !found)) {
          this.element.prepend(li);
        }

        // Support ParentId in JSON Like jsTree
        if (nodeData.parent) {

          if (found && typeof nodeData.parent === 'string') {
            li = this.element.find('#'+nodeData.parent).parent();

            if (!nodeData.disabled && li.is('.is-selected') && typeof nodeData.selected === 'undefined') {
              nodeData.selected = true;
            }
            this.addAsChild(nodeData, li);
          }

          if (nodeData.parent && nodeData.parent instanceof jQuery) {
            li = nodeData.parent;
            if (nodeData.parent.is('a')) {
              li = nodeData.parent.parent();
            }
            this.addAsChild(nodeData, li);
          }
          nodeData.node = li.find('ul li a#'+ nodeData.id);

        } else {
          this.addChildNodes(nodeData, li);
          nodeData.node = li.children('a').first();
        }

        this.decorateNode(a);

        if (nodeData.selected) {
          this.selectNode(a, nodeData.focus);
        }

        a.data('jsonData', nodeData);
        return li;
      },

      //Add a node to an exiting node, making it a folder if need be
      addAsChild: function (nodeData, li) {
        var ul = li.find('ul').first();
        if (ul.length === 0) {
          ul = $('<ul></ul>').appendTo(li);
          ul.addClass('folder');
        }

        ul.addClass(nodeData.open ? 'is-open' : '');
        this.decorateNode(li.find('a').first());

        nodeData.parent = '';
        this.addNode(nodeData, ul);
      },

      //Add the children for the specified node element
      addChildNodes: function (nodeData, li) {
        var self = this,
          ul = li.find('ul');

        if (!nodeData.children) {
          ul.remove();
          return;
        }

        if (ul.length === 0) {
          ul = $('<ul></ul>').appendTo(li);
          ul.addClass(nodeData.open ? 'is-open' : '');
          ul.addClass('folder');
        }

        ul.empty();

        if (nodeData.children) {
          for (var i = 0; i < nodeData.children.length; i++) {
            var elem = nodeData.children[i];
            self.addNode(elem, ul);
          }
        }
      },

      // Check for true value
      isTrue: function(v) {
        return (typeof v !== 'undefined' && v !== null && ((typeof v === 'boolean' && v === true) || (typeof v === 'string' && v.toLowerCase() === 'true')));
      },

      // Check for false value
      isFalse: function(v) {
        return (typeof v !== 'undefined' && v !== null && ((typeof v === 'boolean' && v === false) || (typeof v === 'string' && v.toLowerCase() === 'false')));
      },

      //Update fx rename a node
      updateNode: function (nodeData) {
        //Find the node in the dataset and ui and sync it
        var elem = this.findById(nodeData.id);

        //Passed in the node element
        if (nodeData.node) {
          elem = {};
          elem.node = nodeData.node;
        }

        if (!elem) {
          return;
        }

        var parent = elem.node.parent(),
          isDisabled = this.isTrue(nodeData.disabled) || this.isFalse(nodeData.enabled),
          isEnabled = this.isTrue(nodeData.enabled) || this.isFalse(nodeData.disabled);

        // Update badge
        if (nodeData.badge) {
          var badge = elem.node.find('.tree-badge:first');
          // Add badge if not exists
          if (!badge.length && !nodeData.badge.remove) {
            if (!nodeData.badge.remove && typeof nodeData.badge.text !== 'undefined' && $.trim(nodeData.badge.text) !== '') {
              $('<span class="tree-badge badge"></span>').insertBefore(elem.node.find('.tree-text:first'));
              badge = elem.node.find('.tree-badge:first');
            }
          }
          // Make update changes
          if (badge.length) {
            if (typeof nodeData.badge.text !== 'undefined') {
              nodeData.badge.text = nodeData.badge.text.toString();
              badge.text(nodeData.badge.text).removeClass('round');
              if (nodeData.badge.text.length === 1) {
                badge.addClass('round');
              }
            }
            if (typeof nodeData.badge.type !== 'undefined') {
              badge.removeClass('info good error alert pending');
              if (/info|good|error|alert|pending/i.test(nodeData.badge.type)) {
                badge.addClass(nodeData.badge.type);
              } else if (nodeData.type && nodeData.badge.type.charAt(0) === '#' && nodeData.badge.type.length === 7) {
                badge.elem.css('background-color', nodeData.badge.type);
              }

              if (nodeData.badge.type.indexOf('pending') !== -1) {
                badge.text('');
              }
            }
            elem.badge = nodeData.badge;

            //Remove badge
            if (this.parseBool(nodeData.badge.remove)) {
              badge.remove();
              if (typeof elem.badge !== 'undefined') {
                delete elem.badge;
              }
            }
          }
        }

        if (nodeData.text) {
          elem.node.find('.tree-text').first().text(nodeData.text);
          elem.text = nodeData.text;
        }

        if (nodeData.icon) {
          this.setTreeIcon(elem.node.find('svg.icon-tree').first(), nodeData.icon);
          elem.icon = nodeData.icon;
        }

        if (isDisabled) {
          elem.node.addClass('is-disabled').attr('aria-disabled','true');

          if (parent.is('.folder.is-open')) {
            $('a, ul[role=group]', parent).addClass('is-disabled').attr('aria-disabled','true');
          }
        }

        if (isEnabled) {
          var isParentsDisabled = elem.node.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;

          if (!isParentsDisabled) {
            elem.node.removeClass('is-disabled').removeAttr('aria-disabled');

            if (parent.is('.folder.is-open')) {
              $('a, ul[role=group]', parent).removeClass('is-disabled').removeAttr('aria-disabled');
            }
          }
        }

        if (nodeData.node) {
          this.syncDataset(this.element);
        }

        if (nodeData.children) {
          if (nodeData.children.length) {
            this.addChildNodes(nodeData, parent);
          }
          else {
            this.removeChildren(nodeData, parent);
          }
        }

      },

      // Performs the usual Boolean coercion with the exception of
      // the strings "false" (case insensitive) and "0"
      parseBool: function(b) {
        return !(/^(false|0)$/i).test(b) && !!b;
      },

      // Delete children nodes
      removeChildren: function (nodeData, li) {
        var ul = li.find('ul');

        this.setTreeIcon(li.find('svg.icon-tree').first(), (nodeData.icon || 'icon-tree-node'));
        li.removeClass('folder is-open');
        ul.remove();
      },

      //Delete a node from the dataset or tree
      removeNode: function (nodeData) {
        var elem = this.findById(nodeData.id);

        if (nodeData instanceof jQuery) {
          elem = nodeData;
          elem.parent().remove();
        } else if (elem) {
          elem.node.parent().remove();
        }

        if (!elem) {
          return;
        }
        this.syncDataset(this.element);
      },

      //Attach Context Menus
      attachMenu: function (menuId) {
        var self = this;

        if (!menuId) {
          return;
        }

        this.element.off('contextmenu.tree').on('contextmenu.tree', 'a', function (e) {
          var node = $(this);
          e.preventDefault();

          $(e.currentTarget).popupmenu({menuId: menuId, eventObj: e, trigger: 'immediate', attachToBody: true}).off('selected').on('selected', function (e, args) {
            self.element.triggerHandler('menuselect', {node: node, item: args});
          });

          self.element.triggerHandler('menuopen', {menu: $('#' +menuId), node: node});
          return false;
        });

      },

      // Create sortable
      createSortable: function() {
        if (!this.settings.sortable) {
          return;
        }

        var self = this,
          clone, interval, doDrag;

        self.targetArrow = self.element.prev('.tree-drag-target-arrow');
        self.linkSelector = 'a:not(.is-dragging-clone, .is-disabled)';

        if (!self.targetArrow.length) {
          $('<div class="tree-drag-target-arrow"></div>').insertBefore(self.element);
          self.targetArrow = self.element.prev('.tree-drag-target-arrow');
        }

        function isReady() {
          // Make sure all dynamic nodes sync
          if (!self.loading) {
            clearInterval(interval);

            $(self.linkSelector, self.element).each(function() {
              var a = $(this);

              // Don't drag with folder icon, save for toggle nodes
              a.on('mousedown.tree', function(e) {
                e.preventDefault();
                doDrag = (e.which === 3) ? false : // 3 - Right mouse button clicked
                  ($(e.target).is('.icon') ? !a.parent().is('.folder') : true);
              })

              // Invoke drag
              .drag({
                clone: true,
                cloneAppendTo: a.closest('li'),
                clonePosIsFixed: true
              })

              // Drag start =======================================
              .on('dragstart.tree', function (e, pos, thisClone) {
                if (!thisClone || !doDrag) {
                  a.removeClass('is-dragging');
                  if (thisClone) {
                    thisClone.remove();
                  }
                  return;
                }
                clone = thisClone;
                clone.removeAttr('id').addClass('is-dragging-clone');
                clone.find('.tree-checkbox, .tree-badge').remove();

                self.sortable = {
                  // Do not use index from each loop, get updated index on drag start
                  startIndex: $(self.linkSelector, self.element).index(a),
                  startNode: a,
                  startIcon: $('svg.icon-tree', a).getIconName(),
                  startUl: a.closest('ul'),
                  startFolderNode: a.closest('ul').prev('a'),
                  startWidth: a.outerWidth()
                };

                e.preventDefault();
                e.stopImmediatePropagation();
              })

              // While dragging ===================================
              .on('drag.tree', function (e, pos) {
                if (!clone) {
                  return;
                }
                clone[0].style.left = pos.left + 'px';
                clone[0].style.top = pos.top + 'px';
                clone[0].style.opacity = '1';
                self.setDragOver(clone, pos);
              })

              // Drag end =========================================
              .on('dragend.tree', function (e, pos) {
                self.targetArrow.hide();
                $(self.linkSelector, self.element).removeClass('is-over');

                if (!clone || !self.sortable.overDirection) {
                  return;
                }
                clone[0].style.left = pos.left + 'px';
                clone[0].style.top = pos.top + 'px';

                var start = self.sortable.startNode.parent(),
                  end = self.sortable.overNode.parent();

                // Over
                if (self.sortable.overDirection === 'over') {
                  if (!end.is('.folder')) {
                    self.convertFileToFolder(self.sortable.overNode);
                  }
                  $('ul:first', end).append(start);
                  if (!end.is('.is-open')) {
                    self.toggleNode(self.sortable.overNode);
                  }
                }

                // Up
                else if (self.sortable.overDirection === 'up') {
                  start.insertBefore(end);
                }
                // Down
                else if (self.sortable.overDirection === 'down') {
                  if (end.is('.is-open')) {
                    $('ul:first', end).prepend(start);
                  }
                  else {
                    start.insertAfter(end);
                  }
                }

                // Restore file type
                if ($('li', self.sortable.startUl).length === 0 &&
                  !!self.sortable.startFolderNode.data('oldData') &&
                    self.sortable.startFolderNode.data('oldData').type === 'file') {
                  self.convertFolderToFile(self.sortable.startFolderNode);
                }

                // Fix: On windows 10 with IE-11 icons disappears
                if (self.isIe11) {
                  start.find('.icon-tree').each(function() {
                    var svg = $(this);
                    self.setTreeIcon(svg, svg.find('use').attr('xlink:href'));
                  });
                }

                // Sync dataset and ui
                self.syncDataset(self.element);
                if (self.isMultiselect) {
                  self.initSelected();
                }

              });
            });

          }
        }
        // Wait for make sure all dynamic nodes sync
        interval = setInterval(isReady, 10);
      },

      // Set actions while drag over
      setDragOver: function(clone, pos) {
        var self = this,
          treeRec = self.element[0].getBoundingClientRect(),
          extra = 20,
          exMargin, isParentsStartNode, isBeforeStart, isAfterSttart,
          li, a, ul, links, rec, i, l, left, top, direction, doAction,

          // Set as out of range
          outOfRange = function() {
            self.sortable.overNode = null;
            self.sortable.overIndex = null;
            self.sortable.overDirection = null;

            self.targetArrow.hide();
            self.setTreeIcon($('svg.icon-tree', clone), 'icon-cancel');
          };

        // Moving inside tree
        if (pos.top > (treeRec.top - extra) &&
            pos.top < (treeRec.bottom + extra) &&
            pos.left > (treeRec.left - extra - self.sortable.startWidth) &&
            pos.left < (treeRec.left + treeRec.height + extra)) {

          links = $(self.linkSelector, self.element);
          extra = 2;

          for (i = 0, l = links.length; i < l; i++) {
            direction = null;
            rec = links[i].getBoundingClientRect();

            // Moving on/around node range
            if (pos.top > rec.top - extra && pos.top < rec.bottom + extra) {
              a = $(links[i]);

              // Moving on/around node has parents as same node need to rearrange
              // Cannot rearrange parents to child
              isParentsStartNode = !!a.parentsUntil(self.element, '.folder')
                .filter(function() {
                  return $('a:first', this).is(self.sortable.startNode);
                }).length;
              if (isParentsStartNode) {
                outOfRange();
                continue;
              }

              li = a.parent();
              left = rec.left;
              ul = a.closest('ul');
              exMargin = parseInt(li[0].style.marginTop, 10) > 0 ? 2 : 0;
              isBeforeStart = ((i-1) === self.sortable.startIndex && ul.is(self.sortable.startUl));
              isAfterSttart = ((i+1) === self.sortable.startIndex && ul.is(self.sortable.startUl));
              links.removeClass('is-over');

              // Apply actions
              doAction = function() {
                if (!direction) {
                  outOfRange();
                  return;
                }

                // Reset icon
                self.setTreeIcon($('svg.icon-tree', clone), self.sortable.startIcon);

                // Over
                if (direction === 'over') {
                  self.targetArrow.hide();
                  if (!a.is('.is-disabled')) {
                    a.addClass('is-over');
                  }
                }
                // Up -or- Down
                else {
                  links.removeClass('is-over');
                  top = (direction === 'up') ?
                    (rec.top - 1.5 - (li.is('.is-active') ? 3 : 0)) :
                    (rec.bottom + (li.next().is('.is-active') ? -1 : 1.5) + exMargin);
                  self.targetArrow[0].style.left = left + 'px';
                  self.targetArrow[0].style.top = top + 'px';
                  self.targetArrow.show();
                }

                // Set changes
                self.sortable.overNode = a;
                self.sortable.overIndex = i;
                self.sortable.overDirection = direction;
              };

              // Set moveing directions
              if (i !== self.sortable.startIndex) {
                // If hover on link
                if (pos.left > rec.left - extra - self.sortable.startWidth &&
                  pos.left < rec.right + extra) {
                  if (!isBeforeStart && pos.top < rec.top) {
                    direction = 'up';
                  }
                  else if (!isAfterSttart && pos.top > rec.top + (extra * 2)) {
                    direction = 'down';
                  }
                  else {
                    direction = 'over';
                  }
                }
                // Not hover on link
                else {
                  if (!isBeforeStart && pos.top < rec.top) {
                    direction = 'up';
                  }
                  else if (!isAfterSttart) {
                    direction = 'down';
                  }
                }
              }
              doAction(direction);
            }
          }

        }
        else {
          // Out side from tree area
          outOfRange();
        }
      },

      // Convert file node to folder type
      convertFileToFolder: function(node) {
        var newFolder = $('<ul role="group"></ul>'),
          oldData = {
            icon: $('svg.icon-tree', node).getIconName(),
            type: 'file'
          };
        if (node.is('[class^="icon"]')) {
          var iconClass = node.attr('class').replace(' hide-focus', '').replace(' is-selected', '');
          oldData.iconClass = iconClass;
          node.removeClass(iconClass);
        }
        node.data('oldData', oldData);
        node.parent('li').addClass('folder').append(newFolder);
        this.setTreeIcon($('svg.icon-tree', node), this.settings.folderIconClosed);
      },

      // Convert folder node to file type
      convertFolderToFile: function(node) {
        var parent = node.parent('.folder');
        parent.removeClass('folder is-open');
        $('ul:first', parent).remove();
        if (parent.length) {
          this.setTreeIcon(
            $('svg.icon-tree', node),
            node.data('oldData') ? node.data('oldData').icon : 'tree-node'
          );
          if (node.data('oldData') && node.data('oldData').iconClass) {
            node.addClass(node.data('oldData').iconClass);
          }
          node.data('oldData', null);
        }
      },

      // Tree Related Functions
      destroy: function() {
        if (this.settings.sortable) {
          this.element.find('a').each(function() {
            var a = $(this), dragApi = a.data('drag');
            a.off('mousedown.tree');
            if (!!dragApi && !!dragApi.destroy) {
              dragApi.destroy();
            }
          });
          this.element.prev('.tree-drag-target-arrow').remove();
        }
        this.element.removeData(pluginName);
        this.element.off('contextmenu.tree updated.tree click.tree focus.tree keydown.tree keypress.tree').empty();
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Tree(this, settings));
      }
    });

  };


  /**
   * @class Validator
   * @constructor
   * @param {Object} element
   */
  function Validator(element) {
    this.element = $(element);
    Soho.logTimeStart('Validator');
    this.init();
    Soho.logTimeEnd('Validator');
  }

  // Plugin Object
  Validator.prototype = {

    /**
     * @private
     * @returns {undefined}
     */
    init: function() {
      this.fields = 'input, textarea, select, div[data-validate], div[data-validation]';
      this.isPlaceholderSupport = !!('placeholder' in document.createElement('input'));//placeholder native support is-exists

      //If we initialize with a form find all inputs
      this.inputs = this.element.find(this.fields);

      //Or Just use the current input
      if (this.element.is(this.fields)) {
        this.inputs = $().add(this.element);
      }

      this.element.addClass('validation-active');
      this.timeout = null;
    },

    /**
     * Gets a list of events
     * @private
     */
    extractEvents: function (events) {
      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if (typeof events === 'object') {
        var e = '';
        for (var k in events) {
          if (e.indexOf(events[k]) === -1) {
            e += events[k] +' ';
          }
        }
        e = e.split(' ').join('.validate ');
        events = e;
      }

      return events;
    },

    /**
     * @private
     */
    filterValidations: function (events, type) {
      var validations = [];

      if (!events) {
        return [];
      }

      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if(typeof events === 'object') {
        for (var k in events) {
          if (type && events[k].indexOf(type) > -1) {
            validations.push(k);
          }
        }
      }

      return validations;
    },

    /**
     * @private
     */
    attachEvents: function () {
      var self = this,
        attribs = '[data-validate],[data-validation]';

      //Attach required
      this.inputs.each(function () {
        var field = $(this),
        attr = field.attr('data-validate') || field.attr('data-validation');

        if (attr && attr.indexOf('required') > -1) {
          field.addClass('required');
        }
      });

      //Link on to the current object and perform validation.
      this.inputs.filter('input, textarea, div').filter(attribs).not('input[type=checkbox]').each(function () {
        var field = $(this),
        attribs = field.attr('data-validation-events'),
        events = (attribs ? attribs : 'blur.validate change.validate keyup.validate');

        if (field.is('[readonly]') && !field.parent().is('.field-fileupload')) {
          return;
        }

        events = self.extractEvents(events);

        //Custom enter event
        if (events.indexOf('enter.validate') > -1) {
          field.off('keypress.enter.validate').on('keypress.enter.validate', function (e) {
            var field = $(this);
            if (e.which === 13) {
              self.validate(field, true, e);
            }
          });
        }

        field.off(events).on(events, function (e) {
          var field = $(this),
            handleEventData = field.data('handleEvent' +[(e.type || '')]);
          if (handleEventData &&
              handleEventData.type === e.type &&
              e.handleObj.namespace === 'validate') {
            return;
          } else {
            field.data('handleEvent' +[(e.type || '')], e.handleObj);
          }

          //Skip on Tab
          if (e.type === 'keyup' && e.keyCode === 9) {
            return;
          }

          setTimeout(function () {
            if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation') || field[0].style.visibility === 'is-hidden' || !field.is(':visible')) {
              return;
            }

            if (field.closest('.modal-engaged').length && !field.closest('.modal-body').length) {
              return;
            }

            self.validate(field, true, e);
          }, 300);
        });
      });

      this.inputs.filter('input[type=checkbox]').filter(attribs).on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      this.inputs.filter(':radio').on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      var selects = this.inputs.filter('select').filter(attribs);

      if (selects.length) {
        selects.on('change.validate', function (e) {
          self.validate($(this), true, e);
        }).on('listopened.validate', function() {
          var field = $(this),
            tooltip = field.data('tooltip');

          field.next('.dropdown-wrapper').next('.error-message').hide();
          if (tooltip && document.activeElement === field.data('dropdown').searchInput[0]) {
            tooltip.hide();
          }
          $('#validation-tooltip').hide();

        }).on('listclosed.validate', function() {
          var field = $(this),
            tooltip = field.data('tooltip'),
            dropdownApi = field.data('dropdown');

            if (dropdownApi && dropdownApi.wrapper) {
              tooltip = dropdownApi.wrapper
                .find('.icon-error').data('tooltip');
            }

          field.next('.dropdown-wrapper').next('.error-message').show();
          if (tooltip && document.activeElement !== field.data('dropdown').searchInput[0]) {
            tooltip.show();
          }
        });

        selects.filter(function() {
          return $(this).data('dropdown') !== undefined;
        }).data('dropdown').pseudoElem.on('blur.validate', function(e) {
          var select = $(this).closest('.field, .field-short').find('select');
          self.validate(select, true, e);
        });
      }

      //Attach to Form Submit and Validate
      if (this.element.is('form')) {

        var submitHandler = function (e) {
          e.stopPropagation();
          e.preventDefault();
          self.validateForm(function (isValid) {
            self.element.off('submit.validate');
            self.element.triggerHandler('validated', isValid);
            self.element.data('isValid', isValid);
            self.element.on('submit.validate', submitHandler);
          });
        };

        this.element.on('submit.validate', submitHandler);
      }

    },

    /**
     * @private
     */
    validateForm: function (callback) {
      var self = this,
        deferreds = [];

      self.inputs = this.element.find(self.fields);
      self.inputs.each(function (e) {
        var field = $(this);
        if (field.attr('data-validate')) {

          if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation')) {
            return true;
          }

          var dfds = self.validate(field, false, e);
          for (var i = 0; i < dfds.length; i++) {
            deferreds.push(dfds[i]);
          }
        }

      });

      $.when.apply($, deferreds).then(function () {
        callback(true);
      }, function () {
        callback(false);
      });
    },

    /**
     * Set disable/enable primary button in modal
     * @private
     */
    setModalPrimaryBtn: function(field, modalBtn, isValid) {
      var modal = field.closest('.modal'),
        modalFields = modal.find('[data-validate]:visible, select[data-validate], :checkbox[data-validate]'),
        allValid = true;

      if (modalFields.length > 0) {
        modalFields.each(function () {
          var modalField = $(this);
          modalField.data('isValid', isValid);
          if (modalField.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }
          var isVisible = modalField[0].offsetParent !== null;
          if (modalField.is('.required')) {
            if ((isVisible || modalField.is('select, :checkbox'))  && !modalField.val()) {
              allValid = false;
            }
          } else {
            if ((isVisible  || modalField.is('select, :checkbox')) && !modalField.isValid()) {
              allValid = false;
            }
          }
        });
      }

      if (allValid) {
        modalBtn.removeAttr('disabled');
      } else {
        modalBtn.attr('disabled', 'disabled');
      }
    },

    /**
     * Gets the current value of a field
     * @private
     * @param {jQuery[]} field
     * @returns {?}
     */
    value: function(field) {
      if (field.is('input[type=checkbox]')) {
        return field.prop('checked');
      }
      if (field.is('div')) { // contentEditable div (Rich Text)
        return field[0].innerHTML;
      }
      return field.val();
    },

    /**
     *
     * @private
     * @param {jQuery[]}
     * @param {jQuery.Event} e
     * @returns {Array}
     */
    getTypes: function(field, e) {
      var filters = this.filterValidations(field.attr('data-validation-events'), e.type),
        validations;

      if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validate')) {
        validations = field.prev().prev('select').attr('data-validate').split(' ');
      } else if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validation')) {
        validations = field.prev().prev('select').attr('data-validation').split(' ');
      } else if (field.attr('data-validation')) {
        validations = field.attr('data-validation').split(' ');
      } else if (field.attr('data-validate')) {
        validations = field.attr('data-validate').split(' ');
      } else {
        validations = [];
      }

      //Filter out not needed events
      if (filters.length > 0) {
        validations = validations.filter(function(n) {
          return filters.indexOf(n) !== -1;
        });
      }

      //Filter out specific events that should not use keyup
      if (e.type === 'keyup') {
        validations = validations.filter(function(n) {
          return n !== 'date' && n !== 'time';
        });
      }

      return validations;
    },

    /**
     * Set icon on parent tabs/expandable
     * @private
     * @param {jQuery[]} field
     * @returns {undefined}
     */
    setIconOnParent: function (field, type) {
      var errorIcon = $.createIcon({ classes: ['icon-' + type], icon: type }),
        parent = field.closest('.tab-panel, .expandable-pane'),
        parentContainer = field.closest('.tab-container, .tab-panel-container, .expandable-area'),
        iconTarget = parent.attr('id'),
        iconContainer,
        dropdown,
        dropdownParent,
        menuitem;

      //Tabs
      if (parentContainer.is('.tab-panel-container')) {
        parentContainer = parentContainer.prev('.tab-container');
      }
      if (parentContainer.is('.tab-container')) {
        //Default Tabs
        iconContainer = $('.tab-list a[href="#'+ iconTarget +'"]', parentContainer).closest('.tab');

        //Tabs with Counts
        if (iconContainer.length) {
          if ($('.count', iconContainer).length) {
            iconContainer = $('.count', iconContainer);
          }
        }
        //Dropdown Tabs(with popupmenu)
        else {
          iconTarget = $('a[href="#'+ iconTarget +'"]', '.popupmenu').closest('.popupmenu').attr('id');
          iconContainer = $('.tab-list .tab[aria-controls="'+ iconTarget +'"]', parentContainer);
          dropdown = iconTarget;
        }
      }

      //Expandable
      else if (parentContainer.is('.expandable-area')) {
        iconContainer = $('.expandable-header[aria-controls="'+ iconTarget +'"] .title', parentContainer);
      }

      //No action
      else {
        return;
      }

      //if Dropdown Tabs set each menu item to check
      if (dropdown && dropdown.length) {
        dropdownParent = parent.add($($(dropdown).attr('href')));
        $('a[role="menuitem"]', '#'+ dropdown).each (function () {
          dropdownParent = dropdownParent.add($($(this).attr('href')));
        });
      }
      menuitem = $('a[href="#'+ parent.attr('id') +'"]', '#'+ iconTarget);

      //Add icon
      if ((!!parent && $('.' + type, parent).length) ||
          (!!dropdownParent && $('.' + type, dropdownParent).length)) {

        //if Dropdown Tabs and current menu item has no error remove icon
        if (!$('.' + type, parent).length) {
          menuitem.removeClass('is-' + type);
          $('.icon-' + type, menuitem).remove();
        }

        //if Dropdown Tabs and current menu item has error add icon
        if ($('.' + type, parent).length &&
            $('.' + type, dropdownParent).length &&
            !$('.icon-' + type, menuitem).length) {
            menuitem.addClass('is-' + type).append(errorIcon);
        }

        //Add icon to main tab area
        if (!($('.icon-' + type, iconContainer).length)) {
          iconContainer.addClass('is-' + type).append(errorIcon);
        }
      }

      //Remove icon
      else {
        iconContainer = iconContainer.add(menuitem);
        iconContainer.removeClass('is-' + type);
        $('.icon-' + type, iconContainer).remove();
      }
    },

    /**
     *
     * @private
     * @param {jQuery[]} field
     * @param {boolean} showTooltip
     * @param {jQuery.Event} e
     */
    validate: function (field, showTooltip, e) {
      field.data('handleEvent' +[(e.type || '')], null);

      //call the validation function inline on the element
      var self = this,
        types = self.getTypes(field, e) || [],
        rule, dfd,
        dfds = [],
        results = [],
        i, l, validationType,
        value = self.value(field),
        placeholder = field.attr('placeholder'),

        manageResult = function (result, showTooltip, type) {
          // Only remove if "false", not any other value ie.. undefined
          if (rule.positive === false) {
            self.removePositive(field);
          }

          validationType = $.fn.validation.ValidationTypes[rule.type] || $.fn.validation.ValidationTypes.error;

          if (!result) {
            if (!self.isPlaceholderSupport && (value === placeholder) &&
               (rule.message !== Locale.translate('Required'))) {
              return;
            }

            self.addMessage(field, rule.message, rule.type, field.attr('data-' + validationType.type + '-type') === 'tooltip' ? false: true, showTooltip);
            results.push(rule.type);

            if (validationType.errorsForm) {
              dfd.reject();
            }
            else {
              dfd.resolve();
            }
          }   else if ($.grep(results, function (res) { return res === validationType.type; }).length === 0) {
            self.removeMessage(field, validationType.type);
            dfd.resolve();

            if (rule.positive) {
              // FIX: In Contextual Action Panel control not sure why but need to add error,
              // otherwise "icon-confirm" get misaligned,
              // so for this fix adding and then removing error here
              self.addMessage(field, rule.message, rule.type, rule.inline, showTooltip);
              self.removeMessage(field, rule.type);
              dfd.resolve();

              self.addPositive(field);
            }
          }

          self.setIconOnParent(field, rule.type);
          self.validationStatus[type] = result;

          if (self.eventsStatus(types) && type !== 'required' && !self.validationStatus.triggerValid) {
            self.validationStatus.triggerValid = true;
            field.triggerHandler('valid', {field: field, message: ''});
          }
          field.triggerHandler('isvalid', [result]);

        };

      for (var props in $.fn.validation.ValidationTypes) {
        validationType = $.fn.validation.ValidationTypes[props];
        self.removeMessage(field, validationType.type, true);
        field.removeData('data-' + validationType.type + 'message');
      }

      self.validationStatus = {};
      for (i = 0, l = types.length; i < l; i++) {
        self.validationStatus[types[i]] = false;
        rule = $.fn.validation.rules[types[i]];
        dfd = $.Deferred();

        if (!rule) {
          continue;
        }

        if ($('#calendar-popup').is(':visible')) {
          continue; //dont show validation message while selecting
        }

        if (rule.async) {
          rule.check(value, field, manageResult);
        } else {
          manageResult(rule.check(value, field), showTooltip, types[i]);
        }
        dfds.push(dfd);
      }

      return dfds;
    },

    /**
     * Retrive the actionble element that should have an error class/icon appended to it.
     * @private
     * @param {jQuery[]} field
     * @returns {jQuery[]}
     */
    getField: function(field) {
      if (field.is('select') && field.data('dropdown') !== undefined) {
        field = field.data('dropdown').pseudoElem;
      }
      return field;
    },

    /**
     * Returns true if the given object has an error
     *
     * @param {jQuery[]} field
     * @returns {boolean}
     */
    hasError: function(field) {
      return this.getField(field).hasClass('error');
    },

    /**
     * Adds a message/icon to a form field.
     *
     * @param {jQuery[]} field
     * @param {String} message
     * @param {String} type
     * @param {boolean} inline
     * @param {boolean} showTooltip
     */
    addMessage: function(field, message, type, inline, showTooltip) {
      if (message === '') {
        return;
      }
      var loc = this.getField(field).addClass(type),
         dataMsg = loc.data('data-' + type + 'message'),
         appendedMsg = message,
         validationType = $.fn.validation.ValidationTypes[type] || $.fn.validation.ValidationTypes.error;

      if (dataMsg) {
        appendedMsg = (/^\u2022/.test(dataMsg)) ? '' : '\u2022 ';
        appendedMsg += dataMsg + '<br>\u2022 ' + message;
      }

      loc.data('data-' + validationType.type + 'message', appendedMsg);

      //Add Aria
      if ($.fn.toast !== undefined) {
        $('body').toast({title: Locale.translate(validationType.titleMessageID), audibleOnly: true, message: appendedMsg});
      }

      if (!inline) {
        this.showTooltipMessage(field, appendedMsg, validationType.type, showTooltip);
        return;
      }

      // Disable primary button in modal
      var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
      if (modalBtn.length) {
        this.setModalPrimaryBtn(field, modalBtn, false);
      }

      this.showInlineMessage(field, message, validationType.type);
    },

    /**
     * Shows an error icon
     *
     * @private
     * @param {jQuery[]} field
     * @returns {jQuery[]}
     */
    showIcon: function(field, type) {
      var loc = this.getField(field).addClass(type),
        svg = $.createIconElement({ classes: ['icon-' + type], icon: type }),
        closestField = loc.closest('.field, .field-short'),
        parent = field.parent();

      if (closestField.find('svg.icon-' + type).length === 0) {

        if (parent.is('.editor-container')) {
          field.parent().addClass('is-error');
        }

        if (field.parent(':not(.editor-container)').find('.btn-actions').length ===1) {
          parent.find('.btn-actions').before(svg);
        } else if (parent.find('.data-description').length ===1) {
          parent.find('.data-description').before(svg);
        } else if (parent.find('.field-info').length ===1) {
          parent.find('.field-info').before(svg);
        } else if (field.is('textarea')) {
          field.after(svg);
        } else if (field.is('.dropdown, .multiselect')) {
          parent.find('.dropdown-wrapper').append(svg);
        } else if (field.is('.spinbox')) {
          parent.append(svg);
        } else if (field.is('.lookup')) {
          parent.append(svg);
        } else {
          parent.append(svg);
        }

        $('.icon-confirm', closestField).remove();
      } else {
        svg = closestField.find('svg.icon-error');
      }

      return svg;
    },

    /**
     * Shows an tooltip error
     *
     * @private
     * @param {jQuery[]} field
     * @param {string} message
     * @param {boolean} showTooltip
     */
    showTooltipMessage: function(field, message, type, showTooltip) {
      if (field.is(':radio')) {
        return;
      }

      var icon = this.showIcon(field, type);
      var representationField = field;

      //Add error classes to pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect') && field.data('dropdown') !== undefined) {
        var input = field.data('dropdown').pseudoElem;
        representationField = input;
        input.addClass(type);
      }

      var tooltipAPI = icon.data('tooltip');

      // Error tooltips should be positioned on the 'x' so that they sit directly underneath the fields
      // that they are indicating.
      function tooltipPositionCallback(placementObj) {
        var fieldRect = representationField[0].getBoundingClientRect(),
          elRect = tooltipAPI.tooltip[0].getBoundingClientRect(),
          rtl = $('html').is('[dir="rtl"]'),
          currX = placementObj.x,
          xAdjustment = 0;

        if (rtl) {
          if (elRect.left < fieldRect.left) {
            xAdjustment += (fieldRect.left - elRect.left);
          }
        } else {
          if (elRect.right > fieldRect.right) {
            xAdjustment += (elRect.right - fieldRect.right) * -1;
          }
        }

        placementObj.setCoordinate('x', currX + xAdjustment);
        if (!placementObj.nudges) {
          placementObj.nudges = {};
        }
        placementObj.nudges.x = xAdjustment;

        return placementObj;
      }

      // Build Tooltip
      if (!tooltipAPI) {
        icon.tooltip({
          content: message,
          placement: 'bottom',
          placementOpts: {
            callback: tooltipPositionCallback
          },
          trigger: 'focus',
          isError: true,
          tooltipElement: '#validation-tooltip'
        });
        tooltipAPI = icon.data('tooltip');
      } else {
        tooltipAPI.content = message;
      }

      field.on('focus.validate', function() {
        if (!tooltipAPI) { return; }
        tooltipAPI.show();
      }).on('blur.validate', function() {
        if (!tooltipAPI) { return; }
        tooltipAPI.hide();
      });

      if (showTooltip && tooltipAPI) {
        tooltipAPI.show();
      }
    },

    /**
     * Shows an tooltip error
     *
     * @private
     * @param {jQuery[]} field
     * @param {string} message
     * @param {HTMLElement} markup
     * @param {boolean} isShow
     */
    toggleRadioMessage:  function (field, message, type, markup, isShow) {
      var all, loc,
        name = field.attr('name');

      if (name && name.length) {
        all = $(':radio[name="'+ name +'"], :radio[name="'+ name +'"] + label');
        loc = field.parent().is('.inline') ?
          $(':radio[name="'+ name +'"]:last').parent() :
          $(':radio[name="'+ name +'"]:last + label');

        if (isShow) {
          all.addClass(type);
          $(markup).addClass('radio-group-' + type).insertAfter(loc);
        }
        else {
          all.removeClass(type);
          loc.next('.radio-group-' + type).remove();
        }
      }
    },

    /**
     * Shows an inline error message on a field
     * @private
     *
     * @param {jQuery[]} field
     * @param {string} message
     */
    showInlineMessage: function (field, message, type) {
      var loc = this.getField(field).addClass(type),
        validationType = $.fn.validation.ValidationTypes[type] || $.fn.validation.ValidationTypes.error,
        markup = '<div class="' + validationType.type + '-message">' +
          $.createIcon({ classes: ['icon-' + validationType.type], icon: validationType.type }) +
          '<pre class="audible">'+ Locale.translate(validationType.titleMessageID) +'</pre>' +
          '<p class="message-text">' + message +'</p>' +
          '</div>';

      if (field.is(':radio')) { // Radio button handler
        this.toggleRadioMessage(field, message, validationType.type, markup, true);
      } else { // All other components
        loc.closest('.field, .field-short').find('.formatter-toolbar').addClass(validationType.type);
        loc.closest('.field, .field-short').append(markup);
        loc.closest('.field, .field-short').find('.colorpicker-container').addClass('error');
      }

      //Remove positive errors
      if (validationType.type === 'error') {
        field.parent().find('.icon-confirm').remove();
      }
      // Trigger an event
      field.triggerHandler(validationType.type, {field: field, message: message});
      field.closest('form').triggerHandler(validationType.type, {field: field, message: message});
    },

    /**
     * Shows an inline error message on a field
     *
     * @private
     * @param {jQuery[]} field
     */
    addPositive: function(field) {
      var svg = $.createIcon({ icon: 'confirm', classes: 'icon-confirm'});

      if (!$('.icon-confirm', field.parent('.field, .field-short')).length) {
        field.parent('.field, .field-short').append(svg);
      }
    },

    /**
     * remove the message form the field
     *
     * @private
     * @param {jQuery[]} field
     */
    removeMessage: function(field, type, noTrigger) {
      var loc = this.getField(field),
        isRadio = field.is(':radio'),
        errorIcon = field.closest('.field, .field-short').find('.icon-error'),
        tooltipAPI = errorIcon.data('tooltip'),
        hasTooltip = field.attr('data-' + type + '-type') || !!tooltipAPI;

      this.inputs.filter('input, textarea').off('focus.validate');
      field.removeClass(type);
      field.removeData(type +'-errormessage dataErrormessage');

      if (hasTooltip) {
        tooltipAPI = field.find('.icon.' + type).data('tooltip') || tooltipAPI;

        if (tooltipAPI) {
          tooltipAPI.destroy();
        }
        if (field.attr('aria-describedby') === 'validation-tooltip') {
          field.removeAttr('aria-describedby');
          $('#validation-tooltip').remove();
        }
      }

      if (isRadio) {
        this.toggleRadioMessage(field, '', type);
      }
      else {
        field.next('.icon-' + type).off('click.validate').remove();
      }

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.next().next().removeClass(type); // #shdo
        field.next().find('div.dropdown').removeClass(type).removeData('data-' + type + 'message');
        field.parent().find('.dropdown-wrapper > .icon-' + type).off('click.validate').remove(); // SVG Error Icon
      }

      if (!isRadio) {
        field.next().next('.icon-' + type).remove();
        field.next('.inforCheckboxLabel').next('.icon-' + type).remove();
        field.parent('.field, .field-short').find('span.' + type).remove();
        field.parent().find('.icon-' + type).remove();
        field.off('focus.validate focus.tooltip');
      }

      if (loc.attr('data-placeholder')) {
        loc.attr('placeholder',loc.attr('data-placeholder'));
        loc.removeAttr('data-placeholder');
      }

      //Remove error classes from pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect')) {
        field.data('dropdown').pseudoElem.removeClass(type).removeAttr('placeholder');
      }

      if (field.parent().is('.editor-container')) {
        field.parent().removeClass('is-' + type);
      }
      field.parent('.colorpicker-container').removeClass('error');

      if (field.closest('.field-fileupload').length > -1) {
        field.closest('.field-fileupload').find('input.' + type).removeClass(type);
      }

      // Enable primary button in modal
      var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
      if (modalBtn.length) {
        this.setModalPrimaryBtn(field, modalBtn, true);
      }

      //Stuff for the inline error
      field.closest('.field, .field-short').find('.' + type + '-message').remove();
      field.parent('.field, .field-short').find('.formatter-toolbar').removeClass(type);

      if (type === 'error' && !noTrigger && this.eventsStatus()) {
        field.triggerHandler('valid', {field: field, message: ''});
        field.closest('form').triggerHandler('valid', {field: field, message: ''});
      }
    },

    // Check if all given events are true/valid
    eventsStatus: function(types) {
      var r, status = this.validationStatus;
      if (status) {
        r = true;

        if (types) {
          for (var i=0,l=types.length; i<l; i++) {
            if(!status[types[i]]) {
              r = false;
            }
          }
        } else {
          for (var key in status) {
            if (status.hasOwnProperty(key)) {
              if(!status[key]) {
                r = false;
              }
            }
          }
        }

      } else {
        r = false;
      }
      return r;
    },

    /**
     * Shows an inline error message on a field
     *
     * @private
     * @param {jQuery[]} field
     */
    removePositive: function(field) {
      $('.icon-confirm', field.parent('.field, .field-short')).remove();
    }
  };

  /**
   * Returns the errormessage data object for a Field
   *
   * @param options (object) optional
   */
  $.fn.getErrorMessage = function(options) {
    var defaults = { },
      settings = $.extend({}, defaults, options);

    var instance = new Validator(this, settings);
    return instance.getField($(this)).data('data-errormessage');
  };

  /**
   * ScrollIntoView and sets focus on an element
   *
   * @param alignToTop (boolean) optional - true (default) element will be aligned to the top of the visible area of the scrollable ancestor
   * @param options (object) optional
   */
  $.fn.scrollIntoView = function(alignToTop, options) {
    if (typeof alignToTop !== 'boolean') {
      alignToTop = undefined;
    }
    var defaults = { },
      settings = $.extend({}, defaults, options);

    var instance = new Validator(this, settings);
    var elem = instance.getField($(this));
    elem[0].scrollIntoView(alignToTop);
    elem.focus();
  };

  //Add a Message to a Field
  $.fn.addMessage = function(options) {
    var defaults = {message: '', type: 'error', showTooltip: false, inline: true},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.addMessage($(this), settings.message, settings.type, settings.inline, settings.showTooltip);
    });
  };

  //Add an error Message to a Field
  $.fn.addError = function(options) {
    var defaults = {message: '', showTooltip: false, inline: true},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.addMessage($(this), settings.message, 'error', settings.inline, settings.showTooltip);
    });
  };

  //Remove a Message from a Field
  $.fn.removeMessage = function(options) {
    var defaults = {message: '', type: 'error'},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.removeMessage($(this), settings.type);
    });
  };

  //Remove an error Message from a Field
  $.fn.removeError = function(options) {
    var defaults = {message: ''},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.removeMessage($(this), 'error');
    });
  };

  $.fn.validate = function(options, args) {
    // Settings and Options
    var pluginName = 'validate',
      defaults = {
        inline: true
      },
      settings = $.extend({}, defaults, options);

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);

      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Validator(this, settings));
        instance.attachEvents();
      }
    });
  };

  //The validation rules object
  var Validation = function () {
    var self = this;

    // define standard validation types
    this.ValidationTypes = [];
    this.ValidationTypes.error = { type: 'error', titleMessageID: 'Error', pagingMessageID: 'ErrorOnPage', errorsForm: true };
    this.ValidationTypes.alert = { type: 'alert', titleMessageID: 'Alert', pagingMessageID: 'AlertOnPage', errorsForm: false };
    this.ValidationTypes.confirm = { type: 'confirm', titleMessageID: 'Confirm', pagingMessageID: 'ComfirmOnPage', errorsForm: false };
    this.ValidationTypes.info = { type: 'info', titleMessageID: 'Info', pagingMessageID: 'InfoOnPage', errorsForm: false };

    this.rules = {
      required: {
        isNotEmpty: function(value, field) {
          var supportsPlaceholder = !!('placeholder' in document.createElement('input'));

          if (!supportsPlaceholder && field &&
              (value === field.attr('placeholder') || value === Locale.translate('Required'))) {
            return false;
          }

          if (typeof value === 'string') {
            // strip out any HTML tags and focus only on text content.
            value = $.trim(value.replace(/<\/?[^>]*>/g, ''));
            if ($.trim(value).length === 0) {
              return false;
            }
            return true;
          }

          if (typeof value === 'number') {
            if (isNaN(value)) {
              return false;
            }
            return true;
          }

          return (value ? true : false);
        },

        // Check if at least one radio button checked in group
        isRadioChecked: function (field) {
          var name = field.attr('name');
          return (name && name.length && $('input[name="'+ name +'"]:radio:checked').length);
        },

        check: function (value, field) {
          var self = this;

          //Check all required fields filled on modal

          var allFilled = true;
          field.closest('.modal').find('input.required, textarea.required, select.required').not(':hidden').each(function () {
            if (!self.isNotEmpty($(this).val())) {
              allFilled = false;
            }
          });

          if (allFilled) {
            field.closest('.modal').find('.btn-modal-primary').not('.no-validation').removeAttr('disabled');
          } else {
            field.closest('.modal').find('.btn-modal-primary').not('.no-validation').attr('disabled', 'disabled');
          }

          this.message = Locale.translate('Required');
          return field.is(':radio') ? this.isRadioChecked(field) : this.isNotEmpty(value, field);
        },
        message: 'Required',
        type: 'error'
      },

      //date: Validate date, datetime (24hr or 12hr am/pm)
      date: {
        check: function (value, field) {
          this.message = Locale.translate('InvalidDate');

          if (value instanceof Date) {
            return value && value.getTime && !isNaN(value.getTime());
          }

          var dateFormat = (value.indexOf(':') > -1) ? Locale.calendar().dateFormat.datetime: Locale.calendar().dateFormat.short;

          if (field && field.data('datepicker')) {
            dateFormat = field.data('datepicker').pattern;
          }

          var isStrict = !(dateFormat === 'MMMM d' || dateFormat === 'yyyy'),
            parsedDate = Locale.parseDate(value, dateFormat, isStrict);
          return ((parsedDate === undefined) && value !== '') ? false : true;
        },
        message: 'Invalid Date',
        type: 'error'
      },

      //Validate date, disable dates
      availableDate: {
        check: function (value, field) {
          this.message = Locale.translate('UnavailableDate');
          var check = true;

          // To avoid running into issues of Dates happening in different timezones, create the date as UTC
          function createDateAsUTC(date) {
            return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
          }

          if (value !== '') {
            if (self.rules.date.check(value, field)) { //if valid date
              var d, i, l, min, max,
                d2 = createDateAsUTC(new Date(value)),
                options = field.data('datepicker').settings;

              if (options) {

                min = (createDateAsUTC(new Date(options.disable.minDate))).setHours(0,0,0,0);
                max = (createDateAsUTC(new Date(options.disable.maxDate))).setHours(0,0,0,0);

                //dayOfWeek
                if(options.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
                  check = false;
                }

                d2 = d2.setHours(0,0,0,0);

                //min and max
                if((d2 <= min) || (d2 >= max)) {
                  check = false;
                }

                //dates
                if (options.disable.dates.length && typeof options.disable.dates === 'string') {
                  options.disable.dates = [options.disable.dates];
                }
                for (i=0, l=options.disable.dates.length; i<l; i++) {
                  d = new Date(options.disable.dates[i]);
                  if(d2 === d.setHours(0,0,0,0)) {
                    check = false;
                    break;
                  }
                }
              }
              check = ((check && !options.disable.isEnable) || (!check && options.disable.isEnable)) ? true : false;
            }
            else {// Invalid date
              check = false;
              this.message = '';
            }
          }

          return check;
        },
        message: 'Unavailable Date',
        type: 'error'
      },

      email: {
        check: function (value) {
          this.message = Locale.translate('EmailValidation');
          var regex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,16}(?:\.[a-z]{2})?)$/i;

          return (value.length) ? regex.test(value) : true;
        },
        message: 'EmailValidation'
      },

      enableSubmit: {
        check: function (value, field) {
          var submit = field.closest('.signin').find('button[type="submit"]'),
            ok = ((value.length) && (self.rules.email.check(value) || self.rules.passwordConfirm.check(value, field)));

          if (ok) {
            submit.enable();
          } else {
            submit.disable();
          }
          return true;
        },
        message: '',
        type: 'error'
      },

      emailPositive: {
        check: function (value, field) {
          if($.trim(value).length && !field.is('[readonly]')) {
            self.rules.emailPositive.positive = true;
            this.message = Locale.translate('EmailValidation');

            var isValid = self.rules.email.check(value, field);

            if (isValid) {
              this.message = '';
            }

            return isValid;
          } else {
            self.rules.emailPositive.positive = false;
            return true;
          }
        },
        message: 'EmailValidation',
        type: 'error'
      },

      passwordReq: {
        check: function (value) {
         this.message = Locale.translate('PasswordValidation');
          /* Must be at least 10 characters which contain at least
          ** one lowercase letter,
          ** one uppercase letter,
          ** one numeric digit
          ** and one special character */
          var regex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\s).{10,}$/;
          return (value.length) ? value.match(regex) : true;
        },
        message: 'PasswordValidation',
        type: 'error'
      },

      passwordConfirm: {
        check: function (value, field) {
          this.message = Locale.translate('PasswordConfirmValidation');
          var passwordValue = $('input[type="password"]:not('+ field.attr('id') +')', field.closest('.signin')).eq(0).val(),
            check = ((value === passwordValue) && (self.rules.passwordReq.check(passwordValue)));
          return (value.length) ? check : true;
        },
        message: 'PasswordConfirmValidation',
        type: 'error'
      },

      time: {
        check: function(value, field) {
          value = value.replace(/ /g, '');
          this.message = Locale.translate('InvalidTime');
          var timepicker = field && field.data('timepicker'),
            timepickerSettings = timepicker ? field.data('timepicker').settings : {},
            pattern = timepickerSettings && timepickerSettings.timeFormat ? timepickerSettings.timeFormat : Locale.calendar().timeFormat,
            is24Hour = (pattern.match('HH') || []).length > 0,
            maxHours = is24Hour ? 24 : 12,
            sep = value.indexOf(Locale.calendar().dateFormat.timeSeparator),
            valueHours = 0,
            valueMins = 0,
            valueSecs = 0,
            valueM,
            timeparts;

          if (value === '') {
            return true;
          }

          valueHours = parseInt(value.substring(0, sep));
          valueMins = parseInt(value.substring(sep + 1,sep + 3));

          //getTimeFromField
          if (timepicker) {
              timeparts = timepicker.getTimeFromField();

              valueHours = timeparts.hours;
              valueMins = timeparts.minutes;

              if (timepicker.hasSeconds()) {
                valueSecs = timeparts.seconds;
              }
          }

          if (valueHours.toString().length < 1 || isNaN(valueHours) || parseInt(valueHours) < 0 || parseInt(valueHours) > maxHours) {
            return false;
          }
          if (valueMins.toString().length < 1 || isNaN(valueMins) || parseInt(valueMins) < 0 || parseInt(valueMins) > 59) {
            return false;
          }
          if (valueSecs.toString().length < 1 || isNaN(valueSecs) || parseInt(valueSecs) < 0 || parseInt(valueSecs) > 59) {
            return false;
          }

          // AM/PM
          if (!is24Hour) {
            if (parseInt(valueHours) < 1) {
              return false;
            }
            var period0 = new RegExp(Locale.calendar().dayPeriods[0], 'i'),
              period1 = new RegExp(Locale.calendar().dayPeriods[1], 'i');

            valueM = value.match(period0) || value.match(period1) || [];
            if (valueM.length === 0) {
              return false;
            }
          }

          return true;
        },
        message: 'Invalid Time',
        type: 'error'
      },

      //Test validation function, always returns false
      test: {

        check: function(value) {
          return value === '1' ? true : false;
        },

        message: 'Value is not valid (test).',
        type: 'error'
      }
    };
  };

  $.fn.validation = new Validation();

  $.fn.isValid = function() {
    return ($(this).data('isValid') ? true : false);
  };

 //Check validation manually
  $.fn.checkValidation = function() {
    var field = $(this),
      api = field.data('validate'),
      doAction = function(isValid) {
        field.data('isValid', isValid);
        field.triggerHandler('isvalid', [isValid]);
      };

    if (api && api.validate) {
      var fx = api.validate(field, false, 0);
      $.when.apply($, fx).always(function() {
        // [fail] returns the first fail, so we have to loop deferred objects
        $.each(fx, function() {
          this.done(function() {
            doAction(true);
          }).fail(function() {
            doAction(false);
          });
        });
      });
    }
  };

  //Clear out the stuff on the Form
  $.fn.resetForm = function() {
    var formFields = $(this).find('input, select, textarea');

    //Clear Errors
    formFields.removeClass('error');
    $(this).find('.error').removeClass('error');
    $(this).find('.icon-error').remove();
    $(this).find('.icon-confirm').remove();
    $(this).find('.error-message').remove();

    //Clear Warnings
    formFields.removeClass('alert');
    $(this).find('.alert').removeClass('alert');
    $(this).find('.icon-alert').remove();
    $(this).find('.alert-message').remove();

    //Clear Informations
    formFields.removeClass('info');
    $(this).find('.info').removeClass('info');
    $(this).find('.icon-info').remove();
    $(this).find('.info-message').remove();

    setTimeout(function () {
      $('#validation-errors').addClass('is-hidden');
    }, 300);

    //Remove Dirty
    formFields.data('isDirty', false).removeClass('isDirty');
    $(this).find('.isDirty').removeClass('isDirty');

    //reset form data
    if ($(this).is('form')) {
      $(this)[0].reset();
    }
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.wizard = function(options) {
    'use strict';

    /**
    * The Autocomplete control provides an easier means of searching through a large amount of data by filtering down the results based on keyboard input from the user.
    *
    * @class Wizard
    *
    * @param {jQuery[]} ticks  &nbsp;-&nbsp; Defines the data to use, must be specified.
    *
    */

    // Settings and Options
    var pluginName = 'wizard',
        defaults = {
          ticks: null
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Wizard(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Wizard.prototype = {

      /**
       * @private
       * @returns {this}
       */
      init: function() {
        this
          .build()
          .handleEvents();
      },

      /**
       * @private
       * @returns {this}
       */
      build: function() {
        this.header = this.element.find('.wizard-header');
        if (!this.header.length) {
          this.header = $('<div class="wizard-header"></div>').appendTo(this.element);
        }

        this.bar = this.element.find('.bar');
        if (!this.bar.length) {
          this.bar = $('<div class="bar"></div>').appendTo(this.header);
        }

        this.completedRange = this.element.find('.completed-range');
        if (!this.completedRange.length) {
          this.completedRange = $('<div class="completed-range"></div>').appendTo(this.bar);
        }

        this
          .buildTicks()
          .updateRange();

        return this;
      },

      buildTicks: function() {
        var settingTicks = this.settings.ticks,
          self = this;

        this.ticks = this.bar.children('.tick');

        if (!this.ticks.length && settingTicks) {

          for (var i = 0; i < settingTicks.length; i++) {
            var link = $('<a ng-click="handleClick()" class="tick ' + (settingTicks[i].state ? settingTicks[i].state : '') + '" href="'+ (settingTicks[i].href ? settingTicks[i].href : '#') +'"><span class="label">' + settingTicks[i].label + '</span></a>');

            if (settingTicks[i].ngClick) {
              link.attr('ng-click', settingTicks[i].ngClick);
            }

            self.bar.append(link);
          }
          this.ticks = this.bar.children('.tick');
        }
        this.positionTicks();

        $('.tick', self.element).each(function() {
          var tick = $(this);
          if (tick.hasClass('is-disabled')) {
            tick.removeAttr('onclick ng-click');
          }
        });

        this.element.find('.wizard-header')[0].style.opacity = '1';
        return this;
      },

      positionTicks: function() {
        var l = this.ticks.length,
          delta = 100 / (l - 1),
          tickPos = [];

        function getPoint(i) {
          if (i === 0) {
            return 0;
          }
          if (i === l - 1) {
            return 100;
          } else {
            return delta * i;
          }
        }

        for (var i = 0; i < l; i++) {
          tickPos.push(getPoint(i));
        }

        this.ticks.each(function(i) {
          var tick = $(this),
            label = tick.children('.label'),
            left = Locale.isRTL() ? (100-tickPos[i]) : tickPos[i];

          this.style.left = left + '%';

          for (var i2 = 0, l2 = label.length; i2 < l2; i2++) {
            label[i2].style.left = '-' + (label.outerWidth()/2 - tick.outerWidth()/2) + 'px';
          }

          if (tick.is('.is-disabled')) {
            tick.attr('tabindex', '-1');
          }
        });
      },

      updateRange: function() {
        var currentTick = this.ticks.filter('.current').last(),
          widthPercentage = 0;

        if (currentTick.length) {
          widthPercentage = (100 * parseFloat(window.getComputedStyle(currentTick[0]).left) / parseFloat(window.getComputedStyle(currentTick.parent()[0]).width));
          widthPercentage = Locale.isRTL() ? (100-widthPercentage) : widthPercentage;
        }

        this.completedRange[0].style.width = widthPercentage + '%';
        return this;
      },

      updated: function() {
        this
          .buildTicks()
          .updateRange();

        return this;
      },

      teardown: function() {
        this.ticks.offTouchClick('wizard').off('click.wizard');
        this.element.off('updated.wizard');

        this.ticks.remove();
        return this;
      },

      // Deprecating the "select()" method in favor of "activate()" to match the API of our other controls
      // Temporarily adding functionality that reroutes this method to the new "activate" method.
      select: function(e, tick) {
        return this.activate(e, tick);
      },

      // Activates one of the Wizard's ticks.
      // Tick can either be a number (representing the tick's index) or a jQuery element reference to a tick
      activate: function(e, tick) {
        if (e === undefined && !tick) {
          return this;
        }

        var self = this;

        function getTick() {
          var target;

          // Use the first variable as the tick definition or index if "e" is null, undefined, or not an event object.
          // This is for backwards compatibility with this control's old select() method, which took an index as an argument.
          if (e !== undefined && (e === undefined || e === null || !e.type || !e.target) && !tick) {
            tick = e;
          }

          if (tick === undefined) {
            target = $(e.target);
            return target.is('.label') ? target.parent() : target;
          }

          if (typeof tick === 'number') {
            return self.ticks.eq(tick);
          }

          return tick;
        }

        tick = getTick();

        if (e && (tick.is('[disabled], .is-disabled') || !tick.is('a'))) {
          e.preventDefault();
          e.stopPropagation();
          return this;
        }

        // Cancel selection by returning a 'beforeactivate' handler as 'false'
        var canNav = this.element.triggerHandler('beforeactivate', [tick]);
        if (canNav === false) {
          return this;
        }

        var trueIndex = this.ticks.index(tick);
        this.ticks.removeClass('complete current')
          .eq(trueIndex).addClass('current')
          .prevAll('.tick').addClass('complete');

        this.updateRange();
        this.element.trigger('activated', [tick]);

        // Timeout allows animation to finish
        setTimeout(function () {
          self.element.trigger('afteractivated', [tick]);
        }, 300);

        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       * This component listens to the following events:
       * @param module:Wizard~event:updated
       * @param module:Wizard~event:click
       */
      handleEvents: function() {
        var self = this;

        this.element.on('updated', function() {
          self.updated();
        });

        this.ticks.onTouchClick('wizard').on('click.wizard', function(e) {
          self.activate(e, $(this));
        });

        return this;
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Wizard(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.zoom = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'zoom',
        settings = $.extend({}, options);

    /**
     * @constructor
     * @param {Object} element
     * @param {Object} settings
     */
    function Zoom(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Zoom.prototype = {
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      // Add markup to the control
      build: function() {
        // get references to elements
        this.viewport = this.element.find('meta[name=viewport]');
        this.body = $('body');

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        // Allow the head to listen to events to globally deal with the zoom problem on
        // a per-control basis (for example, Dropdown/Multiselect need to handle this issue manually).
        this.element.on('updated.' + pluginName, function() {
          self.updated();
        }).on('enable-zoom', function() {
          self.enableZoom();
        }).on('disable-zoom', function() {
          self.disableZoom();
        });

        // Don't continue setting this up on each element if
        if (Soho.env.os.name !== 'ios') {
          return this;
        }

        // Setup conditional events for all elements that need it.
        this.body.on('touchstart.zoomdisabler', 'input, label', function() {
          if (self.noZoomTimeout) {
            return;
          }

          self.disableZoom();
        }).on('touchend.zoomdisabler', 'input, label', function() {
          if (self.noZoomTimeout) {
            clearTimeout(self.noZoomTimeout);
            self.noZoomTimeout = null;
          }
          self.noZoomTimeout = setTimeout(function() {
            self.noZoomTimeout = null;
            self.enableZoom();
          }, 600);
        });

        return this;
      },

      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      enableZoom: function() {
        this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=1');
      },

      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      disableZoom: function() {
        this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
      },

      // Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName + ' enable-zoom disable-zoom');
        this.body.off('touchstart.zoomdisabler touchend.zoomdisabler');
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Zoom(this, settings));
      }
    });
  };


}));
//# sourceURL=sohoxi.js
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module
    define('cultures/en-US', ['jquery'], factory);
    factory();
  } else if (typeof exports === 'object') {
    // Node/CommonJS
    module.exports = factory(require('jquery'));
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function () {

  if (!Locale) {
    return;
  }

  //Get Latest from http://www.unicode.org/Public/cldr/25/
  Locale.addCulture('en-US', {
    //layout/language
    language: 'en',
    englishName: 'English (United States)',
    nativeName: 'English (United States)',
    //layout/orientation/@characters
    direction: 'left-to-right',
    //ca-gregorian
    calendars: [{
      name: 'gregorian',
      //ca-gregorian/main/dates/calendars/gregorian/dateFormats/
      dateFormat: {'separator': '/', //Infered
                   'timeSeparator': ':',
                   'short': 'M/d/yyyy', //use four digit year
                   'medium': 'MMM d, yyyy',
                   'long': 'MMMM d, yyyy',
                   'full': 'EEEE, MMMM d, y',
                   'month': 'MMMM d',
                   'year': 'MMMM yyyy',
                   'timestamp': 'h:mm:ss a',
                   'datetime': 'M/d/yyyy h:mm a'}, //Infered short + short gregorian/dateTimeFormats
      //ca-gregorian/main/dates/calendars/gregorian/days/format/short or abbreviated (2 digit)
      days: {
         wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
         abbreviated: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
         narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
      },
      //ca-gregorian/main/dates/calendars/gregorian/months/format/wide
      months: {
        wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
      },
      //ca-gregorian/main/dates/calendars/gregorian/timeFormats/short
      timeFormat: 'h:mm a',
      //ca-gregorian/main/dates/calendars/gregorian/dayPeriods/wide
      dayPeriods: ['AM', 'PM']
    }],

    //numbers/currencyFormats-numberSystem-latn/standard (Replace Sign http://www.currencysymbols.in ?)
    currencySign: '$', //(Replace Sign http://www.currencysymbols.in ?)
    currencyFormat: '¤#,##0.00',
    //numbers/symbols-numberSystem-latn
    numbers: {
      percentSign: '%',
      percentFormat: '#,##0 %',
      minusSign: '-',
      decimal: '.',
      group: ','
    },
    //Resx - Approved By Translation Team
    messages: {
      'AboutText': {id: 'AboutText', value: 'Copyright &copy; {0} Infor. All rights reserved. The word and design marks set forth herein are trademarks and/or registered trademarks of Infor and/or its affiliates and subsidiaries. All rights reserved. All other trademarks listed herein are the property of their respective owners'},
      'Actions': {id: 'Actions', value: 'Actions', comment: 'Tooltip text for the action button with additional in context actions'},
      'AdditionalItems': {id: 'AdditionalItems', value: 'Additional Items', comment: 'Button tooltip used in a list of movable items'},
      'Add': {id: 'Add', value: 'Add', comment: 'Add'},
      'AddNewTab': {id: 'AddNewTab', value: 'Add New Tab', comment: 'Attached to a button that adds new tabs'},
      'AdvancedFilter': {id: 'AdvancedFilter', value: 'Create Advanced Filter', comment: 'In a data grid active an advanced filtering feature'},
      'Alert': {id: 'Alert', value: 'Alert', comment: 'Alert'},
      'AlertOnPage': {id: 'AlertOnPage', value: 'Alert message(s) on page', comment: 'Alert message(s) on page n'},
      'All': {id: 'All', value: 'All', comment: 'All items in the context of a filter'},
      'AllResults': {id: 'AllResults', value: 'All Results For', comment: 'Search Results Text'},
      'AligntoBottom': {id: 'AligntoBottom', value: 'Align Bottom', comment: 'Align to Bottom tooltip'},
      'AlignCenterHorizontally': {id: 'AlignCenterHorizontally', value: 'Horizontal Align Center', comment: 'Align Center Horizontally tooltip'},
      'Amber': {id: 'Amber', value: 'Amber', comment: 'Color in our color pallette'},
      'Amethyst': {id: 'Amethyst', value: 'Amethyst', comment: 'Color in our color pallette'},
      'Apply': {id: 'Apply', value: 'Apply', comment: 'Text in a button to apply an action'},
      'Attach': {id: 'Attach', value: 'Attach', comment: 'Attach'},
      'Available': {id: 'Available', value: 'Available', comment: 'Button tooltip used in a list of movable items'},
      'Azure': {id: 'Azure', value: 'Azure', comment: 'Color in our color pallette'},
      'BackgroundColor': {id: 'BackgroundColor', value: 'Background color', comment: 'add or edit text background color in the editor'},
      'Between': {id: 'Between', value: 'Between', comment: 'Between in icons for filtering'},
      'Blockquote': {id: 'Blockquote', value: 'Block quote', comment: 'insert a block quote in the editor'},
      'Bold': {id: 'Bold', value: 'Bold', comment: 'Make text Bold'},
      'Bookmarked': {id: 'Bookmarked', value: 'Bookmarked', comment: 'Bookmark filled - Element is already bookmarked'},
      'BookmarkThis': {id: 'BookmarkThis', value: 'Bookmark this', comment: 'Bookmark an element'},
      'Breadcrumb': {id: 'Breadcrumb', value: 'Breadcrumb', comment: 'Text describing the Breadcrumb'},
      'Browser': {id: 'Browser', value: 'Browser', comment: 'As in a Web Browser'},
      'BulletedList': {id: 'BulletedList', value: 'Bulleted list', comment: 'Bulleted List tooltip'},
      'Calendar': {id: 'Calendar', value: 'Calendar', comment: 'Inline Text for the title of the Calendar control'},
      'Camera': {id: 'Camera', value: 'Camera', comment: 'Camera tooltip'},
      'Cancel': {id: 'Cancel', value: 'Cancel', comment: 'Cancel tooltip'},
      'CapsLockOn': {id: 'CapsLockOn', value: 'Caps Lock On', comment: 'Caps Lock On message'},
      'Cart': {id: 'Cart', value: 'Cart', comment: 'Cart tooltip'},
      'CenterText': {id: 'CenterText', value: 'Center', comment: 'An Icon Tooltip'},
      'CharactersLeft': {id: 'CharactersLeft', value: 'Characters left {0}', comment: 'indicator showing how many more characters you can type.'},
      'CharactersMax': {id: 'CharactersMax', value: 'Character count maximum of ', comment: 'indicator showing how many max characters you can type.'},
      'ChangeSelection': {id: 'ChangeSelection', value: '. To change the selection use the arrow keys.', comment: 'Audible Text for drop down list help'},
      'Checkbox': {id: 'Checkbox', value: 'Checkbox', comment: 'Checkbox tooltip'},
      'Checked': {id: 'Checked', value: 'Checked', comment: 'Checked tooltip'},
      'Clear': {id: 'Clear', value: 'Clear', comment: 'Tooltip for a Clear Action'},
      'ClearFilter': {id: 'ClearFilter', value: 'Clear Filter', comment: 'Clear the current filter criteria'},
      'ClearSelection': {id: 'ClearSelection', value: '(Clear Selection)', comment: 'clear dropdown selection'},
      'Clock': {id: 'Clock', value: 'Clock', comment: 'Clock tooltip'},
      'Close': {id: 'Close', value: 'Close', comment: 'Tooltip for a Close Button Action'},
      'Clickable': {id: 'Clickable', value: 'Clickable in editor', comment: 'Clickable in editor'},
      'Copy': {id: 'Copy', value: 'Copy', comment: 'Copy tooltip'},
      'Collapse': {id: 'Collapse', value: 'Collapse', comment: 'Collapse / close a tree/submenu'},
      'CollapseAppTray': {id: 'CollapseAppTray', value: 'Collapse App Tray', comment: 'Collapse App Tray tooltip'},
      'Columns': {id: 'Columns', value: 'Columns', comment: 'Columns tooltip'},
      'Component': {id: 'Component', value: 'Component', comment: 'As in a UI component - building block.'},
      'Compose': {id: 'Compose', value: 'Compose', comment: 'Compose tooltip'},
      'Completed': {id: 'Completed', value: 'Completed', comment: 'Text For a Completed Status'},
      'Confirm': {id: 'Confirm', value: 'Confirm', comment: 'Confirm tooltip'},
      'ConfirmOnPage': {id: 'ConfirmOnPage', value: 'Confirm message(s) on page', comment: 'Confirm message(s) on page n'},
      'CookiesEnabled': {id: 'CookiesEnabled', value: 'Cookies Enabled', comment: 'Returns if browser cookies are enabled or not.'},
      'Contains': {id: 'Contains', value: 'Contains', comment: 'Contains in icons for filtering'},
      'CssClass': {id: 'CssClass', value: 'Css Class', comment: 'Label for entering a Css Class name'},
      'Cut': {id: 'Cut', value: 'Cut', comment: 'Cut tooltip'},
      'Date': {id: 'Date', value: 'Date', comment: 'Describes filtering by a date data type'},
      'DaysOverdue': {id: 'DaysOverdue', value: '{0} Days Overdue', comment: 'For a task /date UI'},
      'DaysRemaining': {id: 'DaysRemaining', value: '{0} Days Remaining', comment: 'For a task /date UI'},
      'Delete': {id: 'Delete', value: 'Delete', comment: 'Delete Toolbar Action Tooltip'},
      'DistributeHoriz': {id: 'DistributeHoriz', value: 'Distribute Horizontally', comment: 'Icon button tooltip for action that distributes elements across Horizontally'},
      'Document': {id: 'Document', value: 'Document', comment: 'Document tooltip'},
      'Dirty': {id: 'Dirty', value: 'Row has changed', comment: 'Record is dirty / modified'},
      'Drilldown': {id: 'Drilldown', value: 'Drill down', comment: 'Drill by moving page flow into a record'},
      'Drillup': {id: 'Drillup', value: 'Drill Up', comment: 'Opposite of Drilldown, move back up to a larger set of records'},
      'Dropdown': {id: 'Dropdown', value: 'Dropdown', comment: 'Dropdown'},
      'DoesNotContain': {id: 'DoesNotContain', value: 'Does Not Contain', comment: 'Does Not Contain in icons for filtering'},
      'DoesNotEndWith': {id: 'DoesNotEndWith', value: 'Does Not End With', comment: 'For condition filtering'},
      'DoesNotEqual': {id: 'DoesNotEqual', value: 'Does Not Equal', comment: 'Does Not Equal in icons for filtering'},
      'DoesNotStartWith': {id: 'DoesNotStartWith', value: 'Does Not Start With', comment: 'For condition filtering'},
      'Down': {id: 'Down', value: 'Down', comment: 'Down tooltip'},
      'Download': {id: 'Download', value: 'Download', comment: 'Download tooltip'},
      'Duplicate': {id: 'Duplicate', value: 'Duplicate', comment: 'Duplicate tooltip'},
      'EitherSelectedOrNotSelected': {id: 'EitherSelectedOrNotSelected', value: 'Either Selected Or Not Selected', comment: 'Either Selected Or NotSelected in icons for filtering'},
      'EndsWith': {id: 'EndsWith', value: 'Ends With', comment: 'for condition filtering'},
      'EnterComments': {id: 'EnterComments', value: 'Enter comments here...', comment: 'Placeholder text for a text input (comments)'},
      'Error': {id: 'Error', value: 'Error', comment: 'Title, Spoken Text describing fact an error has occured'},
      'ErrorAllowedTypes': {id: 'ErrorAllowedTypes', value: 'File type is not allowed', comment: 'Error string for file-upload'},
      'ErrorMaxFileSize': {id: 'ErrorMaxFileSize', value: 'Exceeded file size limit', comment: 'Error string for file-upload'},
      'ErrorMaxFilesInProcess': {id: 'ErrorMaxFilesInProcess', value: 'Exceeded maximum files allowed limit', comment: 'Error string for file-upload'},
      'ErrorOnPage': {id: 'ErrorOnPage', value: 'Error message(s) on page', comment: 'Error message(s) on page n'},
      'EmailValidation': {id: 'EmailValidation', value: 'Email address not valid', comment: 'This the rule for email validation'},
      'Emerald': {id: 'Emerald', value: 'Emerald', comment: 'Color in our color pallette'},
      'Expand': {id: 'Expand', value: 'Expand', comment: 'Expand open a tree/submenu'},
      'ExpandAppTray': {id: 'ExpandAppTray', value: 'Expand App Tray', comment: 'ExpandAppTray tooltip'},
      'ExpandCollapse': {id: 'ExpandCollapse', value: 'Expand / Collapse', comment: 'Text to toggle a button in a container.'},
      'ExportAsSpreadsheet': {id: 'ExportAsSpreadsheet', value: 'Export as Spreadsheet', comment: 'Export as Spreadsheet tooltip'},
      'Edit': {id: 'Edit', value: 'Edit', comment: 'Edit tooltip'},
      'Equals': {id: 'Equals', value: 'Equals', comment: 'Equals in icons for filtering'},
      'ExitFullView': {id: 'ExitFullView', value: 'Exit Full View', comment: 'Exit Full View tooltip'},
      'Export': {id: 'Export', value: 'Export', comment: 'Export tooltip'},
      'ExportToExcel': {id: 'ExportToExcel', value: 'Export To Excel', comment: 'Export To Excel menu option in datagrid'},
      'Favorite': {id: 'Favorite', value: 'Favorite', comment: 'A favorite item'},
      'FileUpload': {id: 'FileUpload', value: 'File Upload. Press Enter to Browse for a file', comment: 'Screen Reader instructions'},
      'Filter': {id: 'Filter', value: 'Filter', comment: 'Filter tooltip'},
      'FirstPage': {id: 'FirstPage', value: 'First Page', comment: 'First Page tooltip'},
      'Folder': {id: 'Folder', value: 'Folder', comment: 'Folder tooltip'},
      'FullView': {id: 'FullView', value: 'Full View', comment: 'Full View tooltip'},
      'GoForward': {id: 'GoForward', value: 'Go Forward', comment: 'Move Page / object this direction'},
      'GoBack': {id: 'GoBack', value: 'Go Back', comment: 'Move Page / object this directionp'},
      'GoDown': {id: 'GoDown', value: 'Go Down', comment: 'Move Page / object this directionp'},
      'GoUp': {id: 'GoUp', value: 'Go Up', comment: 'Move Page / object this direction'},
      'Go': {id: 'Go', 'value': 'Go', comment: 'Go, perform a movement, start a search, move to the next "thing" in a workflow.'},
      'Graphite': {id: 'Graphite', value: 'Graphite', comment: 'Color in our color pallette'},
      'GreaterOrEquals': {id: 'GreaterOrEquals', value: 'Greater Than Or Equals', comment: 'Greater Than Or Equals in icons for filtering'},
      'GreaterThan': {id: 'GreaterThan', value: 'Greater Than', comment: 'Greater Than in icons for filtering'},
      'Grid': {id: 'Grid', value: 'Grid', comment: 'Grid tooltip'},
      'Hours': {id: 'Hours', value: 'Hours', comment: 'the hour portion of a time'},
      'HeadingThree': {id: 'HeadingThree', value: 'Heading Three', comment: 'Heading Three tooltip'},
      'HeadingFour': {id: 'HeadingFour', value: 'Heading Four', comment: 'Heading Four tooltip'},
      'Highest': {id: 'Highest', value: 'Highest', comment: 'Highest Four tooltip'},
      'Home': {id: 'Home', value: 'Home', comment: 'Home tooltip'},
      'HtmlView': {id: 'HtmlView', value: 'Html View', comment: 'Html View tooltip'},
      'Image': {id: 'Image', value: 'Image', comment: 'Image of something'},
      'Import': {id: 'Import', value: 'Import', comment: 'Import tooltip'},
      'Info': {id: 'Info', value: 'Info', comment: 'Info tooltip'},
      'InfoOnPage': {id: 'InfoOnPage', value: 'Information message(s) on page', comment: 'Information message(s) on page n'},
      'InProgress': {id: 'In Progress', value: 'In Progress', comment: 'Info tooltip that an action is in progress'},
      'Insert': {id: 'Insert', value: 'Insert', comment: 'Insert Modal Dialog Button'},
      'InsertAnchor': {id: 'InsertAnchor', value: 'Insert Anchor', comment: 'Insert Acnhor (link) in an editor'},
      'InsertImage': {id: 'InsertImage', value: 'Insert Image', comment: 'Insert Image in an editor'},
      'InsertLink': {id: 'InsertLink', value: 'Insert Link', comment: 'Insert Link in an editor'},
      'InsertUrl': {id: 'InsertUrl', value: 'Insert Url', comment: 'Insert a Url in an editor'},
      'Italic': {id: 'Italic', value: 'Italic', comment: 'Make Text Italic'},
      'InvalidDate': {id: 'InvalidDate', value: 'Invalid Date', comment: 'validation message for wrong date format (short)'},
      'InvalidTime': {id: 'InvalidTime', value: 'Invalid Time', comment: 'validation message for wrong time format'},
      'Inventory': {id: 'Inventory', value: 'Inventory', comment: 'Icon button tooltop for Inventory Action'},
      'IsEmpty': {id: 'IsEmpty', value: 'Is Empty', comment: 'Is Empty in icons for filtering'},
      'IsNotEmpty': {id: 'IsNotEmpty', value: 'Is Not Empty', comment: 'Is Not Empty in icons for filtering'},
      'ItemsSelected': {id: 'ItemsSelected', value: 'Items selected', comment: 'Num of Items selected for swaplist'},
      'JustifyCenter': {id: 'JustifyCenter', value: 'Center', comment: 'justify text to center in the editor'},
      'JustifyLeft': {id: 'JustifyLeft', value: 'Align Left', comment: 'justify text to left in the editor'},
      'JustifyRight': {id: 'JustifyRight', value: 'Align Right', comment: 'justify text to right in the editor'},
      'Keyword': {id: 'Keyword', value: 'Keyword', comment: 'Describes filtering by a keyword search'},
      'Launch': {id: 'Launch', value: 'Launch', comment: 'Launch'},
      'LastPage': {id: 'LastPage', value: 'Last Page', comment: 'Last Page tooltip'},
      'Left': {id: 'Left', value: 'Left', comment: 'Left tooltip'},
      'LessOrEquals': {id: 'LessOrEquals', value: 'Less Than Or Equals', comment: 'Less Than Or Equals in icons for filtering'},
      'LessThan': {id: 'LessThan', value: 'Less Than', comment: 'Less Than in icons for filtering'},
      'Link': {id: 'Link', value: 'Link', comment: 'Link - as in hyperlink - icon tooltop'},
      'Load': {id: 'Load', value: 'Load', comment: 'Load icon tooltip'},
      'Loading': {id: 'Loading', value: 'Loading', comment: 'Text below spinning indicator to indicate loading'},
      'Locale': {id: 'Locale', value: 'Locale', comment: 'The users locale string for example en-US, it-It'},
      'Locked': {id: 'Locked', value: 'Locked', comment: 'Locked tooltip'},
      'Logout': {id: 'Logout', value: 'Log Out', comment: 'Log out of the application'},
      'Lookup': {id: 'Lookup', value: 'Lookup', comment: 'Lookup - As in looking up a record or value'},
      'Lowest': {id: 'Lowest', value: 'Lowest', comment: 'Lowest - As in Lowest value'},
      'Mail': {id: 'Mail', value: 'Mail', comment: 'Mail tooltip'},
      'MapPin': {id: 'MapPin', value: 'Pin', comment: 'Map Pin tooltip'},
      'Maximize': {id: 'Maximize', value: 'Maximize', comment: 'Maximize a screen or dialog in the UI'},
      'Median': {id: 'Median', value: 'Median', comment: 'Median in Mathematics'},
      'Medium': {id: 'Medium', value: 'Medium', comment: 'Describes a Medium sized Row Height in a grid/list'},
      'Menu': {id: 'Menu', value: 'Menu', comment: 'Menu tooltip'},
      'MingleShare': {id: 'MingleShare', value: 'Share with Ming.le', comment: 'Share the contextual object/action in the mingle system'},
      'Minutes': {id: 'Minutes', value: 'Minutes', comment: 'the minutes portion of a time'},
      'Minimize': {id: 'Minimize', value: 'Minimize', comment: 'Minimize tooltip'},
      'Minus': {id: 'Minus', value: 'Minus', comment: 'Minus tooltip'},
      'Mobile': {id: 'Mobile', value: 'Mobile', comment: 'Indicates a mobile device (phone tablet ect)'},
      'Month': {id: 'Month', value: 'Month', comment: 'As in a date month'},
      'More': {id: 'More', value: 'More...', comment: 'Text Indicating More Buttons or form content'},
      'MoreActions': {id: 'MoreActions', value: 'More Actions', comment: 'Text on the More Actions button indictating hidden functions'},
      'MoveToLeft': {id: 'MoveToLeft', value: 'Move to left', comment: 'Button tooltip used in a list of movable items'},
      'MoveToRight': {id: 'MoveToRight', value: 'Move to right', comment: 'Button tooltip used in a list of movable items'},
      'MsgDirty': {id: 'MsgDirty', value: ', Modified', comment: 'for modified form fields'},
      'NewDocument': {id: 'NewDocument', value: 'New Document', comment: 'New Document tooltip'},
      'NewItem': {id: 'NewItem', value: 'New item', comment: 'New item in listbuilder'},
      'Next': {id: 'Next', value: 'Next', comment: 'Next in icons tooltip'},
      'NextPage': {id: 'NextPage', value: 'Next Page', comment: 'Next on Pager'},
      'NextMonth': {id: 'NextMonth', value: 'Next Month', comment: 'the label for the button that moves calendar to next/prev'},
      'No': {id: 'No', value: 'No', comment: 'On a dialog button'},
      'NoData': {id: 'NoData', value: 'No Data Available', comment: 'Shown when there is no rows shown in a list'},
      'NoDataFilter': {id: 'NoDataFilter', value: 'No data available, make a new filter selection to see more results.', comment: 'Shown when there is no rows shown in a list'},
      'NoDataList': {id: 'NoDataList', value: 'No data available, make a selection in the list above to see more results.', comment: 'Shown when there is no rows shown in a list'},
      'NoResults': {id: 'NoResults', value: 'No Results', comment: 'Search Results Text'},
      'Normal': {id: 'Normal', value: 'Normal', comment: 'Normal row height'},
      'Notes': {id: 'Notes', value: 'Notes', comment: 'Notes icon tooltip'},
      'NotSelected': {id: 'NotSelected', value: 'Not Selected', comment: 'Not Selected in icons for filtering'},
      'NumberList': {id: 'NumberList', value: 'Number List', comment: 'Number List tooltip'},
      'Ok': {id: 'Ok', value: 'Ok', comment: 'Ok button on a dialog'},
      'OpenBackClose': {id: 'OpenBackClose', value: 'Open / Back / Close', comment: 'Open / Back / Close tooltip'},
      'OpenClose': {id: 'OpenClose', value: 'Open / Close', comment: 'Open / Close tooltip'},
      'OrderedList': {id: 'OrderedList', value: 'Insert/Remove Numbered List', comment: 'Insert an Ordered list in the editor'},
      'Page': {id: 'Page', value: 'page ', comment: 'Text on the pager links'},
      'PageOf': {id: 'PageOf', value: 'Page {0} of {1}', comment: 'Pager Text Showing current and number of pages'},
      'PageOn': {id: 'PageOn', value: 'You are currently on page ', comment: 'Text on the pager links'},
      'Paste': {id: 'Paste', value: 'Paste', comment: 'Paste icon tooltip'},
      'PasswordValidation': {id: 'PasswordValidation', value: '<strong>Password must</strong><br>Be at least 10 characters long<br>Have at least one upper case character<br>Have at least one lower case character<br>Contain one special character<br>Not contain your username<br>Can not be a Previously used password<br>', comment: 'Password validation requirements'},
      'PasswordConfirmValidation': {id: 'PasswordConfirmValidation', value: 'Password must match', comment: 'Password Confirm validation'},
      'Peak': {id: 'Peak', value: 'Peak', comment: 'the max or peak value in a chart'},
      'PersonalizeColumns': {id: 'PersonalizeColumns', value: 'Personalize Columns', comment: 'Customize Columns in a Grid'},
      'Platform': {id: 'Platform', value: 'Platform', comment: 'The users operating system i.e. mac, windows'},
      'Period': {id: 'Period', value: 'Period', comment: 'the am/pm portion of a time'},
      'PressDown': {id: 'PressDown', value: 'Press Down arrow to select a date', comment: 'the audible label for Tooltip about how to operate the date picker'},
      'PressShiftF10': {id: 'PressShiftF10', value: 'Press Shift+F10 to open the context menu.', comment: 'the audible infor for screen readers on how to use a field with a popup menu'},
      'Previous': {id: 'Previous', value: 'Previous', comment: 'Previous icon tooltip - moved to previous record'},
      'PreviousMonth': {id: 'PreviousMonth', value: 'Previous Month', comment: 'the label for the button that moves calendar to next/prev'},
      'PreviousPage': {id: 'PreviousPage', value: 'Previous Page', comment: 'Previous Page tooltip'},
      'Print': {id: 'Print', value: 'Print', comment: 'Print tooltip'},
      'Range': {id: 'Range', value: 'Range', comment: 'Range for tooltip'},
      'RecordsPerPage': {id: 'RecordsPerPage', value: '{0} Records per page', comment: 'Dropdown allows the user to select how many visible records {} shows select value.'},
      'Redo': {id: 'Redo', value: 'Redo', comment: 'Redo tooltip'},
      'ReorderRows': {id: 'ReorderRows', value: 'Reorder Rows', comment: 'Drag and Reorder Grid Rows'},
      'Refresh': {id: 'Refresh', value: 'Refresh', comment: 'Refresh tooltip'},
      'Required': {id: 'Required', value: 'Required', comment: 'indicates a form field is manditory'},
      'Reset': {id: 'Reset', value: 'Reset', comment: 'Reset tooltip'},
      'ResetDefault': {id: 'ResetDefault', value: 'Reset to Default', comment: 'Reset Datagrid Columns, Filter and other Layout'},
      'Result': {id: 'Result', value: 'Result', comment: 'Showing a single result in a List'},
      'Results': {id: 'Results', value: 'Results', comment: 'As in showing N Results (plural) in a List'},
      'RightAlign': {id: 'RightAlign', value: 'Align Right', comment: 'Right Align tooltip'},
      'RightAlignText': {id: 'RightAlignText', value: 'Align Right', comment: 'Right Align Text tooltip'},
      'Right': {id: 'Right', value: 'Right', comment: 'Right'},
      'Roles': {id: 'Roles', value: 'Roles', comment: 'Roles tooltip'},
      'RowHeight': {id: 'RowHeight', value: 'Row Height', comment: 'Describes the Height for Rows in a Data Grid'},
      'Ruby': {id: 'Ruby', value: 'Ruby', comment: 'Color in our color pallette'},
      'RunFilter': {id: 'RunFilter', value: 'Run Filter', comment: 'Execute the current filter criteria'},
      'Save': {id: 'Save', value: 'Save', comment: 'Save tooltip'},
      'SaveCurrentView': {id: 'SaveCurrentView', value: 'Save Current View', comment: 'Datagrids contain view sets. This menu option saves them'},
      'SavedViews': {id: 'SavedViews', value: 'Saved Views', comment: 'Label for a list of Views'},
      'Seconds': {id: 'Seconds', value: 'Seconds', comment: 'the seconds portion of a time'},
      'Search': {id: 'Search', value: 'Search', comment: 'Search tooltip'},
      'SearchColumnName': {id: 'SearchColumnName', value: 'Search for a column name', comment: 'Search for a datagrid column by name'},
      'SearchFolder': {id: 'SearchFolder', value: 'Search in Folder', comment: 'Search Folder tooltip'},
      'SearchList': {id: 'SearchList', value: 'Search List', comment: 'Search List tooltip'},
      'Select': {id: 'Select', value: 'Select', comment: 'text describing a select action'},
      'Selected': {id: 'Selected', value: 'Selected', comment: 'text describing a selected object'},
      'SelectAll': {id: 'SelectAll', value: 'Select All', comment: 'describes the action of selecting all items available in a list'},
      'Send': {id: 'Send', value: 'Send', comment: 'Send tooltip'},
      'SetTime': {id: 'SetTime', value: 'Set Time', comment: 'button text that inserts time when clicked'},
      'Settings': {id: 'Settings', value: 'Settings', comment: 'Settings tooltip'},
      'Short': {id: 'Short', value: 'Short', comment: 'Describes a Shorted Row Height in a grid/list'},
      'ShowFilterRow': {id: 'ShowFilterRow', value: 'Show Filter Row', comment: 'Toggle a row with filer info above a list'},
      'ShowLess': {id: 'ShowLess', value: 'Show Less', comment: 'Show less form content'},
      'ShowMore': {id: 'ShowMore', value: 'Show More', comment: 'Show more form content'},
      'Slate': {id: 'Slate', value: 'Slate', comment: 'Color in our color pallette'},
      'SlideOf': {id: 'SlideOf', value: 'Slide {0} of {1}', comment: 'Slide Text Showing current and total number of slides'},
      'SlidesOf': {id: 'SlidesOf', value: 'Slides {0} and {1} of {2}', comment: 'Slides Text Showing current slides and total number of slides'},
      'SliderHandle': {id: 'SliderHandle', value: 'Handle for', comment: 'Description of the portion of a Slider control that is focusable and changes its value, followed in code by the name of the control'},
      'SliderMaximumHandle': {id: 'SliderMaximumHandle', value: 'Maximum range handle for', comment: 'Describes a maximum value handle in a Range (double slider), followed in code by the name of the control'},
      'SliderMinimumHandle': {id: 'SliderMinimumHandle', value: 'Minimum range handle for', comment: 'Describes a minimum value handle in a Range (double slider), followed in code by the name of the control'},
      'SkipToMain': {id: 'SkipToMain', value: 'Skip to Main Content', comment: 'Skip link in header, jumps when clicked on to main area'},
      'StartsWith': {id: 'StartsWith', value: 'Starts With', comment: 'for condition filtering'},
      'StepsCompleted': {id: 'StepsCompleted', value: '{0} of {1} Steps Completed', comment: 'steps of a wizard/chart'},
      'StrikeThrough': {id: 'StrikeThrough', value: 'Strike Through', comment: 'turn on and off strike through text in text editor (like word)'},
      'SortAtoZ': {id: 'SortAtoZ', value: 'Sort Ascending', comment: 'Sort A to Z in icons for filtering'},
      'SortZtoA': {id: 'SortZtoA', value: 'Sort Descending', comment: 'Sort Z to A in icons for filtering'},
      'SortDown': {id: 'SortDown', value: 'Sort Down', comment: 'Sort Down tooltip'},
      'SortUp': {id: 'SortUp', value: 'Sort Up', comment: 'Sort Up tooltip'},
      'Subscript': {id: 'Subscript', value: 'Subscript', comment: 'Turn on and off Subscript text in text editor (like word)'},
      'Superscript': {id: 'Superscript', value: 'Superscript', comment: 'Turn on and off Superscript text in text editor (like word)'},
      'Tabs': {id: 'Tabs', value: 'Tabs...', comment: 'Used in the Tabs Control\'s more menu, preceeded by a number that describes how many tabs are in the spillover menu'},
      'Tack': {id: 'Tack', value: 'Pin', comment: 'Pin an object'},
      'Tall': {id: 'Tall', value: 'Tall', comment: 'Describes a Taller Row Height in a grid/list'},
      'Target': {id: 'Target', value: 'Target', comment: 'Label for an input to enter a Target (Url Attribute)'},
      'TestLocaleDefaults': {id: 'TestLocaleDefaults', value: 'Test Locale Defaults', comment: 'Do not translate'},
      'TextColor': {id: 'TextColor', value: 'Text color', comment: 'add or edit text color in the editor'},
      'TextDropArea': {id: 'DropArea', value: 'Drag and Drop Files to Upload', comment: 'text for drop area for advanced fileupload'},
      'TextDropAreaWithBrowse': {id: 'TextDropAreaWithBrowse', value: 'Drag and Drop or <span class="hyperlink">Select Files</span> to Upload', comment: 'text for drop area with browse for advanced fileupload'},
      'TextBtnCancel': {id: 'TextBtnCancel', value: 'Cancel uploading this file', comment: 'text for cancel button for advanced fileupload'},
      'TextBtnCloseError': {id: 'TextBtnCloseError', value: 'Close this error', comment: 'text for error close button for advanced fileupload'},
      'TextBtnRemove': {id: 'TextBtnRemove', value: 'Close this error', comment: 'text for remove button for advanced fileupload'},
      'Timer': {id: 'Timer', value: 'Timer', comment: 'Timer tooltip'},
      'Today': {id: 'Today', value: 'Today', comment: 'refering to today on a calendar'},
      'ToggleBold': {id: 'ToggleBold', value: 'Toggle Bold Text', comment: 'turn on and off bold in text editor (like word)'},
      'ToggleH3': {id: 'ToggleH3', value: 'Toggle Heading 3', comment: 'turn on and off heading 3 text'},
      'ToggleH4': {id: 'ToggleH4', value: 'Toggle Heading 4', comment: 'turn on and off heading 4 text'},
      'ToggleItalic': {id: 'ToggleItalic', value: 'Toggle Italic Text', comment: 'turn on and off Italic in text editor (like word)'},
      'ToggleUnderline': {id: 'ToggleUnderline', value: 'Toggle Underline Text', comment: 'turn on and off Underline in text editor (like word)'},
      'Toolbar': {id: 'Toolbar', value: 'Toolbar', comment: 'describing the toolbar component'},
      'TopAlign': {id: 'TopAlign', value: 'Top Align', comment: 'Top Align tooltip'},
      'Total': {id: 'Total', value: 'Total', comment: 'Mathematic total of a calculation'},
      'Totals': {id: 'Totals', value: 'Totals', comment: 'Mathematic total of a calculation (plural)'},
      'TreeCollapse': {id: 'TreeCollapse', value: 'Collapse Tree', comment: 'Tree Collapse tooltip'},
      'TreeExpand': {id: 'TreeExpand', value: 'Expand Tree', comment: 'Tree Expand tooltip'},
      'Turquoise': {id: 'Turquoise', value: 'Turquoise', comment: 'Color in our color pallette'},
      'Up': {id: 'Up', value: 'Up', comment: 'Up tooltip'},
      'Upload': {id: 'Upload', value: 'Upload', comment: 'Upload tooltip'},
      'UnavailableDate': {id: 'UnavailableDate', value: 'Unavailable Date', comment: 'Unavailable Date Text'},
      'Underline': {id: 'Underline', value: 'Underline', comment: 'Make text Underlined'},
      'Undo': {id: 'Undo', value: 'Undo', comment: 'Undo tooltip'},
      'Unlocked': {id: 'Unlocked', value: 'Unlocked', comment: 'Unlocked tooltip'},
      'UnorderedList': {id: 'UnorderedList', value: 'Insert/Remove Bulleted List', comment: 'Insert an Unordered list in the editor'},
      'Unsupported': {id: 'Unsupported', value: 'This content is not available because it uses features not supported in your current browser version.', comment: 'Suggesting browser upgrade for missing features.'},
      'Url': {id: 'Url', value: 'Url', comment: 'Url tooltip'},
      'UseArrow': {id: 'UseArrow', value: '. Use arrow keys to select.', comment: 'Instructional comments for screen readers'},
      'UseEnter': {id: 'UseEnter', value: '. Use enter or down arrow to lookup.', comment: 'Instructional comments for screen readers'},
      'User': {id: 'User', value: 'User', comment: 'User tooltip'},
      'UserProfile': {id: 'UserProfile', value: 'User Profile', comment: 'User Profile tooltip'},
      'VerticalMiddleAlign': {id: 'VerticalMiddleAlign', value: 'Vertical Align Center', comment: 'Vertical Align tooltip'},
      'ViewSource': {id: 'ViewSource', value: 'View Source', comment: 'Toggle the source view in the editor'},
      'ViewVisual': {id: 'ViewVisual', value: 'View Visual', comment: 'Toggle the visual view in the editor'},
      'Year': {id: 'Year', value: 'Year', comment: 'As in a date year'},
      'Yes': {id: 'Yes', value: 'Yes', comment: 'On a dialog button'}
    }
  });
}));

!function() {
  var d3 = {
    version: "3.5.17"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < ε2) {
      S = Math.log(w1 / w0) / ρ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ρ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < π) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) this.d3 = d3, define(d3); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();